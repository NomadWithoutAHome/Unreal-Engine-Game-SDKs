#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Tempest

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "SlateCore_structs.hpp"
#include "SlateCore_classes.hpp"
#include "Tempest_structs.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "FogOfWar_structs.hpp"
#include "FogOfWar_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "NubAI_structs.hpp"
#include "NubAI_classes.hpp"
#include "NubCore_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "GameplayAbilities_classes.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "Pros_structs.hpp"
#include "EnhancedInput_structs.hpp"
#include "EnhancedInput_classes.hpp"
#include "AnimMontageSet_structs.hpp"
#include "GameplayCommands_structs.hpp"
#include "GameplayCommands_classes.hpp"
#include "CustomizableSequencerTracks_classes.hpp"
#include "PhysicsCore_structs.hpp"
#include "NubAudio_structs.hpp"
#include "InputCore_structs.hpp"
#include "FXSystemAnimNotifies_classes.hpp"
#include "SmartDataAsset_classes.hpp"
#include "ReplicationGraph_classes.hpp"
#include "SlipgateCheats_classes.hpp"
#include "NavGrid_structs.hpp"
#include "NavGrid_classes.hpp"
#include "ProsSDK_structs.hpp"
#include "RTSColor_structs.hpp"
#include "NubECS_classes.hpp"
#include "Hydra5_structs.hpp"
#include "ImgMedia_classes.hpp"
#include "LevelSequence_classes.hpp"
#include "Lobby_classes.hpp"
#include "NavigationSystem_classes.hpp"
#include "StructUtils_structs.hpp"
#include "SavedGame_classes.hpp"


namespace SDK
{

// Class Tempest.AICommander
// 0x0058 (0x0080 - 0x0028)
class UAICommander : public UObject
{
public:
	class ATedPlayerState*                        PlayerStateOwner;                                  // 0x0028(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAIManager_Strategy*                    StrategyManager;                                   // 0x0030(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAIManager_Resource*                    ResourceManager;                                   // 0x0038(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAIManager_Production*                  ProductionManager;                                 // 0x0040(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAIManager_Army*                        ArmyManager;                                       // 0x0048(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAIManager_Mission*                     MissionManager;                                    // 0x0050(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAIManager_Strategy>        StrategyManagerClass;                              // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAIManager_Resource>        ResourceManagerClass;                              // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAIManager_Production>      ProductionManagerClass;                            // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAIManager_Army>            ArmyManagerClass;                                  // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAIManager_Mission>         MissionManagerClass;                               // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ReceiveTick(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICommander">();
	}
	static class UAICommander* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICommander>();
	}
};
static_assert(alignof(UAICommander) == 0x000008, "Wrong alignment on UAICommander");
static_assert(sizeof(UAICommander) == 0x000080, "Wrong size on UAICommander");
static_assert(offsetof(UAICommander, PlayerStateOwner) == 0x000028, "Member 'UAICommander::PlayerStateOwner' has a wrong offset!");
static_assert(offsetof(UAICommander, StrategyManager) == 0x000030, "Member 'UAICommander::StrategyManager' has a wrong offset!");
static_assert(offsetof(UAICommander, ResourceManager) == 0x000038, "Member 'UAICommander::ResourceManager' has a wrong offset!");
static_assert(offsetof(UAICommander, ProductionManager) == 0x000040, "Member 'UAICommander::ProductionManager' has a wrong offset!");
static_assert(offsetof(UAICommander, ArmyManager) == 0x000048, "Member 'UAICommander::ArmyManager' has a wrong offset!");
static_assert(offsetof(UAICommander, MissionManager) == 0x000050, "Member 'UAICommander::MissionManager' has a wrong offset!");
static_assert(offsetof(UAICommander, StrategyManagerClass) == 0x000058, "Member 'UAICommander::StrategyManagerClass' has a wrong offset!");
static_assert(offsetof(UAICommander, ResourceManagerClass) == 0x000060, "Member 'UAICommander::ResourceManagerClass' has a wrong offset!");
static_assert(offsetof(UAICommander, ProductionManagerClass) == 0x000068, "Member 'UAICommander::ProductionManagerClass' has a wrong offset!");
static_assert(offsetof(UAICommander, ArmyManagerClass) == 0x000070, "Member 'UAICommander::ArmyManagerClass' has a wrong offset!");
static_assert(offsetof(UAICommander, MissionManagerClass) == 0x000078, "Member 'UAICommander::MissionManagerClass' has a wrong offset!");

// Class Tempest.EcsTypeDesc_AoEReceiver
// 0x0000 (0x0028 - 0x0028)
class UEcsTypeDesc_AoEReceiver final : public UEcsTypeDesc
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EcsTypeDesc_AoEReceiver">();
	}
	static class UEcsTypeDesc_AoEReceiver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEcsTypeDesc_AoEReceiver>();
	}
};
static_assert(alignof(UEcsTypeDesc_AoEReceiver) == 0x000008, "Wrong alignment on UEcsTypeDesc_AoEReceiver");
static_assert(sizeof(UEcsTypeDesc_AoEReceiver) == 0x000028, "Wrong size on UEcsTypeDesc_AoEReceiver");

// Class Tempest.AICommanderFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UAICommanderFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TSubclassOf<class UAISquadOrderType> AISquadOrder_GetOrderType(const struct FAISquadOrder& SquadOrder);
	static class AActor* AISquadOrder_GetTargetActor(const struct FAISquadOrder& SquadOrder);
	static struct FVector2D AISquadOrder_GetTargetLocation(const struct FAISquadOrder& SquadOrder);
	static float AISquadOrder_GetTargetRadius(const struct FAISquadOrder& SquadOrder);
	static bool AISquadOrder_HasOrderType(const struct FAISquadOrder& SquadOrder, const TSubclassOf<class UAISquadOrderType> OrderType);
	static bool AISquadOrder_HasTarget(const struct FAISquadOrder& SquadOrder);
	static bool AISquadOrder_HasTargetActor(const struct FAISquadOrder& SquadOrder);
	static bool AISquadOrder_HasTargetLocation(const struct FAISquadOrder& SquadOrder);
	static bool AISquadOrder_IsValid(const struct FAISquadOrder& SquadOrder);
	static struct FAISquadOrder AISquadOrder_Make(const TSubclassOf<class UAISquadOrderType> OrderType);
	static struct FAISquadOrder AISquadOrder_MakeWithActorLocation(const TSubclassOf<class UAISquadOrderType> OrderType, const class AActor* Actor, const float Radius);
	static struct FAISquadOrder AISquadOrder_MakeWithTargetActor(const TSubclassOf<class UAISquadOrderType> OrderType, const struct FAITargetActor& TargetActor);
	static struct FAISquadOrder AISquadOrder_MakeWithTargetLocation(const TSubclassOf<class UAISquadOrderType> OrderType, const struct FAITargetLocation& TargetLocation);
	static struct FAITarget AITarget_MakeFromAITargetActor(const struct FAITargetActor& AITargetActor);
	static struct FAITarget AITarget_MakeFromAITargetLocation(const struct FAITargetLocation& AITargetLocation);
	static struct FAITarget AITarget_MakeWithActorLocation(const class AActor* Actor, const float Radius);
	static class AActor* AITargetActor_GetActor(const struct FAITargetActor& TargetActor);
	static bool AITargetActor_IsValid(const struct FAITargetActor& TargetActor);
	static struct FAITargetActor AITargetActor_MakeWithActor(class AActor* Actor);
	static struct FAITargetActor AITargetActor_MakeWithActorTag(const class UObject* WorldContextObject, const struct FGameplayTag& ActorTag);
	static struct FVector2D AITargetLocation_GetLocation(const struct FAITargetLocation& TargetLocation);
	static float AITargetLocation_GetRadius(const struct FAITargetLocation& TargetLocation);
	static bool AITargetLocation_IsValid(const struct FAITargetLocation& TargetLocation);
	static struct FAITargetLocation AITargetLocation_Make(const struct FVector2D& Location, const float Radius);
	static struct FAITargetLocation AITargetLocation_MakeWithActorLocation(const class AActor* Actor, const float Radius);
	static class UAIMission* CreateAIMission(const class UObject* WorldContextObject, const ETedPlayerID PlayerID, const TSubclassOf<class UAIMission> MissionClass, const bool bAutoActivate);
	static class UAIMission* FindAIMissionByClass(const class UObject* WorldContextObject, const ETedPlayerID PlayerID, const TSubclassOf<class UAIMission> MissionClass, const bool bExactMatch);
	static class UAIMission* FindAIMissionByHandle(const class UObject* WorldContextObject, const ETedPlayerID PlayerID, const struct FAIMissionHandle& MissionHandle);
	static class UAIMission* FindAIMissionByTag(const class UObject* WorldContextObject, const ETedPlayerID PlayerID, const struct FGameplayTag& MissionTag, const bool bExactMatch);
	static class UAIMission* FindAIMissionByTags(const class UObject* WorldContextObject, const ETedPlayerID PlayerID, const struct FGameplayTagContainer& MissionTags, const EGameplayContainerMatchType MatchType, const bool bExactMatch);
	static TArray<class UAIMission*> FindAIMissions(const class UObject* WorldContextObject, const ETedPlayerID PlayerID, const TSubclassOf<class UAIMission> MissionClass, const bool bExactMatch);
	static TArray<class UAIMission*> FindAIMissionsByTag(const class UObject* WorldContextObject, const ETedPlayerID PlayerID, const struct FGameplayTag& MissionTag, const bool bExactMatch);
	static TArray<class UAIMission*> FindAIMissionsByTags(const class UObject* WorldContextObject, const ETedPlayerID PlayerID, const struct FGameplayTagContainer& MissionTags, const EGameplayContainerMatchType MatchType, const bool bExactMatch);
	static TArray<class UAIMission*> GetAIMissions(const class UObject* WorldContextObject, const ETedPlayerID PlayerID);
	static void RemoveAIMission(const class UObject* WorldContextObject, const ETedPlayerID PlayerID, class UAIMission* Mission);
	static void RemoveAIMissionByHandle(const class UObject* WorldContextObject, const ETedPlayerID PlayerID, const struct FAIMissionHandle& MissionHandle);
	static void RemoveAllAIMissions(const class UObject* WorldContextObject, const ETedPlayerID PlayerID, const TSubclassOf<class UAIMission> MissionClass, const bool bExactMatch);
	static float Skirmish_CalculateWinVal(const TArray<class ATedPawn*>& We, const TArray<class ATedPawn*>& Enemy, int32 Method);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICommanderFunctionLibrary">();
	}
	static class UAICommanderFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICommanderFunctionLibrary>();
	}
};
static_assert(alignof(UAICommanderFunctionLibrary) == 0x000008, "Wrong alignment on UAICommanderFunctionLibrary");
static_assert(sizeof(UAICommanderFunctionLibrary) == 0x000028, "Wrong size on UAICommanderFunctionLibrary");

// Class Tempest.TedUtilityAIConsideration_HasAttackTarget
// 0x0008 (0x0068 - 0x0060)
class UTedUtilityAIConsideration_HasAttackTarget final : public UUtilityAIConsideration
{
public:
	bool                                          bIgnoreTargetOutsideAttackRange;                   // 0x0060(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUtilityAIConsideration_HasAttackTarget">();
	}
	static class UTedUtilityAIConsideration_HasAttackTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUtilityAIConsideration_HasAttackTarget>();
	}
};
static_assert(alignof(UTedUtilityAIConsideration_HasAttackTarget) == 0x000008, "Wrong alignment on UTedUtilityAIConsideration_HasAttackTarget");
static_assert(sizeof(UTedUtilityAIConsideration_HasAttackTarget) == 0x000068, "Wrong size on UTedUtilityAIConsideration_HasAttackTarget");
static_assert(offsetof(UTedUtilityAIConsideration_HasAttackTarget, bIgnoreTargetOutsideAttackRange) == 0x000060, "Member 'UTedUtilityAIConsideration_HasAttackTarget::bIgnoreTargetOutsideAttackRange' has a wrong offset!");

// Class Tempest.AIDefinition_BuildOrder
// 0x0030 (0x0060 - 0x0030)
class UAIDefinition_BuildOrder final : public UDataAsset
{
public:
	ETedFaction                                   Faction;                                           // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIBuildOrder                          BuildOrder;                                        // 0x0038(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDefinition_BuildOrder">();
	}
	static class UAIDefinition_BuildOrder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDefinition_BuildOrder>();
	}
};
static_assert(alignof(UAIDefinition_BuildOrder) == 0x000008, "Wrong alignment on UAIDefinition_BuildOrder");
static_assert(sizeof(UAIDefinition_BuildOrder) == 0x000060, "Wrong size on UAIDefinition_BuildOrder");
static_assert(offsetof(UAIDefinition_BuildOrder, Faction) == 0x000030, "Member 'UAIDefinition_BuildOrder::Faction' has a wrong offset!");
static_assert(offsetof(UAIDefinition_BuildOrder, BuildOrder) == 0x000038, "Member 'UAIDefinition_BuildOrder::BuildOrder' has a wrong offset!");

// Class Tempest.EcsTypeDesc_Pickup
// 0x0000 (0x0028 - 0x0028)
class UEcsTypeDesc_Pickup final : public UEcsTypeDesc
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EcsTypeDesc_Pickup">();
	}
	static class UEcsTypeDesc_Pickup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEcsTypeDesc_Pickup>();
	}
};
static_assert(alignof(UEcsTypeDesc_Pickup) == 0x000008, "Wrong alignment on UEcsTypeDesc_Pickup");
static_assert(sizeof(UEcsTypeDesc_Pickup) == 0x000028, "Wrong size on UEcsTypeDesc_Pickup");

// Class Tempest.AIDefinition_Strategy
// 0x0090 (0x00C0 - 0x0030)
class UAIDefinition_Strategy final : public UDataAsset
{
public:
	ETedFaction                                   Faction;                                           // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIDefinition_BuildOrder*               OpeningBook;                                       // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<TSubclassOf<class UAIMission>>           Missions;                                          // 0x0040(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  LockedTech;                                        // 0x0090(0x0020)(Edit, DisableEditOnInstance, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FAIUnitLimit>                   UnitLimits;                                        // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDefinition_Strategy">();
	}
	static class UAIDefinition_Strategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDefinition_Strategy>();
	}
};
static_assert(alignof(UAIDefinition_Strategy) == 0x000008, "Wrong alignment on UAIDefinition_Strategy");
static_assert(sizeof(UAIDefinition_Strategy) == 0x0000C0, "Wrong size on UAIDefinition_Strategy");
static_assert(offsetof(UAIDefinition_Strategy, Faction) == 0x000030, "Member 'UAIDefinition_Strategy::Faction' has a wrong offset!");
static_assert(offsetof(UAIDefinition_Strategy, OpeningBook) == 0x000038, "Member 'UAIDefinition_Strategy::OpeningBook' has a wrong offset!");
static_assert(offsetof(UAIDefinition_Strategy, Missions) == 0x000040, "Member 'UAIDefinition_Strategy::Missions' has a wrong offset!");
static_assert(offsetof(UAIDefinition_Strategy, LockedTech) == 0x000090, "Member 'UAIDefinition_Strategy::LockedTech' has a wrong offset!");
static_assert(offsetof(UAIDefinition_Strategy, UnitLimits) == 0x0000B0, "Member 'UAIDefinition_Strategy::UnitLimits' has a wrong offset!");

// Class Tempest.AIManager
// 0x0010 (0x0038 - 0x0028)
class UAIManager : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntervalCountdown                     TickInterval;                                      // 0x0030(0x0008)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIManager">();
	}
	static class UAIManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIManager>();
	}
};
static_assert(alignof(UAIManager) == 0x000008, "Wrong alignment on UAIManager");
static_assert(sizeof(UAIManager) == 0x000038, "Wrong size on UAIManager");
static_assert(offsetof(UAIManager, TickInterval) == 0x000030, "Member 'UAIManager::TickInterval' has a wrong offset!");

// Class Tempest.TedEcsModule
// 0x0000 (0x0030 - 0x0030)
class UTedEcsModule : public UEcsModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedEcsModule">();
	}
	static class UTedEcsModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedEcsModule>();
	}
};
static_assert(alignof(UTedEcsModule) == 0x000008, "Wrong alignment on UTedEcsModule");
static_assert(sizeof(UTedEcsModule) == 0x000030, "Wrong size on UTedEcsModule");

// Class Tempest.TedEcsModule_Triggers
// 0x0000 (0x0030 - 0x0030)
class UTedEcsModule_Triggers final : public UTedEcsModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedEcsModule_Triggers">();
	}
	static class UTedEcsModule_Triggers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedEcsModule_Triggers>();
	}
};
static_assert(alignof(UTedEcsModule_Triggers) == 0x000008, "Wrong alignment on UTedEcsModule_Triggers");
static_assert(sizeof(UTedEcsModule_Triggers) == 0x000030, "Wrong size on UTedEcsModule_Triggers");

// Class Tempest.AIManager_Army
// 0x0060 (0x0098 - 0x0038)
class UAIManager_Army final : public UAIManager
{
public:
	TArray<class UAISquad*>                       Squads;                                            // 0x0038(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSet<class ATedPawn*>                         AIControlledPawns;                                 // 0x0048(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIManager_Army">();
	}
	static class UAIManager_Army* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIManager_Army>();
	}
};
static_assert(alignof(UAIManager_Army) == 0x000008, "Wrong alignment on UAIManager_Army");
static_assert(sizeof(UAIManager_Army) == 0x000098, "Wrong size on UAIManager_Army");
static_assert(offsetof(UAIManager_Army, Squads) == 0x000038, "Member 'UAIManager_Army::Squads' has a wrong offset!");
static_assert(offsetof(UAIManager_Army, AIControlledPawns) == 0x000048, "Member 'UAIManager_Army::AIControlledPawns' has a wrong offset!");

// Class Tempest.TedPawn
// 0x1398 (0x16B0 - 0x0318)
#pragma pack(push, 0x1)
class alignas(0x10) ATedPawn : public APawn
{
public:
	uint8                                         Pad_318[0xA0];                                     // 0x0318(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class UEcsActorComponent*                     EcsActor;                                          // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMeshComponent*                         MeshComp;                                          // 0x03C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 SkeletalMeshComp;                                  // 0x03C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   StaticMeshComp;                                    // 0x03D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedAbilityComponent*                   AbilityComponent;                                  // 0x03D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATedAIController*                       MyAIController;                                    // 0x03E0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedAttributeSet*                       DefaultAttributeSet;                               // 0x03E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTedAttributeSetBase*>           SpawnedAttributeSets;                              // 0x03F0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	int32                                         SelectionDecalRadius;                              // 0x0400(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_404[0x4];                                      // 0x0404(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SelectionHitBoxCenterOffset;                       // 0x0408(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              SelectionHitBoxExtent;                             // 0x0420(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDisableStatusEffects : 1;                         // 0x0430(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_431[0x7];                                      // 0x0431(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UTedAnnouncement>           UnderAttackAnnouncement;                           // 0x0438(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTedAnnouncement>           DiedAnnouncement;                                  // 0x0440(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FogOfWarAgentRadiusMultiplier;                     // 0x0448(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DestroyActorDelay;                                 // 0x044C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDontGiveExperience;                               // 0x0450(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_451[0x3];                                      // 0x0451(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MatParam_Health;                                   // 0x0454(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FXSystemComponentTag_GunOverheat;                  // 0x045C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FXThreshold_GunOverheat;                           // 0x0464(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZoomDistanceToLODParticles_GunOverheat;            // 0x0468(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MatParam_GunOverheat;                              // 0x046C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GunOverheatParamIncreasePerShot;                   // 0x0474(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GunOverheatParamFadeoutTimeSeconds;                // 0x0478(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsesPathfinder;                                   // 0x047C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRegisterToNavGrid;                                // 0x047D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_47E[0x2];                                      // 0x047E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UBehaviorTree*                          IdleBehaviorAsset;                                 // 0x0480(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBehaviorTree*                          BaseBehaviorAssetOverride;                         // 0x0488(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlackboardData*                        BlackboardAssetOverride;                           // 0x0490(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class UTedPawnCommandWithBehavior>, struct FTedCommandWithBehaviorAssetSpec> CommandBehaviorOverrides; // 0x0498(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TSet<TSubclassOf<class UGameplayCommand>>     SupportedCommands;                                 // 0x04E8(0x0050)(Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         bCheckFieldOfViewForVision : 1;                    // 0x0538(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_539[0x7];                                      // 0x0539(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInstanceDynamic*>       MeshMIDs;                                          // 0x0540(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bAllowPlayAudioInFoW;                              // 0x0550(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_551[0x7];                                      // 0x0551(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ClientEffectsToTrack;                              // 0x0558(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayEffectStackContainer          GameplayEffectStack;                               // 0x0578(0x0168)(Net, RepNotify, NativeAccessSpecifierPublic)
	float                                         InitialLifetime;                                   // 0x06E0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTimeStart;                                     // 0x06E4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E8[0x18];                                     // 0x06E8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedPawnContainerComponent*             CachedPawnContainerComponent;                      // 0x0700(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           DefinitionId;                                      // 0x0708(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTedDefinitionRef                      DefinitionRef;                                     // 0x0710(0x0020)(Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_730[0x8];                                      // 0x0730(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OverriddenOwner;                                   // 0x0738(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_740[0x28];                                     // 0x0740(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	ETedPlayerID                                  InitPlayerID;                                      // 0x0768(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_769[0x3F];                                     // 0x0769(0x003F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedRepAnimMontage                     RepAnimMontageInfo;                                // 0x07A8(0x0018)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTedLocalAnimMontage                   LocalAnimMontageInfo;                              // 0x07C0(0x0028)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UAnimMontageSet*                        AnimMontageSetAsset;                               // 0x07E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAnimMontageSetData                    LocalAnimMontageSetData;                           // 0x07F0(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class UTedWeapon>, struct FAnimMontageSetData> WeaponAnimMontageSets;           // 0x0840(0x0050)(Protected, NativeAccessSpecifierProtected)
	struct FTedPawnFocusInfo                      FocusInfo;                                         // 0x0890(0x0030)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTedPawnFocusInfo>              CustomFocusInfoArray;                              // 0x08C0(0x0010)(Net, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bUseCustomFocusInfoArray;                          // 0x08D0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8D1[0x3];                                      // 0x08D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentCustomFocusInfoArrayIdx;                    // 0x08D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DefaultPhysicalFireLocSocketName;                  // 0x08D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8E0[0x8];                                      // 0x08E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedWeaponAimOffsetData                DefaultAimOffsetData;                              // 0x08E8(0x0028)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class UTedWeapon>, struct FTedWeaponAimData> WeaponAimDataSetup;                // 0x0910(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTedWeaponAimData                      CurrentAimData;                                    // 0x0960(0x0048)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              AimOffsetPct;                                      // 0x09A8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              CachedTargetAimOffsetPct;                          // 0x09B8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9C8[0x34];                                     // 0x09C8(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RootBoneYawAdjustment;                             // 0x09FC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USoundCue>               LoadSound;                                         // 0x0A00(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USoundCue>               UnloadSound;                                       // 0x0A28(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATedPawn*                               PawnContainerOwner;                                // 0x0A50(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PhysicalFireStartLocOverride;                      // 0x0A58(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A70[0x68];                                     // 0x0A70(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UTedWeapon>>         AvailableWeaponClasses;                            // 0x0AD8(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSubclassOf<class UTedWeapon>                 CurrentWeaponClass;                                // 0x0AE8(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTedWeapon>                 PendingWeaponClass;                                // 0x0AF0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTedWeapon*>                     AvailableWeapons;                                  // 0x0AF8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UTedWeapon*                             CurrentWeapon;                                     // 0x0B08(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTedWeaponInfo>                 WeaponInfoCache;                                   // 0x0B10(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FTedDefinitionRef                      WeaponDefinitionRef;                               // 0x0B20(0x0020)(Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 CachedFireTarget;                                  // 0x0B40(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B48[0x20];                                     // 0x0B48(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedAttackTargetInfo                   AttackTargetInfo;                                  // 0x0B68(0x0040)(Net, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bBypassTargetPriority : 1;                         // 0x0BA8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_BA9[0x12F];                                    // 0x0BA9(0x012F)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ATedPawn* Pawn)> OnDeathBlueprintEvent;                      // 0x0CD8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bDisconnectDeath;                                  // 0x0CE8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CE9[0x3];                                      // 0x0CE9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ATedPawn>                LastHealedBy;                                      // 0x0CEC(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CF4[0x4];                                      // 0x0CF4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedPawnDamageInfo                     LastDamageInfo;                                    // 0x0CF8(0x0020)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTedPawnDeathInfo                      PawnDeath;                                         // 0x0D18(0x0020)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D38[0x20];                                     // 0x0D38(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCameraShakeBase>           DeathCameraShakeClass;                             // 0x0D58(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraShakeInnerRadius;                            // 0x0D60(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraShakeOuterRadius;                            // 0x0D64(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraShakeFalloff;                                // 0x0D68(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOrientShakeTowardsEpicenter;                      // 0x0D6C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D6D[0x13];                                     // 0x0D6D(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bInteractsWithFoliage : 1;                         // 0x0D80(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_D81[0x7];                                      // 0x0D81(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  IgnoreFoliageTypes;                                // 0x0D88(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSet<EFoliageChannel>                         InteractableFoliageChannels;                       // 0x0DA8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         FoliageChannelFlag;                                // 0x0DF8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyFullDamageToPawnsInContainer;                // 0x0DF9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DFA[0x6];                                      // 0x0DFA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ATedPawn* ReplacedPawn, class ATedPawn* ReplacedBy)> OnPawnReplaced; // 0x0E00(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_E10[0x18];                                     // 0x0E10(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ATedPawn*                               ReplacedPawn;                                      // 0x0E28(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsBeingReplaced;                                  // 0x0E30(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E31[0x7];                                      // 0x0E31(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayCommandExecutionInfo          CommandExecutionInfo;                              // 0x0E38(0x0060)(Net, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E98[0x18];                                     // 0x0E98(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayCommandCooldowns              CommandCooldowns;                                  // 0x0EB0(0x0070)(Net, Transient, NativeAccessSpecifierPrivate)
	struct FTedGameplayTagReplicationContainer    ReplicationTags;                                   // 0x0F20(0x0060)(Net, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_F80[0x50];                                     // 0x0F80(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FActiveGameplayCueContainer            ReplicationGameplayCues;                           // 0x0FD0(0x0128)(Net, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class ATedGameplayCueNotify_StatusEffect*> StatusGameplayCues;                            // 0x10F8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1108[0x18];                                    // 0x1108(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UDecalComponent*                        SelectionDecal;                                    // 0x1120(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     SelectionDecalMaterial;                            // 0x1128(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSameTypeSelectable;                               // 0x1130(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMixedTypeSelectable;                              // 0x1131(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bGroupable;                                        // 0x1132(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanEverBeSelected;                                // 0x1133(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1134[0x4];                                     // 0x1134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   IsSelectionDecalSeenByOwnerParamName;              // 0x1138(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastSparseDelegateProperty_             OnVisibilityHasChanged;                            // 0x1140(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1141[0x7];                                     // 0x1141(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedVisibility                         Visibility;                                        // 0x1148(0x0038)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1180[0x68];                                    // 0x1180(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedGhostPawnArray                     GhostPawns;                                        // 0x11E8(0x0028)(Net, Transient, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class ATedGhostPawn>              GhostPawnClass;                                    // 0x1210(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1218[0x1];                                     // 0x1218(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSupportsFowHighlightPawn;                         // 0x1219(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_121A[0x6];                                     // 0x121A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ATedFoWHighlightPawn*                   FoWHighlightPawn;                                  // 0x1220(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1228[0x8];                                     // 0x1228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FName>                             IgnoredMaterialsForFowHighlight;                   // 0x1230(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class ASquareNavGrid*                         CachedNavGrid;                                     // 0x1280(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ARecastNavMesh*                         CachedNavMesh;                                     // 0x1288(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           InitActorTag;                                      // 0x1290(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1298[0x40];                                    // 0x1298(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	ETedVeterancyLevel                            VeterancyLevel;                                    // 0x12D8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12D9[0x3];                                     // 0x12D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GainedExperience;                                  // 0x12DC(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12E0[0x30];                                    // 0x12E0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	ETedPawnUpgradeTypeFlags                      UpgradeFlags;                                      // 0x1310(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedPawnUpgradeTypeFlags                      InitialUpgradeFlags;                               // 0x1311(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1312[0x6];                                     // 0x1312(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedPawnUpgradeData                    ResearchedUpgradeData;                             // 0x1318(0x0170)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FTedPawnUpgradeResearchProgress        UpgradeProgress;                                   // 0x1488(0x0038)(Net, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_14C0[0x8];                                     // 0x14C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRegisterInUpgradeSystem;                          // 0x14C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14C9[0x7];                                     // 0x14C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSavedProvidedAoEInfo                  ProvidedAoEInfo;                                   // 0x14D0(0x0050)(NativeAccessSpecifierPrivate)
	struct FSavedReceivedAoEInfo                  ReceivedAoEInfo;                                   // 0x1520(0x0010)(NativeAccessSpecifierPrivate)
	class UTedEntityDefinitionAsset*              CachedDefinitionAsset;                             // 0x1530(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1538[0x10];                                    // 0x1538(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           TrackedSupportPowerTag;                            // 0x1548(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<ETedStatusType, int32>                   StatusTypeState;                                   // 0x1550(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_15A0[0xE0];                                    // 0x15A0(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	ETedPawnSkinIndex                             SkinOverrideIndex;                                 // 0x1680(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1681[0x7];                                     // 0x1681(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInterface*>             SkinOverrides;                                     // 0x1688(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UMeshComponent*                         SkinOverrideMesh;                                  // 0x1698(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSkinOverridesEnabled;                             // 0x16A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16A1[0x7];                                     // 0x16A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddExperience(const float InGainedExperience);
	void ClearAnimatingAbility(class UGameplayAbility* Ability);
	void Client_R_InterpTo(const struct FTransform& InitLoc, const struct FTransform& TargetLoc, float RotTime, float LocTime, float AlignmentDistanceTolerance);
	void CurrentMontageJumpToSection(class FName SectionName);
	void CurrentMontageSetPlayRate(float InPlayRate);
	void CurrentMontageStop(float OverrideBlendOutTime);
	bool FindPathGoalLocation(const struct FVector& StartPoint, const struct FVector& EndPoint, struct FVector* OutLocation);
	void GiveWeapon(const TSubclassOf<class UTedWeapon> WeaponClass, const bool bSkipNotify);
	void K2_OnWeaponSwitched(class UTedWeapon* NewWeapon, class UTedWeapon* PreviousWeapon);
	void K2_SetCanBeDamaged(const bool bInCanBeDamaged);
	void NetMulticast_Died();
	void NetMulticast_OnLifeTimeExpired();
	void OnDelayedDestroy();
	void OnFirstPlayerStateReplicated(class ATedPlayerController* PlayerController);
	void OnLifeTimeExpired();
	void OnLifeTimeExpiredCosmetic();
	void OnPlayerIDChanged(ETedPlayerID NewPlayerID);
	void OnRep_AvailableWeaponClasses(const TArray<TSubclassOf<class UTedWeapon>>& OldAvailableWeaponClasses);
	void OnRep_CommandExecutionInfo();
	void OnRep_CurrentWeaponClass();
	void OnRep_GainedExperience(const float PreviousExperience);
	void OnRep_GameplayEffectStack();
	void OnRep_InitialLifetime();
	void OnRep_LastDamageInfo();
	void OnRep_PawnContainerOwner();
	void OnRep_PawnDeath();
	void OnRep_RepAnimMontageInfo();
	void OnRep_RepFocusInfo_Debug();
	void OnRep_ReplacedPawn();
	void OnRep_ReplicationTags();
	void OnRep_UpgradeFlags(const ETedPawnUpgradeTypeFlags PrevUpgradeFlags);
	void OnRep_Visibility(const struct FTedVisibility& OldValue);
	void OnRep_WeaponInfoCache(const TArray<struct FTedWeaponInfo>& OldWeaponInfoCache);
	void OnSelectionChanged_Blueprint(const bool bIsSelected, const bool bIsHovered);
	float PlayMontage(class UAnimMontage* AnimMontage, float PlayRate, class FName StartSectionName, float StartTimeSeconds, class UGameplayAbility* AnimatingAbility);
	void ReceiveOnDeath();
	void ReceiveOnPawnReplaced(class ATedPawn* ReplacedBy);
	void ReceiveOnVeterancyLevelChanged(ETedVeterancyLevel NewLevel, ETedVeterancyLevel PreviousLevel);
	void ReceiveTakeAnyDamage(class AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser);
	void ReceiveUpdateHealthEffects(float HealthPct);
	void ReceiveUpgradeActivated(const ETedPawnUpgradeType UpgradeType);
	void RemoveWeapon(const TSubclassOf<class UTedWeapon> WeaponClass, const bool bSkipNotify);
	void Server_DestroyActorDelayed();
	void SetAttackBehaviorEnabled(const bool bEnabled);
	void SetCanBeDamagedDuringCinematic(const bool bCanBeDamagedDuringCinematic);
	void SetCurrentWeapon(const TSubclassOf<class UTedWeapon> WeaponClass);
	void SetEvadeBehaviorEnabled(const bool bEnabled);
	void SetIdleBehaviorsEnabled(const bool bEnabled);
	void SetInvestigationBehaviorEnabled(const bool bEnabled);
	void StartAutoRechargingWeapons();
	void StartRechargingWeapons(bool bAutoRechargeOnly);
	void StopRechargingWeapons(bool bSkipAutoRecharge);
	void UpgradePawn(const ETedPawnUpgradeTypeFlags InUpgradeFlags);

	bool AreAllIdleBehaviorsEnabled() const;
	bool CanBeDamagedDuringCinematicMode() const;
	bool CanFire() const;
	const class UTedWeapon* FindBestWeapon(const class ATedPawn* Target, const struct FVector& TargetLocation, const bool bDoWeaponDistanceCheck) const;
	TSubclassOf<class UTedWeapon> FindBestWeaponClass(const class ATedPawn* Target, const struct FVector& TargetLocation) const;
	class UAnimMontage* GetAnimMontageFromSet(const struct FGameplayTag& MontageId) const;
	class UAnimMontageSet* GetAnimMontageSetAsset() const;
	class UTedWeapon* GetAvailableWeapon(const TSubclassOf<class UTedWeapon> WeaponClass, const bool bExactMatch) const;
	TArray<TSubclassOf<class UTedWeapon>> GetAvailableWeaponClasses() const;
	TArray<class UTedWeapon*> GetAvailableWeapons() const;
	class UAnimMontage* GetCurrentMontage() const;
	class UTedWeapon* GetCurrentWeapon() const;
	TSubclassOf<class UTedWeapon> GetCurrentWeaponClass() const;
	const struct FGameplayTag GetDefinitionId() const;
	struct FGameplayTag GetEntityDomain() const;
	class AActor* GetFireTarget() const;
	struct FVector GetFireTargetLocation() const;
	struct FVector GetFocalPoint() const;
	class AActor* GetFocusActor() const;
	struct FVector GetFocusLocation() const;
	struct FRotator GetFocusRotation() const;
	float GetFoWRevealRadius() const;
	float GetFoWVisionRadius() const;
	float GetGainedExperience() const;
	float GetHealth() const;
	float GetHealthMax() const;
	float GetHealthPct() const;
	const struct FTedPawnDamageInfo GetLastDamageInfo() const;
	float GetLifeTime() const;
	TSoftObjectPtr<class USoundCue> GetLoadSound() const;
	ETedFaction GetOwningFaction() const;
	class ATedPlayerController* GetOwningPlayerController() const;
	class UTedPlayerData* GetOwningPlayerData() const;
	ETedPlayerID GetOwningPlayerID() const;
	class ATedPlayerState* GetOwningPlayerState(bool bReturnOriginalOwner) const;
	class ATedPawn* GetPawnContainerOwner() const;
	ETedFaction GetPawnFactionFromDefinition() const;
	TSubclassOf<class UTedAnnouncement> GetPawnUnderAttackAnnouncement() const;
	struct FVector GetPhysicalFireStartLoc(class FName PhysicalFireLocSocketNameOverride) const;
	float GetPower() const;
	float GetPowerBase() const;
	float GetRemainingLifeTime() const;
	const struct FGameplayTagContainer GetTargetingDomains() const;
	TSoftObjectPtr<class USoundCue> GetUnloadSound() const;
	ETedVeterancyLevel GetVeterancyLevel() const;
	float GetVeterancyProgressToNextLevel() const;
	void HandleCreditsGatheredStatusEffect() const;
	bool HasAmmoForWeapon(const class UTedWeapon* Weapon) const;
	bool HasAnimMontageInSet(const struct FGameplayTag& MontageId) const;
	bool HasAnyWeapon() const;
	bool HasFireTarget() const;
	bool HasFocus() const;
	bool HasMaxAmmoForWeapon(const class UTedWeapon* Weapon) const;
	bool HasUpgrade(const ETedPawnUpgradeType UpgradeType) const;
	bool HasWeapon(const TSubclassOf<class UTedWeapon> WeaponClass) const;
	bool HasWeaponSelected() const;
	bool IsAlive() const;
	bool IsAttackBehaviorEnabled() const;
	bool IsDamaged() const;
	bool IsEvadeBehaviorEnabled() const;
	bool IsFogOfWarVisible(const uint8 ChannelId) const;
	bool IsFogOfWarVisibleFor(const class ATedPlayerController* TedPC) const;
	bool IsFogOfWarVisibleForLocalPlayer() const;
	bool IsFogOfWarVisibleForLocalPlayerReal() const;
	bool IsInContainer() const;
	bool IsInEntityDomain(const struct FGameplayTag& InEntityDomain) const;
	bool IsInvestigationBehaviorEnabled() const;
	bool IsReachargingWeapons() const;
	bool IsResearchingUpgrade() const;
	bool IsUpgraded() const;
	bool IsUpgradeResearchRunning() const;
	TArray<class UAnimMontage*> K2_GetAnimMontagesFromSet(const struct FGameplayTag& MontageId) const;
	uint8 K2_GetLocalVisibilityChannel() const;
	bool K2_WasEverVisibleLocally() const;
	bool ShouldRegisterInUpgradeSystem() const;
	int32 TedGetActiveEffectCount(const TSubclassOf<class UGameplayEffect>& Effect) const;
	bool TedHasAnyActiveEffect(const struct FGameplayTagContainer& InContainer, bool bRequireAll) const;
	bool TedIsEffectActive(const TSubclassOf<class UGameplayEffect>& Effect) const;
	bool WasRecentlyRenderedOnScreen(float Tolerance) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawn">();
	}
	static class ATedPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedPawn>();
	}
};
#pragma pack(pop)
static_assert(alignof(ATedPawn) == 0x000010, "Wrong alignment on ATedPawn");
static_assert(sizeof(ATedPawn) == 0x0016B0, "Wrong size on ATedPawn");
static_assert(offsetof(ATedPawn, EcsActor) == 0x0003B8, "Member 'ATedPawn::EcsActor' has a wrong offset!");
static_assert(offsetof(ATedPawn, MeshComp) == 0x0003C0, "Member 'ATedPawn::MeshComp' has a wrong offset!");
static_assert(offsetof(ATedPawn, SkeletalMeshComp) == 0x0003C8, "Member 'ATedPawn::SkeletalMeshComp' has a wrong offset!");
static_assert(offsetof(ATedPawn, StaticMeshComp) == 0x0003D0, "Member 'ATedPawn::StaticMeshComp' has a wrong offset!");
static_assert(offsetof(ATedPawn, AbilityComponent) == 0x0003D8, "Member 'ATedPawn::AbilityComponent' has a wrong offset!");
static_assert(offsetof(ATedPawn, MyAIController) == 0x0003E0, "Member 'ATedPawn::MyAIController' has a wrong offset!");
static_assert(offsetof(ATedPawn, DefaultAttributeSet) == 0x0003E8, "Member 'ATedPawn::DefaultAttributeSet' has a wrong offset!");
static_assert(offsetof(ATedPawn, SpawnedAttributeSets) == 0x0003F0, "Member 'ATedPawn::SpawnedAttributeSets' has a wrong offset!");
static_assert(offsetof(ATedPawn, SelectionDecalRadius) == 0x000400, "Member 'ATedPawn::SelectionDecalRadius' has a wrong offset!");
static_assert(offsetof(ATedPawn, SelectionHitBoxCenterOffset) == 0x000408, "Member 'ATedPawn::SelectionHitBoxCenterOffset' has a wrong offset!");
static_assert(offsetof(ATedPawn, SelectionHitBoxExtent) == 0x000420, "Member 'ATedPawn::SelectionHitBoxExtent' has a wrong offset!");
static_assert(offsetof(ATedPawn, UnderAttackAnnouncement) == 0x000438, "Member 'ATedPawn::UnderAttackAnnouncement' has a wrong offset!");
static_assert(offsetof(ATedPawn, DiedAnnouncement) == 0x000440, "Member 'ATedPawn::DiedAnnouncement' has a wrong offset!");
static_assert(offsetof(ATedPawn, FogOfWarAgentRadiusMultiplier) == 0x000448, "Member 'ATedPawn::FogOfWarAgentRadiusMultiplier' has a wrong offset!");
static_assert(offsetof(ATedPawn, DestroyActorDelay) == 0x00044C, "Member 'ATedPawn::DestroyActorDelay' has a wrong offset!");
static_assert(offsetof(ATedPawn, bDontGiveExperience) == 0x000450, "Member 'ATedPawn::bDontGiveExperience' has a wrong offset!");
static_assert(offsetof(ATedPawn, MatParam_Health) == 0x000454, "Member 'ATedPawn::MatParam_Health' has a wrong offset!");
static_assert(offsetof(ATedPawn, FXSystemComponentTag_GunOverheat) == 0x00045C, "Member 'ATedPawn::FXSystemComponentTag_GunOverheat' has a wrong offset!");
static_assert(offsetof(ATedPawn, FXThreshold_GunOverheat) == 0x000464, "Member 'ATedPawn::FXThreshold_GunOverheat' has a wrong offset!");
static_assert(offsetof(ATedPawn, ZoomDistanceToLODParticles_GunOverheat) == 0x000468, "Member 'ATedPawn::ZoomDistanceToLODParticles_GunOverheat' has a wrong offset!");
static_assert(offsetof(ATedPawn, MatParam_GunOverheat) == 0x00046C, "Member 'ATedPawn::MatParam_GunOverheat' has a wrong offset!");
static_assert(offsetof(ATedPawn, GunOverheatParamIncreasePerShot) == 0x000474, "Member 'ATedPawn::GunOverheatParamIncreasePerShot' has a wrong offset!");
static_assert(offsetof(ATedPawn, GunOverheatParamFadeoutTimeSeconds) == 0x000478, "Member 'ATedPawn::GunOverheatParamFadeoutTimeSeconds' has a wrong offset!");
static_assert(offsetof(ATedPawn, bUsesPathfinder) == 0x00047C, "Member 'ATedPawn::bUsesPathfinder' has a wrong offset!");
static_assert(offsetof(ATedPawn, bRegisterToNavGrid) == 0x00047D, "Member 'ATedPawn::bRegisterToNavGrid' has a wrong offset!");
static_assert(offsetof(ATedPawn, IdleBehaviorAsset) == 0x000480, "Member 'ATedPawn::IdleBehaviorAsset' has a wrong offset!");
static_assert(offsetof(ATedPawn, BaseBehaviorAssetOverride) == 0x000488, "Member 'ATedPawn::BaseBehaviorAssetOverride' has a wrong offset!");
static_assert(offsetof(ATedPawn, BlackboardAssetOverride) == 0x000490, "Member 'ATedPawn::BlackboardAssetOverride' has a wrong offset!");
static_assert(offsetof(ATedPawn, CommandBehaviorOverrides) == 0x000498, "Member 'ATedPawn::CommandBehaviorOverrides' has a wrong offset!");
static_assert(offsetof(ATedPawn, SupportedCommands) == 0x0004E8, "Member 'ATedPawn::SupportedCommands' has a wrong offset!");
static_assert(offsetof(ATedPawn, MeshMIDs) == 0x000540, "Member 'ATedPawn::MeshMIDs' has a wrong offset!");
static_assert(offsetof(ATedPawn, bAllowPlayAudioInFoW) == 0x000550, "Member 'ATedPawn::bAllowPlayAudioInFoW' has a wrong offset!");
static_assert(offsetof(ATedPawn, ClientEffectsToTrack) == 0x000558, "Member 'ATedPawn::ClientEffectsToTrack' has a wrong offset!");
static_assert(offsetof(ATedPawn, GameplayEffectStack) == 0x000578, "Member 'ATedPawn::GameplayEffectStack' has a wrong offset!");
static_assert(offsetof(ATedPawn, InitialLifetime) == 0x0006E0, "Member 'ATedPawn::InitialLifetime' has a wrong offset!");
static_assert(offsetof(ATedPawn, LifeTimeStart) == 0x0006E4, "Member 'ATedPawn::LifeTimeStart' has a wrong offset!");
static_assert(offsetof(ATedPawn, CachedPawnContainerComponent) == 0x000700, "Member 'ATedPawn::CachedPawnContainerComponent' has a wrong offset!");
static_assert(offsetof(ATedPawn, DefinitionId) == 0x000708, "Member 'ATedPawn::DefinitionId' has a wrong offset!");
static_assert(offsetof(ATedPawn, DefinitionRef) == 0x000710, "Member 'ATedPawn::DefinitionRef' has a wrong offset!");
static_assert(offsetof(ATedPawn, OverriddenOwner) == 0x000738, "Member 'ATedPawn::OverriddenOwner' has a wrong offset!");
static_assert(offsetof(ATedPawn, InitPlayerID) == 0x000768, "Member 'ATedPawn::InitPlayerID' has a wrong offset!");
static_assert(offsetof(ATedPawn, RepAnimMontageInfo) == 0x0007A8, "Member 'ATedPawn::RepAnimMontageInfo' has a wrong offset!");
static_assert(offsetof(ATedPawn, LocalAnimMontageInfo) == 0x0007C0, "Member 'ATedPawn::LocalAnimMontageInfo' has a wrong offset!");
static_assert(offsetof(ATedPawn, AnimMontageSetAsset) == 0x0007E8, "Member 'ATedPawn::AnimMontageSetAsset' has a wrong offset!");
static_assert(offsetof(ATedPawn, LocalAnimMontageSetData) == 0x0007F0, "Member 'ATedPawn::LocalAnimMontageSetData' has a wrong offset!");
static_assert(offsetof(ATedPawn, WeaponAnimMontageSets) == 0x000840, "Member 'ATedPawn::WeaponAnimMontageSets' has a wrong offset!");
static_assert(offsetof(ATedPawn, FocusInfo) == 0x000890, "Member 'ATedPawn::FocusInfo' has a wrong offset!");
static_assert(offsetof(ATedPawn, CustomFocusInfoArray) == 0x0008C0, "Member 'ATedPawn::CustomFocusInfoArray' has a wrong offset!");
static_assert(offsetof(ATedPawn, bUseCustomFocusInfoArray) == 0x0008D0, "Member 'ATedPawn::bUseCustomFocusInfoArray' has a wrong offset!");
static_assert(offsetof(ATedPawn, CurrentCustomFocusInfoArrayIdx) == 0x0008D4, "Member 'ATedPawn::CurrentCustomFocusInfoArrayIdx' has a wrong offset!");
static_assert(offsetof(ATedPawn, DefaultPhysicalFireLocSocketName) == 0x0008D8, "Member 'ATedPawn::DefaultPhysicalFireLocSocketName' has a wrong offset!");
static_assert(offsetof(ATedPawn, DefaultAimOffsetData) == 0x0008E8, "Member 'ATedPawn::DefaultAimOffsetData' has a wrong offset!");
static_assert(offsetof(ATedPawn, WeaponAimDataSetup) == 0x000910, "Member 'ATedPawn::WeaponAimDataSetup' has a wrong offset!");
static_assert(offsetof(ATedPawn, CurrentAimData) == 0x000960, "Member 'ATedPawn::CurrentAimData' has a wrong offset!");
static_assert(offsetof(ATedPawn, AimOffsetPct) == 0x0009A8, "Member 'ATedPawn::AimOffsetPct' has a wrong offset!");
static_assert(offsetof(ATedPawn, CachedTargetAimOffsetPct) == 0x0009B8, "Member 'ATedPawn::CachedTargetAimOffsetPct' has a wrong offset!");
static_assert(offsetof(ATedPawn, RootBoneYawAdjustment) == 0x0009FC, "Member 'ATedPawn::RootBoneYawAdjustment' has a wrong offset!");
static_assert(offsetof(ATedPawn, LoadSound) == 0x000A00, "Member 'ATedPawn::LoadSound' has a wrong offset!");
static_assert(offsetof(ATedPawn, UnloadSound) == 0x000A28, "Member 'ATedPawn::UnloadSound' has a wrong offset!");
static_assert(offsetof(ATedPawn, PawnContainerOwner) == 0x000A50, "Member 'ATedPawn::PawnContainerOwner' has a wrong offset!");
static_assert(offsetof(ATedPawn, PhysicalFireStartLocOverride) == 0x000A58, "Member 'ATedPawn::PhysicalFireStartLocOverride' has a wrong offset!");
static_assert(offsetof(ATedPawn, AvailableWeaponClasses) == 0x000AD8, "Member 'ATedPawn::AvailableWeaponClasses' has a wrong offset!");
static_assert(offsetof(ATedPawn, CurrentWeaponClass) == 0x000AE8, "Member 'ATedPawn::CurrentWeaponClass' has a wrong offset!");
static_assert(offsetof(ATedPawn, PendingWeaponClass) == 0x000AF0, "Member 'ATedPawn::PendingWeaponClass' has a wrong offset!");
static_assert(offsetof(ATedPawn, AvailableWeapons) == 0x000AF8, "Member 'ATedPawn::AvailableWeapons' has a wrong offset!");
static_assert(offsetof(ATedPawn, CurrentWeapon) == 0x000B08, "Member 'ATedPawn::CurrentWeapon' has a wrong offset!");
static_assert(offsetof(ATedPawn, WeaponInfoCache) == 0x000B10, "Member 'ATedPawn::WeaponInfoCache' has a wrong offset!");
static_assert(offsetof(ATedPawn, WeaponDefinitionRef) == 0x000B20, "Member 'ATedPawn::WeaponDefinitionRef' has a wrong offset!");
static_assert(offsetof(ATedPawn, CachedFireTarget) == 0x000B40, "Member 'ATedPawn::CachedFireTarget' has a wrong offset!");
static_assert(offsetof(ATedPawn, AttackTargetInfo) == 0x000B68, "Member 'ATedPawn::AttackTargetInfo' has a wrong offset!");
static_assert(offsetof(ATedPawn, OnDeathBlueprintEvent) == 0x000CD8, "Member 'ATedPawn::OnDeathBlueprintEvent' has a wrong offset!");
static_assert(offsetof(ATedPawn, bDisconnectDeath) == 0x000CE8, "Member 'ATedPawn::bDisconnectDeath' has a wrong offset!");
static_assert(offsetof(ATedPawn, LastHealedBy) == 0x000CEC, "Member 'ATedPawn::LastHealedBy' has a wrong offset!");
static_assert(offsetof(ATedPawn, LastDamageInfo) == 0x000CF8, "Member 'ATedPawn::LastDamageInfo' has a wrong offset!");
static_assert(offsetof(ATedPawn, PawnDeath) == 0x000D18, "Member 'ATedPawn::PawnDeath' has a wrong offset!");
static_assert(offsetof(ATedPawn, DeathCameraShakeClass) == 0x000D58, "Member 'ATedPawn::DeathCameraShakeClass' has a wrong offset!");
static_assert(offsetof(ATedPawn, CameraShakeInnerRadius) == 0x000D60, "Member 'ATedPawn::CameraShakeInnerRadius' has a wrong offset!");
static_assert(offsetof(ATedPawn, CameraShakeOuterRadius) == 0x000D64, "Member 'ATedPawn::CameraShakeOuterRadius' has a wrong offset!");
static_assert(offsetof(ATedPawn, CameraShakeFalloff) == 0x000D68, "Member 'ATedPawn::CameraShakeFalloff' has a wrong offset!");
static_assert(offsetof(ATedPawn, bOrientShakeTowardsEpicenter) == 0x000D6C, "Member 'ATedPawn::bOrientShakeTowardsEpicenter' has a wrong offset!");
static_assert(offsetof(ATedPawn, IgnoreFoliageTypes) == 0x000D88, "Member 'ATedPawn::IgnoreFoliageTypes' has a wrong offset!");
static_assert(offsetof(ATedPawn, InteractableFoliageChannels) == 0x000DA8, "Member 'ATedPawn::InteractableFoliageChannels' has a wrong offset!");
static_assert(offsetof(ATedPawn, FoliageChannelFlag) == 0x000DF8, "Member 'ATedPawn::FoliageChannelFlag' has a wrong offset!");
static_assert(offsetof(ATedPawn, bApplyFullDamageToPawnsInContainer) == 0x000DF9, "Member 'ATedPawn::bApplyFullDamageToPawnsInContainer' has a wrong offset!");
static_assert(offsetof(ATedPawn, OnPawnReplaced) == 0x000E00, "Member 'ATedPawn::OnPawnReplaced' has a wrong offset!");
static_assert(offsetof(ATedPawn, ReplacedPawn) == 0x000E28, "Member 'ATedPawn::ReplacedPawn' has a wrong offset!");
static_assert(offsetof(ATedPawn, bIsBeingReplaced) == 0x000E30, "Member 'ATedPawn::bIsBeingReplaced' has a wrong offset!");
static_assert(offsetof(ATedPawn, CommandExecutionInfo) == 0x000E38, "Member 'ATedPawn::CommandExecutionInfo' has a wrong offset!");
static_assert(offsetof(ATedPawn, CommandCooldowns) == 0x000EB0, "Member 'ATedPawn::CommandCooldowns' has a wrong offset!");
static_assert(offsetof(ATedPawn, ReplicationTags) == 0x000F20, "Member 'ATedPawn::ReplicationTags' has a wrong offset!");
static_assert(offsetof(ATedPawn, ReplicationGameplayCues) == 0x000FD0, "Member 'ATedPawn::ReplicationGameplayCues' has a wrong offset!");
static_assert(offsetof(ATedPawn, StatusGameplayCues) == 0x0010F8, "Member 'ATedPawn::StatusGameplayCues' has a wrong offset!");
static_assert(offsetof(ATedPawn, SelectionDecal) == 0x001120, "Member 'ATedPawn::SelectionDecal' has a wrong offset!");
static_assert(offsetof(ATedPawn, SelectionDecalMaterial) == 0x001128, "Member 'ATedPawn::SelectionDecalMaterial' has a wrong offset!");
static_assert(offsetof(ATedPawn, bSameTypeSelectable) == 0x001130, "Member 'ATedPawn::bSameTypeSelectable' has a wrong offset!");
static_assert(offsetof(ATedPawn, bMixedTypeSelectable) == 0x001131, "Member 'ATedPawn::bMixedTypeSelectable' has a wrong offset!");
static_assert(offsetof(ATedPawn, bGroupable) == 0x001132, "Member 'ATedPawn::bGroupable' has a wrong offset!");
static_assert(offsetof(ATedPawn, bCanEverBeSelected) == 0x001133, "Member 'ATedPawn::bCanEverBeSelected' has a wrong offset!");
static_assert(offsetof(ATedPawn, IsSelectionDecalSeenByOwnerParamName) == 0x001138, "Member 'ATedPawn::IsSelectionDecalSeenByOwnerParamName' has a wrong offset!");
static_assert(offsetof(ATedPawn, OnVisibilityHasChanged) == 0x001140, "Member 'ATedPawn::OnVisibilityHasChanged' has a wrong offset!");
static_assert(offsetof(ATedPawn, Visibility) == 0x001148, "Member 'ATedPawn::Visibility' has a wrong offset!");
static_assert(offsetof(ATedPawn, GhostPawns) == 0x0011E8, "Member 'ATedPawn::GhostPawns' has a wrong offset!");
static_assert(offsetof(ATedPawn, GhostPawnClass) == 0x001210, "Member 'ATedPawn::GhostPawnClass' has a wrong offset!");
static_assert(offsetof(ATedPawn, bSupportsFowHighlightPawn) == 0x001219, "Member 'ATedPawn::bSupportsFowHighlightPawn' has a wrong offset!");
static_assert(offsetof(ATedPawn, FoWHighlightPawn) == 0x001220, "Member 'ATedPawn::FoWHighlightPawn' has a wrong offset!");
static_assert(offsetof(ATedPawn, IgnoredMaterialsForFowHighlight) == 0x001230, "Member 'ATedPawn::IgnoredMaterialsForFowHighlight' has a wrong offset!");
static_assert(offsetof(ATedPawn, CachedNavGrid) == 0x001280, "Member 'ATedPawn::CachedNavGrid' has a wrong offset!");
static_assert(offsetof(ATedPawn, CachedNavMesh) == 0x001288, "Member 'ATedPawn::CachedNavMesh' has a wrong offset!");
static_assert(offsetof(ATedPawn, InitActorTag) == 0x001290, "Member 'ATedPawn::InitActorTag' has a wrong offset!");
static_assert(offsetof(ATedPawn, VeterancyLevel) == 0x0012D8, "Member 'ATedPawn::VeterancyLevel' has a wrong offset!");
static_assert(offsetof(ATedPawn, GainedExperience) == 0x0012DC, "Member 'ATedPawn::GainedExperience' has a wrong offset!");
static_assert(offsetof(ATedPawn, UpgradeFlags) == 0x001310, "Member 'ATedPawn::UpgradeFlags' has a wrong offset!");
static_assert(offsetof(ATedPawn, InitialUpgradeFlags) == 0x001311, "Member 'ATedPawn::InitialUpgradeFlags' has a wrong offset!");
static_assert(offsetof(ATedPawn, ResearchedUpgradeData) == 0x001318, "Member 'ATedPawn::ResearchedUpgradeData' has a wrong offset!");
static_assert(offsetof(ATedPawn, UpgradeProgress) == 0x001488, "Member 'ATedPawn::UpgradeProgress' has a wrong offset!");
static_assert(offsetof(ATedPawn, bRegisterInUpgradeSystem) == 0x0014C8, "Member 'ATedPawn::bRegisterInUpgradeSystem' has a wrong offset!");
static_assert(offsetof(ATedPawn, ProvidedAoEInfo) == 0x0014D0, "Member 'ATedPawn::ProvidedAoEInfo' has a wrong offset!");
static_assert(offsetof(ATedPawn, ReceivedAoEInfo) == 0x001520, "Member 'ATedPawn::ReceivedAoEInfo' has a wrong offset!");
static_assert(offsetof(ATedPawn, CachedDefinitionAsset) == 0x001530, "Member 'ATedPawn::CachedDefinitionAsset' has a wrong offset!");
static_assert(offsetof(ATedPawn, TrackedSupportPowerTag) == 0x001548, "Member 'ATedPawn::TrackedSupportPowerTag' has a wrong offset!");
static_assert(offsetof(ATedPawn, StatusTypeState) == 0x001550, "Member 'ATedPawn::StatusTypeState' has a wrong offset!");
static_assert(offsetof(ATedPawn, SkinOverrideIndex) == 0x001680, "Member 'ATedPawn::SkinOverrideIndex' has a wrong offset!");
static_assert(offsetof(ATedPawn, SkinOverrides) == 0x001688, "Member 'ATedPawn::SkinOverrides' has a wrong offset!");
static_assert(offsetof(ATedPawn, SkinOverrideMesh) == 0x001698, "Member 'ATedPawn::SkinOverrideMesh' has a wrong offset!");
static_assert(offsetof(ATedPawn, bSkinOverridesEnabled) == 0x0016A0, "Member 'ATedPawn::bSkinOverridesEnabled' has a wrong offset!");

// Class Tempest.TedStructureBase
// 0x0350 (0x1A00 - 0x16B0)
#pragma pack(push, 0x1)
class alignas(0x10) ATedStructureBase : public ATedPawn
{
public:
	float                                         StructureSellBeginTime;                            // 0x16A8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16AC[0x4];                                     // 0x16AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           SellStructure_TimerHandle;                         // 0x16B0(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16B8[0x18];                                    // 0x16B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          NavModifier;                                       // 0x16D0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FIntPoint                              StructureGridSize;                                 // 0x16D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           SpawnAnimation;                                    // 0x16E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           DeconstructAnimation;                              // 0x16E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationAsset*                        PlacementPreviewAnim;                              // 0x16F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class FName>                             PlacementPreviewHiddenBones;                       // 0x16F8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSet<TSubclassOf<class UNavArea>>             InvalidNavAreas;                                   // 0x1748(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FVector                                GridPivotOffsetLocation;                           // 0x1798(0x0018)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CollisionRadiusModifier;                           // 0x17B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIgnoreInfluenceArea : 1;                          // 0x17B4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_17B5[0x3];                                     // 0x17B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   UnitSpawnSplineComponentTag;                       // 0x17B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            SellTimeToHP;                                      // 0x17C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            CaptureTimeToHP;                                   // 0x17C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              IdleSound;                                         // 0x17D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              SpawnSound;                                        // 0x17D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StructureSoundVolume;                              // 0x17E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StructureSoundPitch;                               // 0x17E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        IdleAC;                                            // 0x17E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OriginalCreationTime;                              // 0x17F0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17F4[0x54];                                    // 0x17F4(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CaptureStructureBeginTime;                         // 0x1848(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERTSColor                                     CapturePlayerColorId;                              // 0x184C(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_184D[0x3];                                     // 0x184D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CachedCaptureInstigator;                           // 0x1850(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           CaptureStructure_TimerHandle;                      // 0x1858(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 CachedNewOwner;                                    // 0x1860(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1868[0x18];                                    // 0x1868(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETedPawnUpgradeTypeFlags, struct FTedStructureUpgradeEffects> UpgradeEffects;               // 0x1880(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            GE_InsufficientPower;                              // 0x18D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            GE_NoPower;                                        // 0x18D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         PowerState;                                        // 0x18E0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_18E1[0x2];                                     // 0x18E1(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsUserPowered;                                    // 0x18E3(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bRepairing : 1;                                    // 0x18E4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_18E5[0x3];                                     // 0x18E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           TH_Repairing;                                      // 0x18E8(0x0008)(Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_18F0[0x4];                                     // 0x18F0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bConstructingVisualsRelevant : 1;                  // 0x18F4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseConstructionVisualComponentTag : 1;            // 0x18F4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_18F5[0x3];                                     // 0x18F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistributionModeConstructionPlayRate;              // 0x18F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ConstructionVisualComponentTag;                    // 0x18FC(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1904[0xC];                                     // 0x1904(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOffsetCoords>                  ReplicatedBuildRadius;                             // 0x1910(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	TSet<struct FOffsetCoords>                    BuildRadius;                                       // 0x1920(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	bool                                          bCanChangeAlignment;                               // 0x1970(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedStructureAlignment                        Alignment;                                         // 0x1971(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         AlignmentOffset;                                   // 0x1972(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1973[0x5];                                     // 0x1973(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   TempStaticMesh;                                    // 0x1978(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1980[0x8];                                     // 0x1980(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bDeconstructing : 1;                               // 0x1988(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1989[0x7];                                     // 0x1989(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRallyPointTarget                      RallyPointTarget;                                  // 0x1990(0x0068)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)

public:
	void Client_OnUnitSpawned(class ATedUnitBase* SpawnedUnit);
	void FinishDeconstruction();
	void K2_OnBeginSellingStructure();
	void K2_OnEndSellingStructure();
	class ATedUnitBase* K2_OnUnitSpawned(class ATedUnitBase* SpawnedUnit);
	void Multicast_OnCaptured(ETedPlayerID NewPlayerID);
	void NetMulticast_OnUnitSpawned(class ATedUnitBase* SpawnedUnit);
	void OnCapturedCosmetic(ETedPlayerID NewPlayerID);
	void OnPlaySpawnEffectsCosmetic();
	void OnRep_Alignment();
	void OnRep_PowerState();
	void OnRep_RallyPointTarget();
	void OnRep_Repairing();
	void OnRep_ReplicatedBuildRadius();
	void OnRep_StructureSell();
	void ReceiveHandleConstructionVisuals(const bool bInConstructing);
	void ReceiveHandlePowerStateVisuals(const bool bBlackedOut, const bool bUserPowered, const bool bSufficientPower);
	void ReceiveOnCaptured(ETedPlayerID NewPlayerID);
	void SetConstructionPlayRateOverride(const bool bSet, const float InPlayRate);
	void SetPowerStateFlag(const ETedPowerStateFlag InFlag, const bool bInEnable);
	void SetRepairing(const bool bInRepairing);
	class ATedUnitBase* SpawnUnit(TSubclassOf<class ATedUnitBase> InUnitClass, ETedStructureUnitSpawnMode InMode);
	void StartDeconstructing();

	bool CanSpawnUnit() const;
	ETedStructureAlignment GetAlignment(const bool bIgnoreOffset) const;
	const class UTedStructureDefinitionAsset* GetDefinitionAsset() const;
	class UBoxComponent* GetNavModifier() const;
	ETedPowerStatus GetPowerStatus() const;
	float GetStructureCaptureBeginTime() const;
	float GetStructureCaptureProgress() const;
	float GetStructureCaptureTime() const;
	const struct FIntPoint GetStructureGridSize() const;
	const struct FIntPoint GetStructureGridSizeAligned(const ETedStructureAlignment InAlignment) const;
	float GetStructureSellBeginTime() const;
	float GetStructureSellProgress() const;
	float GetStructureSellTime() const;
	class UStaticMeshComponent* GetTempStaticMesh() const;
	bool HasPowerStateFlag(const ETedPowerStateFlag InFlag) const;
	bool IsConstructing() const;
	bool IsRepairing() const;
	bool IsStructureBeingCaptured() const;
	bool IsStructureBeingSold() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedStructureBase">();
	}
	static class ATedStructureBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedStructureBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(ATedStructureBase) == 0x000010, "Wrong alignment on ATedStructureBase");
static_assert(sizeof(ATedStructureBase) == 0x001A00, "Wrong size on ATedStructureBase");
static_assert(offsetof(ATedStructureBase, StructureSellBeginTime) == 0x0016A8, "Member 'ATedStructureBase::StructureSellBeginTime' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, SellStructure_TimerHandle) == 0x0016B0, "Member 'ATedStructureBase::SellStructure_TimerHandle' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, NavModifier) == 0x0016D0, "Member 'ATedStructureBase::NavModifier' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, StructureGridSize) == 0x0016D8, "Member 'ATedStructureBase::StructureGridSize' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, SpawnAnimation) == 0x0016E0, "Member 'ATedStructureBase::SpawnAnimation' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, DeconstructAnimation) == 0x0016E8, "Member 'ATedStructureBase::DeconstructAnimation' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, PlacementPreviewAnim) == 0x0016F0, "Member 'ATedStructureBase::PlacementPreviewAnim' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, PlacementPreviewHiddenBones) == 0x0016F8, "Member 'ATedStructureBase::PlacementPreviewHiddenBones' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, InvalidNavAreas) == 0x001748, "Member 'ATedStructureBase::InvalidNavAreas' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, GridPivotOffsetLocation) == 0x001798, "Member 'ATedStructureBase::GridPivotOffsetLocation' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, CollisionRadiusModifier) == 0x0017B0, "Member 'ATedStructureBase::CollisionRadiusModifier' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, UnitSpawnSplineComponentTag) == 0x0017B8, "Member 'ATedStructureBase::UnitSpawnSplineComponentTag' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, SellTimeToHP) == 0x0017C0, "Member 'ATedStructureBase::SellTimeToHP' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, CaptureTimeToHP) == 0x0017C8, "Member 'ATedStructureBase::CaptureTimeToHP' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, IdleSound) == 0x0017D0, "Member 'ATedStructureBase::IdleSound' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, SpawnSound) == 0x0017D8, "Member 'ATedStructureBase::SpawnSound' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, StructureSoundVolume) == 0x0017E0, "Member 'ATedStructureBase::StructureSoundVolume' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, StructureSoundPitch) == 0x0017E4, "Member 'ATedStructureBase::StructureSoundPitch' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, IdleAC) == 0x0017E8, "Member 'ATedStructureBase::IdleAC' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, OriginalCreationTime) == 0x0017F0, "Member 'ATedStructureBase::OriginalCreationTime' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, CaptureStructureBeginTime) == 0x001848, "Member 'ATedStructureBase::CaptureStructureBeginTime' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, CapturePlayerColorId) == 0x00184C, "Member 'ATedStructureBase::CapturePlayerColorId' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, CachedCaptureInstigator) == 0x001850, "Member 'ATedStructureBase::CachedCaptureInstigator' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, CaptureStructure_TimerHandle) == 0x001858, "Member 'ATedStructureBase::CaptureStructure_TimerHandle' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, CachedNewOwner) == 0x001860, "Member 'ATedStructureBase::CachedNewOwner' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, UpgradeEffects) == 0x001880, "Member 'ATedStructureBase::UpgradeEffects' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, GE_InsufficientPower) == 0x0018D0, "Member 'ATedStructureBase::GE_InsufficientPower' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, GE_NoPower) == 0x0018D8, "Member 'ATedStructureBase::GE_NoPower' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, PowerState) == 0x0018E0, "Member 'ATedStructureBase::PowerState' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, bIsUserPowered) == 0x0018E3, "Member 'ATedStructureBase::bIsUserPowered' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, TH_Repairing) == 0x0018E8, "Member 'ATedStructureBase::TH_Repairing' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, DistributionModeConstructionPlayRate) == 0x0018F8, "Member 'ATedStructureBase::DistributionModeConstructionPlayRate' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, ConstructionVisualComponentTag) == 0x0018FC, "Member 'ATedStructureBase::ConstructionVisualComponentTag' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, ReplicatedBuildRadius) == 0x001910, "Member 'ATedStructureBase::ReplicatedBuildRadius' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, BuildRadius) == 0x001920, "Member 'ATedStructureBase::BuildRadius' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, bCanChangeAlignment) == 0x001970, "Member 'ATedStructureBase::bCanChangeAlignment' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, Alignment) == 0x001971, "Member 'ATedStructureBase::Alignment' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, AlignmentOffset) == 0x001972, "Member 'ATedStructureBase::AlignmentOffset' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, TempStaticMesh) == 0x001978, "Member 'ATedStructureBase::TempStaticMesh' has a wrong offset!");
static_assert(offsetof(ATedStructureBase, RallyPointTarget) == 0x001990, "Member 'ATedStructureBase::RallyPointTarget' has a wrong offset!");

// Class Tempest.TedStructureHarvester
// 0x00F0 (0x1AF0 - 0x1A00)
class ATedStructureHarvester final : public ATedStructureBase
{
public:
	uint8                                         Pad_19F8[0x30];                                    // 0x19F8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStructureHarvesterData                HarvesterData;                                     // 0x1A28(0x0038)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bAutoharvestOn;                                    // 0x1A60(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EStructureHarvesterStage                      CurrentHarvestingSpeed;                            // 0x1A61(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A62[0x6];                                     // 0x1A62(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           NextStageTimerHandle;                              // 0x1A68(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           ConvertResourceToCashTimerHandle;                  // 0x1A70(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentResource;                                   // 0x1A78(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A7C[0x4];                                     // 0x1A7C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<int32>                                   TargetFieldTileIndices;                            // 0x1A80(0x0050)(NativeAccessSpecifierPrivate)
	class UTedPlayerData*                         CachedPlayerData;                                  // 0x1AD0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ATempestFieldVolume*                    CachedTargetResourceVolume;                        // 0x1AD8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CollectedResources;                                // 0x1AE0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1AE4[0xC];                                     // 0x1AE4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHarvestingSpeedChangedCosmetic(EStructureHarvesterStage NewState);
	void OnRep_HarvestingSpeed();

	EStructureHarvesterStage GetCurrentHarvestingSpeed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedStructureHarvester">();
	}
	static class ATedStructureHarvester* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedStructureHarvester>();
	}
};
static_assert(alignof(ATedStructureHarvester) == 0x000010, "Wrong alignment on ATedStructureHarvester");
static_assert(sizeof(ATedStructureHarvester) == 0x001AF0, "Wrong size on ATedStructureHarvester");
static_assert(offsetof(ATedStructureHarvester, HarvesterData) == 0x001A28, "Member 'ATedStructureHarvester::HarvesterData' has a wrong offset!");
static_assert(offsetof(ATedStructureHarvester, bAutoharvestOn) == 0x001A60, "Member 'ATedStructureHarvester::bAutoharvestOn' has a wrong offset!");
static_assert(offsetof(ATedStructureHarvester, CurrentHarvestingSpeed) == 0x001A61, "Member 'ATedStructureHarvester::CurrentHarvestingSpeed' has a wrong offset!");
static_assert(offsetof(ATedStructureHarvester, NextStageTimerHandle) == 0x001A68, "Member 'ATedStructureHarvester::NextStageTimerHandle' has a wrong offset!");
static_assert(offsetof(ATedStructureHarvester, ConvertResourceToCashTimerHandle) == 0x001A70, "Member 'ATedStructureHarvester::ConvertResourceToCashTimerHandle' has a wrong offset!");
static_assert(offsetof(ATedStructureHarvester, CurrentResource) == 0x001A78, "Member 'ATedStructureHarvester::CurrentResource' has a wrong offset!");
static_assert(offsetof(ATedStructureHarvester, TargetFieldTileIndices) == 0x001A80, "Member 'ATedStructureHarvester::TargetFieldTileIndices' has a wrong offset!");
static_assert(offsetof(ATedStructureHarvester, CachedPlayerData) == 0x001AD0, "Member 'ATedStructureHarvester::CachedPlayerData' has a wrong offset!");
static_assert(offsetof(ATedStructureHarvester, CachedTargetResourceVolume) == 0x001AD8, "Member 'ATedStructureHarvester::CachedTargetResourceVolume' has a wrong offset!");
static_assert(offsetof(ATedStructureHarvester, CollectedResources) == 0x001AE0, "Member 'ATedStructureHarvester::CollectedResources' has a wrong offset!");

// Class Tempest.AIManager_Knowledge
// 0x0000 (0x0038 - 0x0038)
class UAIManager_Knowledge final : public UAIManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIManager_Knowledge">();
	}
	static class UAIManager_Knowledge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIManager_Knowledge>();
	}
};
static_assert(alignof(UAIManager_Knowledge) == 0x000008, "Wrong alignment on UAIManager_Knowledge");
static_assert(sizeof(UAIManager_Knowledge) == 0x000038, "Wrong size on UAIManager_Knowledge");

// Class Tempest.EcsTypeDesc_StealthOverridingEntity
// 0x0000 (0x0028 - 0x0028)
class UEcsTypeDesc_StealthOverridingEntity final : public UEcsTypeDesc
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EcsTypeDesc_StealthOverridingEntity">();
	}
	static class UEcsTypeDesc_StealthOverridingEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEcsTypeDesc_StealthOverridingEntity>();
	}
};
static_assert(alignof(UEcsTypeDesc_StealthOverridingEntity) == 0x000008, "Wrong alignment on UEcsTypeDesc_StealthOverridingEntity");
static_assert(sizeof(UEcsTypeDesc_StealthOverridingEntity) == 0x000028, "Wrong size on UEcsTypeDesc_StealthOverridingEntity");

// Class Tempest.AIManager_Mission
// 0x0010 (0x0048 - 0x0038)
class UAIManager_Mission final : public UAIManager
{
public:
	TArray<class UAIMission*>                     Missions;                                          // 0x0038(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIManager_Mission">();
	}
	static class UAIManager_Mission* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIManager_Mission>();
	}
};
static_assert(alignof(UAIManager_Mission) == 0x000008, "Wrong alignment on UAIManager_Mission");
static_assert(sizeof(UAIManager_Mission) == 0x000048, "Wrong size on UAIManager_Mission");
static_assert(offsetof(UAIManager_Mission, Missions) == 0x000038, "Member 'UAIManager_Mission::Missions' has a wrong offset!");

// Class Tempest.AIManager_Production
// 0x0150 (0x0188 - 0x0038)
class UAIManager_Production final : public UAIManager
{
public:
	struct FAIBuildOrderQueue                     BuildOrderQueue;                                   // 0x0038(0x0030)(SaveGame, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAIPendingStructureConstructionElement> PendingStructureConstructions;             // 0x0068(0x0010)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAIPendingUnitConstructionElement> PendingUnitConstructions;                       // 0x0078(0x0010)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAIPendingUpgradeResearchElement> PendingUpgrades;                                 // 0x0088(0x0010)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0xF0];                                      // 0x0098(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIManager_Production">();
	}
	static class UAIManager_Production* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIManager_Production>();
	}
};
static_assert(alignof(UAIManager_Production) == 0x000008, "Wrong alignment on UAIManager_Production");
static_assert(sizeof(UAIManager_Production) == 0x000188, "Wrong size on UAIManager_Production");
static_assert(offsetof(UAIManager_Production, BuildOrderQueue) == 0x000038, "Member 'UAIManager_Production::BuildOrderQueue' has a wrong offset!");
static_assert(offsetof(UAIManager_Production, PendingStructureConstructions) == 0x000068, "Member 'UAIManager_Production::PendingStructureConstructions' has a wrong offset!");
static_assert(offsetof(UAIManager_Production, PendingUnitConstructions) == 0x000078, "Member 'UAIManager_Production::PendingUnitConstructions' has a wrong offset!");
static_assert(offsetof(UAIManager_Production, PendingUpgrades) == 0x000088, "Member 'UAIManager_Production::PendingUpgrades' has a wrong offset!");

// Class Tempest.EcsTypeDesc_Pawn
// 0x0000 (0x0028 - 0x0028)
class UEcsTypeDesc_Pawn final : public UEcsTypeDesc
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EcsTypeDesc_Pawn">();
	}
	static class UEcsTypeDesc_Pawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEcsTypeDesc_Pawn>();
	}
};
static_assert(alignof(UEcsTypeDesc_Pawn) == 0x000008, "Wrong alignment on UEcsTypeDesc_Pawn");
static_assert(sizeof(UEcsTypeDesc_Pawn) == 0x000028, "Wrong size on UEcsTypeDesc_Pawn");

// Class Tempest.AIManager_Resource
// 0x0000 (0x0038 - 0x0038)
class UAIManager_Resource final : public UAIManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIManager_Resource">();
	}
	static class UAIManager_Resource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIManager_Resource>();
	}
};
static_assert(alignof(UAIManager_Resource) == 0x000008, "Wrong alignment on UAIManager_Resource");
static_assert(sizeof(UAIManager_Resource) == 0x000038, "Wrong size on UAIManager_Resource");

// Class Tempest.TedStructureUnitFactory
// 0x0000 (0x1A00 - 0x1A00)
class ATedStructureUnitFactory : public ATedStructureBase
{
public:
	class USplineComponent*                       UnitSpawnSpline;                                   // 0x19F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedStructureUnitFactory">();
	}
	static class ATedStructureUnitFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedStructureUnitFactory>();
	}
};
static_assert(alignof(ATedStructureUnitFactory) == 0x000010, "Wrong alignment on ATedStructureUnitFactory");
static_assert(sizeof(ATedStructureUnitFactory) == 0x001A00, "Wrong size on ATedStructureUnitFactory");
static_assert(offsetof(ATedStructureUnitFactory, UnitSpawnSpline) == 0x0019F8, "Member 'ATedStructureUnitFactory::UnitSpawnSpline' has a wrong offset!");

// Class Tempest.TedStructureRefinery
// 0x0110 (0x1B10 - 0x1A00)
class ATedStructureRefinery : public ATedStructureUnitFactory
{
public:
	uint8                                         Pad_1A00[0x30];                                    // 0x1A00(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HarvesterDistanceTolerance;                        // 0x1A30(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A34[0x4];                                     // 0x1A34(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       QueueSpline;                                       // 0x1A38(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedPlayerData*                         CachedPD;                                          // 0x1A40(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ATedUnitBase*>                   HarvesterQueue;                                    // 0x1A48(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class ATedUnitBase*, struct FTimerHandle> DepositResourceHandles;                           // 0x1A58(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<class ATedUnitBase*>                   DepositSlots;                                      // 0x1AA8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AB8[0x58];                                    // 0x1AB8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedStructureRefinery">();
	}
	static class ATedStructureRefinery* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedStructureRefinery>();
	}
};
static_assert(alignof(ATedStructureRefinery) == 0x000010, "Wrong alignment on ATedStructureRefinery");
static_assert(sizeof(ATedStructureRefinery) == 0x001B10, "Wrong size on ATedStructureRefinery");
static_assert(offsetof(ATedStructureRefinery, HarvesterDistanceTolerance) == 0x001A30, "Member 'ATedStructureRefinery::HarvesterDistanceTolerance' has a wrong offset!");
static_assert(offsetof(ATedStructureRefinery, QueueSpline) == 0x001A38, "Member 'ATedStructureRefinery::QueueSpline' has a wrong offset!");
static_assert(offsetof(ATedStructureRefinery, CachedPD) == 0x001A40, "Member 'ATedStructureRefinery::CachedPD' has a wrong offset!");
static_assert(offsetof(ATedStructureRefinery, HarvesterQueue) == 0x001A48, "Member 'ATedStructureRefinery::HarvesterQueue' has a wrong offset!");
static_assert(offsetof(ATedStructureRefinery, DepositResourceHandles) == 0x001A58, "Member 'ATedStructureRefinery::DepositResourceHandles' has a wrong offset!");
static_assert(offsetof(ATedStructureRefinery, DepositSlots) == 0x001AA8, "Member 'ATedStructureRefinery::DepositSlots' has a wrong offset!");

// Class Tempest.TedStructureRefinery_DYN
// 0x00E0 (0x1BF0 - 0x1B10)
class ATedStructureRefinery_DYN : public ATedStructureRefinery
{
public:
	uint8                                         Pad_1B10[0xA8];                                    // 0x1B10(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAutoharvestOn;                                    // 0x1BB8(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1BB9[0x3];                                     // 0x1BB9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           RecallCommandType;                                 // 0x1BBC(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TargetResourceVolumeBBKey;                         // 0x1BC4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DepositSlotNum;                                    // 0x1BCC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedPawnContainerComponent*             PawnContainerComponent;                            // 0x1BD0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ATedUnitBase*>                   Harvesters;                                        // 0x1BD8(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bRecallActive : 1;                                 // 0x1BE8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1BE9[0x7];                                     // 0x1BE9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UTedPawnContainerComponent* GetPawnContainerComponent() const;
	struct FVector2D GetRefineryExitLocation() const;
	bool IsRecallActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedStructureRefinery_DYN">();
	}
	static class ATedStructureRefinery_DYN* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedStructureRefinery_DYN>();
	}
};
static_assert(alignof(ATedStructureRefinery_DYN) == 0x000010, "Wrong alignment on ATedStructureRefinery_DYN");
static_assert(sizeof(ATedStructureRefinery_DYN) == 0x001BF0, "Wrong size on ATedStructureRefinery_DYN");
static_assert(offsetof(ATedStructureRefinery_DYN, bAutoharvestOn) == 0x001BB8, "Member 'ATedStructureRefinery_DYN::bAutoharvestOn' has a wrong offset!");
static_assert(offsetof(ATedStructureRefinery_DYN, RecallCommandType) == 0x001BBC, "Member 'ATedStructureRefinery_DYN::RecallCommandType' has a wrong offset!");
static_assert(offsetof(ATedStructureRefinery_DYN, TargetResourceVolumeBBKey) == 0x001BC4, "Member 'ATedStructureRefinery_DYN::TargetResourceVolumeBBKey' has a wrong offset!");
static_assert(offsetof(ATedStructureRefinery_DYN, DepositSlotNum) == 0x001BCC, "Member 'ATedStructureRefinery_DYN::DepositSlotNum' has a wrong offset!");
static_assert(offsetof(ATedStructureRefinery_DYN, PawnContainerComponent) == 0x001BD0, "Member 'ATedStructureRefinery_DYN::PawnContainerComponent' has a wrong offset!");
static_assert(offsetof(ATedStructureRefinery_DYN, Harvesters) == 0x001BD8, "Member 'ATedStructureRefinery_DYN::Harvesters' has a wrong offset!");

// Class Tempest.AIManager_Strategy
// 0x0018 (0x0050 - 0x0038)
class UAIManager_Strategy final : public UAIManager
{
public:
	class UAIDefinition_Strategy*                 CurrentStrategy;                                   // 0x0038(0x0008)(ZeroConstructor, SaveGame, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAIMissionHandle>               StrategyMissionHandles;                            // 0x0040(0x0010)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIManager_Strategy">();
	}
	static class UAIManager_Strategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIManager_Strategy>();
	}
};
static_assert(alignof(UAIManager_Strategy) == 0x000008, "Wrong alignment on UAIManager_Strategy");
static_assert(sizeof(UAIManager_Strategy) == 0x000050, "Wrong size on UAIManager_Strategy");
static_assert(offsetof(UAIManager_Strategy, CurrentStrategy) == 0x000038, "Member 'UAIManager_Strategy::CurrentStrategy' has a wrong offset!");
static_assert(offsetof(UAIManager_Strategy, StrategyMissionHandles) == 0x000040, "Member 'UAIManager_Strategy::StrategyMissionHandles' has a wrong offset!");

// Class Tempest.EcsTypeDesc_NavGridTrigger
// 0x0000 (0x0028 - 0x0028)
class UEcsTypeDesc_NavGridTrigger final : public UEcsTypeDesc
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EcsTypeDesc_NavGridTrigger">();
	}
	static class UEcsTypeDesc_NavGridTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEcsTypeDesc_NavGridTrigger>();
	}
};
static_assert(alignof(UEcsTypeDesc_NavGridTrigger) == 0x000008, "Wrong alignment on UEcsTypeDesc_NavGridTrigger");
static_assert(sizeof(UEcsTypeDesc_NavGridTrigger) == 0x000028, "Wrong size on UEcsTypeDesc_NavGridTrigger");

// Class Tempest.AIManager_Utility
// 0x0008 (0x0040 - 0x0038)
class UAIManager_Utility final : public UAIManager
{
public:
	class UUtilityAIBrain*                        UtilityAIBrain;                                    // 0x0038(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UUtilityAIBrain* GetUtilityAIBrain() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIManager_Utility">();
	}
	static class UAIManager_Utility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIManager_Utility>();
	}
};
static_assert(alignof(UAIManager_Utility) == 0x000008, "Wrong alignment on UAIManager_Utility");
static_assert(sizeof(UAIManager_Utility) == 0x000040, "Wrong size on UAIManager_Utility");
static_assert(offsetof(UAIManager_Utility, UtilityAIBrain) == 0x000038, "Member 'UAIManager_Utility::UtilityAIBrain' has a wrong offset!");

// Class Tempest.AIMicroManager
// 0x0010 (0x0038 - 0x0028)
class UAIMicroManager : public UObject
{
public:
	TArray<class ATedPawn*>                       Pawns;                                             // 0x0028(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIMicroManager">();
	}
	static class UAIMicroManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIMicroManager>();
	}
};
static_assert(alignof(UAIMicroManager) == 0x000008, "Wrong alignment on UAIMicroManager");
static_assert(sizeof(UAIMicroManager) == 0x000038, "Wrong size on UAIMicroManager");
static_assert(offsetof(UAIMicroManager, Pawns) == 0x000028, "Member 'UAIMicroManager::Pawns' has a wrong offset!");

// Class Tempest.TedHotspotFunctionsLibrary
// 0x0000 (0x0028 - 0x0028)
class UTedHotspotFunctionsLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FTedHotspotHandle AddHotspotAtLocation(const class UObject* WorldContext, const class UTedHotspotConfig* Config, const struct FVector& Location);
	static struct FTedHotspotHandle AddHotspotAttached(const class UObject* WorldContext, const class UTedHotspotConfig* Config, const class AActor* Target);
	static bool RemoveHotspotByHandle(const class UObject* WorldContext, const struct FTedHotspotHandle& Handle);
	static bool RemoveHotspotByTarget(const class UObject* WorldContext, const class AActor* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedHotspotFunctionsLibrary">();
	}
	static class UTedHotspotFunctionsLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedHotspotFunctionsLibrary>();
	}
};
static_assert(alignof(UTedHotspotFunctionsLibrary) == 0x000008, "Wrong alignment on UTedHotspotFunctionsLibrary");
static_assert(sizeof(UTedHotspotFunctionsLibrary) == 0x000028, "Wrong size on UTedHotspotFunctionsLibrary");

// Class Tempest.AIMicroManager_Generic
// 0x0058 (0x0090 - 0x0038)
class UAIMicroManager_Generic : public UAIMicroManager
{
public:
	struct FAISquadOrder                          LastOrder;                                         // 0x0038(0x0058)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIMicroManager_Generic">();
	}
	static class UAIMicroManager_Generic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIMicroManager_Generic>();
	}
};
static_assert(alignof(UAIMicroManager_Generic) == 0x000008, "Wrong alignment on UAIMicroManager_Generic");
static_assert(sizeof(UAIMicroManager_Generic) == 0x000090, "Wrong size on UAIMicroManager_Generic");
static_assert(offsetof(UAIMicroManager_Generic, LastOrder) == 0x000038, "Member 'UAIMicroManager_Generic::LastOrder' has a wrong offset!");

// Class Tempest.TedStructureSettings
// 0x0118 (0x0150 - 0x0038)
class UTedStructureSettings final : public UDeveloperSettings
{
public:
	uint8                                         bStopRepairWhenBroke : 1;                          // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RepairTickInterval;                                // 0x003C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RepairTickMagnitude;                               // 0x0040(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           NeighborEndCapSocketsOrder;                        // 0x0048(0x0010)(Edit, EditFixedSize, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	struct FTedStructureMIDParameterValues        GhostMIDParameterOverrides;                        // 0x0058(0x00F0)(Edit, Config, Protected, NativeAccessSpecifierProtected)
	uint8                                         bTempAllowLowPowerIcon : 1;                        // 0x0148(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTempAllowPowerOffIcon : 1;                        // 0x0148(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedStructureSettings">();
	}
	static class UTedStructureSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedStructureSettings>();
	}
};
static_assert(alignof(UTedStructureSettings) == 0x000008, "Wrong alignment on UTedStructureSettings");
static_assert(sizeof(UTedStructureSettings) == 0x000150, "Wrong size on UTedStructureSettings");
static_assert(offsetof(UTedStructureSettings, RepairTickInterval) == 0x00003C, "Member 'UTedStructureSettings::RepairTickInterval' has a wrong offset!");
static_assert(offsetof(UTedStructureSettings, RepairTickMagnitude) == 0x000040, "Member 'UTedStructureSettings::RepairTickMagnitude' has a wrong offset!");
static_assert(offsetof(UTedStructureSettings, NeighborEndCapSocketsOrder) == 0x000048, "Member 'UTedStructureSettings::NeighborEndCapSocketsOrder' has a wrong offset!");
static_assert(offsetof(UTedStructureSettings, GhostMIDParameterOverrides) == 0x000058, "Member 'UTedStructureSettings::GhostMIDParameterOverrides' has a wrong offset!");

// Class Tempest.AIMicroManager_Convoy
// 0x0010 (0x00A0 - 0x0090)
class UAIMicroManager_Convoy final : public UAIMicroManager_Generic
{
public:
	uint8                                         Pad_90[0x10];                                      // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIMicroManager_Convoy">();
	}
	static class UAIMicroManager_Convoy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIMicroManager_Convoy>();
	}
};
static_assert(alignof(UAIMicroManager_Convoy) == 0x000008, "Wrong alignment on UAIMicroManager_Convoy");
static_assert(sizeof(UAIMicroManager_Convoy) == 0x0000A0, "Wrong size on UAIMicroManager_Convoy");

// Class Tempest.TedGridVisualizationComponent
// 0x00C0 (0x0650 - 0x0590)
class UTedGridVisualizationComponent final : public UGridMeshComponent
{
public:
	uint8                                         Pad_590[0xC0];                                     // 0x0590(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGridVisualizationComponent">();
	}
	static class UTedGridVisualizationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedGridVisualizationComponent>();
	}
};
static_assert(alignof(UTedGridVisualizationComponent) == 0x000010, "Wrong alignment on UTedGridVisualizationComponent");
static_assert(sizeof(UTedGridVisualizationComponent) == 0x000650, "Wrong size on UTedGridVisualizationComponent");

// Class Tempest.AIMission
// 0x01D8 (0x0200 - 0x0028)
class UAIMission : public UObject
{
public:
	TMulticastInlineDelegate<void(class UAIMission* Mission, EAIMissionState PrevState)> OnMissionStateChangeDelegateK2; // 0x0028(0x0010)(ZeroConstructor, InstancedReference, SaveGame, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MissionPriority;                                   // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  MissionTags;                                       // 0x0058(0x0020)(Edit, DisableEditOnInstance, SaveGame, Protected, NativeAccessSpecifierProtected)
	class FString                                 FriendlyName;                                      // 0x0078(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, SaveGame, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 SquadName;                                         // 0x0088(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, SaveGame, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStartWhenReady;                                   // 0x0098(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRemoveOnFinish;                                   // 0x0099(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIDefinition_BuildOrder*               SquadBuildOrder;                                   // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, SaveGame, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequiresFullSquad;                                // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLockSquad;                                        // 0x00A9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanStealSquadMembers;                             // 0x00AA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReleaseSquadOnDeactivate;                         // 0x00AB(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAlwaysRerunSquadBuildOrderOnRestart;              // 0x00AC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequestSquadPawnProductionWhenDied;               // 0x00AD(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AE[0x2];                                       // 0x00AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIMissionDiedSquadPawnProductionSettings DiedSquadPawnProductionSettings;                // 0x00B0(0x0048)(Edit, DisableEditOnInstance, SaveGame, Protected, NativeAccessSpecifierProtected)
	TSet<TSubclassOf<class UAIMicroManager>>      MicroManagers;                                     // 0x00F8(0x0050)(Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FAIMissionHandle                       MissionHandle;                                     // 0x0148(0x0004)(SaveGame, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAIMissionState                               MissionState;                                      // 0x014C(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bActive;                                           // 0x014D(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14E[0xA];                                      // 0x014E(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAISquadOrder                          MissionSquadOrder;                                 // 0x0158(0x0058)(SaveGame, Protected, NativeAccessSpecifierProtected)
	struct FAITargetLocation                      SquadProductionLocation;                           // 0x01B0(0x0018)(SaveGame, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAITargetLocation                      SquadRallyPoint;                                   // 0x01C8(0x0018)(SaveGame, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bRequestedSquadProduction;                         // 0x01E0(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E1[0x3];                                      // 0x01E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RequestedDiedSquadPawnProductionCount;             // 0x01E4(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAIBuildOrderQueueElementHandle> RequestedDiedSquadPawnProductionHandles;          // 0x01E8(0x0010)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F8[0x8];                                      // 0x01F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Activate();
	void AddPawnsToSquad(const TArray<class ATedPawn*>& Pawns);
	void AddPawnToSquad(class ATedPawn* Pawn);
	void ClearSquad();
	void ClearSquadRallyPoint();
	void Deactivate();
	void RemovePawnFromSquad(class ATedPawn* Pawn);
	void RemovePawnsFromSquad(const TArray<class ATedPawn*>& Pawns);
	void Restart();
	void SetActive(const bool bActive_0);
	void SetAlwaysRerunSquadBuildOrderOnRestart(const bool bAlwaysRerunSquadBuildOrderOnRestart_0);
	void SetCanStealSquadMembers(const bool bCanStealSquadMembers_0);
	void SetDiedSquadPawnProductionSettings(const struct FAIMissionDiedSquadPawnProductionSettings& DiedSquadPawnProductionSettings_0);
	void SetFriendlyName(const class FString& FriendlyName_0);
	void SetMissionPriority(const int32 MissionPriority_0);
	void SetMissionTags(const struct FGameplayTagContainer& MissionsTags);
	void SetRemoveOnFinish(const bool bRemoveOnFinish_0);
	void SetRequestSquadPawnProductionWhenDied(const bool bRequestSquadPawnProductionWhenDied_0);
	void SetRequiresFullSquad(const bool bRequiresFullSquad_0);
	void SetSquadBuildOrder(const class UAIDefinition_BuildOrder* SquadBuildOrder_0);
	void SetSquadLocked(const bool bLockSquad_0);
	void SetSquadProductionLocation(const struct FAITargetLocation& SquadProductionLocation_0);
	void SetSquadRallyPoint(const struct FAITargetLocation& SquadRallyPoint_0);
	void SetStartWhenReady(const bool bStartWhenReady_0);
	void StartWhenReady();

	bool CanStealSquadMembers() const;
	const struct FAIMissionDiedSquadPawnProductionSettings GetDiedSquadPawnProductionSettings() const;
	class FString GetDisplayName() const;
	class FString GetFriendlyName() const;
	struct FAIMissionHandle GetMissionHandle() const;
	int32 GetMissionPriority() const;
	EAIMissionState GetMissionState() const;
	const struct FGameplayTagContainer GetMissionTags() const;
	const class UAIDefinition_BuildOrder* GetSquadBuildOrder() const;
	struct FAISquadOrder GetSquadOrder() const;
	const struct FAITargetLocation GetSquadProductionLocation() const;
	const struct FAITargetLocation GetSquadRallyPoint() const;
	bool HasActiveSquadProduction() const;
	bool HasPawnInSquad(const class ATedPawn* Pawn) const;
	bool HasSquad() const;
	bool HasSquadRallyPoint() const;
	bool IsActive() const;
	bool IsSquadAlive() const;
	bool IsSquadLocked() const;
	bool IsSquadReady() const;
	bool IsSquadWiped() const;
	TArray<class ATedPawn*> K2_GetSquadPawns() const;
	bool RequiresFullSquad() const;
	bool ShouldAlwaysRerunSquadBuildOrderOnRestart() const;
	bool ShouldRemoveOnFinish() const;
	bool ShouldRequestSquadPawnProductionWhenDied() const;
	bool ShouldStartWhenReady() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIMission">();
	}
	static class UAIMission* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIMission>();
	}
};
static_assert(alignof(UAIMission) == 0x000008, "Wrong alignment on UAIMission");
static_assert(sizeof(UAIMission) == 0x000200, "Wrong size on UAIMission");
static_assert(offsetof(UAIMission, OnMissionStateChangeDelegateK2) == 0x000028, "Member 'UAIMission::OnMissionStateChangeDelegateK2' has a wrong offset!");
static_assert(offsetof(UAIMission, MissionPriority) == 0x000050, "Member 'UAIMission::MissionPriority' has a wrong offset!");
static_assert(offsetof(UAIMission, MissionTags) == 0x000058, "Member 'UAIMission::MissionTags' has a wrong offset!");
static_assert(offsetof(UAIMission, FriendlyName) == 0x000078, "Member 'UAIMission::FriendlyName' has a wrong offset!");
static_assert(offsetof(UAIMission, SquadName) == 0x000088, "Member 'UAIMission::SquadName' has a wrong offset!");
static_assert(offsetof(UAIMission, bStartWhenReady) == 0x000098, "Member 'UAIMission::bStartWhenReady' has a wrong offset!");
static_assert(offsetof(UAIMission, bRemoveOnFinish) == 0x000099, "Member 'UAIMission::bRemoveOnFinish' has a wrong offset!");
static_assert(offsetof(UAIMission, SquadBuildOrder) == 0x0000A0, "Member 'UAIMission::SquadBuildOrder' has a wrong offset!");
static_assert(offsetof(UAIMission, bRequiresFullSquad) == 0x0000A8, "Member 'UAIMission::bRequiresFullSquad' has a wrong offset!");
static_assert(offsetof(UAIMission, bLockSquad) == 0x0000A9, "Member 'UAIMission::bLockSquad' has a wrong offset!");
static_assert(offsetof(UAIMission, bCanStealSquadMembers) == 0x0000AA, "Member 'UAIMission::bCanStealSquadMembers' has a wrong offset!");
static_assert(offsetof(UAIMission, bReleaseSquadOnDeactivate) == 0x0000AB, "Member 'UAIMission::bReleaseSquadOnDeactivate' has a wrong offset!");
static_assert(offsetof(UAIMission, bAlwaysRerunSquadBuildOrderOnRestart) == 0x0000AC, "Member 'UAIMission::bAlwaysRerunSquadBuildOrderOnRestart' has a wrong offset!");
static_assert(offsetof(UAIMission, bRequestSquadPawnProductionWhenDied) == 0x0000AD, "Member 'UAIMission::bRequestSquadPawnProductionWhenDied' has a wrong offset!");
static_assert(offsetof(UAIMission, DiedSquadPawnProductionSettings) == 0x0000B0, "Member 'UAIMission::DiedSquadPawnProductionSettings' has a wrong offset!");
static_assert(offsetof(UAIMission, MicroManagers) == 0x0000F8, "Member 'UAIMission::MicroManagers' has a wrong offset!");
static_assert(offsetof(UAIMission, MissionHandle) == 0x000148, "Member 'UAIMission::MissionHandle' has a wrong offset!");
static_assert(offsetof(UAIMission, MissionState) == 0x00014C, "Member 'UAIMission::MissionState' has a wrong offset!");
static_assert(offsetof(UAIMission, bActive) == 0x00014D, "Member 'UAIMission::bActive' has a wrong offset!");
static_assert(offsetof(UAIMission, MissionSquadOrder) == 0x000158, "Member 'UAIMission::MissionSquadOrder' has a wrong offset!");
static_assert(offsetof(UAIMission, SquadProductionLocation) == 0x0001B0, "Member 'UAIMission::SquadProductionLocation' has a wrong offset!");
static_assert(offsetof(UAIMission, SquadRallyPoint) == 0x0001C8, "Member 'UAIMission::SquadRallyPoint' has a wrong offset!");
static_assert(offsetof(UAIMission, bRequestedSquadProduction) == 0x0001E0, "Member 'UAIMission::bRequestedSquadProduction' has a wrong offset!");
static_assert(offsetof(UAIMission, RequestedDiedSquadPawnProductionCount) == 0x0001E4, "Member 'UAIMission::RequestedDiedSquadPawnProductionCount' has a wrong offset!");
static_assert(offsetof(UAIMission, RequestedDiedSquadPawnProductionHandles) == 0x0001E8, "Member 'UAIMission::RequestedDiedSquadPawnProductionHandles' has a wrong offset!");

// Class Tempest.AIMission_Attack
// 0x0000 (0x0200 - 0x0200)
class UAIMission_Attack final : public UAIMission
{
public:
	void SetSquadTarget(const struct FAITarget& Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIMission_Attack">();
	}
	static class UAIMission_Attack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIMission_Attack>();
	}
};
static_assert(alignof(UAIMission_Attack) == 0x000008, "Wrong alignment on UAIMission_Attack");
static_assert(sizeof(UAIMission_Attack) == 0x000200, "Wrong size on UAIMission_Attack");

// Class Tempest.TedEcsModule_Stealth
// 0x0000 (0x0030 - 0x0030)
class UTedEcsModule_Stealth final : public UTedEcsModule
{
public:
	static void K2_SetStealthRevealEnabled(class ATedPawn* TargetPawn, bool bEnable, float Radius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedEcsModule_Stealth">();
	}
	static class UTedEcsModule_Stealth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedEcsModule_Stealth>();
	}
};
static_assert(alignof(UTedEcsModule_Stealth) == 0x000008, "Wrong alignment on UTedEcsModule_Stealth");
static_assert(sizeof(UTedEcsModule_Stealth) == 0x000030, "Wrong size on UTedEcsModule_Stealth");

// Class Tempest.AIMission_CaptureStructures
// 0x0050 (0x0250 - 0x0200)
class UAIMission_CaptureStructures final : public UAIMission
{
public:
	int32                                         MaxCaptureCount;                                   // 0x0200(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ATedStructureBase>       WeakCurrentStructureToCapture;                     // 0x0204(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20C[0x4];                                      // 0x020C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class ATedStructureBase>> WeakStructuresToCapture;                         // 0x0210(0x0010)(ZeroConstructor, SaveGame, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  StructureTags;                                     // 0x0220(0x0020)(SaveGame, Protected, NativeAccessSpecifierProtected)
	bool                                          bStructureTagsExactMatch;                          // 0x0240(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_241[0x3];                                      // 0x0241(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CapturedStructuresCount;                           // 0x0244(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAIMissionCaptureStructureTargetType          CaptureStructureTargetType;                        // 0x0248(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMaxCaptureCount(const int32 MaxCaptureCount_0);
	void SetTargetStructure(class ATedStructureBase* Structure);
	void SetTargetStructures(const TArray<class ATedStructureBase*>& Structures);
	void SetTargetStructuresByActorTags(const struct FGameplayTagContainer& ActorTags, const bool bExactMatch);
	void SetTargetStructuresByDefinitionIds(const struct FGameplayTagContainer& DefinitionIds, const bool bExactMatch);

	int32 GetMaxCaptureCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIMission_CaptureStructures">();
	}
	static class UAIMission_CaptureStructures* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIMission_CaptureStructures>();
	}
};
static_assert(alignof(UAIMission_CaptureStructures) == 0x000008, "Wrong alignment on UAIMission_CaptureStructures");
static_assert(sizeof(UAIMission_CaptureStructures) == 0x000250, "Wrong size on UAIMission_CaptureStructures");
static_assert(offsetof(UAIMission_CaptureStructures, MaxCaptureCount) == 0x000200, "Member 'UAIMission_CaptureStructures::MaxCaptureCount' has a wrong offset!");
static_assert(offsetof(UAIMission_CaptureStructures, WeakCurrentStructureToCapture) == 0x000204, "Member 'UAIMission_CaptureStructures::WeakCurrentStructureToCapture' has a wrong offset!");
static_assert(offsetof(UAIMission_CaptureStructures, WeakStructuresToCapture) == 0x000210, "Member 'UAIMission_CaptureStructures::WeakStructuresToCapture' has a wrong offset!");
static_assert(offsetof(UAIMission_CaptureStructures, StructureTags) == 0x000220, "Member 'UAIMission_CaptureStructures::StructureTags' has a wrong offset!");
static_assert(offsetof(UAIMission_CaptureStructures, bStructureTagsExactMatch) == 0x000240, "Member 'UAIMission_CaptureStructures::bStructureTagsExactMatch' has a wrong offset!");
static_assert(offsetof(UAIMission_CaptureStructures, CapturedStructuresCount) == 0x000244, "Member 'UAIMission_CaptureStructures::CapturedStructuresCount' has a wrong offset!");
static_assert(offsetof(UAIMission_CaptureStructures, CaptureStructureTargetType) == 0x000248, "Member 'UAIMission_CaptureStructures::CaptureStructureTargetType' has a wrong offset!");

// Class Tempest.TedSubtitleTrackInstance
// 0x0010 (0x0060 - 0x0050)
class UTedSubtitleTrackInstance final : public USequencerTrackInstanceBP
{
public:
	class UTedSubtitleWidget*                     SubtitleWidget;                                    // 0x0050(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGameActive;                                     // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PushSubtitlesToHUD(const class FText& Text) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSubtitleTrackInstance">();
	}
	static class UTedSubtitleTrackInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSubtitleTrackInstance>();
	}
};
static_assert(alignof(UTedSubtitleTrackInstance) == 0x000008, "Wrong alignment on UTedSubtitleTrackInstance");
static_assert(sizeof(UTedSubtitleTrackInstance) == 0x000060, "Wrong size on UTedSubtitleTrackInstance");
static_assert(offsetof(UTedSubtitleTrackInstance, SubtitleWidget) == 0x000050, "Member 'UTedSubtitleTrackInstance::SubtitleWidget' has a wrong offset!");
static_assert(offsetof(UTedSubtitleTrackInstance, bIsGameActive) == 0x000058, "Member 'UTedSubtitleTrackInstance::bIsGameActive' has a wrong offset!");

// Class Tempest.AIMission_Convoy
// 0x0070 (0x0270 - 0x0200)
class UAIMission_Convoy final : public UAIMission
{
public:
	EAIMissionConvoyMode                          ConvoyMode;                                        // 0x0200(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_201[0x3];                                      // 0x0201(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumRepeats;                                        // 0x0204(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStartAtClosestWaypoint;                           // 0x0208(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_209[0x7];                                      // 0x0209(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class ATedUnitBase>>    WeakColumnUnits;                                   // 0x0210(0x0010)(ZeroConstructor, SaveGame, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  ColumnUnitDefinitionIds;                           // 0x0220(0x0020)(SaveGame, Protected, NativeAccessSpecifierProtected)
	bool                                          bColumnUnitDefinitionIdsExactMatch;                // 0x0240(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_241[0x3];                                      // 0x0241(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AAISplineRoute>          WeakAISplineRoute;                                 // 0x0244(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StartWaypointIdx;                                  // 0x024C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPreparingToStartConvoy;                           // 0x0250(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_251[0x3];                                      // 0x0251(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RepeatCounter;                                     // 0x0254(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_258[0x18];                                     // 0x0258(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAISplineRoute(const class AAISplineRoute* AISplineRoute);
	void SetConvoyColumnUnit(class ATedUnitBase* Unit);
	void SetConvoyColumnUnits(const TArray<class ATedUnitBase*>& Units);
	void SetConvoyColumnUnitsByDefinitionIds(const struct FGameplayTagContainer& DefinitionIds, const bool bExactMatch);
	void SetConvoyMode(const EAIMissionConvoyMode ConvoyMode_0);
	void SetInfiniteConvoy(const bool bInfiniteConvoy);
	void SetNumRepeats(const int32 NumRepeats_0, const bool bRestartRepeatsCounter);
	void SetStartAtClosestWaypoint(const bool bStartAtClosestWaypoint_0);

	TArray<class ATedUnitBase*> GetConvoyColumnUnits() const;
	EAIMissionConvoyMode GetConvoyMode() const;
	int32 GetNumRepeats() const;
	bool IsInfiniteConvoy() const;
	bool ShouldStartAtClosestWaypoint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIMission_Convoy">();
	}
	static class UAIMission_Convoy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIMission_Convoy>();
	}
};
static_assert(alignof(UAIMission_Convoy) == 0x000008, "Wrong alignment on UAIMission_Convoy");
static_assert(sizeof(UAIMission_Convoy) == 0x000270, "Wrong size on UAIMission_Convoy");
static_assert(offsetof(UAIMission_Convoy, ConvoyMode) == 0x000200, "Member 'UAIMission_Convoy::ConvoyMode' has a wrong offset!");
static_assert(offsetof(UAIMission_Convoy, NumRepeats) == 0x000204, "Member 'UAIMission_Convoy::NumRepeats' has a wrong offset!");
static_assert(offsetof(UAIMission_Convoy, bStartAtClosestWaypoint) == 0x000208, "Member 'UAIMission_Convoy::bStartAtClosestWaypoint' has a wrong offset!");
static_assert(offsetof(UAIMission_Convoy, WeakColumnUnits) == 0x000210, "Member 'UAIMission_Convoy::WeakColumnUnits' has a wrong offset!");
static_assert(offsetof(UAIMission_Convoy, ColumnUnitDefinitionIds) == 0x000220, "Member 'UAIMission_Convoy::ColumnUnitDefinitionIds' has a wrong offset!");
static_assert(offsetof(UAIMission_Convoy, bColumnUnitDefinitionIdsExactMatch) == 0x000240, "Member 'UAIMission_Convoy::bColumnUnitDefinitionIdsExactMatch' has a wrong offset!");
static_assert(offsetof(UAIMission_Convoy, WeakAISplineRoute) == 0x000244, "Member 'UAIMission_Convoy::WeakAISplineRoute' has a wrong offset!");
static_assert(offsetof(UAIMission_Convoy, StartWaypointIdx) == 0x00024C, "Member 'UAIMission_Convoy::StartWaypointIdx' has a wrong offset!");
static_assert(offsetof(UAIMission_Convoy, bPreparingToStartConvoy) == 0x000250, "Member 'UAIMission_Convoy::bPreparingToStartConvoy' has a wrong offset!");
static_assert(offsetof(UAIMission_Convoy, RepeatCounter) == 0x000254, "Member 'UAIMission_Convoy::RepeatCounter' has a wrong offset!");

// Class Tempest.TedUserWidget
// 0x0118 (0x0400 - 0x02E8)
class UTedUserWidget : public UUserWidget
{
public:
	uint8                                         bTrackAsWidgetUnderCursor : 1;                     // 0x02E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bConsumeMouseClicks : 1;                           // 0x02E8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2E9[0x7];                                      // 0x02E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UTedTooltipWidget>          CustomTooltipClass;                                // 0x02F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTedTooltipDisplayParams               CustomTooltipDefaultDisplayParams;                 // 0x02F8(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UTedUserWidget* InWidget, const struct FGameplayTag& InAnimation)> OnWidgetAnimationStart; // 0x0368(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTedUserWidget* InWidget, const struct FGameplayTag& InAnimation)> OnWidgetAnimationEnd; // 0x0378(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  IgnoredHidingContext;                              // 0x0388(0x0020)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	uint8                                         bReactToControlMappingsChange : 1;                 // 0x03A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3A9[0x7];                                      // 0x03A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TSubclassOf<class UUserWidgetExtension>> AutoConstructExtensions;                           // 0x03B0(0x0050)(Edit, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	bool CanPlayWidgetAnimation(const struct FGameplayTag& InAnim);
	void HideCustomTooltip();
	void HidePopup(class UTedPopup* InPopup);
	void NativeRefreshControlMappings();
	void NotifyWidgetAnimationEnd(const struct FGameplayTag& InAnim);
	void NotifyWidgetAnimationStart(const struct FGameplayTag& InAnim);
	void OnPlayWidgetAnimation(const struct FGameplayTag& InAnim);
	void OnRefreshControlMappings();
	void OnStopWidgetAnimation(const struct FGameplayTag& InAnim);
	void PlaySoundUI(class USoundCue* InSound);
	void PlayWidgetAnimation(const struct FGameplayTag& InAnim);
	void RefreshUI();
	void ShowCustomTooltip();
	void StopWidgetAnimation(const struct FGameplayTag& InAnim);

	TArray<class FName> GetAvailableShortcutNames() const;
	void GetCustomTooltipDisplayParams(struct FTedTooltipDisplayParams* OutParams) const;
	class ATedHUD* GetHUD() const;
	bool HasValidSetup() const;
	bool IsStartupSequenceEnabled() const;
	bool IsStartupSequenceFinished() const;
	bool OnCanPlayWidgetAnimation(const struct FGameplayTag& InAnim) const;
	void PaintSpline(struct FPaintContext& InContext, const struct FVector2D& InStartLoc, const struct FVector2D& InStartDir, const struct FVector2D& InEndLoc, const struct FVector2D& InEndDir, const struct FLinearColor& InTint, const float InThickness) const;
	bool SupportsCustomTooltip() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUserWidget">();
	}
	static class UTedUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUserWidget>();
	}
};
static_assert(alignof(UTedUserWidget) == 0x000008, "Wrong alignment on UTedUserWidget");
static_assert(sizeof(UTedUserWidget) == 0x000400, "Wrong size on UTedUserWidget");
static_assert(offsetof(UTedUserWidget, CustomTooltipClass) == 0x0002F0, "Member 'UTedUserWidget::CustomTooltipClass' has a wrong offset!");
static_assert(offsetof(UTedUserWidget, CustomTooltipDefaultDisplayParams) == 0x0002F8, "Member 'UTedUserWidget::CustomTooltipDefaultDisplayParams' has a wrong offset!");
static_assert(offsetof(UTedUserWidget, OnWidgetAnimationStart) == 0x000368, "Member 'UTedUserWidget::OnWidgetAnimationStart' has a wrong offset!");
static_assert(offsetof(UTedUserWidget, OnWidgetAnimationEnd) == 0x000378, "Member 'UTedUserWidget::OnWidgetAnimationEnd' has a wrong offset!");
static_assert(offsetof(UTedUserWidget, IgnoredHidingContext) == 0x000388, "Member 'UTedUserWidget::IgnoredHidingContext' has a wrong offset!");
static_assert(offsetof(UTedUserWidget, AutoConstructExtensions) == 0x0003B0, "Member 'UTedUserWidget::AutoConstructExtensions' has a wrong offset!");

// Class Tempest.TedHintsMainWidget
// 0x0000 (0x0400 - 0x0400)
class UTedHintsMainWidget : public UTedUserWidget
{
public:
	void OnHintHidden();
	void OnNewHintTriggered(int32 NewHintsNumber);
	void OnNewHintUIFocusRequested(class UTedHintsAsset* HintToFocus);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedHintsMainWidget">();
	}
	static class UTedHintsMainWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedHintsMainWidget>();
	}
};
static_assert(alignof(UTedHintsMainWidget) == 0x000008, "Wrong alignment on UTedHintsMainWidget");
static_assert(sizeof(UTedHintsMainWidget) == 0x000400, "Wrong size on UTedHintsMainWidget");

// Class Tempest.AIMission_Defend
// 0x0000 (0x0200 - 0x0200)
class UAIMission_Defend final : public UAIMission
{
public:
	void SetSquadTarget(const struct FAITarget& Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIMission_Defend">();
	}
	static class UAIMission_Defend* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIMission_Defend>();
	}
};
static_assert(alignof(UAIMission_Defend) == 0x000008, "Wrong alignment on UAIMission_Defend");
static_assert(sizeof(UAIMission_Defend) == 0x000200, "Wrong size on UAIMission_Defend");

// Class Tempest.AIMission_EnsurePower
// 0x0028 (0x0228 - 0x0200)
class UAIMission_EnsurePower final : public UAIMission
{
public:
	bool                                          bBuildingPower;                                    // 0x0200(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_201[0x3];                                      // 0x0201(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialBuildPowerDelay;                            // 0x0204(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SubsequentBuildPowerDelay;                         // 0x0208(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20C[0x4];                                      // 0x020C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAITargetLocation>              PreferredBuildLocations;                           // 0x0210(0x0010)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddPreferredBuildLocation(const struct FAITargetLocation& Location);
	void ClearPreferredBuildLocation();
	void RemovePreferredBuildLocation(const struct FAITargetLocation& Location);
	void SetInitialBuildPowerDelay(const float Delay);
	void SetPreferredBuildLocations(const TArray<struct FAITargetLocation>& Locations);
	void SetSubsequentBuildPowerDelay(const float Delay);

	float GetInitialBuildPowerDelay() const;
	const TArray<struct FAITargetLocation> GetPreferredBuildLocations() const;
	float GetSubsequentBuildPowerDelay() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIMission_EnsurePower">();
	}
	static class UAIMission_EnsurePower* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIMission_EnsurePower>();
	}
};
static_assert(alignof(UAIMission_EnsurePower) == 0x000008, "Wrong alignment on UAIMission_EnsurePower");
static_assert(sizeof(UAIMission_EnsurePower) == 0x000228, "Wrong size on UAIMission_EnsurePower");
static_assert(offsetof(UAIMission_EnsurePower, bBuildingPower) == 0x000200, "Member 'UAIMission_EnsurePower::bBuildingPower' has a wrong offset!");
static_assert(offsetof(UAIMission_EnsurePower, InitialBuildPowerDelay) == 0x000204, "Member 'UAIMission_EnsurePower::InitialBuildPowerDelay' has a wrong offset!");
static_assert(offsetof(UAIMission_EnsurePower, SubsequentBuildPowerDelay) == 0x000208, "Member 'UAIMission_EnsurePower::SubsequentBuildPowerDelay' has a wrong offset!");
static_assert(offsetof(UAIMission_EnsurePower, PreferredBuildLocations) == 0x000210, "Member 'UAIMission_EnsurePower::PreferredBuildLocations' has a wrong offset!");

// Class Tempest.TedContentPanelBase
// 0x0340 (0x0740 - 0x0400)
class UTedContentPanelBase : public UTedUserWidget
{
public:
	TMulticastInlineDelegate<void(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction)> OnTriggerSlotAction; // 0x0400(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotState InState, bool bInActivated)> OnActivateSlotState; // 0x0410(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         SelectedSlotsLimit;                                // 0x0420(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAutoDeselectWhenReachedLimit : 1;                 // 0x0421(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSupressDisabledSlotActions : 1;                   // 0x0421(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSupressEmptySlotActions : 1;                      // 0x0421(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_422[0x6];                                      // 0x0422(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<ETedContentSlotState>                    InvalidStatesInEmptySlots;                         // 0x0428(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TSet<ETedContentSlotState>                    InvalidStatesInDisabledSlots;                      // 0x0478(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TSet<ETedContentSlotState>                    InvalidStatesInUnavailableSlots;                   // 0x04C8(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TMap<ETedContentSlotState, class USoundCue*>  StateActivationSounds;                             // 0x0518(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TMap<ETedContentSlotAction, class USoundCue*> SlotActionSounds;                                  // 0x0568(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TSet<ETedContentSlotState>                    StatesSuppressingSlotCustomTooltip;                // 0x05B8(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TSet<ETedContentSlotState>                    StatesRequiredForCustomTooltip;                    // 0x0608(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FTedTooltipDisplayParams               SlotCustomTooltipDisplayParams;                    // 0x0658(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UPanelWidget*                           InnerContentPanel;                                 // 0x06C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTedContentPanelSlotBase*>       RegisteredContentSlots;                            // 0x06D0(0x0010)(ExportObject, ZeroConstructor, Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTedContentPanelSlotArray>      CachedSlotStates;                                  // 0x06E0(0x0010)(ZeroConstructor, Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FTedContentSlotStateAssetSelector> SlotStateAssetSelectors;     // 0x06F0(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	void ActivateSlotState(int32 InSlotIndex, ETedContentSlotState InState, bool bInActivate);
	void ClearAllSlotStates();
	void ClearSlotStates(int32 InSlotIndex);
	void HideSlotCustomTooltip(TSubclassOf<class UTedTooltipWidget> InTooltipClass, const int32 InSlotIndex);
	void OnActivateSlotStateInternal(class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotState InState, bool bInActivated);
	void OnRegisterContentSlot(class UTedContentPanelSlotBase* InContentSlot, ETedContentPanelRegistration InMode);
	void OnShowSlotCustomTooltip(TSubclassOf<class UTedTooltipWidget> InTooltipClass, class UTedContentPanelSlotBase* InContentSlo);
	void OnTriggerSlotActionInternal(class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction);
	void OnUnregisterContentSlot(class UTedContentPanelSlotBase* InContentSlot);
	void RefreshContentSlotUI(const int32 InSlotIndex);
	void RefreshUIFor(const TArray<class UTedContentPanelSlotBase*>& InSlots);
	void ShowSlotCustomTooltip(TSubclassOf<class UTedTooltipWidget> InTooltipClass, const int32 InSlotIndex);
	void TriggerSlotAction(int32 InSlotIndex, ETedContentSlotAction InAction);

	bool CanActivateSlotState(const class UTedContentPanelSlotBase* InSlotWidget, ETedContentSlotState InState, bool bInActivate) const;
	bool CanTriggerSlotAction(const class UTedContentPanelSlotBase* InSlotWidget, ETedContentSlotAction InAction) const;
	class UTedContentPanelSlotBase* GetContentSlot(int32 InSlotIndex) const;
	class UTedContentPanelSlotBase* GetContentSlotByState(const ETedContentSlotState InState, const int32 InIndex) const;
	int32 GetContentSlotIndexByState(const ETedContentSlotState InState, const int32 InIndex) const;
	bool GetContentSlots(TArray<class UTedContentPanelSlotBase*>* OutSlots) const;
	bool GetContentSlotsByState(ETedContentSlotState InState, TArray<class UTedContentPanelSlotBase*>* OutSlots) const;
	int32 GetContentSlotsCount() const;
	int32 GetContentSlotsCountByState(ETedContentSlotState InState) const;
	void GetSlotCustomTooltipDisplayParams(const int32 InSlotIndex, struct FTedTooltipDisplayParams* OutParams) const;
	bool IsAnySlotStateActive(const int32 InSlotIndex, const TSet<ETedContentSlotState>& InStates) const;
	bool IsSlotStateActive(int32 InSlotIndex, ETedContentSlotState InState) const;
	bool K2_GetSlotStateAssetSelector(const struct FGameplayTag& InSelectorKey, struct FTedContentSlotStateAssetSelector* Out) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedContentPanelBase">();
	}
	static class UTedContentPanelBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedContentPanelBase>();
	}
};
static_assert(alignof(UTedContentPanelBase) == 0x000008, "Wrong alignment on UTedContentPanelBase");
static_assert(sizeof(UTedContentPanelBase) == 0x000740, "Wrong size on UTedContentPanelBase");
static_assert(offsetof(UTedContentPanelBase, OnTriggerSlotAction) == 0x000400, "Member 'UTedContentPanelBase::OnTriggerSlotAction' has a wrong offset!");
static_assert(offsetof(UTedContentPanelBase, OnActivateSlotState) == 0x000410, "Member 'UTedContentPanelBase::OnActivateSlotState' has a wrong offset!");
static_assert(offsetof(UTedContentPanelBase, SelectedSlotsLimit) == 0x000420, "Member 'UTedContentPanelBase::SelectedSlotsLimit' has a wrong offset!");
static_assert(offsetof(UTedContentPanelBase, InvalidStatesInEmptySlots) == 0x000428, "Member 'UTedContentPanelBase::InvalidStatesInEmptySlots' has a wrong offset!");
static_assert(offsetof(UTedContentPanelBase, InvalidStatesInDisabledSlots) == 0x000478, "Member 'UTedContentPanelBase::InvalidStatesInDisabledSlots' has a wrong offset!");
static_assert(offsetof(UTedContentPanelBase, InvalidStatesInUnavailableSlots) == 0x0004C8, "Member 'UTedContentPanelBase::InvalidStatesInUnavailableSlots' has a wrong offset!");
static_assert(offsetof(UTedContentPanelBase, StateActivationSounds) == 0x000518, "Member 'UTedContentPanelBase::StateActivationSounds' has a wrong offset!");
static_assert(offsetof(UTedContentPanelBase, SlotActionSounds) == 0x000568, "Member 'UTedContentPanelBase::SlotActionSounds' has a wrong offset!");
static_assert(offsetof(UTedContentPanelBase, StatesSuppressingSlotCustomTooltip) == 0x0005B8, "Member 'UTedContentPanelBase::StatesSuppressingSlotCustomTooltip' has a wrong offset!");
static_assert(offsetof(UTedContentPanelBase, StatesRequiredForCustomTooltip) == 0x000608, "Member 'UTedContentPanelBase::StatesRequiredForCustomTooltip' has a wrong offset!");
static_assert(offsetof(UTedContentPanelBase, SlotCustomTooltipDisplayParams) == 0x000658, "Member 'UTedContentPanelBase::SlotCustomTooltipDisplayParams' has a wrong offset!");
static_assert(offsetof(UTedContentPanelBase, InnerContentPanel) == 0x0006C8, "Member 'UTedContentPanelBase::InnerContentPanel' has a wrong offset!");
static_assert(offsetof(UTedContentPanelBase, RegisteredContentSlots) == 0x0006D0, "Member 'UTedContentPanelBase::RegisteredContentSlots' has a wrong offset!");
static_assert(offsetof(UTedContentPanelBase, CachedSlotStates) == 0x0006E0, "Member 'UTedContentPanelBase::CachedSlotStates' has a wrong offset!");
static_assert(offsetof(UTedContentPanelBase, SlotStateAssetSelectors) == 0x0006F0, "Member 'UTedContentPanelBase::SlotStateAssetSelectors' has a wrong offset!");

// Class Tempest.TedContentPanelDynamic
// 0x0070 (0x07B0 - 0x0740)
class UTedContentPanelDynamic : public UTedContentPanelBase
{
public:
	TSubclassOf<class UTedContentPanelSlotBase>   DefaultSlotClass;                                  // 0x0740(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, TSubclassOf<class UTedContentPanelSlotBase>> OverrideSlotClassMap;                   // 0x0748(0x0050)(Edit, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         bMultiClassSupport : 1;                            // 0x0798(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bMultiPanelSupport : 1;                            // 0x0798(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_799[0x7];                                      // 0x0799(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UTedContentPanelDynamic* InContentPanel)> OnContentChange;   // 0x07A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void OnCacheContent(int32* OutExpectedSlotsCount);
	void OnResetContent();
	void RefreshContent();
	void ResetContent();

	class UPanelWidget* GetInnerContentPanelOverride(const class UTedContentPanelSlotBase* InContentSlot) const;
	bool GetSlotClassOverride(int32 InSlotIndex, TSubclassOf<class UTedContentPanelSlotBase>* OutClass) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedContentPanelDynamic">();
	}
	static class UTedContentPanelDynamic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedContentPanelDynamic>();
	}
};
static_assert(alignof(UTedContentPanelDynamic) == 0x000008, "Wrong alignment on UTedContentPanelDynamic");
static_assert(sizeof(UTedContentPanelDynamic) == 0x0007B0, "Wrong size on UTedContentPanelDynamic");
static_assert(offsetof(UTedContentPanelDynamic, DefaultSlotClass) == 0x000740, "Member 'UTedContentPanelDynamic::DefaultSlotClass' has a wrong offset!");
static_assert(offsetof(UTedContentPanelDynamic, OverrideSlotClassMap) == 0x000748, "Member 'UTedContentPanelDynamic::OverrideSlotClassMap' has a wrong offset!");
static_assert(offsetof(UTedContentPanelDynamic, OnContentChange) == 0x0007A0, "Member 'UTedContentPanelDynamic::OnContentChange' has a wrong offset!");

// Class Tempest.TedEquipmentPanel
// 0x0110 (0x08C0 - 0x07B0)
class UTedEquipmentPanel final : public UTedContentPanelDynamic
{
public:
	TMulticastInlineDelegate<void(class UTedEquipmentSlot* InEquipmentSlot)> OnRequestBuy;           // 0x07B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTedEquipmentSlot* InEquipmentSlot)> OnRequestEquip;         // 0x07C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTedEquipmentSlot* InEquipmentSlot)> OnRequestUnequip;       // 0x07D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E0[0x70];                                     // 0x07E0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bSortAlphabetically : 1;                           // 0x0850(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPurchasedOnTop : 1;                               // 0x0850(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_851[0x7];                                      // 0x0851(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UEditableTextBox*                       EditableTextBox_SearchString;                      // 0x0858(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedDropDown*                           TedDropDown_Filters;                               // 0x0860(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_RemainingRequisitionPoints;                   // 0x0868(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedEquipmentPanelSearchStringCheck           SearchStringRule;                                  // 0x0870(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_871[0x7];                                      // 0x0871(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTedEquipmentPanelFilterOption> AvailableFilters;                                  // 0x0878(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UTedEquipment*>                  content;                                           // 0x0888(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TArray<class UTedEquipment*>                  FilteredContent;                                   // 0x0898(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	class FString                                 SearchString;                                      // 0x08A8(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedEquipmentPanelFilterOptionType            FilterType;                                        // 0x08B8(0x0001)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8B9[0x7];                                      // 0x08B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_SetContent(const TArray<class UTedEquipment*>& InContent);
	void OnEditableTextBoxSearchStringChange(const class FText& InText);
	void RequestBuy(class UTedEquipmentSlot* InEquipmentSlot);
	void RequestEquip(class UTedEquipmentSlot* InEquipmentSlot);
	void RequestUnequip(class UTedEquipmentSlot* InEquipmentSlot);
	void SetFilterType(const ETedEquipmentPanelFilterOptionType InType);
	void SetSearchString(const class FString& InSearchString);
	void SortContent();

	bool CanEquipmentBeEquipped(const class UTedEquipment* InEquipment) const;
	bool CanEquipmentBePurchased(const class UTedEquipment* InEquipment) const;
	ETedEquipmentPanelFilterOptionType GetCurrentFilterType() const;
	int32 GetRemainingRequisitionPoints() const;
	class FString GetSearchString() const;
	bool HasRequisitionForEquipment(const class UTedEquipment* InEquipment) const;
	bool HasSpaceForEquipment(const class UTedEquipment* InEquipment) const;
	bool IsEquipmentEquipped(const class UTedEquipment* InEquipment) const;
	bool IsEquipmentPurchased(const class UTedEquipment* InEquipment) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedEquipmentPanel">();
	}
	static class UTedEquipmentPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedEquipmentPanel>();
	}
};
static_assert(alignof(UTedEquipmentPanel) == 0x000008, "Wrong alignment on UTedEquipmentPanel");
static_assert(sizeof(UTedEquipmentPanel) == 0x0008C0, "Wrong size on UTedEquipmentPanel");
static_assert(offsetof(UTedEquipmentPanel, OnRequestBuy) == 0x0007B0, "Member 'UTedEquipmentPanel::OnRequestBuy' has a wrong offset!");
static_assert(offsetof(UTedEquipmentPanel, OnRequestEquip) == 0x0007C0, "Member 'UTedEquipmentPanel::OnRequestEquip' has a wrong offset!");
static_assert(offsetof(UTedEquipmentPanel, OnRequestUnequip) == 0x0007D0, "Member 'UTedEquipmentPanel::OnRequestUnequip' has a wrong offset!");
static_assert(offsetof(UTedEquipmentPanel, EditableTextBox_SearchString) == 0x000858, "Member 'UTedEquipmentPanel::EditableTextBox_SearchString' has a wrong offset!");
static_assert(offsetof(UTedEquipmentPanel, TedDropDown_Filters) == 0x000860, "Member 'UTedEquipmentPanel::TedDropDown_Filters' has a wrong offset!");
static_assert(offsetof(UTedEquipmentPanel, Text_RemainingRequisitionPoints) == 0x000868, "Member 'UTedEquipmentPanel::Text_RemainingRequisitionPoints' has a wrong offset!");
static_assert(offsetof(UTedEquipmentPanel, SearchStringRule) == 0x000870, "Member 'UTedEquipmentPanel::SearchStringRule' has a wrong offset!");
static_assert(offsetof(UTedEquipmentPanel, AvailableFilters) == 0x000878, "Member 'UTedEquipmentPanel::AvailableFilters' has a wrong offset!");
static_assert(offsetof(UTedEquipmentPanel, content) == 0x000888, "Member 'UTedEquipmentPanel::content' has a wrong offset!");
static_assert(offsetof(UTedEquipmentPanel, FilteredContent) == 0x000898, "Member 'UTedEquipmentPanel::FilteredContent' has a wrong offset!");
static_assert(offsetof(UTedEquipmentPanel, SearchString) == 0x0008A8, "Member 'UTedEquipmentPanel::SearchString' has a wrong offset!");
static_assert(offsetof(UTedEquipmentPanel, FilterType) == 0x0008B8, "Member 'UTedEquipmentPanel::FilterType' has a wrong offset!");

// Class Tempest.AIMission_Patrol
// 0x0040 (0x0240 - 0x0200)
class UAIMission_Patrol final : public UAIMission
{
public:
	EAIMissionPatrolMode                          PatrolMode;                                        // 0x0200(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_201[0x3];                                      // 0x0201(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumRepeats;                                        // 0x0204(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStartAtClosestWaypoint;                           // 0x0208(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_209[0x7];                                      // 0x0209(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector2D>                      Waypoints;                                         // 0x0210(0x0010)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentWaypointIdx;                                // 0x0220(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RepeatCounter;                                     // 0x0224(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         bPingPongDirection;                                // 0x0228(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 NotUsedRandomWaypointIndices;                      // 0x0230(0x0010)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)

public:
	void SetInfinitePatrol(const bool bInfinitePatrol);
	void SetNumRepeats(const int32 NumRepeats_0, const bool bRestartRepeatsCounter);
	void SetPatrolMode(const EAIMissionPatrolMode PatrolMode_0);
	void SetStartAtClosestWaypoint(const bool bStartAtClosestWaypoint_0);
	void SetWaypoints(const TArray<struct FVector>& Waypoints_0);
	void SetWaypointsFromActorLocations(const TArray<class AActor*>& Actors);
	void SetWaypointsFromAIRoute(const class AAIRoute* AIRoute);

	int32 GetNumRepeats() const;
	EAIMissionPatrolMode GetPatrolMode() const;
	bool IsInfinitePatrol() const;
	bool ShouldStartAtClosestWaypoint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIMission_Patrol">();
	}
	static class UAIMission_Patrol* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIMission_Patrol>();
	}
};
static_assert(alignof(UAIMission_Patrol) == 0x000008, "Wrong alignment on UAIMission_Patrol");
static_assert(sizeof(UAIMission_Patrol) == 0x000240, "Wrong size on UAIMission_Patrol");
static_assert(offsetof(UAIMission_Patrol, PatrolMode) == 0x000200, "Member 'UAIMission_Patrol::PatrolMode' has a wrong offset!");
static_assert(offsetof(UAIMission_Patrol, NumRepeats) == 0x000204, "Member 'UAIMission_Patrol::NumRepeats' has a wrong offset!");
static_assert(offsetof(UAIMission_Patrol, bStartAtClosestWaypoint) == 0x000208, "Member 'UAIMission_Patrol::bStartAtClosestWaypoint' has a wrong offset!");
static_assert(offsetof(UAIMission_Patrol, Waypoints) == 0x000210, "Member 'UAIMission_Patrol::Waypoints' has a wrong offset!");
static_assert(offsetof(UAIMission_Patrol, CurrentWaypointIdx) == 0x000220, "Member 'UAIMission_Patrol::CurrentWaypointIdx' has a wrong offset!");
static_assert(offsetof(UAIMission_Patrol, RepeatCounter) == 0x000224, "Member 'UAIMission_Patrol::RepeatCounter' has a wrong offset!");
static_assert(offsetof(UAIMission_Patrol, bPingPongDirection) == 0x000228, "Member 'UAIMission_Patrol::bPingPongDirection' has a wrong offset!");
static_assert(offsetof(UAIMission_Patrol, NotUsedRandomWaypointIndices) == 0x000230, "Member 'UAIMission_Patrol::NotUsedRandomWaypointIndices' has a wrong offset!");

// Class Tempest.TedSelectionBoxWidget
// 0x02F0 (0x06F0 - 0x0400)
class UTedSelectionBoxWidget : public UTedUserWidget
{
public:
	uint8                                         bPaintSecondBorder : 1;                            // 0x0400(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPaintHealthBars : 1;                              // 0x0400(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_401[0x7];                                      // 0x0401(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     FillMaterial;                                      // 0x0408(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FillMaterialSizeParam_Width;                       // 0x0410(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FillMaterialSizeParam_Height;                      // 0x0418(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FillMaterialOriginParam_X;                         // 0x0420(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FillMaterialOriginParam_Y;                         // 0x0428(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateBrush                            BorderBrush;                                       // 0x0430(0x00D0)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            SecondBorderBrush;                                 // 0x0500(0x00D0)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         SecondBorderOffset;                                // 0x05D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D4[0x4];                                      // 0x05D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedHealthBarsProxyWidget*              HealthBarsProxy;                                   // 0x05D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               FillMaterialMID;                                   // 0x05E0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E8[0x8];                                      // 0x05E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            FillBrush;                                         // 0x05F0(0x00D0)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              position;                                          // 0x06C0(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              Size;                                              // 0x06D0(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedSelectionBoxOrigin                        Origin;                                            // 0x06E0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6E1[0xF];                                      // 0x06E1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSelectionBoxWidget">();
	}
	static class UTedSelectionBoxWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSelectionBoxWidget>();
	}
};
static_assert(alignof(UTedSelectionBoxWidget) == 0x000010, "Wrong alignment on UTedSelectionBoxWidget");
static_assert(sizeof(UTedSelectionBoxWidget) == 0x0006F0, "Wrong size on UTedSelectionBoxWidget");
static_assert(offsetof(UTedSelectionBoxWidget, FillMaterial) == 0x000408, "Member 'UTedSelectionBoxWidget::FillMaterial' has a wrong offset!");
static_assert(offsetof(UTedSelectionBoxWidget, FillMaterialSizeParam_Width) == 0x000410, "Member 'UTedSelectionBoxWidget::FillMaterialSizeParam_Width' has a wrong offset!");
static_assert(offsetof(UTedSelectionBoxWidget, FillMaterialSizeParam_Height) == 0x000418, "Member 'UTedSelectionBoxWidget::FillMaterialSizeParam_Height' has a wrong offset!");
static_assert(offsetof(UTedSelectionBoxWidget, FillMaterialOriginParam_X) == 0x000420, "Member 'UTedSelectionBoxWidget::FillMaterialOriginParam_X' has a wrong offset!");
static_assert(offsetof(UTedSelectionBoxWidget, FillMaterialOriginParam_Y) == 0x000428, "Member 'UTedSelectionBoxWidget::FillMaterialOriginParam_Y' has a wrong offset!");
static_assert(offsetof(UTedSelectionBoxWidget, BorderBrush) == 0x000430, "Member 'UTedSelectionBoxWidget::BorderBrush' has a wrong offset!");
static_assert(offsetof(UTedSelectionBoxWidget, SecondBorderBrush) == 0x000500, "Member 'UTedSelectionBoxWidget::SecondBorderBrush' has a wrong offset!");
static_assert(offsetof(UTedSelectionBoxWidget, SecondBorderOffset) == 0x0005D0, "Member 'UTedSelectionBoxWidget::SecondBorderOffset' has a wrong offset!");
static_assert(offsetof(UTedSelectionBoxWidget, HealthBarsProxy) == 0x0005D8, "Member 'UTedSelectionBoxWidget::HealthBarsProxy' has a wrong offset!");
static_assert(offsetof(UTedSelectionBoxWidget, FillMaterialMID) == 0x0005E0, "Member 'UTedSelectionBoxWidget::FillMaterialMID' has a wrong offset!");
static_assert(offsetof(UTedSelectionBoxWidget, FillBrush) == 0x0005F0, "Member 'UTedSelectionBoxWidget::FillBrush' has a wrong offset!");
static_assert(offsetof(UTedSelectionBoxWidget, position) == 0x0006C0, "Member 'UTedSelectionBoxWidget::position' has a wrong offset!");
static_assert(offsetof(UTedSelectionBoxWidget, Size) == 0x0006D0, "Member 'UTedSelectionBoxWidget::Size' has a wrong offset!");
static_assert(offsetof(UTedSelectionBoxWidget, Origin) == 0x0006E0, "Member 'UTedSelectionBoxWidget::Origin' has a wrong offset!");

// Class Tempest.AIMission_RebuildStructures
// 0x0150 (0x0350 - 0x0200)
class UAIMission_RebuildStructures final : public UAIMission
{
public:
	float                                         RebuildDelay;                                      // 0x0200(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxRebuildCount;                                   // 0x0204(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnorePrerequisites;                              // 0x0208(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_209[0x7];                                      // 0x0209(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TWeakObjectPtr<class ATedStructureBase>, struct FAIMissionRebuildStructureDataHandle> RegisteredStructures; // 0x0210(0x0050)(SaveGame, Protected, NativeAccessSpecifierProtected)
	TMap<struct FAIMissionRebuildStructureDataHandle, struct FAIMissionRebuildStructureData> RebuildStructuresData; // 0x0260(0x0050)(SaveGame, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B0[0x50];                                     // 0x02B0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FAIBuildOrderQueueElementHandle, struct FAIMissionRebuildStructureDataHandle> SparseProductionElementHandles; // 0x0300(0x0050)(SaveGame, Protected, NativeAccessSpecifierProtected)

public:
	void OnStructureActorDestroyed(class AActor* Actor);
	void RegisterAllStructures();
	void RegisterStructure(class ATedStructureBase* Structure);
	void RegisterStructures(const TArray<class ATedStructureBase*>& Structures);
	void RegisterStructuresByActorTag(const struct FGameplayTagContainer& ActorTags, const bool bExactMatch);
	void RegisterStructuresByDefinitionId(const struct FGameplayTagContainer& DefinitionIds, const bool bExactMatch);
	void RegisterStructuresByOwnedTags(const struct FGameplayTagContainer& Tags, const EGameplayContainerMatchType MatchType, const bool bExactMatch);
	void RegisterStructuresByType(const EAIMissionRebuildStructureType StructureType);
	void SetIgnorePrerequisites(const bool bIgnorePrerequisites_0);
	void SetMaxRebuildCount(const int32 MaxRebuildCount_0);
	void SetRebuildDelay(const float Delay);
	void UnregisterAllStructures();
	void UnregisterStructure(class ATedStructureBase* Structure);
	void UnregisterStructures(const TArray<class ATedStructureBase*>& Structures);

	bool GetIgnorePrerequisites() const;
	int32 GetMaxRebuildCount() const;
	float GetRebuildDelay() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIMission_RebuildStructures">();
	}
	static class UAIMission_RebuildStructures* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIMission_RebuildStructures>();
	}
};
static_assert(alignof(UAIMission_RebuildStructures) == 0x000008, "Wrong alignment on UAIMission_RebuildStructures");
static_assert(sizeof(UAIMission_RebuildStructures) == 0x000350, "Wrong size on UAIMission_RebuildStructures");
static_assert(offsetof(UAIMission_RebuildStructures, RebuildDelay) == 0x000200, "Member 'UAIMission_RebuildStructures::RebuildDelay' has a wrong offset!");
static_assert(offsetof(UAIMission_RebuildStructures, MaxRebuildCount) == 0x000204, "Member 'UAIMission_RebuildStructures::MaxRebuildCount' has a wrong offset!");
static_assert(offsetof(UAIMission_RebuildStructures, bIgnorePrerequisites) == 0x000208, "Member 'UAIMission_RebuildStructures::bIgnorePrerequisites' has a wrong offset!");
static_assert(offsetof(UAIMission_RebuildStructures, RegisteredStructures) == 0x000210, "Member 'UAIMission_RebuildStructures::RegisteredStructures' has a wrong offset!");
static_assert(offsetof(UAIMission_RebuildStructures, RebuildStructuresData) == 0x000260, "Member 'UAIMission_RebuildStructures::RebuildStructuresData' has a wrong offset!");
static_assert(offsetof(UAIMission_RebuildStructures, SparseProductionElementHandles) == 0x000300, "Member 'UAIMission_RebuildStructures::SparseProductionElementHandles' has a wrong offset!");

// Class Tempest.TedCommand
// 0x02B8 (0x0538 - 0x0280)
class UTedCommand : public UGameplayCommand
{
public:
	uint8                                         bContextualSelect : 1;                             // 0x0280(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bContextualHover : 1;                              // 0x0280(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bNotContextualOnOwnedTargetWithLMB : 1;            // 0x0280(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bExecuteOnDoubleTap : 1;                           // 0x0280(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bRandomLocationNearUnitOnDoubleTap : 1;            // 0x0280(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_281[0x3];                                      // 0x0281(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomLocationOnDoubleTapDistance;                 // 0x0284(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bFindClosestValidAttackPosition : 1;               // 0x0288(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bProcessPawnReplacement : 1;                       // 0x0288(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAllowForSpectators : 1;                           // 0x0288(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bNotifyClientOfExecutionState : 1;                 // 0x0288(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAllocateCustomPayloadIfMissing : 1;               // 0x0288(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_289[0x3];                                      // 0x0289(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CommandRange;                                      // 0x028C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   Name_0;                                            // 0x0290(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTedFormattedText                      Description;                                       // 0x02A0(0x0060)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             Icon;                                              // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedCursorConfig*                       CursorConfig;                                      // 0x0308(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             Cursor;                                            // 0x0310(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bCursorAttitudeColoring : 1;                       // 0x0318(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bShowCursorWhenContextual : 1;                     // 0x0318(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	ETedCommandDisplaySection                     DisplaySection;                                    // 0x0319(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         DisplaySectionFixedSlot;                           // 0x031A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAlternating;                                    // 0x031B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   KeyBinding;                                        // 0x031C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UTedPawnSound>              PawnSoundClass;                                    // 0x0328(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTedCommandSoundOverride>       SoundClassOverrides;                               // 0x0330(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FFGameplayCommandValue                 CreditCost;                                        // 0x0340(0x0028)(Edit, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FFGameplayCommandValue                 IntelCost;                                         // 0x0368(0x0028)(Edit, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FFGameplayCommandValue                 PowerCost;                                         // 0x0390(0x0028)(Edit, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FFGameplayCommandValue                 PopulationCost;                                    // 0x03B8(0x0028)(Edit, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  TooltipTagRequirements;                            // 0x03E0(0x0020)(Deprecated, Protected, NativeAccessSpecifierProtected)
	struct FTedPrerequisiteContainer              TooltipRequirements;                               // 0x0400(0x0110)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bShowLowPowerRequirement : 1;                      // 0x0510(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bShowInsufficientCreditsRequirement : 1;           // 0x0510(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bShowInsufficientIntelRequirement : 1;             // 0x0510(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bShowPopulationFullRequirement : 1;                // 0x0510(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_511[0x7];                                      // 0x0511(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisabledInfo;                                      // 0x0518(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   AutoCastUIHint;                                    // 0x0528(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static TArray<class FName> GetAvailableKeyBindingsSorted();

	int32 GetCreditCost(const class AActor* CommandActor) const;
	const class UTedCursorConfig* GetCursorConfig() const;
	class UTexture2D* GetDisplayCursor() const;
	class FText GetDisplayDescription() const;
	class UTexture2D* GetDisplayIcon() const;
	const class FText GetDisplayName() const;
	ETedCommandDisplaySection GetDisplaySection() const;
	int32 GetIntelCost(const class AActor* CommandActor) const;
	bool GetIsAlternating() const;
	int32 GetPopulationCost(const class AActor* CommandActor) const;
	int32 GetPowerCost(const class AActor* CommandActor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommand">();
	}
	static class UTedCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCommand>();
	}
};
static_assert(alignof(UTedCommand) == 0x000008, "Wrong alignment on UTedCommand");
static_assert(sizeof(UTedCommand) == 0x000538, "Wrong size on UTedCommand");
static_assert(offsetof(UTedCommand, RandomLocationOnDoubleTapDistance) == 0x000284, "Member 'UTedCommand::RandomLocationOnDoubleTapDistance' has a wrong offset!");
static_assert(offsetof(UTedCommand, CommandRange) == 0x00028C, "Member 'UTedCommand::CommandRange' has a wrong offset!");
static_assert(offsetof(UTedCommand, Name_0) == 0x000290, "Member 'UTedCommand::Name_0' has a wrong offset!");
static_assert(offsetof(UTedCommand, Description) == 0x0002A0, "Member 'UTedCommand::Description' has a wrong offset!");
static_assert(offsetof(UTedCommand, Icon) == 0x000300, "Member 'UTedCommand::Icon' has a wrong offset!");
static_assert(offsetof(UTedCommand, CursorConfig) == 0x000308, "Member 'UTedCommand::CursorConfig' has a wrong offset!");
static_assert(offsetof(UTedCommand, Cursor) == 0x000310, "Member 'UTedCommand::Cursor' has a wrong offset!");
static_assert(offsetof(UTedCommand, DisplaySection) == 0x000319, "Member 'UTedCommand::DisplaySection' has a wrong offset!");
static_assert(offsetof(UTedCommand, DisplaySectionFixedSlot) == 0x00031A, "Member 'UTedCommand::DisplaySectionFixedSlot' has a wrong offset!");
static_assert(offsetof(UTedCommand, bIsAlternating) == 0x00031B, "Member 'UTedCommand::bIsAlternating' has a wrong offset!");
static_assert(offsetof(UTedCommand, KeyBinding) == 0x00031C, "Member 'UTedCommand::KeyBinding' has a wrong offset!");
static_assert(offsetof(UTedCommand, PawnSoundClass) == 0x000328, "Member 'UTedCommand::PawnSoundClass' has a wrong offset!");
static_assert(offsetof(UTedCommand, SoundClassOverrides) == 0x000330, "Member 'UTedCommand::SoundClassOverrides' has a wrong offset!");
static_assert(offsetof(UTedCommand, CreditCost) == 0x000340, "Member 'UTedCommand::CreditCost' has a wrong offset!");
static_assert(offsetof(UTedCommand, IntelCost) == 0x000368, "Member 'UTedCommand::IntelCost' has a wrong offset!");
static_assert(offsetof(UTedCommand, PowerCost) == 0x000390, "Member 'UTedCommand::PowerCost' has a wrong offset!");
static_assert(offsetof(UTedCommand, PopulationCost) == 0x0003B8, "Member 'UTedCommand::PopulationCost' has a wrong offset!");
static_assert(offsetof(UTedCommand, TooltipTagRequirements) == 0x0003E0, "Member 'UTedCommand::TooltipTagRequirements' has a wrong offset!");
static_assert(offsetof(UTedCommand, TooltipRequirements) == 0x000400, "Member 'UTedCommand::TooltipRequirements' has a wrong offset!");
static_assert(offsetof(UTedCommand, DisabledInfo) == 0x000518, "Member 'UTedCommand::DisabledInfo' has a wrong offset!");
static_assert(offsetof(UTedCommand, AutoCastUIHint) == 0x000528, "Member 'UTedCommand::AutoCastUIHint' has a wrong offset!");

// Class Tempest.TedPawnCommand
// 0x0008 (0x0540 - 0x0538)
class UTedPawnCommand : public UTedCommand
{
public:
	uint8                                         bCreatesIndividualTargetLocations : 1;             // 0x0538(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_539[0x7];                                      // 0x0539(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommand">();
	}
	static class UTedPawnCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnCommand>();
	}
};
static_assert(alignof(UTedPawnCommand) == 0x000008, "Wrong alignment on UTedPawnCommand");
static_assert(sizeof(UTedPawnCommand) == 0x000540, "Wrong size on UTedPawnCommand");

// Class Tempest.TedPawnCommandWithBehavior
// 0x0030 (0x0570 - 0x0540)
class UTedPawnCommandWithBehavior : public UTedPawnCommand
{
public:
	struct FTedCommandWithBehaviorAssetSpec       BehaviorAssetSpec;                                 // 0x0540(0x0030)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommandWithBehavior">();
	}
	static class UTedPawnCommandWithBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnCommandWithBehavior>();
	}
};
static_assert(alignof(UTedPawnCommandWithBehavior) == 0x000008, "Wrong alignment on UTedPawnCommandWithBehavior");
static_assert(sizeof(UTedPawnCommandWithBehavior) == 0x000570, "Wrong size on UTedPawnCommandWithBehavior");
static_assert(offsetof(UTedPawnCommandWithBehavior, BehaviorAssetSpec) == 0x000540, "Member 'UTedPawnCommandWithBehavior::BehaviorAssetSpec' has a wrong offset!");

// Class Tempest.TedPawnCommand_ToggleAutoHarvest
// 0x0000 (0x0570 - 0x0570)
class UTedPawnCommand_ToggleAutoHarvest : public UTedPawnCommandWithBehavior
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommand_ToggleAutoHarvest">();
	}
	static class UTedPawnCommand_ToggleAutoHarvest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnCommand_ToggleAutoHarvest>();
	}
};
static_assert(alignof(UTedPawnCommand_ToggleAutoHarvest) == 0x000008, "Wrong alignment on UTedPawnCommand_ToggleAutoHarvest");
static_assert(sizeof(UTedPawnCommand_ToggleAutoHarvest) == 0x000570, "Wrong size on UTedPawnCommand_ToggleAutoHarvest");

// Class Tempest.TedEncyclopediaFactionPanel
// 0x0020 (0x07D0 - 0x07B0)
class UTedEncyclopediaFactionPanel final : public UTedContentPanelDynamic
{
public:
	TMulticastInlineDelegate<void(class UTedEncyclopediaDefinitionAsset* Asset, EEncyclopediaAssetStatus CurrentStatus)> OnEntrySelected; // 0x07B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FEncyclopediaFactoryPanelInfo>  content;                                           // 0x07C0(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)

public:
	void SetContent(const TArray<struct FEncyclopediaFactoryPanelInfo>& NewContent);

	struct FEncyclopediaFactoryPanelInfo GetContent(int32 Index_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedEncyclopediaFactionPanel">();
	}
	static class UTedEncyclopediaFactionPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedEncyclopediaFactionPanel>();
	}
};
static_assert(alignof(UTedEncyclopediaFactionPanel) == 0x000008, "Wrong alignment on UTedEncyclopediaFactionPanel");
static_assert(sizeof(UTedEncyclopediaFactionPanel) == 0x0007D0, "Wrong size on UTedEncyclopediaFactionPanel");
static_assert(offsetof(UTedEncyclopediaFactionPanel, OnEntrySelected) == 0x0007B0, "Member 'UTedEncyclopediaFactionPanel::OnEntrySelected' has a wrong offset!");
static_assert(offsetof(UTedEncyclopediaFactionPanel, content) == 0x0007C0, "Member 'UTedEncyclopediaFactionPanel::content' has a wrong offset!");

// Class Tempest.AIMission_Reserves
// 0x0000 (0x0200 - 0x0200)
class UAIMission_Reserves final : public UAIMission
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIMission_Reserves">();
	}
	static class UAIMission_Reserves* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIMission_Reserves>();
	}
};
static_assert(alignof(UAIMission_Reserves) == 0x000008, "Wrong alignment on UAIMission_Reserves");
static_assert(sizeof(UAIMission_Reserves) == 0x000200, "Wrong size on UAIMission_Reserves");

// Class Tempest.AIMission_Scout
// 0x0000 (0x0200 - 0x0200)
class UAIMission_Scout final : public UAIMission
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIMission_Scout">();
	}
	static class UAIMission_Scout* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIMission_Scout>();
	}
};
static_assert(alignof(UAIMission_Scout) == 0x000008, "Wrong alignment on UAIMission_Scout");
static_assert(sizeof(UAIMission_Scout) == 0x000200, "Wrong size on UAIMission_Scout");

// Class Tempest.TedContentPanelSlotBase
// 0x0010 (0x0410 - 0x0400)
class UTedContentPanelSlotBase : public UTedUserWidget
{
public:
	class UTedContentPanelBase*                   ParentPanel;                                       // 0x0400(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SlotIndex;                                         // 0x0408(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40C[0x4];                                      // 0x040C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateState(ETedContentSlotState InState, bool bInActivate);
	class UTedContentPanelBase* K2_GetParentContentPanel();
	int32 K2_GetSlotIndex();
	void OnActivateState(ETedContentSlotState InState, bool bInActivated);
	void OnTriggerAction(ETedContentSlotAction InAction);
	void TriggerAction(ETedContentSlotAction InAction);

	void GetMaterialsSupportingStates(TArray<class UMaterialInstanceDynamic*>* OutMIDs) const;
	class UTedContentPanelBase* GetParentContentPanel() const;
	int32 GetSlotIndex() const;
	bool IsStateActive(ETedContentSlotState InState) const;
	bool K2_GetAssetSelector(const struct FGameplayTag& InSelectorKey, struct FTedContentSlotStateAssetSelector* Out) const;
	bool RefreshWidgetUsingAssetSelector(const struct FGameplayTag& InSelectorKey, class UWidget* InTargetWidget) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedContentPanelSlotBase">();
	}
	static class UTedContentPanelSlotBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedContentPanelSlotBase>();
	}
};
static_assert(alignof(UTedContentPanelSlotBase) == 0x000008, "Wrong alignment on UTedContentPanelSlotBase");
static_assert(sizeof(UTedContentPanelSlotBase) == 0x000410, "Wrong size on UTedContentPanelSlotBase");
static_assert(offsetof(UTedContentPanelSlotBase, ParentPanel) == 0x000400, "Member 'UTedContentPanelSlotBase::ParentPanel' has a wrong offset!");
static_assert(offsetof(UTedContentPanelSlotBase, SlotIndex) == 0x000408, "Member 'UTedContentPanelSlotBase::SlotIndex' has a wrong offset!");

// Class Tempest.TedContentPanelSlotButton
// 0x0020 (0x0430 - 0x0410)
class UTedContentPanelSlotButton : public UTedContentPanelSlotBase
{
public:
	bool                                          bShouldForceAcquireFocus;                          // 0x0410(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_411[0x7];                                      // 0x0411(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   LastPressedKey;                                    // 0x0418(0x0018)(Transient, DuplicateTransient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedContentPanelSlotButton">();
	}
	static class UTedContentPanelSlotButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedContentPanelSlotButton>();
	}
};
static_assert(alignof(UTedContentPanelSlotButton) == 0x000008, "Wrong alignment on UTedContentPanelSlotButton");
static_assert(sizeof(UTedContentPanelSlotButton) == 0x000430, "Wrong size on UTedContentPanelSlotButton");
static_assert(offsetof(UTedContentPanelSlotButton, bShouldForceAcquireFocus) == 0x000410, "Member 'UTedContentPanelSlotButton::bShouldForceAcquireFocus' has a wrong offset!");
static_assert(offsetof(UTedContentPanelSlotButton, LastPressedKey) == 0x000418, "Member 'UTedContentPanelSlotButton::LastPressedKey' has a wrong offset!");

// Class Tempest.TedEncyclepediaFactionSlot
// 0x0048 (0x0478 - 0x0430)
class UTedEncyclepediaFactionSlot final : public UTedContentPanelSlotButton
{
public:
	class UImage*                                 SlotBG;                                            // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Maintext;                                          // 0x0438(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ActiveStatusArrow;                                 // 0x0440(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedEncyclopediaEntryPanel*             EntriesPanel;                                      // 0x0448(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DefaultStatusArrowTexture;                         // 0x0450(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     ActiveStatusArrowTexture;                          // 0x0458(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DefaultBG;                                         // 0x0460(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     SelectedBG;                                        // 0x0468(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     HoveredBG;                                         // 0x0470(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedEncyclepediaFactionSlot">();
	}
	static class UTedEncyclepediaFactionSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedEncyclepediaFactionSlot>();
	}
};
static_assert(alignof(UTedEncyclepediaFactionSlot) == 0x000008, "Wrong alignment on UTedEncyclepediaFactionSlot");
static_assert(sizeof(UTedEncyclepediaFactionSlot) == 0x000478, "Wrong size on UTedEncyclepediaFactionSlot");
static_assert(offsetof(UTedEncyclepediaFactionSlot, SlotBG) == 0x000430, "Member 'UTedEncyclepediaFactionSlot::SlotBG' has a wrong offset!");
static_assert(offsetof(UTedEncyclepediaFactionSlot, Maintext) == 0x000438, "Member 'UTedEncyclepediaFactionSlot::Maintext' has a wrong offset!");
static_assert(offsetof(UTedEncyclepediaFactionSlot, ActiveStatusArrow) == 0x000440, "Member 'UTedEncyclepediaFactionSlot::ActiveStatusArrow' has a wrong offset!");
static_assert(offsetof(UTedEncyclepediaFactionSlot, EntriesPanel) == 0x000448, "Member 'UTedEncyclepediaFactionSlot::EntriesPanel' has a wrong offset!");
static_assert(offsetof(UTedEncyclepediaFactionSlot, DefaultStatusArrowTexture) == 0x000450, "Member 'UTedEncyclepediaFactionSlot::DefaultStatusArrowTexture' has a wrong offset!");
static_assert(offsetof(UTedEncyclepediaFactionSlot, ActiveStatusArrowTexture) == 0x000458, "Member 'UTedEncyclepediaFactionSlot::ActiveStatusArrowTexture' has a wrong offset!");
static_assert(offsetof(UTedEncyclepediaFactionSlot, DefaultBG) == 0x000460, "Member 'UTedEncyclepediaFactionSlot::DefaultBG' has a wrong offset!");
static_assert(offsetof(UTedEncyclepediaFactionSlot, SelectedBG) == 0x000468, "Member 'UTedEncyclepediaFactionSlot::SelectedBG' has a wrong offset!");
static_assert(offsetof(UTedEncyclepediaFactionSlot, HoveredBG) == 0x000470, "Member 'UTedEncyclepediaFactionSlot::HoveredBG' has a wrong offset!");

// Class Tempest.AIMission_Scriptable
// 0x0000 (0x0200 - 0x0200)
class UAIMission_Scriptable final : public UAIMission
{
public:
	void SetSquadOrder(const struct FAISquadOrder& Order);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIMission_Scriptable">();
	}
	static class UAIMission_Scriptable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIMission_Scriptable>();
	}
};
static_assert(alignof(UAIMission_Scriptable) == 0x000008, "Wrong alignment on UAIMission_Scriptable");
static_assert(sizeof(UAIMission_Scriptable) == 0x000200, "Wrong size on UAIMission_Scriptable");

// Class Tempest.TedPawnsPanel
// 0x0028 (0x07D8 - 0x07B0)
class UTedPawnsPanel : public UTedContentPanelDynamic
{
public:
	TMulticastInlineDelegate<void(class AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser)> OnPawnDamagedDelegate; // 0x07B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         bAutoRemoveContentOnDeath : 1;                     // 0x07C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAllowDuplicates : 1;                              // 0x07C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAllowUnits : 1;                                   // 0x07C0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAllowStructures : 1;                              // 0x07C0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAllowEmpty : 1;                                   // 0x07C0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bShouldGeneratePawnDamagedEvents : 1;              // 0x07C0(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_7C1[0x7];                                      // 0x07C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATedPawn*>                       content;                                           // 0x07C8(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)

public:
	void AddContent(const TArray<class ATedPawn*>& InContent, const bool bInRefreshUI);
	void ClearContent(const bool bInRefreshUI);
	bool ContainsPawnOfClass(TSubclassOf<class ATedPawn> InClass);
	void OnPawnEndPlay_Handler(class AActor* InActor, EEndPlayReason InEndPlayReason);
	void RemoveContent(const TArray<class ATedPawn*>& InContent, const bool bInRefreshUI);
	void SetContent(const TArray<class ATedPawn*>& InContent, const bool bInRefreshUI);

	const TArray<class ATedPawn*> GetAllContent() const;
	int32 GetContentIndex(const class ATedPawn* InPawn) const;
	class UTedContentPanelSlotBase* GetContentSlotByContent(const class ATedPawn* InPawn) const;
	class ATedPawn* GetSlotContent(const int32 InSlotIndex) const;
	bool ShouldGeneratePawnDamagedEvents() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnsPanel">();
	}
	static class UTedPawnsPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnsPanel>();
	}
};
static_assert(alignof(UTedPawnsPanel) == 0x000008, "Wrong alignment on UTedPawnsPanel");
static_assert(sizeof(UTedPawnsPanel) == 0x0007D8, "Wrong size on UTedPawnsPanel");
static_assert(offsetof(UTedPawnsPanel, OnPawnDamagedDelegate) == 0x0007B0, "Member 'UTedPawnsPanel::OnPawnDamagedDelegate' has a wrong offset!");
static_assert(offsetof(UTedPawnsPanel, content) == 0x0007C8, "Member 'UTedPawnsPanel::content' has a wrong offset!");

// Class Tempest.TedSelectionDetailsPawnsGrid
// 0x00F8 (0x08D0 - 0x07D8)
class UTedSelectionDetailsPawnsGrid : public UTedPawnsPanel
{
public:
	uint8                                         MaxColumns;                                        // 0x07D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         MaxRows;                                           // 0x07D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bReserveLastSlotForContentBeyondCapacity : 1;      // 0x07DA(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSortContentByHP : 1;                              // 0x07DA(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSwitchRowsOnMouseWheel : 1;                       // 0x07DA(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bTryMaintainRowAfterRefresh : 1;                   // 0x07DA(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_7DB[0x1];                                      // 0x07DB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SwitchRowsOnMouseWheelTolerance;                   // 0x07DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                SlotPadding;                                       // 0x07E0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTedShortcutUI                         SelectSingle;                                      // 0x07F0(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FTedShortcutUI                         DeselectSingle;                                    // 0x0810(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FTedShortcutUI                         SelectByType;                                      // 0x0830(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FTedShortcutUI                         DeselectByType;                                    // 0x0850(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	TSet<class ATedPawn*>                         SelectedPawns;                                     // 0x0870(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentRow;                                        // 0x08C0(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C4[0x4];                                      // 0x08C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           OnSortAndRefreshAfterPawnHPChangeHandle;           // 0x08C8(0x0008)(Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnSortAndRefreshAfterPawnHPChange();
	void SetCurrentRow(const int32 InRow);
	void SwitchRow(const bool bInUp);

	bool CanSwitch(const bool bInUp) const;
	bool CanSwitchDown() const;
	bool CanSwitchUp() const;
	int32 GetLastAvailableRowToSwitch() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSelectionDetailsPawnsGrid">();
	}
	static class UTedSelectionDetailsPawnsGrid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSelectionDetailsPawnsGrid>();
	}
};
static_assert(alignof(UTedSelectionDetailsPawnsGrid) == 0x000008, "Wrong alignment on UTedSelectionDetailsPawnsGrid");
static_assert(sizeof(UTedSelectionDetailsPawnsGrid) == 0x0008D0, "Wrong size on UTedSelectionDetailsPawnsGrid");
static_assert(offsetof(UTedSelectionDetailsPawnsGrid, MaxColumns) == 0x0007D8, "Member 'UTedSelectionDetailsPawnsGrid::MaxColumns' has a wrong offset!");
static_assert(offsetof(UTedSelectionDetailsPawnsGrid, MaxRows) == 0x0007D9, "Member 'UTedSelectionDetailsPawnsGrid::MaxRows' has a wrong offset!");
static_assert(offsetof(UTedSelectionDetailsPawnsGrid, SwitchRowsOnMouseWheelTolerance) == 0x0007DC, "Member 'UTedSelectionDetailsPawnsGrid::SwitchRowsOnMouseWheelTolerance' has a wrong offset!");
static_assert(offsetof(UTedSelectionDetailsPawnsGrid, SlotPadding) == 0x0007E0, "Member 'UTedSelectionDetailsPawnsGrid::SlotPadding' has a wrong offset!");
static_assert(offsetof(UTedSelectionDetailsPawnsGrid, SelectSingle) == 0x0007F0, "Member 'UTedSelectionDetailsPawnsGrid::SelectSingle' has a wrong offset!");
static_assert(offsetof(UTedSelectionDetailsPawnsGrid, DeselectSingle) == 0x000810, "Member 'UTedSelectionDetailsPawnsGrid::DeselectSingle' has a wrong offset!");
static_assert(offsetof(UTedSelectionDetailsPawnsGrid, SelectByType) == 0x000830, "Member 'UTedSelectionDetailsPawnsGrid::SelectByType' has a wrong offset!");
static_assert(offsetof(UTedSelectionDetailsPawnsGrid, DeselectByType) == 0x000850, "Member 'UTedSelectionDetailsPawnsGrid::DeselectByType' has a wrong offset!");
static_assert(offsetof(UTedSelectionDetailsPawnsGrid, SelectedPawns) == 0x000870, "Member 'UTedSelectionDetailsPawnsGrid::SelectedPawns' has a wrong offset!");
static_assert(offsetof(UTedSelectionDetailsPawnsGrid, CurrentRow) == 0x0008C0, "Member 'UTedSelectionDetailsPawnsGrid::CurrentRow' has a wrong offset!");
static_assert(offsetof(UTedSelectionDetailsPawnsGrid, OnSortAndRefreshAfterPawnHPChangeHandle) == 0x0008C8, "Member 'UTedSelectionDetailsPawnsGrid::OnSortAndRefreshAfterPawnHPChangeHandle' has a wrong offset!");

// Class Tempest.AIMission_SeekPlayerStructures
// 0x0030 (0x0230 - 0x0200)
class UAIMission_SeekPlayerStructures final : public UAIMission
{
public:
	struct FGameplayTagContainer                  TargetsToSeek;                                     // 0x0200(0x0020)(SaveGame, Protected, NativeAccessSpecifierProtected)
	class ATedStructureBase*                      SelectedStructure;                                 // 0x0220(0x0008)(ZeroConstructor, SaveGame, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxStructures;                                     // 0x0228(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSquadStructureTarget(const struct FGameplayTagContainer& Targets, int32 InMaxStructures);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIMission_SeekPlayerStructures">();
	}
	static class UAIMission_SeekPlayerStructures* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIMission_SeekPlayerStructures>();
	}
};
static_assert(alignof(UAIMission_SeekPlayerStructures) == 0x000008, "Wrong alignment on UAIMission_SeekPlayerStructures");
static_assert(sizeof(UAIMission_SeekPlayerStructures) == 0x000230, "Wrong size on UAIMission_SeekPlayerStructures");
static_assert(offsetof(UAIMission_SeekPlayerStructures, TargetsToSeek) == 0x000200, "Member 'UAIMission_SeekPlayerStructures::TargetsToSeek' has a wrong offset!");
static_assert(offsetof(UAIMission_SeekPlayerStructures, SelectedStructure) == 0x000220, "Member 'UAIMission_SeekPlayerStructures::SelectedStructure' has a wrong offset!");
static_assert(offsetof(UAIMission_SeekPlayerStructures, MaxStructures) == 0x000228, "Member 'UAIMission_SeekPlayerStructures::MaxStructures' has a wrong offset!");

// Class Tempest.TedDefinitionAsset
// 0x0078 (0x00B0 - 0x0038)
class UTedDefinitionAsset : public USmartDataAsset
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           AssetIdentifier;                                   // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x18];                                      // 0x0048(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FTedDefinitionModAggregatorRef> ModAggregatorRefs;                      // 0x0060(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)

public:
	static struct FGameplayTag GetAssetIdentifierFromDefinition(TSoftObjectPtr<class UTedDefinitionAsset> Definition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedDefinitionAsset">();
	}
	static class UTedDefinitionAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedDefinitionAsset>();
	}
};
static_assert(alignof(UTedDefinitionAsset) == 0x000008, "Wrong alignment on UTedDefinitionAsset");
static_assert(sizeof(UTedDefinitionAsset) == 0x0000B0, "Wrong size on UTedDefinitionAsset");
static_assert(offsetof(UTedDefinitionAsset, AssetIdentifier) == 0x000040, "Member 'UTedDefinitionAsset::AssetIdentifier' has a wrong offset!");
static_assert(offsetof(UTedDefinitionAsset, ModAggregatorRefs) == 0x000060, "Member 'UTedDefinitionAsset::ModAggregatorRefs' has a wrong offset!");

// Class Tempest.TedEntityDefinitionAsset
// 0x0660 (0x0710 - 0x00B0)
class UTedEntityDefinitionAsset : public UTedDefinitionAsset
{
public:
	TSoftClassPtr<class UClass>                   PawnClass;                                         // 0x00B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETedFaction                                   Affiliation;                                       // 0x00D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConstructionTime;                                  // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Lifetime;                                          // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TechTag_OLD;                                       // 0x00E4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  OwnedTags;                                         // 0x00F0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  Prerequisites_OLD;                                 // 0x0110(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTedPrerequisiteContainer              Prerequisites;                                     // 0x0130(0x0110)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttributeMod                          AttributeTagMap;                                   // 0x0240(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ApplyOwnerTags;                                    // 0x0288(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           FactoryTab;                                        // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerFinishConstructionAnimation;               // 0x02B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         InfluenceRange;                                    // 0x02B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B2[0x2];                                      // 0x02B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         cost;                                              // 0x02B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntelCost;                                         // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KillIntelValue;                                    // 0x02BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PopulationCost;                                    // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Power;                                             // 0x02C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GunResistance;                                     // 0x02CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireResistance;                                    // 0x02D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CannonResistance;                                  // 0x02D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RocketResistance;                                  // 0x02D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SniperResistance;                                  // 0x02DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosiveResistance;                               // 0x02E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StealthRevealRange;                                // 0x02E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoStealthWhenStationary;                        // 0x02E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoStealthWhenNotAttacking;                      // 0x02E9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EA[0x2];                                      // 0x02EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoStealthDelay;                                  // 0x02EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RevealRadius;                                      // 0x02F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VisionRadius;                                      // 0x02F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckFieldOfViewForVision;                        // 0x02F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F9[0x3];                                      // 0x02F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           EntityDomain;                                      // 0x02FC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AttackTargetPriority;                              // 0x0304(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AiAttackTargetPriorityOverride;                    // 0x0308(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UTedWeapon>>         Weapons;                                           // 0x0310(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UTedAoEConfigAsset*>             ProvidedEffects;                                   // 0x0320(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ProvidedEffectsTags;                               // 0x0330(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UTedEffectAppliedToAttackerConfigAsset*> EffectsAppliedToAttackers;                 // 0x0350(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSkirmishCombatValue                   SkirmishAICombatValue;                             // 0x0360(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bCanGainExperience;                                // 0x0370(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETedVeterancyLevel                            InitialVeterancyLevel;                             // 0x0371(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETedVeterancyLevel                            TrainedVeterancyLevel;                             // 0x0372(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExplicitExperienceToNextLevel;                    // 0x0373(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExperienceToNextLevel;                             // 0x0374(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExperienceGainSpeedMod;                            // 0x0378(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37C[0x4];                                      // 0x037C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETedVeterancyLevel, TSubclassOf<class UGameplayEffect>> VeterancyBuffs;                     // 0x0380(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         SelectionPriority;                                 // 0x03D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreForSelectAllCombatUnits;                    // 0x03D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D5[0x3];                                      // 0x03D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UTedCommand>>        SupportedCommands;                                 // 0x03D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class UTedPawnCommandWithBehavior>, struct FTedCommandWithBehaviorAssetSpec> CommandBehaviorOverrides; // 0x03E8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class UTedPawnSound>, class USoundCue*> CommandSounds;                          // 0x0438(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           AbilitySet;                                        // 0x0488(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bHasBehavior;                                      // 0x0498(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_499[0x7];                                      // 0x0499(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UBehaviorTree>           IdleBehaviorAsset;                                 // 0x04A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBehaviorTree>           BaseBehaviorAssetOverride;                         // 0x04C8(0x0028)(Edit, DisableEditOnInstance, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlackboardData*                        BlackboardAssetOverride;                           // 0x04F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class UUtilityAIBehaviorSet*>            DefaultUtilityBehaviors;                           // 0x04F8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0548(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTedFormattedText                      Description;                                       // 0x0558(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x05B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTedPassiveAbilityDefinitionAsset*> PassivieAbilityDefinitions;                     // 0x05C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTedPassiveAbilityDefinitionAsset*      EntityTypePassivieAbilityDefinition;               // 0x05D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTedPawnScoreScreenConfig              ScoreScreenConfig;                                 // 0x05D8(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTedTelemetryPawnSettings              TelemetrySettings;                                 // 0x0638(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bStatusBarOverrides;                               // 0x063A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_63B[0x5];                                      // 0x063B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TSubclassOf<class UTedHUDInstancedValueProcessor>, struct FInstancedStruct> StatusBarOverrides; // 0x0640(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         BarWidthOverride;                                  // 0x0690(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_694[0x4];                                      // 0x0694(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ETedBarType>                           SupportedBars;                                     // 0x0698(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<ETedBarType>                           UnsupportedBars;                                   // 0x06A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         DelayedDestroyLifespan;                            // 0x06B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideOnDelayedDestroy;                             // 0x06BC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6BD[0x3];                                      // 0x06BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedPawnSkinConfig                     SkinConfig;                                        // 0x06C0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	class FText GetDescription() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedEntityDefinitionAsset">();
	}
	static class UTedEntityDefinitionAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedEntityDefinitionAsset>();
	}
};
static_assert(alignof(UTedEntityDefinitionAsset) == 0x000008, "Wrong alignment on UTedEntityDefinitionAsset");
static_assert(sizeof(UTedEntityDefinitionAsset) == 0x000710, "Wrong size on UTedEntityDefinitionAsset");
static_assert(offsetof(UTedEntityDefinitionAsset, PawnClass) == 0x0000B0, "Member 'UTedEntityDefinitionAsset::PawnClass' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, Affiliation) == 0x0000D8, "Member 'UTedEntityDefinitionAsset::Affiliation' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, ConstructionTime) == 0x0000DC, "Member 'UTedEntityDefinitionAsset::ConstructionTime' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, Lifetime) == 0x0000E0, "Member 'UTedEntityDefinitionAsset::Lifetime' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, TechTag_OLD) == 0x0000E4, "Member 'UTedEntityDefinitionAsset::TechTag_OLD' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, OwnedTags) == 0x0000F0, "Member 'UTedEntityDefinitionAsset::OwnedTags' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, Prerequisites_OLD) == 0x000110, "Member 'UTedEntityDefinitionAsset::Prerequisites_OLD' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, Prerequisites) == 0x000130, "Member 'UTedEntityDefinitionAsset::Prerequisites' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, AttributeTagMap) == 0x000240, "Member 'UTedEntityDefinitionAsset::AttributeTagMap' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, ApplyOwnerTags) == 0x000288, "Member 'UTedEntityDefinitionAsset::ApplyOwnerTags' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, FactoryTab) == 0x0002A8, "Member 'UTedEntityDefinitionAsset::FactoryTab' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, bTriggerFinishConstructionAnimation) == 0x0002B0, "Member 'UTedEntityDefinitionAsset::bTriggerFinishConstructionAnimation' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, InfluenceRange) == 0x0002B1, "Member 'UTedEntityDefinitionAsset::InfluenceRange' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, cost) == 0x0002B4, "Member 'UTedEntityDefinitionAsset::cost' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, IntelCost) == 0x0002B8, "Member 'UTedEntityDefinitionAsset::IntelCost' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, KillIntelValue) == 0x0002BC, "Member 'UTedEntityDefinitionAsset::KillIntelValue' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, PopulationCost) == 0x0002C0, "Member 'UTedEntityDefinitionAsset::PopulationCost' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, Power) == 0x0002C4, "Member 'UTedEntityDefinitionAsset::Power' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, Health) == 0x0002C8, "Member 'UTedEntityDefinitionAsset::Health' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, GunResistance) == 0x0002CC, "Member 'UTedEntityDefinitionAsset::GunResistance' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, FireResistance) == 0x0002D0, "Member 'UTedEntityDefinitionAsset::FireResistance' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, CannonResistance) == 0x0002D4, "Member 'UTedEntityDefinitionAsset::CannonResistance' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, RocketResistance) == 0x0002D8, "Member 'UTedEntityDefinitionAsset::RocketResistance' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, SniperResistance) == 0x0002DC, "Member 'UTedEntityDefinitionAsset::SniperResistance' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, ExplosiveResistance) == 0x0002E0, "Member 'UTedEntityDefinitionAsset::ExplosiveResistance' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, StealthRevealRange) == 0x0002E4, "Member 'UTedEntityDefinitionAsset::StealthRevealRange' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, bAutoStealthWhenStationary) == 0x0002E8, "Member 'UTedEntityDefinitionAsset::bAutoStealthWhenStationary' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, bAutoStealthWhenNotAttacking) == 0x0002E9, "Member 'UTedEntityDefinitionAsset::bAutoStealthWhenNotAttacking' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, AutoStealthDelay) == 0x0002EC, "Member 'UTedEntityDefinitionAsset::AutoStealthDelay' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, RevealRadius) == 0x0002F0, "Member 'UTedEntityDefinitionAsset::RevealRadius' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, VisionRadius) == 0x0002F4, "Member 'UTedEntityDefinitionAsset::VisionRadius' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, bCheckFieldOfViewForVision) == 0x0002F8, "Member 'UTedEntityDefinitionAsset::bCheckFieldOfViewForVision' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, EntityDomain) == 0x0002FC, "Member 'UTedEntityDefinitionAsset::EntityDomain' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, AttackTargetPriority) == 0x000304, "Member 'UTedEntityDefinitionAsset::AttackTargetPriority' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, AiAttackTargetPriorityOverride) == 0x000308, "Member 'UTedEntityDefinitionAsset::AiAttackTargetPriorityOverride' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, Weapons) == 0x000310, "Member 'UTedEntityDefinitionAsset::Weapons' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, ProvidedEffects) == 0x000320, "Member 'UTedEntityDefinitionAsset::ProvidedEffects' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, ProvidedEffectsTags) == 0x000330, "Member 'UTedEntityDefinitionAsset::ProvidedEffectsTags' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, EffectsAppliedToAttackers) == 0x000350, "Member 'UTedEntityDefinitionAsset::EffectsAppliedToAttackers' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, SkirmishAICombatValue) == 0x000360, "Member 'UTedEntityDefinitionAsset::SkirmishAICombatValue' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, bCanGainExperience) == 0x000370, "Member 'UTedEntityDefinitionAsset::bCanGainExperience' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, InitialVeterancyLevel) == 0x000371, "Member 'UTedEntityDefinitionAsset::InitialVeterancyLevel' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, TrainedVeterancyLevel) == 0x000372, "Member 'UTedEntityDefinitionAsset::TrainedVeterancyLevel' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, bExplicitExperienceToNextLevel) == 0x000373, "Member 'UTedEntityDefinitionAsset::bExplicitExperienceToNextLevel' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, ExperienceToNextLevel) == 0x000374, "Member 'UTedEntityDefinitionAsset::ExperienceToNextLevel' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, ExperienceGainSpeedMod) == 0x000378, "Member 'UTedEntityDefinitionAsset::ExperienceGainSpeedMod' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, VeterancyBuffs) == 0x000380, "Member 'UTedEntityDefinitionAsset::VeterancyBuffs' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, SelectionPriority) == 0x0003D0, "Member 'UTedEntityDefinitionAsset::SelectionPriority' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, bIgnoreForSelectAllCombatUnits) == 0x0003D4, "Member 'UTedEntityDefinitionAsset::bIgnoreForSelectAllCombatUnits' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, SupportedCommands) == 0x0003D8, "Member 'UTedEntityDefinitionAsset::SupportedCommands' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, CommandBehaviorOverrides) == 0x0003E8, "Member 'UTedEntityDefinitionAsset::CommandBehaviorOverrides' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, CommandSounds) == 0x000438, "Member 'UTedEntityDefinitionAsset::CommandSounds' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, AbilitySet) == 0x000488, "Member 'UTedEntityDefinitionAsset::AbilitySet' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, bHasBehavior) == 0x000498, "Member 'UTedEntityDefinitionAsset::bHasBehavior' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, IdleBehaviorAsset) == 0x0004A0, "Member 'UTedEntityDefinitionAsset::IdleBehaviorAsset' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, BaseBehaviorAssetOverride) == 0x0004C8, "Member 'UTedEntityDefinitionAsset::BaseBehaviorAssetOverride' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, BlackboardAssetOverride) == 0x0004F0, "Member 'UTedEntityDefinitionAsset::BlackboardAssetOverride' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, DefaultUtilityBehaviors) == 0x0004F8, "Member 'UTedEntityDefinitionAsset::DefaultUtilityBehaviors' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, DisplayName) == 0x000548, "Member 'UTedEntityDefinitionAsset::DisplayName' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, Description) == 0x000558, "Member 'UTedEntityDefinitionAsset::Description' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, Icon) == 0x0005B8, "Member 'UTedEntityDefinitionAsset::Icon' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, PassivieAbilityDefinitions) == 0x0005C0, "Member 'UTedEntityDefinitionAsset::PassivieAbilityDefinitions' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, EntityTypePassivieAbilityDefinition) == 0x0005D0, "Member 'UTedEntityDefinitionAsset::EntityTypePassivieAbilityDefinition' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, ScoreScreenConfig) == 0x0005D8, "Member 'UTedEntityDefinitionAsset::ScoreScreenConfig' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, TelemetrySettings) == 0x000638, "Member 'UTedEntityDefinitionAsset::TelemetrySettings' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, bStatusBarOverrides) == 0x00063A, "Member 'UTedEntityDefinitionAsset::bStatusBarOverrides' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, StatusBarOverrides) == 0x000640, "Member 'UTedEntityDefinitionAsset::StatusBarOverrides' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, BarWidthOverride) == 0x000690, "Member 'UTedEntityDefinitionAsset::BarWidthOverride' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, SupportedBars) == 0x000698, "Member 'UTedEntityDefinitionAsset::SupportedBars' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, UnsupportedBars) == 0x0006A8, "Member 'UTedEntityDefinitionAsset::UnsupportedBars' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, DelayedDestroyLifespan) == 0x0006B8, "Member 'UTedEntityDefinitionAsset::DelayedDestroyLifespan' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, bHideOnDelayedDestroy) == 0x0006BC, "Member 'UTedEntityDefinitionAsset::bHideOnDelayedDestroy' has a wrong offset!");
static_assert(offsetof(UTedEntityDefinitionAsset, SkinConfig) == 0x0006C0, "Member 'UTedEntityDefinitionAsset::SkinConfig' has a wrong offset!");

// Class Tempest.TedEngine
// 0x0000 (0x10F8 - 0x10F8)
class UTedEngine final : public UGameEngine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedEngine">();
	}
	static class UTedEngine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedEngine>();
	}
};
static_assert(alignof(UTedEngine) == 0x000008, "Wrong alignment on UTedEngine");
static_assert(sizeof(UTedEngine) == 0x0010F8, "Wrong size on UTedEngine");

// Class Tempest.AIRoute
// 0x0018 (0x02A8 - 0x0290)
class AAIRoute final : public AActor
{
public:
	class USceneComponent*                        ActorRootComponent;                                // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        Waypoints;                                         // 0x0298(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	TArray<struct FVector2D> GetWaypoints() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIRoute">();
	}
	static class AAIRoute* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAIRoute>();
	}
};
static_assert(alignof(AAIRoute) == 0x000008, "Wrong alignment on AAIRoute");
static_assert(sizeof(AAIRoute) == 0x0002A8, "Wrong size on AAIRoute");
static_assert(offsetof(AAIRoute, ActorRootComponent) == 0x000290, "Member 'AAIRoute::ActorRootComponent' has a wrong offset!");
static_assert(offsetof(AAIRoute, Waypoints) == 0x000298, "Member 'AAIRoute::Waypoints' has a wrong offset!");

// Class Tempest.AISplineRoute
// 0x0010 (0x02A0 - 0x0290)
class AAISplineRoute final : public AActor
{
public:
	class USceneComponent*                        ActorRootComponent;                                // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAISplineRouteComponent*                SplineComponent;                                   // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	TArray<struct FVector> GetWaypoints() const;
	TArray<struct FVector2D> GetWaypoints2D() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISplineRoute">();
	}
	static class AAISplineRoute* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAISplineRoute>();
	}
};
static_assert(alignof(AAISplineRoute) == 0x000008, "Wrong alignment on AAISplineRoute");
static_assert(sizeof(AAISplineRoute) == 0x0002A0, "Wrong size on AAISplineRoute");
static_assert(offsetof(AAISplineRoute, ActorRootComponent) == 0x000290, "Member 'AAISplineRoute::ActorRootComponent' has a wrong offset!");
static_assert(offsetof(AAISplineRoute, SplineComponent) == 0x000298, "Member 'AAISplineRoute::SplineComponent' has a wrong offset!");

// Class Tempest.TedFoWHighlightPawn
// 0x0050 (0x02E0 - 0x0290)
class ATedFoWHighlightPawn final : public AActor
{
public:
	uint8                                         Pad_290[0x10];                                     // 0x0290(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ATedPawn*                               ParentPawn;                                        // 0x02A0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPoseableMeshComponent*                 SkeletalMesh;                                      // 0x02A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   StaticMesh;                                        // 0x02B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       MIDs;                                              // 0x02B8(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     FoWHighlightMaterial;                              // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D0[0x10];                                     // 0x02D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedFoWHighlightPawn">();
	}
	static class ATedFoWHighlightPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedFoWHighlightPawn>();
	}
};
static_assert(alignof(ATedFoWHighlightPawn) == 0x000008, "Wrong alignment on ATedFoWHighlightPawn");
static_assert(sizeof(ATedFoWHighlightPawn) == 0x0002E0, "Wrong size on ATedFoWHighlightPawn");
static_assert(offsetof(ATedFoWHighlightPawn, ParentPawn) == 0x0002A0, "Member 'ATedFoWHighlightPawn::ParentPawn' has a wrong offset!");
static_assert(offsetof(ATedFoWHighlightPawn, SkeletalMesh) == 0x0002A8, "Member 'ATedFoWHighlightPawn::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(ATedFoWHighlightPawn, StaticMesh) == 0x0002B0, "Member 'ATedFoWHighlightPawn::StaticMesh' has a wrong offset!");
static_assert(offsetof(ATedFoWHighlightPawn, MIDs) == 0x0002B8, "Member 'ATedFoWHighlightPawn::MIDs' has a wrong offset!");
static_assert(offsetof(ATedFoWHighlightPawn, FoWHighlightMaterial) == 0x0002C8, "Member 'ATedFoWHighlightPawn::FoWHighlightMaterial' has a wrong offset!");

// Class Tempest.AISplineRouteComponent
// 0x0000 (0x0630 - 0x0630)
class UAISplineRouteComponent final : public USplineComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISplineRouteComponent">();
	}
	static class UAISplineRouteComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISplineRouteComponent>();
	}
};
static_assert(alignof(UAISplineRouteComponent) == 0x000010, "Wrong alignment on UAISplineRouteComponent");
static_assert(sizeof(UAISplineRouteComponent) == 0x000630, "Wrong size on UAISplineRouteComponent");

// Class Tempest.TedTooltipWidget
// 0x00A0 (0x04A0 - 0x0400)
class UTedTooltipWidget : public UTedUserWidget
{
public:
	uint8                                         bSyncDescriptionWrappingWithRoot : 1;              // 0x0400(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_401[0x7];                                      // 0x0401(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedShortcutsPanel*                     ShortcutsPanel;                                    // 0x0408(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                ControlsHintWidget;                                // 0x0410(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_Description;                             // 0x0418(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               Root_SizeBox;                                      // 0x0420(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                TargetWidget;                                      // 0x0428(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTedTooltipDisplayParams               DesiredDisplayParams;                              // 0x0430(0x0070)(BlueprintVisible, BlueprintReadOnly, Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnTooltipHidden();
	void OnTooltipShown();

	class UWidget* GetTargetWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedTooltipWidget">();
	}
	static class UTedTooltipWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedTooltipWidget>();
	}
};
static_assert(alignof(UTedTooltipWidget) == 0x000008, "Wrong alignment on UTedTooltipWidget");
static_assert(sizeof(UTedTooltipWidget) == 0x0004A0, "Wrong size on UTedTooltipWidget");
static_assert(offsetof(UTedTooltipWidget, ShortcutsPanel) == 0x000408, "Member 'UTedTooltipWidget::ShortcutsPanel' has a wrong offset!");
static_assert(offsetof(UTedTooltipWidget, ControlsHintWidget) == 0x000410, "Member 'UTedTooltipWidget::ControlsHintWidget' has a wrong offset!");
static_assert(offsetof(UTedTooltipWidget, TextBlock_Description) == 0x000418, "Member 'UTedTooltipWidget::TextBlock_Description' has a wrong offset!");
static_assert(offsetof(UTedTooltipWidget, Root_SizeBox) == 0x000420, "Member 'UTedTooltipWidget::Root_SizeBox' has a wrong offset!");
static_assert(offsetof(UTedTooltipWidget, TargetWidget) == 0x000428, "Member 'UTedTooltipWidget::TargetWidget' has a wrong offset!");
static_assert(offsetof(UTedTooltipWidget, DesiredDisplayParams) == 0x000430, "Member 'UTedTooltipWidget::DesiredDisplayParams' has a wrong offset!");

// Class Tempest.TedSelectionDetails_InfoSlots_Tooltip_Defense
// 0x0020 (0x04C0 - 0x04A0)
class UTedSelectionDetails_InfoSlots_Tooltip_Defense : public UTedTooltipWidget
{
public:
	class ATedPawn*                               TargetPawn;                                        // 0x04A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedPassiveAbilityPanel*                PassiveAbilities;                                  // 0x04A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                PassiveAbilities_Separator;                        // 0x04B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedAttributePanel*                     Resistances;                                       // 0x04B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetTargetPawn(class ATedPawn* InPawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSelectionDetails_InfoSlots_Tooltip_Defense">();
	}
	static class UTedSelectionDetails_InfoSlots_Tooltip_Defense* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSelectionDetails_InfoSlots_Tooltip_Defense>();
	}
};
static_assert(alignof(UTedSelectionDetails_InfoSlots_Tooltip_Defense) == 0x000008, "Wrong alignment on UTedSelectionDetails_InfoSlots_Tooltip_Defense");
static_assert(sizeof(UTedSelectionDetails_InfoSlots_Tooltip_Defense) == 0x0004C0, "Wrong size on UTedSelectionDetails_InfoSlots_Tooltip_Defense");
static_assert(offsetof(UTedSelectionDetails_InfoSlots_Tooltip_Defense, TargetPawn) == 0x0004A0, "Member 'UTedSelectionDetails_InfoSlots_Tooltip_Defense::TargetPawn' has a wrong offset!");
static_assert(offsetof(UTedSelectionDetails_InfoSlots_Tooltip_Defense, PassiveAbilities) == 0x0004A8, "Member 'UTedSelectionDetails_InfoSlots_Tooltip_Defense::PassiveAbilities' has a wrong offset!");
static_assert(offsetof(UTedSelectionDetails_InfoSlots_Tooltip_Defense, PassiveAbilities_Separator) == 0x0004B0, "Member 'UTedSelectionDetails_InfoSlots_Tooltip_Defense::PassiveAbilities_Separator' has a wrong offset!");
static_assert(offsetof(UTedSelectionDetails_InfoSlots_Tooltip_Defense, Resistances) == 0x0004B8, "Member 'UTedSelectionDetails_InfoSlots_Tooltip_Defense::Resistances' has a wrong offset!");

// Class Tempest.AISquad
// 0x0118 (0x0140 - 0x0028)
class UAISquad final : public UObject
{
public:
	struct FAISquadHandle                         SquadHandle;                                       // 0x0028(0x0004)(SaveGame, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C[0xC];                                       // 0x002C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAIMicroManager*>                MicroManagers;                                     // 0x0038(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FString                                 SquadName;                                         // 0x0048(0x0010)(ZeroConstructor, SaveGame, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Priority;                                          // 0x0058(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class ATedPawn*>                         Pawns;                                             // 0x0060(0x0050)(SaveGame, Protected, NativeAccessSpecifierProtected)
	struct FAISquadOrder                          Order;                                             // 0x00B0(0x0058)(SaveGame, Protected, NativeAccessSpecifierProtected)
	bool                                          bLocked;                                           // 0x0108(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReady;                                            // 0x0109(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSquadWiped;                                       // 0x010A(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10B[0x35];                                     // 0x010B(0x0035)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISquad">();
	}
	static class UAISquad* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISquad>();
	}
};
static_assert(alignof(UAISquad) == 0x000008, "Wrong alignment on UAISquad");
static_assert(sizeof(UAISquad) == 0x000140, "Wrong size on UAISquad");
static_assert(offsetof(UAISquad, SquadHandle) == 0x000028, "Member 'UAISquad::SquadHandle' has a wrong offset!");
static_assert(offsetof(UAISquad, MicroManagers) == 0x000038, "Member 'UAISquad::MicroManagers' has a wrong offset!");
static_assert(offsetof(UAISquad, SquadName) == 0x000048, "Member 'UAISquad::SquadName' has a wrong offset!");
static_assert(offsetof(UAISquad, Priority) == 0x000058, "Member 'UAISquad::Priority' has a wrong offset!");
static_assert(offsetof(UAISquad, Pawns) == 0x000060, "Member 'UAISquad::Pawns' has a wrong offset!");
static_assert(offsetof(UAISquad, Order) == 0x0000B0, "Member 'UAISquad::Order' has a wrong offset!");
static_assert(offsetof(UAISquad, bLocked) == 0x000108, "Member 'UAISquad::bLocked' has a wrong offset!");
static_assert(offsetof(UAISquad, bReady) == 0x000109, "Member 'UAISquad::bReady' has a wrong offset!");
static_assert(offsetof(UAISquad, bSquadWiped) == 0x00010A, "Member 'UAISquad::bSquadWiped' has a wrong offset!");

// Class Tempest.TedEquipmentSlotTooltip
// 0x0018 (0x04B8 - 0x04A0)
class UTedEquipmentSlotTooltip final : public UTedTooltipWidget
{
public:
	class UTextBlock*                             Text_Title;                                        // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Description;                                  // 0x04A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedContentPanelInstanced*              Panel_ExtendedDescriptions;                        // 0x04B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class FText GetDescription() const;
	const class UTedEquipmentSlot* GetEquipmentSlot() const;
	class UTexture2D* GetIcon() const;
	int32 GetInventorySpaceCost() const;
	int32 GetRequisitionCost() const;
	const class FText GetTitle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedEquipmentSlotTooltip">();
	}
	static class UTedEquipmentSlotTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedEquipmentSlotTooltip>();
	}
};
static_assert(alignof(UTedEquipmentSlotTooltip) == 0x000008, "Wrong alignment on UTedEquipmentSlotTooltip");
static_assert(sizeof(UTedEquipmentSlotTooltip) == 0x0004B8, "Wrong size on UTedEquipmentSlotTooltip");
static_assert(offsetof(UTedEquipmentSlotTooltip, Text_Title) == 0x0004A0, "Member 'UTedEquipmentSlotTooltip::Text_Title' has a wrong offset!");
static_assert(offsetof(UTedEquipmentSlotTooltip, Text_Description) == 0x0004A8, "Member 'UTedEquipmentSlotTooltip::Text_Description' has a wrong offset!");
static_assert(offsetof(UTedEquipmentSlotTooltip, Panel_ExtendedDescriptions) == 0x0004B0, "Member 'UTedEquipmentSlotTooltip::Panel_ExtendedDescriptions' has a wrong offset!");

// Class Tempest.AISquadOrderType
// 0x0000 (0x0028 - 0x0028)
class UAISquadOrderType : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISquadOrderType">();
	}
	static class UAISquadOrderType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISquadOrderType>();
	}
};
static_assert(alignof(UAISquadOrderType) == 0x000008, "Wrong alignment on UAISquadOrderType");
static_assert(sizeof(UAISquadOrderType) == 0x000028, "Wrong size on UAISquadOrderType");

// Class Tempest.AISquadOrderType_Idle
// 0x0000 (0x0028 - 0x0028)
class UAISquadOrderType_Idle final : public UAISquadOrderType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISquadOrderType_Idle">();
	}
	static class UAISquadOrderType_Idle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISquadOrderType_Idle>();
	}
};
static_assert(alignof(UAISquadOrderType_Idle) == 0x000008, "Wrong alignment on UAISquadOrderType_Idle");
static_assert(sizeof(UAISquadOrderType_Idle) == 0x000028, "Wrong size on UAISquadOrderType_Idle");

// Class Tempest.TedEncyclopediaSubsystem
// 0x0018 (0x0048 - 0x0030)
class UTedEncyclopediaSubsystem final : public UWorldSubsystem
{
public:
	TArray<class UTedEncyclopediaDefinitionAsset*> SeenAssets;                                       // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bAllAssetUnlocked;                                 // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AllAssetsUnlocked();
	EEncyclopediaAssetStatus GetAssetStatus(class UTedEncyclopediaDefinitionAsset* Asset);
	bool IsUnLocked(class UTedEncyclopediaDefinitionAsset* Asset);
	void MarkAsRead(class UTedEncyclopediaDefinitionAsset* NewAsset);
	void UnlockAllAssets();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedEncyclopediaSubsystem">();
	}
	static class UTedEncyclopediaSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedEncyclopediaSubsystem>();
	}
};
static_assert(alignof(UTedEncyclopediaSubsystem) == 0x000008, "Wrong alignment on UTedEncyclopediaSubsystem");
static_assert(sizeof(UTedEncyclopediaSubsystem) == 0x000048, "Wrong size on UTedEncyclopediaSubsystem");
static_assert(offsetof(UTedEncyclopediaSubsystem, SeenAssets) == 0x000030, "Member 'UTedEncyclopediaSubsystem::SeenAssets' has a wrong offset!");
static_assert(offsetof(UTedEncyclopediaSubsystem, bAllAssetUnlocked) == 0x000040, "Member 'UTedEncyclopediaSubsystem::bAllAssetUnlocked' has a wrong offset!");

// Class Tempest.AISquadOrderType_Move
// 0x0000 (0x0028 - 0x0028)
class UAISquadOrderType_Move final : public UAISquadOrderType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISquadOrderType_Move">();
	}
	static class UAISquadOrderType_Move* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISquadOrderType_Move>();
	}
};
static_assert(alignof(UAISquadOrderType_Move) == 0x000008, "Wrong alignment on UAISquadOrderType_Move");
static_assert(sizeof(UAISquadOrderType_Move) == 0x000028, "Wrong size on UAISquadOrderType_Move");

// Class Tempest.TedContentPanelStatic
// 0x0018 (0x0758 - 0x0740)
class UTedContentPanelStatic : public UTedContentPanelBase
{
public:
	TMulticastInlineDelegate<void(class UTedContentPanelStatic* InContentPanel, class UObject* InPrevContext, class UObject* InNewContext)> OnContextChange; // 0x0740(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UObject*                                RuntimeContext;                                    // 0x0750(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetRuntimeContext(class UObject* InContext);

	class UObject* GetRuntimeContext() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedContentPanelStatic">();
	}
	static class UTedContentPanelStatic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedContentPanelStatic>();
	}
};
static_assert(alignof(UTedContentPanelStatic) == 0x000008, "Wrong alignment on UTedContentPanelStatic");
static_assert(sizeof(UTedContentPanelStatic) == 0x000758, "Wrong size on UTedContentPanelStatic");
static_assert(offsetof(UTedContentPanelStatic, OnContextChange) == 0x000740, "Member 'UTedContentPanelStatic::OnContextChange' has a wrong offset!");
static_assert(offsetof(UTedContentPanelStatic, RuntimeContext) == 0x000750, "Member 'UTedContentPanelStatic::RuntimeContext' has a wrong offset!");

// Class Tempest.TedSettingsPanel
// 0x0008 (0x0760 - 0x0758)
class UTedSettingsPanel : public UTedContentPanelStatic
{
public:
	class UTedSettingsSlotClasses*                SupportedSlotClasses;                              // 0x0758(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSettingsPanel">();
	}
	static class UTedSettingsPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSettingsPanel>();
	}
};
static_assert(alignof(UTedSettingsPanel) == 0x000008, "Wrong alignment on UTedSettingsPanel");
static_assert(sizeof(UTedSettingsPanel) == 0x000760, "Wrong size on UTedSettingsPanel");
static_assert(offsetof(UTedSettingsPanel, SupportedSlotClasses) == 0x000758, "Member 'UTedSettingsPanel::SupportedSlotClasses' has a wrong offset!");

// Class Tempest.AISquadOrderType_Attack
// 0x0000 (0x0028 - 0x0028)
class UAISquadOrderType_Attack final : public UAISquadOrderType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISquadOrderType_Attack">();
	}
	static class UAISquadOrderType_Attack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISquadOrderType_Attack>();
	}
};
static_assert(alignof(UAISquadOrderType_Attack) == 0x000008, "Wrong alignment on UAISquadOrderType_Attack");
static_assert(sizeof(UAISquadOrderType_Attack) == 0x000028, "Wrong size on UAISquadOrderType_Attack");

// Class Tempest.TedFogOfWarManager
// 0x0078 (0x02A0 - 0x0228)
class UTedFogOfWarManager : public UFogOfWarManager
{
public:
	TSoftClassPtr<class UClass>                   FoWAgentActorClass;                                // 0x0228(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FFoWAgentHandle, TWeakObjectPtr<class ATedFogOfWarAgentActor>> CachedFoWAgents;      // 0x0250(0x0050)(Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static void DisableFogOfWarReveal(const class UObject* WorldContextObject, const struct FFoWAgentHandle& InFoWAgentHandle);
	static struct FFoWAgentHandle RevealFogOfWar(const class UObject* WorldContextObject, const float RevealRadius, const float VisionRadius, const uint8 ChannelId, const float RevealTime, const struct FVector& Location, class AActor* TargetActor);

	void OnAttachActorDied(class AActor* InActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedFogOfWarManager">();
	}
	static class UTedFogOfWarManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedFogOfWarManager>();
	}
};
static_assert(alignof(UTedFogOfWarManager) == 0x000008, "Wrong alignment on UTedFogOfWarManager");
static_assert(sizeof(UTedFogOfWarManager) == 0x0002A0, "Wrong size on UTedFogOfWarManager");
static_assert(offsetof(UTedFogOfWarManager, FoWAgentActorClass) == 0x000228, "Member 'UTedFogOfWarManager::FoWAgentActorClass' has a wrong offset!");
static_assert(offsetof(UTedFogOfWarManager, CachedFoWAgents) == 0x000250, "Member 'UTedFogOfWarManager::CachedFoWAgents' has a wrong offset!");

// Class Tempest.AISquadOrderType_Defend
// 0x0000 (0x0028 - 0x0028)
class UAISquadOrderType_Defend final : public UAISquadOrderType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISquadOrderType_Defend">();
	}
	static class UAISquadOrderType_Defend* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISquadOrderType_Defend>();
	}
};
static_assert(alignof(UAISquadOrderType_Defend) == 0x000008, "Wrong alignment on UAISquadOrderType_Defend");
static_assert(sizeof(UAISquadOrderType_Defend) == 0x000028, "Wrong size on UAISquadOrderType_Defend");

// Class Tempest.AISquadOrderType_CaptureStructure
// 0x0000 (0x0028 - 0x0028)
class UAISquadOrderType_CaptureStructure final : public UAISquadOrderType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISquadOrderType_CaptureStructure">();
	}
	static class UAISquadOrderType_CaptureStructure* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISquadOrderType_CaptureStructure>();
	}
};
static_assert(alignof(UAISquadOrderType_CaptureStructure) == 0x000008, "Wrong alignment on UAISquadOrderType_CaptureStructure");
static_assert(sizeof(UAISquadOrderType_CaptureStructure) == 0x000028, "Wrong size on UAISquadOrderType_CaptureStructure");

// Class Tempest.TedGameModeBase
// 0x0050 (0x03C0 - 0x0370)
class ATedGameModeBase : public AGameMode
{
public:
	uint8                                         bAutoResetServer : 1;                              // 0x0370(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_371[0x3];                                      // 0x0371(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AutoResetServerSeconds;                            // 0x0374(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AutoResetServerSecondsPostMatch;                   // 0x0378(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InitialAutoResetServerSeconds;                     // 0x037C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AutoResetServerMap;                                // 0x0380(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 AutoResetServerOptions;                            // 0x0388(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           AutoResetServerHandle;                             // 0x0398(0x0008)(Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        MatchEndedTime;                                    // 0x03A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0x18];                                     // 0x03A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GameTestStartCapturingBroadcast(int32 CapturingIndex, const class FString& CaptureName);
	void GameTestStopCapturingBroadcast(int32 CapturingIndex, const class FString& CaptureName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGameModeBase">();
	}
	static class ATedGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedGameModeBase>();
	}
};
static_assert(alignof(ATedGameModeBase) == 0x000008, "Wrong alignment on ATedGameModeBase");
static_assert(sizeof(ATedGameModeBase) == 0x0003C0, "Wrong size on ATedGameModeBase");
static_assert(offsetof(ATedGameModeBase, AutoResetServerSeconds) == 0x000374, "Member 'ATedGameModeBase::AutoResetServerSeconds' has a wrong offset!");
static_assert(offsetof(ATedGameModeBase, AutoResetServerSecondsPostMatch) == 0x000378, "Member 'ATedGameModeBase::AutoResetServerSecondsPostMatch' has a wrong offset!");
static_assert(offsetof(ATedGameModeBase, InitialAutoResetServerSeconds) == 0x00037C, "Member 'ATedGameModeBase::InitialAutoResetServerSeconds' has a wrong offset!");
static_assert(offsetof(ATedGameModeBase, AutoResetServerMap) == 0x000380, "Member 'ATedGameModeBase::AutoResetServerMap' has a wrong offset!");
static_assert(offsetof(ATedGameModeBase, AutoResetServerOptions) == 0x000388, "Member 'ATedGameModeBase::AutoResetServerOptions' has a wrong offset!");
static_assert(offsetof(ATedGameModeBase, AutoResetServerHandle) == 0x000398, "Member 'ATedGameModeBase::AutoResetServerHandle' has a wrong offset!");
static_assert(offsetof(ATedGameModeBase, MatchEndedTime) == 0x0003A0, "Member 'ATedGameModeBase::MatchEndedTime' has a wrong offset!");

// Class Tempest.TedGameMode
// 0x0060 (0x0420 - 0x03C0)
class ATedGameMode : public ATedGameModeBase
{
public:
	ETedGameMusicMode                             MusicMode;                                         // 0x03C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C1[0x7];                                      // 0x03C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ATedBotPlayerController>    BotPlayerControllerClass;                          // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSupportGameDifficulty;                            // 0x03D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D1[0x3];                                      // 0x03D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ExpectedHumans;                                    // 0x03D4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ExpectedBots;                                      // 0x03D8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumOnlySpectators;                                 // 0x03DC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumBotsTakingOver;                                 // 0x03E0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         GameDifficultyOverride;                            // 0x03E4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumDefeatedPlayers;                                // 0x03E8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3EC[0x4];                                      // 0x03EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedMapInfo*                            CachedMapInfo;                                     // 0x03F0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bAllowAttitudeBasedColors : 1;                     // 0x03F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3F9[0x17];                                     // 0x03F9(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         CachedSkirmishBotNames;                            // 0x0410(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static ETedGameDifficulty K2_GetGameDifficulty(const class UObject* WorldContextObject);
	static void K2_GetGameDifficultySwitch(const class UObject* WorldContextObject, ETedGameDifficulty* Difficulty);

	bool K2_GetSupportsDifficulty() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGameMode">();
	}
	static class ATedGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedGameMode>();
	}
};
static_assert(alignof(ATedGameMode) == 0x000008, "Wrong alignment on ATedGameMode");
static_assert(sizeof(ATedGameMode) == 0x000420, "Wrong size on ATedGameMode");
static_assert(offsetof(ATedGameMode, MusicMode) == 0x0003C0, "Member 'ATedGameMode::MusicMode' has a wrong offset!");
static_assert(offsetof(ATedGameMode, BotPlayerControllerClass) == 0x0003C8, "Member 'ATedGameMode::BotPlayerControllerClass' has a wrong offset!");
static_assert(offsetof(ATedGameMode, bSupportGameDifficulty) == 0x0003D0, "Member 'ATedGameMode::bSupportGameDifficulty' has a wrong offset!");
static_assert(offsetof(ATedGameMode, ExpectedHumans) == 0x0003D4, "Member 'ATedGameMode::ExpectedHumans' has a wrong offset!");
static_assert(offsetof(ATedGameMode, ExpectedBots) == 0x0003D8, "Member 'ATedGameMode::ExpectedBots' has a wrong offset!");
static_assert(offsetof(ATedGameMode, NumOnlySpectators) == 0x0003DC, "Member 'ATedGameMode::NumOnlySpectators' has a wrong offset!");
static_assert(offsetof(ATedGameMode, NumBotsTakingOver) == 0x0003E0, "Member 'ATedGameMode::NumBotsTakingOver' has a wrong offset!");
static_assert(offsetof(ATedGameMode, GameDifficultyOverride) == 0x0003E4, "Member 'ATedGameMode::GameDifficultyOverride' has a wrong offset!");
static_assert(offsetof(ATedGameMode, NumDefeatedPlayers) == 0x0003E8, "Member 'ATedGameMode::NumDefeatedPlayers' has a wrong offset!");
static_assert(offsetof(ATedGameMode, CachedMapInfo) == 0x0003F0, "Member 'ATedGameMode::CachedMapInfo' has a wrong offset!");
static_assert(offsetof(ATedGameMode, CachedSkirmishBotNames) == 0x000410, "Member 'ATedGameMode::CachedSkirmishBotNames' has a wrong offset!");

// Class Tempest.BTDecorator_CanCrush
// 0x0008 (0x0098 - 0x0090)
class UBTDecorator_CanCrush final : public UBTDecorator_BlackboardBase
{
public:
	bool                                          bRequireHostility;                                 // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_CanCrush">();
	}
	static class UBTDecorator_CanCrush* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_CanCrush>();
	}
};
static_assert(alignof(UBTDecorator_CanCrush) == 0x000008, "Wrong alignment on UBTDecorator_CanCrush");
static_assert(sizeof(UBTDecorator_CanCrush) == 0x000098, "Wrong size on UBTDecorator_CanCrush");
static_assert(offsetof(UBTDecorator_CanCrush, bRequireHostility) == 0x000090, "Member 'UBTDecorator_CanCrush::bRequireHostility' has a wrong offset!");

// Class Tempest.TedUnitCommand_MoveAlongSpline
// 0x0000 (0x0540 - 0x0540)
class UTedUnitCommand_MoveAlongSpline : public UTedPawnCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitCommand_MoveAlongSpline">();
	}
	static class UTedUnitCommand_MoveAlongSpline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUnitCommand_MoveAlongSpline>();
	}
};
static_assert(alignof(UTedUnitCommand_MoveAlongSpline) == 0x000008, "Wrong alignment on UTedUnitCommand_MoveAlongSpline");
static_assert(sizeof(UTedUnitCommand_MoveAlongSpline) == 0x000540, "Wrong size on UTedUnitCommand_MoveAlongSpline");

// Class Tempest.BTDecorator_CompareValue
// 0x0040 (0x00D0 - 0x0090)
class UBTDecorator_CompareValue final : public UBTDecorator_BlackboardBase
{
public:
	uint8                                         bExplicitTestValue : 1;                            // 0x0090(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 TestValueKey;                                      // 0x0098(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         TestValueKeyMultiplier;                            // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TestValue;                                         // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EComparison                                   TestMethod;                                        // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_CompareValue">();
	}
	static class UBTDecorator_CompareValue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_CompareValue>();
	}
};
static_assert(alignof(UBTDecorator_CompareValue) == 0x000008, "Wrong alignment on UBTDecorator_CompareValue");
static_assert(sizeof(UBTDecorator_CompareValue) == 0x0000D0, "Wrong size on UBTDecorator_CompareValue");
static_assert(offsetof(UBTDecorator_CompareValue, TestValueKey) == 0x000098, "Member 'UBTDecorator_CompareValue::TestValueKey' has a wrong offset!");
static_assert(offsetof(UBTDecorator_CompareValue, TestValueKeyMultiplier) == 0x0000C0, "Member 'UBTDecorator_CompareValue::TestValueKeyMultiplier' has a wrong offset!");
static_assert(offsetof(UBTDecorator_CompareValue, TestValue) == 0x0000C4, "Member 'UBTDecorator_CompareValue::TestValue' has a wrong offset!");
static_assert(offsetof(UBTDecorator_CompareValue, TestMethod) == 0x0000C8, "Member 'UBTDecorator_CompareValue::TestMethod' has a wrong offset!");

// Class Tempest.TedGameCreationPlayersPanel
// 0x00D0 (0x0880 - 0x07B0)
class UTedGameCreationPlayersPanel final : public UTedContentPanelDynamic
{
public:
	TMulticastInlineDelegate<void(class UTedGameCreationPlayersPanel* InPlayersPanel, const int32 InContentSlotIndex, const ETedSessionMemberSettingKey InKey, const int32 InNewValue, const int32 InOldValue)> OnPlayerSettingChange; // 0x07B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTedGameCreationPlayersPanel* InPlayersPanel)> OnRequestAddHumanPlayer; // 0x07C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D0[0x10];                                     // 0x07D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UTedGameCreationPlayersPanel* InPlayersPanel)> OnRequestAddBotPlayer; // 0x07E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTedGameCreationPlayersPanel* InPlayersPanel, const int32 InSlotIndex)> OnRequestRemovePlayer; // 0x07F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_800[0x50];                                     // 0x0800(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bTeamRelevant : 1;                                 // 0x0850(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	ETedTeamID                                    Team;                                              // 0x0851(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_852[0x6];                                      // 0x0852(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TitleOverride;                                     // 0x0858(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)
	class UWidget*                                TextWidget_Title;                                  // 0x0868(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTedGameCreationTeam                   content;                                           // 0x0870(0x0010)(Edit, Transient, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	void AddContent(const struct FTedGameCreationPlayer& InContent, const bool bInSkipRefresContent);
	void ClearTitleOverride();
	void InsertContent(const int32 InSlotIndex, const struct FTedGameCreationPlayer& InContent, const bool bInSkipRefresContent);
	void OverrideTitle(const class FText& InTitle);
	void RegenPreviewTeam();
	bool RemoveContent(const int32 InSlotIndex, const bool bInSkipRefresContent);
	void RequestAddBotPlayer();
	void RequestAddHumanPlayer();
	void RequestRemovePlayer(const int32 InSlotIndex);
	void SetContent(const struct FTedGameCreationTeam& InContent, const bool bInSkipRefresContent);
	void SetContentInSlot(const int32 InSlotIndex, const struct FTedGameCreationPlayer& InContent);
	void SetLabel(const int32 InSlotIndex, const class FText& InLabel);
	void UpdateTitle();

	bool CanRequestAddBotPlayer(const int32 InPlayerIndex) const;
	class UTexture2D* GetAvatar(const int32 InSlotIndex) const;
	const struct FTedGameCreationTeam GetContent() const;
	const class FText GetLabel(const int32 InSlotIndex) const;
	bool GetPlayerSettingValue(const int32 InPlayerIndex, const ETedSessionMemberSettingKey InKey, int32* OutValue) const;
	int32 GetPlayersNum() const;
	ETedTeamID GetTeam() const;
	bool HasPlayerSetting(const int32 InPlayerIndex, const ETedSessionMemberSettingKey InKey) const;
	bool IsAdmin(const int32 InPlayerIndex) const;
	bool IsBot(const int32 InSlotIndex) const;
	bool IsEmpty(const int32 InSlotIndex) const;
	bool IsHuman(const int32 InSlotIndex) const;
	bool IsPlayerSettingValueUsed(const ETedSessionMemberSettingKey InKey, const int32 InValue) const;
	bool IsReady(const int32 InSlotIndex) const;
	bool IsTeamRelevant() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGameCreationPlayersPanel">();
	}
	static class UTedGameCreationPlayersPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedGameCreationPlayersPanel>();
	}
};
static_assert(alignof(UTedGameCreationPlayersPanel) == 0x000008, "Wrong alignment on UTedGameCreationPlayersPanel");
static_assert(sizeof(UTedGameCreationPlayersPanel) == 0x000880, "Wrong size on UTedGameCreationPlayersPanel");
static_assert(offsetof(UTedGameCreationPlayersPanel, OnPlayerSettingChange) == 0x0007B0, "Member 'UTedGameCreationPlayersPanel::OnPlayerSettingChange' has a wrong offset!");
static_assert(offsetof(UTedGameCreationPlayersPanel, OnRequestAddHumanPlayer) == 0x0007C0, "Member 'UTedGameCreationPlayersPanel::OnRequestAddHumanPlayer' has a wrong offset!");
static_assert(offsetof(UTedGameCreationPlayersPanel, OnRequestAddBotPlayer) == 0x0007E0, "Member 'UTedGameCreationPlayersPanel::OnRequestAddBotPlayer' has a wrong offset!");
static_assert(offsetof(UTedGameCreationPlayersPanel, OnRequestRemovePlayer) == 0x0007F0, "Member 'UTedGameCreationPlayersPanel::OnRequestRemovePlayer' has a wrong offset!");
static_assert(offsetof(UTedGameCreationPlayersPanel, Team) == 0x000851, "Member 'UTedGameCreationPlayersPanel::Team' has a wrong offset!");
static_assert(offsetof(UTedGameCreationPlayersPanel, TitleOverride) == 0x000858, "Member 'UTedGameCreationPlayersPanel::TitleOverride' has a wrong offset!");
static_assert(offsetof(UTedGameCreationPlayersPanel, TextWidget_Title) == 0x000868, "Member 'UTedGameCreationPlayersPanel::TextWidget_Title' has a wrong offset!");
static_assert(offsetof(UTedGameCreationPlayersPanel, content) == 0x000870, "Member 'UTedGameCreationPlayersPanel::content' has a wrong offset!");

// Class Tempest.BTDecorator_DoesOverlapPawn
// 0x0000 (0x0090 - 0x0090)
class UBTDecorator_DoesOverlapPawn final : public UBTDecorator_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_DoesOverlapPawn">();
	}
	static class UBTDecorator_DoesOverlapPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_DoesOverlapPawn>();
	}
};
static_assert(alignof(UBTDecorator_DoesOverlapPawn) == 0x000008, "Wrong alignment on UBTDecorator_DoesOverlapPawn");
static_assert(sizeof(UBTDecorator_DoesOverlapPawn) == 0x000090, "Wrong size on UBTDecorator_DoesOverlapPawn");

// Class Tempest.BTDecorator_HasAmmo
// 0x0008 (0x0070 - 0x0068)
class UBTDecorator_HasAmmo final : public UBTDecorator
{
public:
	ETedWeaponAmmoCheckOptions                    WeaponToCheck;                                     // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCheckForMaxAmmo;                                  // 0x0069(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_HasAmmo">();
	}
	static class UBTDecorator_HasAmmo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_HasAmmo>();
	}
};
static_assert(alignof(UBTDecorator_HasAmmo) == 0x000008, "Wrong alignment on UBTDecorator_HasAmmo");
static_assert(sizeof(UBTDecorator_HasAmmo) == 0x000070, "Wrong size on UBTDecorator_HasAmmo");
static_assert(offsetof(UBTDecorator_HasAmmo, WeaponToCheck) == 0x000068, "Member 'UBTDecorator_HasAmmo::WeaponToCheck' has a wrong offset!");
static_assert(offsetof(UBTDecorator_HasAmmo, bCheckForMaxAmmo) == 0x000069, "Member 'UBTDecorator_HasAmmo::bCheckForMaxAmmo' has a wrong offset!");

// Class Tempest.TedFeatures
// 0x0000 (0x0028 - 0x0028)
class UTedFeatures final : public UBlueprintFunctionLibrary
{
public:
	static bool AreLeaderboardsAvailable();
	static bool DoesPlayerProfileShowEmptyRatingsAndPlacements();
	static bool IsAnyOfGameBranch(const TArray<ETedBranch>& InBranches);
	static bool IsCampaignAvailable();
	static bool IsCampaignMissionSelectAvailable();
	static bool IsCheatMenuAvailable();
	static bool IsCodexAvailable();
	static bool IsCustomMultiplayerAvailable();
	static bool IsFriendsAvailable();
	static bool IsGameBranch(const ETedBranch InBranch);
	static bool IsGlobalBuildQueueAvailable();
	static bool IsMapBanAvailable();
	static bool IsMultiplayerAvailable();
	static bool IsNetworkRequiredToRunGame();
	static bool IsNotAnyOfGameBranch(const TArray<ETedBranch>& InBranches);
	static bool IsNotGameBranch(const ETedBranch InBranch);
	static bool IsPartyAvailable();
	static bool IsPlayerProfileAvailable();
	static bool IsQrCodeAvailable();
	static bool IsRandomFactionAvailable();
	static bool IsRankedMultiplayerAvailable();
	static bool IsReplayAvailable();
	static bool IsSkirmishAvailable();
	static bool IsSpectatorAvailable();
	static bool IsSuperWeaponAvailable();
	static bool IsUnrankedMultiplayerAvailable();
	static bool IsVetiAvailable();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedFeatures">();
	}
	static class UTedFeatures* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedFeatures>();
	}
};
static_assert(alignof(UTedFeatures) == 0x000008, "Wrong alignment on UTedFeatures");
static_assert(sizeof(UTedFeatures) == 0x000028, "Wrong size on UTedFeatures");

// Class Tempest.BTDecorator_HasValidCommandTarget
// 0x0008 (0x0070 - 0x0068)
class UBTDecorator_HasValidCommandTarget final : public UBTDecorator
{
public:
	float                                         TickInterval;                                      // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TickRandomDeviation;                               // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_HasValidCommandTarget">();
	}
	static class UBTDecorator_HasValidCommandTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_HasValidCommandTarget>();
	}
};
static_assert(alignof(UBTDecorator_HasValidCommandTarget) == 0x000008, "Wrong alignment on UBTDecorator_HasValidCommandTarget");
static_assert(sizeof(UBTDecorator_HasValidCommandTarget) == 0x000070, "Wrong size on UBTDecorator_HasValidCommandTarget");
static_assert(offsetof(UBTDecorator_HasValidCommandTarget, TickInterval) == 0x000068, "Member 'UBTDecorator_HasValidCommandTarget::TickInterval' has a wrong offset!");
static_assert(offsetof(UBTDecorator_HasValidCommandTarget, TickRandomDeviation) == 0x00006C, "Member 'UBTDecorator_HasValidCommandTarget::TickRandomDeviation' has a wrong offset!");

// Class Tempest.TedUnitCommand_GuardLocation
// 0x0000 (0x0570 - 0x0570)
class UTedUnitCommand_GuardLocation : public UTedPawnCommandWithBehavior
{
public:
	static struct FGameplayCommandData CreateGuardLocationCommandData(TSubclassOf<class UTedUnitCommand_GuardLocation> CommandClass, const struct FVector& Location, const float Radius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitCommand_GuardLocation">();
	}
	static class UTedUnitCommand_GuardLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUnitCommand_GuardLocation>();
	}
};
static_assert(alignof(UTedUnitCommand_GuardLocation) == 0x000008, "Wrong alignment on UTedUnitCommand_GuardLocation");
static_assert(sizeof(UTedUnitCommand_GuardLocation) == 0x000570, "Wrong size on UTedUnitCommand_GuardLocation");

// Class Tempest.BTDecorator_InAttackChaseRange
// 0x0000 (0x0090 - 0x0090)
class UBTDecorator_InAttackChaseRange final : public UBTDecorator_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_InAttackChaseRange">();
	}
	static class UBTDecorator_InAttackChaseRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_InAttackChaseRange>();
	}
};
static_assert(alignof(UBTDecorator_InAttackChaseRange) == 0x000008, "Wrong alignment on UBTDecorator_InAttackChaseRange");
static_assert(sizeof(UBTDecorator_InAttackChaseRange) == 0x000090, "Wrong size on UBTDecorator_InAttackChaseRange");

// Class Tempest.TedGameInstance
// 0x0030 (0x01F0 - 0x01C0)
class UTedGameInstance final : public UGameInstance
{
public:
	class UDataTable*                             DefaultAttackWavePreset;                           // 0x01C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DefaultDelayPreset;                                // 0x01C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DefaultUnitsSpawnPreset;                           // 0x01D0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D8[0x4];                                      // 0x01D8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActiveResetDelay;                                  // 0x01DC(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E0[0x10];                                     // 0x01E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGameInstance">();
	}
	static class UTedGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedGameInstance>();
	}
};
static_assert(alignof(UTedGameInstance) == 0x000008, "Wrong alignment on UTedGameInstance");
static_assert(sizeof(UTedGameInstance) == 0x0001F0, "Wrong size on UTedGameInstance");
static_assert(offsetof(UTedGameInstance, DefaultAttackWavePreset) == 0x0001C0, "Member 'UTedGameInstance::DefaultAttackWavePreset' has a wrong offset!");
static_assert(offsetof(UTedGameInstance, DefaultDelayPreset) == 0x0001C8, "Member 'UTedGameInstance::DefaultDelayPreset' has a wrong offset!");
static_assert(offsetof(UTedGameInstance, DefaultUnitsSpawnPreset) == 0x0001D0, "Member 'UTedGameInstance::DefaultUnitsSpawnPreset' has a wrong offset!");
static_assert(offsetof(UTedGameInstance, ActiveResetDelay) == 0x0001DC, "Member 'UTedGameInstance::ActiveResetDelay' has a wrong offset!");

// Class Tempest.BTDecorator_InChaseRange
// 0x0008 (0x0098 - 0x0090)
class UBTDecorator_InChaseRange final : public UBTDecorator_BlackboardBase
{
public:
	float                                         RangeTolerance;                                    // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreWithoutLeashLock;                           // 0x0094(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_InChaseRange">();
	}
	static class UBTDecorator_InChaseRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_InChaseRange>();
	}
};
static_assert(alignof(UBTDecorator_InChaseRange) == 0x000008, "Wrong alignment on UBTDecorator_InChaseRange");
static_assert(sizeof(UBTDecorator_InChaseRange) == 0x000098, "Wrong size on UBTDecorator_InChaseRange");
static_assert(offsetof(UBTDecorator_InChaseRange, RangeTolerance) == 0x000090, "Member 'UBTDecorator_InChaseRange::RangeTolerance' has a wrong offset!");
static_assert(offsetof(UBTDecorator_InChaseRange, bIgnoreWithoutLeashLock) == 0x000094, "Member 'UBTDecorator_InChaseRange::bIgnoreWithoutLeashLock' has a wrong offset!");

// Class Tempest.BTDecorator_IsAlive
// 0x0000 (0x0090 - 0x0090)
class UBTDecorator_IsAlive final : public UBTDecorator_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsAlive">();
	}
	static class UBTDecorator_IsAlive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsAlive>();
	}
};
static_assert(alignof(UBTDecorator_IsAlive) == 0x000008, "Wrong alignment on UBTDecorator_IsAlive");
static_assert(sizeof(UBTDecorator_IsAlive) == 0x000090, "Wrong size on UBTDecorator_IsAlive");

// Class Tempest.TedDropDownStyleContainer
// 0x1430 (0x1460 - 0x0030)
class UTedDropDownStyleContainer final : public USlateWidgetStyleContainerBase
{
public:
	struct FTedDropDownStyle                      Style;                                             // 0x0030(0x1430)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedDropDownStyleContainer">();
	}
	static class UTedDropDownStyleContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedDropDownStyleContainer>();
	}
};
static_assert(alignof(UTedDropDownStyleContainer) == 0x000010, "Wrong alignment on UTedDropDownStyleContainer");
static_assert(sizeof(UTedDropDownStyleContainer) == 0x001460, "Wrong size on UTedDropDownStyleContainer");
static_assert(offsetof(UTedDropDownStyleContainer, Style) == 0x000030, "Member 'UTedDropDownStyleContainer::Style' has a wrong offset!");

// Class Tempest.BTDecorator_IsAnyRefineryAround
// 0x0010 (0x0078 - 0x0068)
class UBTDecorator_IsAnyRefineryAround final : public UBTDecorator
{
public:
	float                                         MaxPathLength;                                     // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           QueueStructureEntityTag;                           // 0x006C(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRequireSpecificFaction;                           // 0x0074(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETedFaction                                   QueueStructureFaction;                             // 0x0075(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRequirePowerState;                                // 0x0076(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETedPowerStateFlag                            PowerStateFlag;                                    // 0x0077(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsAnyRefineryAround">();
	}
	static class UBTDecorator_IsAnyRefineryAround* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsAnyRefineryAround>();
	}
};
static_assert(alignof(UBTDecorator_IsAnyRefineryAround) == 0x000008, "Wrong alignment on UBTDecorator_IsAnyRefineryAround");
static_assert(sizeof(UBTDecorator_IsAnyRefineryAround) == 0x000078, "Wrong size on UBTDecorator_IsAnyRefineryAround");
static_assert(offsetof(UBTDecorator_IsAnyRefineryAround, MaxPathLength) == 0x000068, "Member 'UBTDecorator_IsAnyRefineryAround::MaxPathLength' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsAnyRefineryAround, QueueStructureEntityTag) == 0x00006C, "Member 'UBTDecorator_IsAnyRefineryAround::QueueStructureEntityTag' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsAnyRefineryAround, bRequireSpecificFaction) == 0x000074, "Member 'UBTDecorator_IsAnyRefineryAround::bRequireSpecificFaction' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsAnyRefineryAround, QueueStructureFaction) == 0x000075, "Member 'UBTDecorator_IsAnyRefineryAround::QueueStructureFaction' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsAnyRefineryAround, bRequirePowerState) == 0x000076, "Member 'UBTDecorator_IsAnyRefineryAround::bRequirePowerState' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsAnyRefineryAround, PowerStateFlag) == 0x000077, "Member 'UBTDecorator_IsAnyRefineryAround::PowerStateFlag' has a wrong offset!");

// Class Tempest.TedUnitCommand_MoveToFactoryExit
// 0x0000 (0x0540 - 0x0540)
class UTedUnitCommand_MoveToFactoryExit final : public UTedPawnCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitCommand_MoveToFactoryExit">();
	}
	static class UTedUnitCommand_MoveToFactoryExit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUnitCommand_MoveToFactoryExit>();
	}
};
static_assert(alignof(UTedUnitCommand_MoveToFactoryExit) == 0x000008, "Wrong alignment on UTedUnitCommand_MoveToFactoryExit");
static_assert(sizeof(UTedUnitCommand_MoveToFactoryExit) == 0x000540, "Wrong size on UTedUnitCommand_MoveToFactoryExit");

// Class Tempest.BTDecorator_IsCommandQueued
// 0x0010 (0x0078 - 0x0068)
class UBTDecorator_IsCommandQueued final : public UBTDecorator
{
public:
	TSubclassOf<class UGameplayCommand>           CommandToCheck;                                    // 0x0068(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAnyCommandExceptThis;                             // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsCommandQueued">();
	}
	static class UBTDecorator_IsCommandQueued* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsCommandQueued>();
	}
};
static_assert(alignof(UBTDecorator_IsCommandQueued) == 0x000008, "Wrong alignment on UBTDecorator_IsCommandQueued");
static_assert(sizeof(UBTDecorator_IsCommandQueued) == 0x000078, "Wrong size on UBTDecorator_IsCommandQueued");
static_assert(offsetof(UBTDecorator_IsCommandQueued, CommandToCheck) == 0x000068, "Member 'UBTDecorator_IsCommandQueued::CommandToCheck' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsCommandQueued, bAnyCommandExceptThis) == 0x000070, "Member 'UBTDecorator_IsCommandQueued::bAnyCommandExceptThis' has a wrong offset!");

// Class Tempest.TedPawnCommand_AttackBase
// 0x0010 (0x0580 - 0x0570)
class UTedPawnCommand_AttackBase : public UTedPawnCommandWithBehavior
{
public:
	TSubclassOf<class UTedWeapon>                 WeaponClass;                                       // 0x0570(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCheckRequiredRange;                               // 0x0578(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCheckForValidGroundLocation;                      // 0x0579(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_57A[0x6];                                      // 0x057A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommand_AttackBase">();
	}
	static class UTedPawnCommand_AttackBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnCommand_AttackBase>();
	}
};
static_assert(alignof(UTedPawnCommand_AttackBase) == 0x000008, "Wrong alignment on UTedPawnCommand_AttackBase");
static_assert(sizeof(UTedPawnCommand_AttackBase) == 0x000580, "Wrong size on UTedPawnCommand_AttackBase");
static_assert(offsetof(UTedPawnCommand_AttackBase, WeaponClass) == 0x000570, "Member 'UTedPawnCommand_AttackBase::WeaponClass' has a wrong offset!");
static_assert(offsetof(UTedPawnCommand_AttackBase, bCheckRequiredRange) == 0x000578, "Member 'UTedPawnCommand_AttackBase::bCheckRequiredRange' has a wrong offset!");
static_assert(offsetof(UTedPawnCommand_AttackBase, bCheckForValidGroundLocation) == 0x000579, "Member 'UTedPawnCommand_AttackBase::bCheckForValidGroundLocation' has a wrong offset!");

// Class Tempest.TedPawnCommand_Attack
// 0x0000 (0x0580 - 0x0580)
class UTedPawnCommand_Attack : public UTedPawnCommand_AttackBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommand_Attack">();
	}
	static class UTedPawnCommand_Attack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnCommand_Attack>();
	}
};
static_assert(alignof(UTedPawnCommand_Attack) == 0x000008, "Wrong alignment on UTedPawnCommand_Attack");
static_assert(sizeof(UTedPawnCommand_Attack) == 0x000580, "Wrong size on UTedPawnCommand_Attack");

// Class Tempest.BTDecorator_IsValidAirpad
// 0x0000 (0x0090 - 0x0090)
class UBTDecorator_IsValidAirpad final : public UBTDecorator_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsValidAirpad">();
	}
	static class UBTDecorator_IsValidAirpad* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsValidAirpad>();
	}
};
static_assert(alignof(UBTDecorator_IsValidAirpad) == 0x000008, "Wrong alignment on UBTDecorator_IsValidAirpad");
static_assert(sizeof(UBTDecorator_IsValidAirpad) == 0x000090, "Wrong size on UBTDecorator_IsValidAirpad");

// Class Tempest.BTDecorator_IsValidAttackTarget
// 0x0008 (0x0098 - 0x0090)
class UBTDecorator_IsValidAttackTarget final : public UBTDecorator_BlackboardBase
{
public:
	bool                                          bSkipAttitudeCheck;                                // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDoWeaponDistanceCheck;                            // 0x0091(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedWeaponSelection                           WeaponSelection;                                   // 0x0092(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_93[0x5];                                       // 0x0093(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsValidAttackTarget">();
	}
	static class UBTDecorator_IsValidAttackTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsValidAttackTarget>();
	}
};
static_assert(alignof(UBTDecorator_IsValidAttackTarget) == 0x000008, "Wrong alignment on UBTDecorator_IsValidAttackTarget");
static_assert(sizeof(UBTDecorator_IsValidAttackTarget) == 0x000098, "Wrong size on UBTDecorator_IsValidAttackTarget");
static_assert(offsetof(UBTDecorator_IsValidAttackTarget, bSkipAttitudeCheck) == 0x000090, "Member 'UBTDecorator_IsValidAttackTarget::bSkipAttitudeCheck' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsValidAttackTarget, bDoWeaponDistanceCheck) == 0x000091, "Member 'UBTDecorator_IsValidAttackTarget::bDoWeaponDistanceCheck' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsValidAttackTarget, WeaponSelection) == 0x000092, "Member 'UBTDecorator_IsValidAttackTarget::WeaponSelection' has a wrong offset!");

// Class Tempest.TedGameCreationSettingsWidget
// 0x00D8 (0x04D8 - 0x0400)
class UTedGameCreationSettingsWidget final : public UTedUserWidget
{
public:
	TArray<ETedSessionSettingKey>                 AvailableSettings;                                 // 0x0400(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UTedSettingsPanel*                      SettingsPanel;                                     // 0x0410(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<ETedSessionSettingKey, class UTedSettingsSlot*> KeyToSlotMap;                               // 0x0418(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_468[0x70];                                     // 0x0468(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGameCreationSettingsWidget">();
	}
	static class UTedGameCreationSettingsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedGameCreationSettingsWidget>();
	}
};
static_assert(alignof(UTedGameCreationSettingsWidget) == 0x000008, "Wrong alignment on UTedGameCreationSettingsWidget");
static_assert(sizeof(UTedGameCreationSettingsWidget) == 0x0004D8, "Wrong size on UTedGameCreationSettingsWidget");
static_assert(offsetof(UTedGameCreationSettingsWidget, AvailableSettings) == 0x000400, "Member 'UTedGameCreationSettingsWidget::AvailableSettings' has a wrong offset!");
static_assert(offsetof(UTedGameCreationSettingsWidget, SettingsPanel) == 0x000410, "Member 'UTedGameCreationSettingsWidget::SettingsPanel' has a wrong offset!");
static_assert(offsetof(UTedGameCreationSettingsWidget, KeyToSlotMap) == 0x000418, "Member 'UTedGameCreationSettingsWidget::KeyToSlotMap' has a wrong offset!");

// Class Tempest.BTDecorator_IsWell
// 0x0000 (0x0090 - 0x0090)
class UBTDecorator_IsWell final : public UBTDecorator_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsWell">();
	}
	static class UBTDecorator_IsWell* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsWell>();
	}
};
static_assert(alignof(UBTDecorator_IsWell) == 0x000008, "Wrong alignment on UBTDecorator_IsWell");
static_assert(sizeof(UBTDecorator_IsWell) == 0x000090, "Wrong size on UBTDecorator_IsWell");

// Class Tempest.TedUnitMovementReplicationManager
// 0x0130 (0x03C0 - 0x0290)
class ATedUnitMovementReplicationManager final : public AActor
{
public:
	TArray<struct FMoveSnapshotRepHistory>        MoveSnapshotRepHistory;                            // 0x0290(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TArray<class ATedUnitBase*>                   RegisteredUnits;                                   // 0x02A0(0x0010)(Net, ZeroConstructor, Transient, DuplicateTransient, RepNotify, Protected, NativeAccessSpecifierProtected)
	TSet<class ATedUnitBase*>                     ClientAckRegisteredUnits;                          // 0x02B0(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TMap<class ATedUnitBase*, int32>              UnitToIndex;                                       // 0x0300(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0x70];                                     // 0x0350(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_ReceiveMovementSnapshotBatch(const struct FRepMoveSnapshotBatch& MoveSnapshotBatch);
	void OnRep_RegisteredUnits(const TArray<class ATedUnitBase*>& OldValue);
	void Server_ReceiveMovementSnapshotBatchAck(const int32 BatchID);
	void Server_ReceiveUnitRegisteredAck(const TArray<class ATedUnitBase*>& Units);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitMovementReplicationManager">();
	}
	static class ATedUnitMovementReplicationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedUnitMovementReplicationManager>();
	}
};
static_assert(alignof(ATedUnitMovementReplicationManager) == 0x000008, "Wrong alignment on ATedUnitMovementReplicationManager");
static_assert(sizeof(ATedUnitMovementReplicationManager) == 0x0003C0, "Wrong size on ATedUnitMovementReplicationManager");
static_assert(offsetof(ATedUnitMovementReplicationManager, MoveSnapshotRepHistory) == 0x000290, "Member 'ATedUnitMovementReplicationManager::MoveSnapshotRepHistory' has a wrong offset!");
static_assert(offsetof(ATedUnitMovementReplicationManager, RegisteredUnits) == 0x0002A0, "Member 'ATedUnitMovementReplicationManager::RegisteredUnits' has a wrong offset!");
static_assert(offsetof(ATedUnitMovementReplicationManager, ClientAckRegisteredUnits) == 0x0002B0, "Member 'ATedUnitMovementReplicationManager::ClientAckRegisteredUnits' has a wrong offset!");
static_assert(offsetof(ATedUnitMovementReplicationManager, UnitToIndex) == 0x000300, "Member 'ATedUnitMovementReplicationManager::UnitToIndex' has a wrong offset!");

// Class Tempest.BTDecorator_TedIsBBEntryOfClass
// 0x0010 (0x00A0 - 0x0090)
class UBTDecorator_TedIsBBEntryOfClass final : public UBTDecorator_BlackboardBase
{
public:
	TSubclassOf<class UObject>                    TestClass;                                         // 0x0090(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bExactMatch : 1;                                   // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_TedIsBBEntryOfClass">();
	}
	static class UBTDecorator_TedIsBBEntryOfClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_TedIsBBEntryOfClass>();
	}
};
static_assert(alignof(UBTDecorator_TedIsBBEntryOfClass) == 0x000008, "Wrong alignment on UBTDecorator_TedIsBBEntryOfClass");
static_assert(sizeof(UBTDecorator_TedIsBBEntryOfClass) == 0x0000A0, "Wrong size on UBTDecorator_TedIsBBEntryOfClass");
static_assert(offsetof(UBTDecorator_TedIsBBEntryOfClass, TestClass) == 0x000090, "Member 'UBTDecorator_TedIsBBEntryOfClass::TestClass' has a wrong offset!");

// Class Tempest.TedDropDown
// 0x1500 (0x1680 - 0x0180)
class UTedDropDown final : public UWidget
{
public:
	uint8                                         Pad_180[0x60];                                     // 0x0180(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	struct FComboBoxStyle                         WidgetStyle;                                       // 0x01E0(0x0660)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FTableRowStyle                         ItemStyle;                                         // 0x0840(0x0D50)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class FName                                   ArrowMaterialOpenParam;                            // 0x1590(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                ContentPadding;                                    // 0x1598(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         MaxListHeight;                                     // 0x15A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          HasDownArrow;                                      // 0x15AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15AD[0x3];                                     // 0x15AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateFontInfo                         Font;                                              // 0x15B0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateColor                            ForegroundColor;                                   // 0x1610(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1624[0x34];                                    // 0x1624(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SelectedOptionIndex;                               // 0x1658(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_165C[0x24];                                    // 0x165C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AddOption(const int32 InOptionValue);
	void ClearOptions();
	void ClearSelection();
	class UMaterialInstanceDynamic* GetOrCreateArrowMID();
	void RefreshOptions();
	bool RemoveOption(const int32 InOptionValue);
	void SelectOptionByIndex(const int32 InOptionIndex);
	void SelectOptionByValue(const int32 InOptionValue);

	class UMaterialInstanceDynamic* GetArrowMID() const;
	int32 GetOptionIndex(const int32 InOptionValue) const;
	int32 GetOptionsCount() const;
	int32 GetOptionValue(const int32 InOptionIndex) const;
	class FText GetOptionValueText(const int32 InOptionValue) const;
	int32 GetSelectedOptionIndex() const;
	int32 GetSelectedOptionValue() const;
	bool IsOpen() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedDropDown">();
	}
	static class UTedDropDown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedDropDown>();
	}
};
static_assert(alignof(UTedDropDown) == 0x000010, "Wrong alignment on UTedDropDown");
static_assert(sizeof(UTedDropDown) == 0x001680, "Wrong size on UTedDropDown");
static_assert(offsetof(UTedDropDown, WidgetStyle) == 0x0001E0, "Member 'UTedDropDown::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UTedDropDown, ItemStyle) == 0x000840, "Member 'UTedDropDown::ItemStyle' has a wrong offset!");
static_assert(offsetof(UTedDropDown, ArrowMaterialOpenParam) == 0x001590, "Member 'UTedDropDown::ArrowMaterialOpenParam' has a wrong offset!");
static_assert(offsetof(UTedDropDown, ContentPadding) == 0x001598, "Member 'UTedDropDown::ContentPadding' has a wrong offset!");
static_assert(offsetof(UTedDropDown, MaxListHeight) == 0x0015A8, "Member 'UTedDropDown::MaxListHeight' has a wrong offset!");
static_assert(offsetof(UTedDropDown, HasDownArrow) == 0x0015AC, "Member 'UTedDropDown::HasDownArrow' has a wrong offset!");
static_assert(offsetof(UTedDropDown, Font) == 0x0015B0, "Member 'UTedDropDown::Font' has a wrong offset!");
static_assert(offsetof(UTedDropDown, ForegroundColor) == 0x001610, "Member 'UTedDropDown::ForegroundColor' has a wrong offset!");
static_assert(offsetof(UTedDropDown, SelectedOptionIndex) == 0x001658, "Member 'UTedDropDown::SelectedOptionIndex' has a wrong offset!");

// Class Tempest.BTService_BlockCommandBehaviorRestart
// 0x0000 (0x0070 - 0x0070)
class UBTService_BlockCommandBehaviorRestart final : public UBTService
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_BlockCommandBehaviorRestart">();
	}
	static class UBTService_BlockCommandBehaviorRestart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_BlockCommandBehaviorRestart>();
	}
};
static_assert(alignof(UBTService_BlockCommandBehaviorRestart) == 0x000008, "Wrong alignment on UBTService_BlockCommandBehaviorRestart");
static_assert(sizeof(UBTService_BlockCommandBehaviorRestart) == 0x000070, "Wrong size on UBTService_BlockCommandBehaviorRestart");

// Class Tempest.BTService_CacheDistance
// 0x0058 (0x00F0 - 0x0098)
class UBTService_CacheDistance final : public UBTService_BlackboardBase
{
public:
	struct FBlackboardKeySelector                 DistanceKey;                                       // 0x0098(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 PointKey;                                          // 0x00C0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bCheckTargetVisibility;                            // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnorePointKeyRadius;                             // 0x00E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreBlackboardKeyRadius;                        // 0x00EA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EB[0x5];                                       // 0x00EB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_CacheDistance">();
	}
	static class UBTService_CacheDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_CacheDistance>();
	}
};
static_assert(alignof(UBTService_CacheDistance) == 0x000008, "Wrong alignment on UBTService_CacheDistance");
static_assert(sizeof(UBTService_CacheDistance) == 0x0000F0, "Wrong size on UBTService_CacheDistance");
static_assert(offsetof(UBTService_CacheDistance, DistanceKey) == 0x000098, "Member 'UBTService_CacheDistance::DistanceKey' has a wrong offset!");
static_assert(offsetof(UBTService_CacheDistance, PointKey) == 0x0000C0, "Member 'UBTService_CacheDistance::PointKey' has a wrong offset!");
static_assert(offsetof(UBTService_CacheDistance, bCheckTargetVisibility) == 0x0000E8, "Member 'UBTService_CacheDistance::bCheckTargetVisibility' has a wrong offset!");
static_assert(offsetof(UBTService_CacheDistance, bIgnorePointKeyRadius) == 0x0000E9, "Member 'UBTService_CacheDistance::bIgnorePointKeyRadius' has a wrong offset!");
static_assert(offsetof(UBTService_CacheDistance, bIgnoreBlackboardKeyRadius) == 0x0000EA, "Member 'UBTService_CacheDistance::bIgnoreBlackboardKeyRadius' has a wrong offset!");

// Class Tempest.TedSimulatedGameProgress
// 0x0020 (0x0050 - 0x0030)
class UTedSimulatedGameProgress final : public UDataAsset
{
public:
	TArray<struct FTedCampaignProgress>           Data;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTedCampaignInfo*                       CurrentCampaign;                                   // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTedMapInfo*                            CurrentMap;                                        // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSimulatedGameProgress">();
	}
	static class UTedSimulatedGameProgress* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSimulatedGameProgress>();
	}
};
static_assert(alignof(UTedSimulatedGameProgress) == 0x000008, "Wrong alignment on UTedSimulatedGameProgress");
static_assert(sizeof(UTedSimulatedGameProgress) == 0x000050, "Wrong size on UTedSimulatedGameProgress");
static_assert(offsetof(UTedSimulatedGameProgress, Data) == 0x000030, "Member 'UTedSimulatedGameProgress::Data' has a wrong offset!");
static_assert(offsetof(UTedSimulatedGameProgress, CurrentCampaign) == 0x000040, "Member 'UTedSimulatedGameProgress::CurrentCampaign' has a wrong offset!");
static_assert(offsetof(UTedSimulatedGameProgress, CurrentMap) == 0x000048, "Member 'UTedSimulatedGameProgress::CurrentMap' has a wrong offset!");

// Class Tempest.BTService_FindAttackTarget
// 0x0048 (0x00E0 - 0x0098)
class UBTService_FindAttackTarget final : public UBTService_BlackboardBase
{
public:
	bool                                          bExplicitRangeValue;                               // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RangeValue;                                        // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 RangeKey;                                          // 0x00A0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         RangeKeyMultiplier;                                // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedWeaponSelection                           WeaponSelection;                                   // 0x00CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSkipFakeWeapons;                                  // 0x00CD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CE[0x12];                                      // 0x00CE(0x0012)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindAttackTarget">();
	}
	static class UBTService_FindAttackTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindAttackTarget>();
	}
};
static_assert(alignof(UBTService_FindAttackTarget) == 0x000008, "Wrong alignment on UBTService_FindAttackTarget");
static_assert(sizeof(UBTService_FindAttackTarget) == 0x0000E0, "Wrong size on UBTService_FindAttackTarget");
static_assert(offsetof(UBTService_FindAttackTarget, bExplicitRangeValue) == 0x000098, "Member 'UBTService_FindAttackTarget::bExplicitRangeValue' has a wrong offset!");
static_assert(offsetof(UBTService_FindAttackTarget, RangeValue) == 0x00009C, "Member 'UBTService_FindAttackTarget::RangeValue' has a wrong offset!");
static_assert(offsetof(UBTService_FindAttackTarget, RangeKey) == 0x0000A0, "Member 'UBTService_FindAttackTarget::RangeKey' has a wrong offset!");
static_assert(offsetof(UBTService_FindAttackTarget, RangeKeyMultiplier) == 0x0000C8, "Member 'UBTService_FindAttackTarget::RangeKeyMultiplier' has a wrong offset!");
static_assert(offsetof(UBTService_FindAttackTarget, WeaponSelection) == 0x0000CC, "Member 'UBTService_FindAttackTarget::WeaponSelection' has a wrong offset!");
static_assert(offsetof(UBTService_FindAttackTarget, bSkipFakeWeapons) == 0x0000CD, "Member 'UBTService_FindAttackTarget::bSkipFakeWeapons' has a wrong offset!");

// Class Tempest.BTService_FindAttackTarget_Drone
// 0x0028 (0x00C0 - 0x0098)
class UBTService_FindAttackTarget_Drone final : public UBTService_BlackboardBase
{
public:
	struct FBlackboardKeySelector                 DroneOwnerKey;                                     // 0x0098(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindAttackTarget_Drone">();
	}
	static class UBTService_FindAttackTarget_Drone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindAttackTarget_Drone>();
	}
};
static_assert(alignof(UBTService_FindAttackTarget_Drone) == 0x000008, "Wrong alignment on UBTService_FindAttackTarget_Drone");
static_assert(sizeof(UBTService_FindAttackTarget_Drone) == 0x0000C0, "Wrong size on UBTService_FindAttackTarget_Drone");
static_assert(offsetof(UBTService_FindAttackTarget_Drone, DroneOwnerKey) == 0x000098, "Member 'UBTService_FindAttackTarget_Drone::DroneOwnerKey' has a wrong offset!");

// Class Tempest.TedGameplayCueNotify_Actor
// 0x0050 (0x0350 - 0x0300)
class ATedGameplayCueNotify_Actor : public AGameplayCueNotify_Actor
{
public:
	uint8                                         Pad_300[0x50];                                     // 0x0300(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGameplayCueNotify_Actor">();
	}
	static class ATedGameplayCueNotify_Actor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedGameplayCueNotify_Actor>();
	}
};
static_assert(alignof(ATedGameplayCueNotify_Actor) == 0x000008, "Wrong alignment on ATedGameplayCueNotify_Actor");
static_assert(sizeof(ATedGameplayCueNotify_Actor) == 0x000350, "Wrong size on ATedGameplayCueNotify_Actor");

// Class Tempest.TedGameplayCueNotify_HitActor
// 0x0048 (0x0398 - 0x0350)
class ATedGameplayCueNotify_HitActor : public ATedGameplayCueNotify_Actor
{
public:
	class USoundBase*                             Sound;                                             // 0x0350(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGCueParticleConfig>            FXAssetConfigs;                                    // 0x0358(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DecalMaterial;                                     // 0x0368(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecalSize;                                         // 0x0370(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecalFadeOutStartDelay;                            // 0x0374(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecalFadeOutDuration;                              // 0x0378(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecalFadeInDuration;                               // 0x037C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShakeBase>           CameraShakeClass;                                  // 0x0380(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraShakeInnerRadius;                            // 0x0388(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraShakeOuterRadius;                            // 0x038C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraShakeFalloff;                                // 0x0390(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOrientShakeTowardsEpicenter;                      // 0x0394(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_395[0x3];                                      // 0x0395(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnNiagaraFinished(class UNiagaraComponent* ParticleSC);
	void OnParticleFinished(class UParticleSystemComponent* ParticleSC);
	void OnSoundFinished(class UAudioComponent* AudioComp);

	TArray<struct FGCueParticleConfig> K2_GetFXAssetConfigs(const class AActor* TargetActor, const struct FGameplayCueParameters& GCueParams) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGameplayCueNotify_HitActor">();
	}
	static class ATedGameplayCueNotify_HitActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedGameplayCueNotify_HitActor>();
	}
};
static_assert(alignof(ATedGameplayCueNotify_HitActor) == 0x000008, "Wrong alignment on ATedGameplayCueNotify_HitActor");
static_assert(sizeof(ATedGameplayCueNotify_HitActor) == 0x000398, "Wrong size on ATedGameplayCueNotify_HitActor");
static_assert(offsetof(ATedGameplayCueNotify_HitActor, Sound) == 0x000350, "Member 'ATedGameplayCueNotify_HitActor::Sound' has a wrong offset!");
static_assert(offsetof(ATedGameplayCueNotify_HitActor, FXAssetConfigs) == 0x000358, "Member 'ATedGameplayCueNotify_HitActor::FXAssetConfigs' has a wrong offset!");
static_assert(offsetof(ATedGameplayCueNotify_HitActor, DecalMaterial) == 0x000368, "Member 'ATedGameplayCueNotify_HitActor::DecalMaterial' has a wrong offset!");
static_assert(offsetof(ATedGameplayCueNotify_HitActor, DecalSize) == 0x000370, "Member 'ATedGameplayCueNotify_HitActor::DecalSize' has a wrong offset!");
static_assert(offsetof(ATedGameplayCueNotify_HitActor, DecalFadeOutStartDelay) == 0x000374, "Member 'ATedGameplayCueNotify_HitActor::DecalFadeOutStartDelay' has a wrong offset!");
static_assert(offsetof(ATedGameplayCueNotify_HitActor, DecalFadeOutDuration) == 0x000378, "Member 'ATedGameplayCueNotify_HitActor::DecalFadeOutDuration' has a wrong offset!");
static_assert(offsetof(ATedGameplayCueNotify_HitActor, DecalFadeInDuration) == 0x00037C, "Member 'ATedGameplayCueNotify_HitActor::DecalFadeInDuration' has a wrong offset!");
static_assert(offsetof(ATedGameplayCueNotify_HitActor, CameraShakeClass) == 0x000380, "Member 'ATedGameplayCueNotify_HitActor::CameraShakeClass' has a wrong offset!");
static_assert(offsetof(ATedGameplayCueNotify_HitActor, CameraShakeInnerRadius) == 0x000388, "Member 'ATedGameplayCueNotify_HitActor::CameraShakeInnerRadius' has a wrong offset!");
static_assert(offsetof(ATedGameplayCueNotify_HitActor, CameraShakeOuterRadius) == 0x00038C, "Member 'ATedGameplayCueNotify_HitActor::CameraShakeOuterRadius' has a wrong offset!");
static_assert(offsetof(ATedGameplayCueNotify_HitActor, CameraShakeFalloff) == 0x000390, "Member 'ATedGameplayCueNotify_HitActor::CameraShakeFalloff' has a wrong offset!");
static_assert(offsetof(ATedGameplayCueNotify_HitActor, bOrientShakeTowardsEpicenter) == 0x000394, "Member 'ATedGameplayCueNotify_HitActor::bOrientShakeTowardsEpicenter' has a wrong offset!");

// Class Tempest.BTService_FindHealingTarget
// 0x0080 (0x0118 - 0x0098)
class UBTService_FindHealingTarget final : public UBTService_BlackboardBase
{
public:
	struct FGameplayTagContainer                  EntityTypesFilter;                                 // 0x0098(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 PointKey;                                          // 0x00B8(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         bExplicitRangeValue : 1;                           // 0x00E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 RangeKey;                                          // 0x00E8(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         RangeValue;                                        // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindHealingTarget">();
	}
	static class UBTService_FindHealingTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindHealingTarget>();
	}
};
static_assert(alignof(UBTService_FindHealingTarget) == 0x000008, "Wrong alignment on UBTService_FindHealingTarget");
static_assert(sizeof(UBTService_FindHealingTarget) == 0x000118, "Wrong size on UBTService_FindHealingTarget");
static_assert(offsetof(UBTService_FindHealingTarget, EntityTypesFilter) == 0x000098, "Member 'UBTService_FindHealingTarget::EntityTypesFilter' has a wrong offset!");
static_assert(offsetof(UBTService_FindHealingTarget, PointKey) == 0x0000B8, "Member 'UBTService_FindHealingTarget::PointKey' has a wrong offset!");
static_assert(offsetof(UBTService_FindHealingTarget, RangeKey) == 0x0000E8, "Member 'UBTService_FindHealingTarget::RangeKey' has a wrong offset!");
static_assert(offsetof(UBTService_FindHealingTarget, RangeValue) == 0x000110, "Member 'UBTService_FindHealingTarget::RangeValue' has a wrong offset!");

// Class Tempest.BTService_FindRepairTarget
// 0x0060 (0x00F8 - 0x0098)
class UBTService_FindRepairTarget final : public UBTService_BlackboardBase
{
public:
	struct FBlackboardKeySelector                 PointKey;                                          // 0x0098(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         bExplicitRangeValue : 1;                           // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 RangeKey;                                          // 0x00C8(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         RangeValue;                                        // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindRepairTarget">();
	}
	static class UBTService_FindRepairTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindRepairTarget>();
	}
};
static_assert(alignof(UBTService_FindRepairTarget) == 0x000008, "Wrong alignment on UBTService_FindRepairTarget");
static_assert(sizeof(UBTService_FindRepairTarget) == 0x0000F8, "Wrong size on UBTService_FindRepairTarget");
static_assert(offsetof(UBTService_FindRepairTarget, PointKey) == 0x000098, "Member 'UBTService_FindRepairTarget::PointKey' has a wrong offset!");
static_assert(offsetof(UBTService_FindRepairTarget, RangeKey) == 0x0000C8, "Member 'UBTService_FindRepairTarget::RangeKey' has a wrong offset!");
static_assert(offsetof(UBTService_FindRepairTarget, RangeValue) == 0x0000F0, "Member 'UBTService_FindRepairTarget::RangeValue' has a wrong offset!");

// Class Tempest.TedGameMode_MP
// 0x0028 (0x0448 - 0x0420)
class ATedGameMode_MP : public ATedGameMode
{
public:
	int32                                         MaxMultiplayerWaitTime;                            // 0x0420(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAllowBotTakingOver : 1;                           // 0x0424(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAllowSpectatorsSeeAll : 1;                        // 0x0424(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_425[0x3];                                      // 0x0425(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialBotTakeOverTime;                            // 0x0428(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_42C[0x4];                                      // 0x042C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           InitialBotTakeOverTimerHandle;                     // 0x0430(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bSkirmish : 1;                                     // 0x0438(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_439[0x7];                                      // 0x0439(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           PauseGameHandle;                                   // 0x0440(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnInactivePlayerStateEndPlay(class AActor* InActor, EEndPlayReason InEndPlayReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGameMode_MP">();
	}
	static class ATedGameMode_MP* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedGameMode_MP>();
	}
};
static_assert(alignof(ATedGameMode_MP) == 0x000008, "Wrong alignment on ATedGameMode_MP");
static_assert(sizeof(ATedGameMode_MP) == 0x000448, "Wrong size on ATedGameMode_MP");
static_assert(offsetof(ATedGameMode_MP, MaxMultiplayerWaitTime) == 0x000420, "Member 'ATedGameMode_MP::MaxMultiplayerWaitTime' has a wrong offset!");
static_assert(offsetof(ATedGameMode_MP, InitialBotTakeOverTime) == 0x000428, "Member 'ATedGameMode_MP::InitialBotTakeOverTime' has a wrong offset!");
static_assert(offsetof(ATedGameMode_MP, InitialBotTakeOverTimerHandle) == 0x000430, "Member 'ATedGameMode_MP::InitialBotTakeOverTimerHandle' has a wrong offset!");
static_assert(offsetof(ATedGameMode_MP, PauseGameHandle) == 0x000440, "Member 'ATedGameMode_MP::PauseGameHandle' has a wrong offset!");

// Class Tempest.BTService_QueueForLanding
// 0x0000 (0x0098 - 0x0098)
class UBTService_QueueForLanding final : public UBTService_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_QueueForLanding">();
	}
	static class UBTService_QueueForLanding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_QueueForLanding>();
	}
};
static_assert(alignof(UBTService_QueueForLanding) == 0x000008, "Wrong alignment on UBTService_QueueForLanding");
static_assert(sizeof(UBTService_QueueForLanding) == 0x000098, "Wrong size on UBTService_QueueForLanding");

// Class Tempest.BTService_SetFollowUnit
// 0x0038 (0x00D0 - 0x0098)
class UBTService_SetFollowUnit final : public UBTService_BlackboardBase
{
public:
	uint8                                         bOverrideSpeedAdjustmentDistance : 1;              // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bExplicitSpeedAdjustmentDistanceVaue : 1;          // 0x0098(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 SpeedAdjustmentDistanceKey;                        // 0x00A0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         SpeedAdjustmentDistanceMultiplier;                 // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeedAdjustmentDistance;                           // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_SetFollowUnit">();
	}
	static class UBTService_SetFollowUnit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_SetFollowUnit>();
	}
};
static_assert(alignof(UBTService_SetFollowUnit) == 0x000008, "Wrong alignment on UBTService_SetFollowUnit");
static_assert(sizeof(UBTService_SetFollowUnit) == 0x0000D0, "Wrong size on UBTService_SetFollowUnit");
static_assert(offsetof(UBTService_SetFollowUnit, SpeedAdjustmentDistanceKey) == 0x0000A0, "Member 'UBTService_SetFollowUnit::SpeedAdjustmentDistanceKey' has a wrong offset!");
static_assert(offsetof(UBTService_SetFollowUnit, SpeedAdjustmentDistanceMultiplier) == 0x0000C8, "Member 'UBTService_SetFollowUnit::SpeedAdjustmentDistanceMultiplier' has a wrong offset!");
static_assert(offsetof(UBTService_SetFollowUnit, SpeedAdjustmentDistance) == 0x0000CC, "Member 'UBTService_SetFollowUnit::SpeedAdjustmentDistance' has a wrong offset!");

// Class Tempest.TedGameProgressFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UTedGameProgressFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool CanContinueCampaign(const class UObject* InWorldContext);
	static bool ContinueCampaignFromBriefing(const class UObject* InWorldContext, const class UTedCampaignInfo* InCampaign, const class UTedMapInfo* InMap);
	static bool ContinueCampaignFromBriefingWithDifficulty(const class UObject* InWorldContext, const class UTedCampaignInfo* InCampaign, const class UTedMapInfo* InMap, ETedGameDifficulty InDifficulty);
	static bool ContinueCampaignFromMap(const class UObject* InWorldContext, const class UTedCampaignInfo* InCampaign, const class UTedMapInfo* InMap, const bool bInOpenMap);
	static const class UTedMapInfo* GetCampaignLatestUnlockedMap(const class UObject* InWorldContext, const class UTedCampaignInfo* InCampaign);
	static const class UTedCampaignInfo* GetCurrentCampaign(const class UObject* InWorldContext);
	static const class UTedMapInfo* GetCurrentCampaignMap(const class UObject* InWorldContext);
	static bool IsAnyCampaignStarted(const class UObject* InWorldContext);
	static bool IsCampaignStarted(const class UObject* InWorldContext, const class UTedCampaignInfo* InCampaign);
	static void SimulateGameProgress(const class UObject* InWorldContext, const class UTedSimulatedGameProgress* InSimulatedProgress);
	static bool StartCampaign(const class UObject* InWorldContext, const class UTedCampaignInfo* InCampaign, const bool bInOpenMap, ETedGameDifficulty InDifficulty);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGameProgressFunctionLibrary">();
	}
	static class UTedGameProgressFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedGameProgressFunctionLibrary>();
	}
};
static_assert(alignof(UTedGameProgressFunctionLibrary) == 0x000008, "Wrong alignment on UTedGameProgressFunctionLibrary");
static_assert(sizeof(UTedGameProgressFunctionLibrary) == 0x000028, "Wrong size on UTedGameProgressFunctionLibrary");

// Class Tempest.BTService_TryFindBetterWeapon
// 0x0000 (0x0098 - 0x0098)
class UBTService_TryFindBetterWeapon final : public UBTService_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_TryFindBetterWeapon">();
	}
	static class UBTService_TryFindBetterWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_TryFindBetterWeapon>();
	}
};
static_assert(alignof(UBTService_TryFindBetterWeapon) == 0x000008, "Wrong alignment on UBTService_TryFindBetterWeapon");
static_assert(sizeof(UBTService_TryFindBetterWeapon) == 0x000098, "Wrong size on UBTService_TryFindBetterWeapon");

// Class Tempest.BTService_UpdateGraceRangeUsage
// 0x0000 (0x0098 - 0x0098)
class UBTService_UpdateGraceRangeUsage final : public UBTService_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_UpdateGraceRangeUsage">();
	}
	static class UBTService_UpdateGraceRangeUsage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_UpdateGraceRangeUsage>();
	}
};
static_assert(alignof(UBTService_UpdateGraceRangeUsage) == 0x000008, "Wrong alignment on UBTService_UpdateGraceRangeUsage");
static_assert(sizeof(UBTService_UpdateGraceRangeUsage) == 0x000098, "Wrong size on UBTService_UpdateGraceRangeUsage");

// Class Tempest.TedGenericDataContentSlot
// 0x0000 (0x0430 - 0x0430)
class UTedGenericDataContentSlot : public UTedContentPanelSlotButton
{
public:
	bool GetContent(struct FTedGenericDataContainer* OutContent) const;
	class UTedGenericDataContentPanel* GetGenericDataContentPanel() const;
	bool K2_GetContentValue_Float(const struct FGameplayTag& InKey, float* OutValue) const;
	bool K2_GetContentValue_Int32(const struct FGameplayTag& InKey, int32* OutValue) const;
	bool K2_GetContentValue_Object(const struct FGameplayTag& InKey, const TSubclassOf<class UObject> InOutputType, class UObject** OutValue) const;
	bool K2_GetContentValue_SlateBrush(const struct FGameplayTag& InKey, struct FSlateBrush* OutValue) const;
	bool K2_GetContentValue_Text(const struct FGameplayTag& InKey, class FText* OutValue) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGenericDataContentSlot">();
	}
	static class UTedGenericDataContentSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedGenericDataContentSlot>();
	}
};
static_assert(alignof(UTedGenericDataContentSlot) == 0x000008, "Wrong alignment on UTedGenericDataContentSlot");
static_assert(sizeof(UTedGenericDataContentSlot) == 0x000430, "Wrong size on UTedGenericDataContentSlot");

// Class Tempest.BTService_UpdateLeash
// 0x0000 (0x0070 - 0x0070)
class UBTService_UpdateLeash final : public UBTService
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_UpdateLeash">();
	}
	static class UBTService_UpdateLeash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_UpdateLeash>();
	}
};
static_assert(alignof(UBTService_UpdateLeash) == 0x000008, "Wrong alignment on UBTService_UpdateLeash");
static_assert(sizeof(UBTService_UpdateLeash) == 0x000070, "Wrong size on UBTService_UpdateLeash");

// Class Tempest.BTTask_ClearBBEntry
// 0x0000 (0x0098 - 0x0098)
class UBTTask_ClearBBEntry final : public UBTTask_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_ClearBBEntry">();
	}
	static class UBTTask_ClearBBEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_ClearBBEntry>();
	}
};
static_assert(alignof(UBTTask_ClearBBEntry) == 0x000008, "Wrong alignment on UBTTask_ClearBBEntry");
static_assert(sizeof(UBTTask_ClearBBEntry) == 0x000098, "Wrong size on UBTTask_ClearBBEntry");

// Class Tempest.TedGameSessionBase
// 0x0020 (0x02D8 - 0x02B8)
class ATedGameSessionBase : public AGameSession
{
public:
	class FString                                 Password;                                          // 0x02B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 LobbyName;                                         // 0x02C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGameSessionBase">();
	}
	static class ATedGameSessionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedGameSessionBase>();
	}
};
static_assert(alignof(ATedGameSessionBase) == 0x000008, "Wrong alignment on ATedGameSessionBase");
static_assert(sizeof(ATedGameSessionBase) == 0x0002D8, "Wrong size on ATedGameSessionBase");
static_assert(offsetof(ATedGameSessionBase, Password) == 0x0002B8, "Member 'ATedGameSessionBase::Password' has a wrong offset!");
static_assert(offsetof(ATedGameSessionBase, LobbyName) == 0x0002C8, "Member 'ATedGameSessionBase::LobbyName' has a wrong offset!");

// Class Tempest.TedGameSession
// 0x0068 (0x0340 - 0x02D8)
class ATedGameSession final : public ATedGameSessionBase
{
public:
	uint8                                         Pad_2D8[0x68];                                     // 0x02D8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGameSession">();
	}
	static class ATedGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedGameSession>();
	}
};
static_assert(alignof(ATedGameSession) == 0x000008, "Wrong alignment on ATedGameSession");
static_assert(sizeof(ATedGameSession) == 0x000340, "Wrong size on ATedGameSession");

// Class Tempest.BTTask_CommandFinished
// 0x0008 (0x0078 - 0x0070)
class UBTTask_CommandFinished final : public UBTTaskNode
{
public:
	EBTNodeResult                                 Result;                                            // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_CommandFinished">();
	}
	static class UBTTask_CommandFinished* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_CommandFinished>();
	}
};
static_assert(alignof(UBTTask_CommandFinished) == 0x000008, "Wrong alignment on UBTTask_CommandFinished");
static_assert(sizeof(UBTTask_CommandFinished) == 0x000078, "Wrong size on UBTTask_CommandFinished");
static_assert(offsetof(UBTTask_CommandFinished, Result) == 0x000070, "Member 'UBTTask_CommandFinished::Result' has a wrong offset!");

// Class Tempest.BTTask_FindAttackTarget
// 0x0018 (0x00B0 - 0x0098)
class UBTTask_FindAttackTarget final : public UBTTask_BlackboardBase
{
public:
	ETedWeaponSelection                           WeaponSelection;                                   // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_99[0x17];                                      // 0x0099(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_FindAttackTarget">();
	}
	static class UBTTask_FindAttackTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_FindAttackTarget>();
	}
};
static_assert(alignof(UBTTask_FindAttackTarget) == 0x000008, "Wrong alignment on UBTTask_FindAttackTarget");
static_assert(sizeof(UBTTask_FindAttackTarget) == 0x0000B0, "Wrong size on UBTTask_FindAttackTarget");
static_assert(offsetof(UBTTask_FindAttackTarget, WeaponSelection) == 0x000098, "Member 'UBTTask_FindAttackTarget::WeaponSelection' has a wrong offset!");

// Class Tempest.TedGameplayCueNotify_StatusEffect
// 0x0000 (0x0350 - 0x0350)
class ATedGameplayCueNotify_StatusEffect : public ATedGameplayCueNotify_Actor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGameplayCueNotify_StatusEffect">();
	}
	static class ATedGameplayCueNotify_StatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedGameplayCueNotify_StatusEffect>();
	}
};
static_assert(alignof(ATedGameplayCueNotify_StatusEffect) == 0x000008, "Wrong alignment on ATedGameplayCueNotify_StatusEffect");
static_assert(sizeof(ATedGameplayCueNotify_StatusEffect) == 0x000350, "Wrong size on ATedGameplayCueNotify_StatusEffect");

// Class Tempest.BTTask_FindAttackTarget_Drone
// 0x0028 (0x00C0 - 0x0098)
class UBTTask_FindAttackTarget_Drone final : public UBTTask_BlackboardBase
{
public:
	struct FBlackboardKeySelector                 DroneOwnerKey;                                     // 0x0098(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_FindAttackTarget_Drone">();
	}
	static class UBTTask_FindAttackTarget_Drone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_FindAttackTarget_Drone>();
	}
};
static_assert(alignof(UBTTask_FindAttackTarget_Drone) == 0x000008, "Wrong alignment on UBTTask_FindAttackTarget_Drone");
static_assert(sizeof(UBTTask_FindAttackTarget_Drone) == 0x0000C0, "Wrong size on UBTTask_FindAttackTarget_Drone");
static_assert(offsetof(UBTTask_FindAttackTarget_Drone, DroneOwnerKey) == 0x000098, "Member 'UBTTask_FindAttackTarget_Drone::DroneOwnerKey' has a wrong offset!");

// Class Tempest.BTTask_FindClosestQueueStructure
// 0x0018 (0x00B0 - 0x0098)
class UBTTask_FindClosestQueueStructure final : public UBTTask_BlackboardBase
{
public:
	float                                         PathLengthScoringFactor;                           // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         QueueNumScoringFactor;                             // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxPathLength;                                     // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           QueueStructureEntityTag;                           // 0x00A4(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequireSpecificFaction;                           // 0x00AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedFaction                                   QueueStructureFaction;                             // 0x00AD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequirePowerState;                                // 0x00AE(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedPowerStateFlag                            PowerStateFlag;                                    // 0x00AF(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_FindClosestQueueStructure">();
	}
	static class UBTTask_FindClosestQueueStructure* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_FindClosestQueueStructure>();
	}
};
static_assert(alignof(UBTTask_FindClosestQueueStructure) == 0x000008, "Wrong alignment on UBTTask_FindClosestQueueStructure");
static_assert(sizeof(UBTTask_FindClosestQueueStructure) == 0x0000B0, "Wrong size on UBTTask_FindClosestQueueStructure");
static_assert(offsetof(UBTTask_FindClosestQueueStructure, PathLengthScoringFactor) == 0x000098, "Member 'UBTTask_FindClosestQueueStructure::PathLengthScoringFactor' has a wrong offset!");
static_assert(offsetof(UBTTask_FindClosestQueueStructure, QueueNumScoringFactor) == 0x00009C, "Member 'UBTTask_FindClosestQueueStructure::QueueNumScoringFactor' has a wrong offset!");
static_assert(offsetof(UBTTask_FindClosestQueueStructure, MaxPathLength) == 0x0000A0, "Member 'UBTTask_FindClosestQueueStructure::MaxPathLength' has a wrong offset!");
static_assert(offsetof(UBTTask_FindClosestQueueStructure, QueueStructureEntityTag) == 0x0000A4, "Member 'UBTTask_FindClosestQueueStructure::QueueStructureEntityTag' has a wrong offset!");
static_assert(offsetof(UBTTask_FindClosestQueueStructure, bRequireSpecificFaction) == 0x0000AC, "Member 'UBTTask_FindClosestQueueStructure::bRequireSpecificFaction' has a wrong offset!");
static_assert(offsetof(UBTTask_FindClosestQueueStructure, QueueStructureFaction) == 0x0000AD, "Member 'UBTTask_FindClosestQueueStructure::QueueStructureFaction' has a wrong offset!");
static_assert(offsetof(UBTTask_FindClosestQueueStructure, bRequirePowerState) == 0x0000AE, "Member 'UBTTask_FindClosestQueueStructure::bRequirePowerState' has a wrong offset!");
static_assert(offsetof(UBTTask_FindClosestQueueStructure, PowerStateFlag) == 0x0000AF, "Member 'UBTTask_FindClosestQueueStructure::PowerStateFlag' has a wrong offset!");

// Class Tempest.TedGarrisonBarsProxyWidget
// 0x0068 (0x0468 - 0x0400)
class UTedGarrisonBarsProxyWidget final : public UTedUserWidget
{
public:
	TArray<struct FTedGarrisonBarConfig>          Configs;                                           // 0x0400(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              OffsetOnScreen;                                    // 0x0410(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              BoxOffsetOnScreen;                                 // 0x0420(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        DataPackingPrecission;                             // 0x0430(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MinDisplayLengthParam;                             // 0x0434(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MaxDisplayLengthParam;                             // 0x043C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DisplayHeightParam;                                // 0x0444(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DataPackingPrecissionParam;                        // 0x044C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_454[0x4];                                      // 0x0454(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedProceduralMeshWidget*               GarrisonBarsWidget;                                // 0x0458(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedProceduralMeshWidget*               GarrisonBoxWidget;                                 // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGarrisonBarsProxyWidget">();
	}
	static class UTedGarrisonBarsProxyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedGarrisonBarsProxyWidget>();
	}
};
static_assert(alignof(UTedGarrisonBarsProxyWidget) == 0x000008, "Wrong alignment on UTedGarrisonBarsProxyWidget");
static_assert(sizeof(UTedGarrisonBarsProxyWidget) == 0x000468, "Wrong size on UTedGarrisonBarsProxyWidget");
static_assert(offsetof(UTedGarrisonBarsProxyWidget, Configs) == 0x000400, "Member 'UTedGarrisonBarsProxyWidget::Configs' has a wrong offset!");
static_assert(offsetof(UTedGarrisonBarsProxyWidget, OffsetOnScreen) == 0x000410, "Member 'UTedGarrisonBarsProxyWidget::OffsetOnScreen' has a wrong offset!");
static_assert(offsetof(UTedGarrisonBarsProxyWidget, BoxOffsetOnScreen) == 0x000420, "Member 'UTedGarrisonBarsProxyWidget::BoxOffsetOnScreen' has a wrong offset!");
static_assert(offsetof(UTedGarrisonBarsProxyWidget, DataPackingPrecission) == 0x000430, "Member 'UTedGarrisonBarsProxyWidget::DataPackingPrecission' has a wrong offset!");
static_assert(offsetof(UTedGarrisonBarsProxyWidget, MinDisplayLengthParam) == 0x000434, "Member 'UTedGarrisonBarsProxyWidget::MinDisplayLengthParam' has a wrong offset!");
static_assert(offsetof(UTedGarrisonBarsProxyWidget, MaxDisplayLengthParam) == 0x00043C, "Member 'UTedGarrisonBarsProxyWidget::MaxDisplayLengthParam' has a wrong offset!");
static_assert(offsetof(UTedGarrisonBarsProxyWidget, DisplayHeightParam) == 0x000444, "Member 'UTedGarrisonBarsProxyWidget::DisplayHeightParam' has a wrong offset!");
static_assert(offsetof(UTedGarrisonBarsProxyWidget, DataPackingPrecissionParam) == 0x00044C, "Member 'UTedGarrisonBarsProxyWidget::DataPackingPrecissionParam' has a wrong offset!");
static_assert(offsetof(UTedGarrisonBarsProxyWidget, GarrisonBarsWidget) == 0x000458, "Member 'UTedGarrisonBarsProxyWidget::GarrisonBarsWidget' has a wrong offset!");
static_assert(offsetof(UTedGarrisonBarsProxyWidget, GarrisonBoxWidget) == 0x000460, "Member 'UTedGarrisonBarsProxyWidget::GarrisonBoxWidget' has a wrong offset!");

// Class Tempest.BTTask_FindClosestResourceVolume
// 0x0040 (0x00D8 - 0x0098)
class UBTTask_FindClosestResourceVolume final : public UBTTask_BlackboardBase
{
public:
	bool                                          bUseFixedMaxPathDistanceValue;                     // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxPathDistance;                                   // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 MaxPathDistanceKey;                                // 0x00A0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bCheckDepletion;                                   // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinResources;                                      // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxClaimedResourceTiles;                           // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_FindClosestResourceVolume">();
	}
	static class UBTTask_FindClosestResourceVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_FindClosestResourceVolume>();
	}
};
static_assert(alignof(UBTTask_FindClosestResourceVolume) == 0x000008, "Wrong alignment on UBTTask_FindClosestResourceVolume");
static_assert(sizeof(UBTTask_FindClosestResourceVolume) == 0x0000D8, "Wrong size on UBTTask_FindClosestResourceVolume");
static_assert(offsetof(UBTTask_FindClosestResourceVolume, bUseFixedMaxPathDistanceValue) == 0x000098, "Member 'UBTTask_FindClosestResourceVolume::bUseFixedMaxPathDistanceValue' has a wrong offset!");
static_assert(offsetof(UBTTask_FindClosestResourceVolume, MaxPathDistance) == 0x00009C, "Member 'UBTTask_FindClosestResourceVolume::MaxPathDistance' has a wrong offset!");
static_assert(offsetof(UBTTask_FindClosestResourceVolume, MaxPathDistanceKey) == 0x0000A0, "Member 'UBTTask_FindClosestResourceVolume::MaxPathDistanceKey' has a wrong offset!");
static_assert(offsetof(UBTTask_FindClosestResourceVolume, bCheckDepletion) == 0x0000C8, "Member 'UBTTask_FindClosestResourceVolume::bCheckDepletion' has a wrong offset!");
static_assert(offsetof(UBTTask_FindClosestResourceVolume, MinResources) == 0x0000CC, "Member 'UBTTask_FindClosestResourceVolume::MinResources' has a wrong offset!");
static_assert(offsetof(UBTTask_FindClosestResourceVolume, MaxClaimedResourceTiles) == 0x0000D0, "Member 'UBTTask_FindClosestResourceVolume::MaxClaimedResourceTiles' has a wrong offset!");

// Class Tempest.BTTask_FindMine
// 0x0060 (0x00F8 - 0x0098)
class UBTTask_FindMine final : public UBTTask_BlackboardBase
{
public:
	struct FBlackboardKeySelector                 PointKey;                                          // 0x0098(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         bExplicitRangeValue : 1;                           // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 RangeKey;                                          // 0x00C8(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         RangeValue;                                        // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_FindMine">();
	}
	static class UBTTask_FindMine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_FindMine>();
	}
};
static_assert(alignof(UBTTask_FindMine) == 0x000008, "Wrong alignment on UBTTask_FindMine");
static_assert(sizeof(UBTTask_FindMine) == 0x0000F8, "Wrong size on UBTTask_FindMine");
static_assert(offsetof(UBTTask_FindMine, PointKey) == 0x000098, "Member 'UBTTask_FindMine::PointKey' has a wrong offset!");
static_assert(offsetof(UBTTask_FindMine, RangeKey) == 0x0000C8, "Member 'UBTTask_FindMine::RangeKey' has a wrong offset!");
static_assert(offsetof(UBTTask_FindMine, RangeValue) == 0x0000F0, "Member 'UBTTask_FindMine::RangeValue' has a wrong offset!");

// Class Tempest.TedGridAreaVolume
// 0x0058 (0x0390 - 0x0338)
class ATedGridAreaVolume : public AGridAreaVolume
{
public:
	class UEcsActorComponent*                     EcsActor;                                          // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class AActor*>                           OverlappingActors;                                 // 0x0340(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGridAreaVolume">();
	}
	static class ATedGridAreaVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedGridAreaVolume>();
	}
};
static_assert(alignof(ATedGridAreaVolume) == 0x000008, "Wrong alignment on ATedGridAreaVolume");
static_assert(sizeof(ATedGridAreaVolume) == 0x000390, "Wrong size on ATedGridAreaVolume");
static_assert(offsetof(ATedGridAreaVolume, EcsActor) == 0x000338, "Member 'ATedGridAreaVolume::EcsActor' has a wrong offset!");
static_assert(offsetof(ATedGridAreaVolume, OverlappingActors) == 0x000340, "Member 'ATedGridAreaVolume::OverlappingActors' has a wrong offset!");

// Class Tempest.TedHudPopup
// 0x0010 (0x0410 - 0x0400)
class UTedHudPopup : public UTedUserWidget
{
public:
	class UTedPopup*                              Popup_Default;                                     // 0x0400(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bSideLocation : 1;                                 // 0x0408(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_409[0x7];                                      // 0x0409(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cancel();
	void K2_HideButton();
	void K2_ShowButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedHudPopup">();
	}
	static class UTedHudPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedHudPopup>();
	}
};
static_assert(alignof(UTedHudPopup) == 0x000008, "Wrong alignment on UTedHudPopup");
static_assert(sizeof(UTedHudPopup) == 0x000410, "Wrong size on UTedHudPopup");
static_assert(offsetof(UTedHudPopup, Popup_Default) == 0x000400, "Member 'UTedHudPopup::Popup_Default' has a wrong offset!");

// Class Tempest.BTTask_FindNextPatrolPoint
// 0x0008 (0x00A0 - 0x0098)
class UBTTask_FindNextPatrolPoint final : public UBTTask_BlackboardBase
{
public:
	uint8                                         bReachTestIncludesAgentRadius : 1;                 // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ArrivalTolerance;                                  // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_FindNextPatrolPoint">();
	}
	static class UBTTask_FindNextPatrolPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_FindNextPatrolPoint>();
	}
};
static_assert(alignof(UBTTask_FindNextPatrolPoint) == 0x000008, "Wrong alignment on UBTTask_FindNextPatrolPoint");
static_assert(sizeof(UBTTask_FindNextPatrolPoint) == 0x0000A0, "Wrong size on UBTTask_FindNextPatrolPoint");
static_assert(offsetof(UBTTask_FindNextPatrolPoint, ArrivalTolerance) == 0x00009C, "Member 'UBTTask_FindNextPatrolPoint::ArrivalTolerance' has a wrong offset!");

// Class Tempest.TedVehicleWreckActor
// 0x0110 (0x03A0 - 0x0290)
class ATedVehicleWreckActor : public AActor
{
public:
	class USceneComponent*                        DefaultRoot;                                       // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   Mesh;                                              // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       MIDs;                                              // 0x02A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   VehicleHPParameterName;                            // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ForceToApply;                                      // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MinImpulseLocationRange;                           // 0x02C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                MaxImpulseLocationRange;                           // 0x02D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDissolve : 1;                                     // 0x02F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2F1[0x3];                                      // 0x02F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DissolveParameterName;                             // 0x02F4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     DissolveCurve;                                     // 0x0300(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         DissolveDelay;                                     // 0x0388(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDestroyAfterDissolve : 1;                         // 0x038C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_38D[0x3];                                      // 0x038D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           DissolveTimerHandle;                               // 0x0390(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Time;                                              // 0x0398(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bDissolveFinished : 1;                             // 0x039C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_39D[0x3];                                      // 0x039D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedVehicleWreckActor">();
	}
	static class ATedVehicleWreckActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedVehicleWreckActor>();
	}
};
static_assert(alignof(ATedVehicleWreckActor) == 0x000008, "Wrong alignment on ATedVehicleWreckActor");
static_assert(sizeof(ATedVehicleWreckActor) == 0x0003A0, "Wrong size on ATedVehicleWreckActor");
static_assert(offsetof(ATedVehicleWreckActor, DefaultRoot) == 0x000290, "Member 'ATedVehicleWreckActor::DefaultRoot' has a wrong offset!");
static_assert(offsetof(ATedVehicleWreckActor, Mesh) == 0x000298, "Member 'ATedVehicleWreckActor::Mesh' has a wrong offset!");
static_assert(offsetof(ATedVehicleWreckActor, MIDs) == 0x0002A0, "Member 'ATedVehicleWreckActor::MIDs' has a wrong offset!");
static_assert(offsetof(ATedVehicleWreckActor, VehicleHPParameterName) == 0x0002B0, "Member 'ATedVehicleWreckActor::VehicleHPParameterName' has a wrong offset!");
static_assert(offsetof(ATedVehicleWreckActor, ForceToApply) == 0x0002B8, "Member 'ATedVehicleWreckActor::ForceToApply' has a wrong offset!");
static_assert(offsetof(ATedVehicleWreckActor, MinImpulseLocationRange) == 0x0002C0, "Member 'ATedVehicleWreckActor::MinImpulseLocationRange' has a wrong offset!");
static_assert(offsetof(ATedVehicleWreckActor, MaxImpulseLocationRange) == 0x0002D8, "Member 'ATedVehicleWreckActor::MaxImpulseLocationRange' has a wrong offset!");
static_assert(offsetof(ATedVehicleWreckActor, DissolveParameterName) == 0x0002F4, "Member 'ATedVehicleWreckActor::DissolveParameterName' has a wrong offset!");
static_assert(offsetof(ATedVehicleWreckActor, DissolveCurve) == 0x000300, "Member 'ATedVehicleWreckActor::DissolveCurve' has a wrong offset!");
static_assert(offsetof(ATedVehicleWreckActor, DissolveDelay) == 0x000388, "Member 'ATedVehicleWreckActor::DissolveDelay' has a wrong offset!");
static_assert(offsetof(ATedVehicleWreckActor, DissolveTimerHandle) == 0x000390, "Member 'ATedVehicleWreckActor::DissolveTimerHandle' has a wrong offset!");
static_assert(offsetof(ATedVehicleWreckActor, Time) == 0x000398, "Member 'ATedVehicleWreckActor::Time' has a wrong offset!");

// Class Tempest.BTTask_TedMoveTo
// 0x0008 (0x00B8 - 0x00B0)
class UBTTask_TedMoveTo : public UBTTask_MoveTo
{
public:
	uint8                                         bMoveDirectlyTowardGoal : 1;                       // 0x00B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bObserveGoalLocation : 1;                          // 0x00B0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIgnoreForGroupMovement : 1;                       // 0x00B0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_TedMoveTo">();
	}
	static class UBTTask_TedMoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_TedMoveTo>();
	}
};
static_assert(alignof(UBTTask_TedMoveTo) == 0x000008, "Wrong alignment on UBTTask_TedMoveTo");
static_assert(sizeof(UBTTask_TedMoveTo) == 0x0000B8, "Wrong size on UBTTask_TedMoveTo");

// Class Tempest.TedGhostPawn
// 0x0020 (0x16D0 - 0x16B0)
class ATedGhostPawn : public ATedPawn
{
public:
	class UPoseableMeshComponent*                 SkeletalMesh;                                      // 0x16A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16B0[0x10];                                    // 0x16B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ATedPawn>                ParentPawn;                                        // 0x16C0(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAbandoned : 1;                                    // 0x16C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_16C9[0x7];                                     // 0x16C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGhostPawn">();
	}
	static class ATedGhostPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedGhostPawn>();
	}
};
static_assert(alignof(ATedGhostPawn) == 0x000010, "Wrong alignment on ATedGhostPawn");
static_assert(sizeof(ATedGhostPawn) == 0x0016D0, "Wrong size on ATedGhostPawn");
static_assert(offsetof(ATedGhostPawn, SkeletalMesh) == 0x0016A8, "Member 'ATedGhostPawn::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(ATedGhostPawn, ParentPawn) == 0x0016C0, "Member 'ATedGhostPawn::ParentPawn' has a wrong offset!");

// Class Tempest.BTTask_MoveToEvadeLocation
// 0x0018 (0x00D0 - 0x00B8)
class UBTTask_MoveToEvadeLocation final : public UBTTask_TedMoveTo
{
public:
	class UInfluenceMapQueryPreset*               QueryPreset;                                       // 0x00B8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InfluenceThreshold;                                // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageTimeThreshold;                               // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickInterval;                                      // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickRandomDeviation;                               // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_MoveToEvadeLocation">();
	}
	static class UBTTask_MoveToEvadeLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_MoveToEvadeLocation>();
	}
};
static_assert(alignof(UBTTask_MoveToEvadeLocation) == 0x000008, "Wrong alignment on UBTTask_MoveToEvadeLocation");
static_assert(sizeof(UBTTask_MoveToEvadeLocation) == 0x0000D0, "Wrong size on UBTTask_MoveToEvadeLocation");
static_assert(offsetof(UBTTask_MoveToEvadeLocation, QueryPreset) == 0x0000B8, "Member 'UBTTask_MoveToEvadeLocation::QueryPreset' has a wrong offset!");
static_assert(offsetof(UBTTask_MoveToEvadeLocation, InfluenceThreshold) == 0x0000C0, "Member 'UBTTask_MoveToEvadeLocation::InfluenceThreshold' has a wrong offset!");
static_assert(offsetof(UBTTask_MoveToEvadeLocation, DamageTimeThreshold) == 0x0000C4, "Member 'UBTTask_MoveToEvadeLocation::DamageTimeThreshold' has a wrong offset!");
static_assert(offsetof(UBTTask_MoveToEvadeLocation, TickInterval) == 0x0000C8, "Member 'UBTTask_MoveToEvadeLocation::TickInterval' has a wrong offset!");
static_assert(offsetof(UBTTask_MoveToEvadeLocation, TickRandomDeviation) == 0x0000CC, "Member 'UBTTask_MoveToEvadeLocation::TickRandomDeviation' has a wrong offset!");

// Class Tempest.BTTask_MoveToInvestigationLocation
// 0x0000 (0x00B0 - 0x00B0)
class UBTTask_MoveToInvestigationLocation final : public UBTTask_MoveTo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_MoveToInvestigationLocation">();
	}
	static class UBTTask_MoveToInvestigationLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_MoveToInvestigationLocation>();
	}
};
static_assert(alignof(UBTTask_MoveToInvestigationLocation) == 0x000008, "Wrong alignment on UBTTask_MoveToInvestigationLocation");
static_assert(sizeof(UBTTask_MoveToInvestigationLocation) == 0x0000B0, "Wrong size on UBTTask_MoveToInvestigationLocation");

// Class Tempest.TedGameVersionWidget
// 0x0020 (0x0420 - 0x0400)
class UTedGameVersionWidget : public UTedUserWidget
{
public:
	class UTextBlock*                             Text_Version;                                      // 0x0400(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_408[0x18];                                     // 0x0408(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FText GetGameVersion() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGameVersionWidget">();
	}
	static class UTedGameVersionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedGameVersionWidget>();
	}
};
static_assert(alignof(UTedGameVersionWidget) == 0x000008, "Wrong alignment on UTedGameVersionWidget");
static_assert(sizeof(UTedGameVersionWidget) == 0x000420, "Wrong size on UTedGameVersionWidget");
static_assert(offsetof(UTedGameVersionWidget, Text_Version) == 0x000400, "Member 'UTedGameVersionWidget::Text_Version' has a wrong offset!");

// Class Tempest.TedPopupButtonsSlot
// 0x0008 (0x0438 - 0x0430)
class UTedPopupButtonsSlot : public UTedContentPanelSlotButton
{
public:
	class UTextBlock*                             Text_DisplayText;                                  // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void NotifyContentClicked();

	class UTedPopupButtonsPanel* GetButtonsPanel() const;
	const class FText GetContentDescription() const;
	const class FText GetContentText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPopupButtonsSlot">();
	}
	static class UTedPopupButtonsSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPopupButtonsSlot>();
	}
};
static_assert(alignof(UTedPopupButtonsSlot) == 0x000008, "Wrong alignment on UTedPopupButtonsSlot");
static_assert(sizeof(UTedPopupButtonsSlot) == 0x000438, "Wrong size on UTedPopupButtonsSlot");
static_assert(offsetof(UTedPopupButtonsSlot, Text_DisplayText) == 0x000430, "Member 'UTedPopupButtonsSlot::Text_DisplayText' has a wrong offset!");

// Class Tempest.BTTask_MoveToPatrol
// 0x0008 (0x00C0 - 0x00B8)
class UBTTask_MoveToPatrol final : public UBTTask_TedMoveTo
{
public:
	float                                         ArrivalTolerance;                                  // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_MoveToPatrol">();
	}
	static class UBTTask_MoveToPatrol* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_MoveToPatrol>();
	}
};
static_assert(alignof(UBTTask_MoveToPatrol) == 0x000008, "Wrong alignment on UBTTask_MoveToPatrol");
static_assert(sizeof(UBTTask_MoveToPatrol) == 0x0000C0, "Wrong size on UBTTask_MoveToPatrol");
static_assert(offsetof(UBTTask_MoveToPatrol, ArrivalTolerance) == 0x0000B8, "Member 'UBTTask_MoveToPatrol::ArrivalTolerance' has a wrong offset!");

// Class Tempest.TedVetiForceField
// 0x0010 (0x02A0 - 0x0290)
class ATedVetiForceField final : public AActor
{
public:
	class USphereComponent*                       SphereCollision;                                   // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   SphereMesh;                                        // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedVetiForceField">();
	}
	static class ATedVetiForceField* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedVetiForceField>();
	}
};
static_assert(alignof(ATedVetiForceField) == 0x000008, "Wrong alignment on ATedVetiForceField");
static_assert(sizeof(ATedVetiForceField) == 0x0002A0, "Wrong size on ATedVetiForceField");
static_assert(offsetof(ATedVetiForceField, SphereCollision) == 0x000290, "Member 'ATedVetiForceField::SphereCollision' has a wrong offset!");
static_assert(offsetof(ATedVetiForceField, SphereMesh) == 0x000298, "Member 'ATedVetiForceField::SphereMesh' has a wrong offset!");

// Class Tempest.BTTask_PushCommandToGarrison
// 0x0030 (0x00A0 - 0x0070)
class UBTTask_PushCommandToGarrison final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 TargetBlackboardKey;                               // 0x0070(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           CommandType;                                       // 0x0098(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_PushCommandToGarrison">();
	}
	static class UBTTask_PushCommandToGarrison* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_PushCommandToGarrison>();
	}
};
static_assert(alignof(UBTTask_PushCommandToGarrison) == 0x000008, "Wrong alignment on UBTTask_PushCommandToGarrison");
static_assert(sizeof(UBTTask_PushCommandToGarrison) == 0x0000A0, "Wrong size on UBTTask_PushCommandToGarrison");
static_assert(offsetof(UBTTask_PushCommandToGarrison, TargetBlackboardKey) == 0x000070, "Member 'UBTTask_PushCommandToGarrison::TargetBlackboardKey' has a wrong offset!");
static_assert(offsetof(UBTTask_PushCommandToGarrison, CommandType) == 0x000098, "Member 'UBTTask_PushCommandToGarrison::CommandType' has a wrong offset!");

// Class Tempest.TedGlowingButton
// 0x0020 (0x0420 - 0x0400)
class UTedGlowingButton : public UTedUserWidget
{
public:
	class UButton*                                Value_Button;                                      // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTedUserWidget*                         Value_GlowText;                                    // 0x0408(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTextBlock*>                     CachedGlowTextBlocks;                              // 0x0410(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	TArray<class UTextBlock*> GetGlowTextBlocks();
	void SetGlowText(const class FText& Text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGlowingButton">();
	}
	static class UTedGlowingButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedGlowingButton>();
	}
};
static_assert(alignof(UTedGlowingButton) == 0x000008, "Wrong alignment on UTedGlowingButton");
static_assert(sizeof(UTedGlowingButton) == 0x000420, "Wrong size on UTedGlowingButton");
static_assert(offsetof(UTedGlowingButton, Value_Button) == 0x000400, "Member 'UTedGlowingButton::Value_Button' has a wrong offset!");
static_assert(offsetof(UTedGlowingButton, Value_GlowText) == 0x000408, "Member 'UTedGlowingButton::Value_GlowText' has a wrong offset!");
static_assert(offsetof(UTedGlowingButton, CachedGlowTextBlocks) == 0x000410, "Member 'UTedGlowingButton::CachedGlowTextBlocks' has a wrong offset!");

// Class Tempest.BTTask_RefreshLandingData
// 0x0000 (0x0098 - 0x0098)
class UBTTask_RefreshLandingData final : public UBTTask_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RefreshLandingData">();
	}
	static class UBTTask_RefreshLandingData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RefreshLandingData>();
	}
};
static_assert(alignof(UBTTask_RefreshLandingData) == 0x000008, "Wrong alignment on UBTTask_RefreshLandingData");
static_assert(sizeof(UBTTask_RefreshLandingData) == 0x000098, "Wrong size on UBTTask_RefreshLandingData");

// Class Tempest.BTTask_RunTedAIQuery
// 0x0008 (0x00A0 - 0x0098)
class UBTTask_RunTedAIQuery : public UBTTask_BlackboardBase
{
public:
	EEnvQueryRunMode                              RunMode;                                           // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RunTedAIQuery">();
	}
	static class UBTTask_RunTedAIQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RunTedAIQuery>();
	}
};
static_assert(alignof(UBTTask_RunTedAIQuery) == 0x000008, "Wrong alignment on UBTTask_RunTedAIQuery");
static_assert(sizeof(UBTTask_RunTedAIQuery) == 0x0000A0, "Wrong size on UBTTask_RunTedAIQuery");
static_assert(offsetof(UBTTask_RunTedAIQuery, RunMode) == 0x000098, "Member 'UBTTask_RunTedAIQuery::RunMode' has a wrong offset!");

// Class Tempest.TedProjectile
// 0x01D0 (0x0460 - 0x0290)
class ATedProjectile : public AActor
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedProjectileMovementComponent*        ProjectileMovement;                                // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDamageKind                                   DamageKind;                                        // 0x02A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A1[0x3];                                      // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PointDamageAmount;                                 // 0x02A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRadialDamageParams                    RadialDamageParams;                                // 0x02A8(0x0014)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FConeDamageParams                      ConeDamageParams;                                  // 0x02BC(0x0018)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UTedDamageType>             DamageType;                                        // 0x02D8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTedUtilsPawnFilter                    DamageFilter;                                      // 0x02E0(0x00D0)(Protected, NativeAccessSpecifierProtected)
	TArray<class UGameplayEffect*>                EffectsToApplyOnDamage;                            // 0x03B0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bDealsFullDamageToTarget;                          // 0x03C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bPlayEffectsWithNoTarget : 1;                      // 0x03C1(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3C2[0x2];                                      // 0x03C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayCueTag                        HitGameplayCue;                                    // 0x03C4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueTag                        RadialHitGameplayCueOverride;                      // 0x03CC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bTraceGroundForPhysMat : 1;                        // 0x03D4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPlayHitEffectAtDestinationLocation : 1;           // 0x03D4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPlayHitEffectAtTargetLocation : 1;                // 0x03D4(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPassDamagedPawnAsTargetToGCue : 1;                // 0x03D4(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPlayHitEffectOnRadialDamageTargets : 1;           // 0x03D4(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsHoming : 1;                                     // 0x03D4(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseSuggestedProjectileVelocity : 1;               // 0x03D4(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseFixedArc : 1;                                  // 0x03D4(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bFavorHighArc : 1;                                 // 0x03D5(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDrawTrajectoryDebug : 1;                          // 0x03D5(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanBePooled : 1;                                  // 0x03D5(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanRecycleOldestActive : 1;                       // 0x03D5(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3D6[0x2];                                      // 0x03D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        MaxPoolSize;                                       // 0x03D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExtraKeepAliveTime;                                // 0x03DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArcParam;                                          // 0x03E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToImpactDelay;                                 // 0x03E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAcceptClosestOnNoSolutions;                       // 0x03E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E9[0x7];                                      // 0x03E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ATedPawn*                               Target;                                            // 0x03F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetLocation;                                    // 0x03F8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                StartLocation;                                     // 0x0410(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ATedPawn*>                       CachedDamagedPawns;                                // 0x0428(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_438[0x20];                                     // 0x0438(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           TrackedSupportPowerTag;                            // 0x0458(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ReceiveOnProjectileFired();
	void ReceiveOnProjectileHit();

	struct FGameplayEffectSpecHandle GetDamageGESpec() const;
	struct FVector GetDestination() const;
	struct FVector GetStart() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedProjectile">();
	}
	static class ATedProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedProjectile>();
	}
};
static_assert(alignof(ATedProjectile) == 0x000008, "Wrong alignment on ATedProjectile");
static_assert(sizeof(ATedProjectile) == 0x000460, "Wrong size on ATedProjectile");
static_assert(offsetof(ATedProjectile, ProjectileMovement) == 0x000298, "Member 'ATedProjectile::ProjectileMovement' has a wrong offset!");
static_assert(offsetof(ATedProjectile, DamageKind) == 0x0002A0, "Member 'ATedProjectile::DamageKind' has a wrong offset!");
static_assert(offsetof(ATedProjectile, PointDamageAmount) == 0x0002A4, "Member 'ATedProjectile::PointDamageAmount' has a wrong offset!");
static_assert(offsetof(ATedProjectile, RadialDamageParams) == 0x0002A8, "Member 'ATedProjectile::RadialDamageParams' has a wrong offset!");
static_assert(offsetof(ATedProjectile, ConeDamageParams) == 0x0002BC, "Member 'ATedProjectile::ConeDamageParams' has a wrong offset!");
static_assert(offsetof(ATedProjectile, DamageType) == 0x0002D8, "Member 'ATedProjectile::DamageType' has a wrong offset!");
static_assert(offsetof(ATedProjectile, DamageFilter) == 0x0002E0, "Member 'ATedProjectile::DamageFilter' has a wrong offset!");
static_assert(offsetof(ATedProjectile, EffectsToApplyOnDamage) == 0x0003B0, "Member 'ATedProjectile::EffectsToApplyOnDamage' has a wrong offset!");
static_assert(offsetof(ATedProjectile, bDealsFullDamageToTarget) == 0x0003C0, "Member 'ATedProjectile::bDealsFullDamageToTarget' has a wrong offset!");
static_assert(offsetof(ATedProjectile, HitGameplayCue) == 0x0003C4, "Member 'ATedProjectile::HitGameplayCue' has a wrong offset!");
static_assert(offsetof(ATedProjectile, RadialHitGameplayCueOverride) == 0x0003CC, "Member 'ATedProjectile::RadialHitGameplayCueOverride' has a wrong offset!");
static_assert(offsetof(ATedProjectile, MaxPoolSize) == 0x0003D8, "Member 'ATedProjectile::MaxPoolSize' has a wrong offset!");
static_assert(offsetof(ATedProjectile, ExtraKeepAliveTime) == 0x0003DC, "Member 'ATedProjectile::ExtraKeepAliveTime' has a wrong offset!");
static_assert(offsetof(ATedProjectile, ArcParam) == 0x0003E0, "Member 'ATedProjectile::ArcParam' has a wrong offset!");
static_assert(offsetof(ATedProjectile, TimeToImpactDelay) == 0x0003E4, "Member 'ATedProjectile::TimeToImpactDelay' has a wrong offset!");
static_assert(offsetof(ATedProjectile, bAcceptClosestOnNoSolutions) == 0x0003E8, "Member 'ATedProjectile::bAcceptClosestOnNoSolutions' has a wrong offset!");
static_assert(offsetof(ATedProjectile, Target) == 0x0003F0, "Member 'ATedProjectile::Target' has a wrong offset!");
static_assert(offsetof(ATedProjectile, TargetLocation) == 0x0003F8, "Member 'ATedProjectile::TargetLocation' has a wrong offset!");
static_assert(offsetof(ATedProjectile, StartLocation) == 0x000410, "Member 'ATedProjectile::StartLocation' has a wrong offset!");
static_assert(offsetof(ATedProjectile, CachedDamagedPawns) == 0x000428, "Member 'ATedProjectile::CachedDamagedPawns' has a wrong offset!");
static_assert(offsetof(ATedProjectile, TrackedSupportPowerTag) == 0x000458, "Member 'ATedProjectile::TrackedSupportPowerTag' has a wrong offset!");

// Class Tempest.BTTask_RunTedAIQuery_RefineryDeployLocation
// 0x0080 (0x0120 - 0x00A0)
class UBTTask_RunTedAIQuery_RefineryDeployLocation final : public UBTTask_RunTedAIQuery
{
public:
	struct FBlackboardKeySelector                 OutResourceVolumeKey;                              // 0x00A0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   RefineryClass;                                     // 0x00C8(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AdditionalSearchExtentTiles;                       // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLocationInsideVolume;                             // 0x00F4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTestNeighborTilesForResource;                     // 0x00F5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F6[0x2];                                       // 0x00F6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FQueryTestConfig_Distance_RefineryDeployLoc> DistanceTests;                        // 0x00F8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FQueryTestConfig_Value                 ResourceTest;                                      // 0x0108(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RunTedAIQuery_RefineryDeployLocation">();
	}
	static class UBTTask_RunTedAIQuery_RefineryDeployLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RunTedAIQuery_RefineryDeployLocation>();
	}
};
static_assert(alignof(UBTTask_RunTedAIQuery_RefineryDeployLocation) == 0x000008, "Wrong alignment on UBTTask_RunTedAIQuery_RefineryDeployLocation");
static_assert(sizeof(UBTTask_RunTedAIQuery_RefineryDeployLocation) == 0x000120, "Wrong size on UBTTask_RunTedAIQuery_RefineryDeployLocation");
static_assert(offsetof(UBTTask_RunTedAIQuery_RefineryDeployLocation, OutResourceVolumeKey) == 0x0000A0, "Member 'UBTTask_RunTedAIQuery_RefineryDeployLocation::OutResourceVolumeKey' has a wrong offset!");
static_assert(offsetof(UBTTask_RunTedAIQuery_RefineryDeployLocation, RefineryClass) == 0x0000C8, "Member 'UBTTask_RunTedAIQuery_RefineryDeployLocation::RefineryClass' has a wrong offset!");
static_assert(offsetof(UBTTask_RunTedAIQuery_RefineryDeployLocation, AdditionalSearchExtentTiles) == 0x0000F0, "Member 'UBTTask_RunTedAIQuery_RefineryDeployLocation::AdditionalSearchExtentTiles' has a wrong offset!");
static_assert(offsetof(UBTTask_RunTedAIQuery_RefineryDeployLocation, bLocationInsideVolume) == 0x0000F4, "Member 'UBTTask_RunTedAIQuery_RefineryDeployLocation::bLocationInsideVolume' has a wrong offset!");
static_assert(offsetof(UBTTask_RunTedAIQuery_RefineryDeployLocation, bTestNeighborTilesForResource) == 0x0000F5, "Member 'UBTTask_RunTedAIQuery_RefineryDeployLocation::bTestNeighborTilesForResource' has a wrong offset!");
static_assert(offsetof(UBTTask_RunTedAIQuery_RefineryDeployLocation, DistanceTests) == 0x0000F8, "Member 'UBTTask_RunTedAIQuery_RefineryDeployLocation::DistanceTests' has a wrong offset!");
static_assert(offsetof(UBTTask_RunTedAIQuery_RefineryDeployLocation, ResourceTest) == 0x000108, "Member 'UBTTask_RunTedAIQuery_RefineryDeployLocation::ResourceTest' has a wrong offset!");

// Class Tempest.TedWidgetExtension
// 0x0000 (0x0028 - 0x0028)
class UTedWidgetExtension : public UUserWidgetExtension
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedWidgetExtension">();
	}
	static class UTedWidgetExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedWidgetExtension>();
	}
};
static_assert(alignof(UTedWidgetExtension) == 0x000008, "Wrong alignment on UTedWidgetExtension");
static_assert(sizeof(UTedWidgetExtension) == 0x000028, "Wrong size on UTedWidgetExtension");

// Class Tempest.TedWidgetVisibilityExtension
// 0x0008 (0x0030 - 0x0028)
class UTedWidgetVisibilityExtension : public UTedWidgetExtension
{
public:
	ESlateVisibility                              WidgetDesiredVisibility;                           // 0x0028(0x0001)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedWidgetVisibilityExtension">();
	}
	static class UTedWidgetVisibilityExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedWidgetVisibilityExtension>();
	}
};
static_assert(alignof(UTedWidgetVisibilityExtension) == 0x000008, "Wrong alignment on UTedWidgetVisibilityExtension");
static_assert(sizeof(UTedWidgetVisibilityExtension) == 0x000030, "Wrong size on UTedWidgetVisibilityExtension");
static_assert(offsetof(UTedWidgetVisibilityExtension, WidgetDesiredVisibility) == 0x000028, "Member 'UTedWidgetVisibilityExtension::WidgetDesiredVisibility' has a wrong offset!");

// Class Tempest.BTTask_SetCurrentWeapon
// 0x0030 (0x00A0 - 0x0070)
class UBTTask_SetCurrentWeapon final : public UBTTaskNode
{
public:
	bool                                          bUseDefinitionTag;                                 // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           WeaponDefinitionAssetTag;                          // 0x0074(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  WeaponOwnedTags;                                   // 0x0080(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_SetCurrentWeapon">();
	}
	static class UBTTask_SetCurrentWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_SetCurrentWeapon>();
	}
};
static_assert(alignof(UBTTask_SetCurrentWeapon) == 0x000008, "Wrong alignment on UBTTask_SetCurrentWeapon");
static_assert(sizeof(UBTTask_SetCurrentWeapon) == 0x0000A0, "Wrong size on UBTTask_SetCurrentWeapon");
static_assert(offsetof(UBTTask_SetCurrentWeapon, bUseDefinitionTag) == 0x000070, "Member 'UBTTask_SetCurrentWeapon::bUseDefinitionTag' has a wrong offset!");
static_assert(offsetof(UBTTask_SetCurrentWeapon, WeaponDefinitionAssetTag) == 0x000074, "Member 'UBTTask_SetCurrentWeapon::WeaponDefinitionAssetTag' has a wrong offset!");
static_assert(offsetof(UBTTask_SetCurrentWeapon, WeaponOwnedTags) == 0x000080, "Member 'UBTTask_SetCurrentWeapon::WeaponOwnedTags' has a wrong offset!");

// Class Tempest.BTTask_SetFollowUnit
// 0x0038 (0x00D0 - 0x0098)
class UBTTask_SetFollowUnit final : public UBTTask_BlackboardBase
{
public:
	uint8                                         bClear : 1;                                        // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bOverrideSpeedAdjustmentDistance : 1;              // 0x0098(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bExplicitSpeedAdjustmentDistanceVaue : 1;          // 0x0098(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 SpeedAdjustmentDistanceKey;                        // 0x00A0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         SpeedAdjustmentDistanceMultiplier;                 // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeedAdjustmentDistance;                           // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_SetFollowUnit">();
	}
	static class UBTTask_SetFollowUnit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_SetFollowUnit>();
	}
};
static_assert(alignof(UBTTask_SetFollowUnit) == 0x000008, "Wrong alignment on UBTTask_SetFollowUnit");
static_assert(sizeof(UBTTask_SetFollowUnit) == 0x0000D0, "Wrong size on UBTTask_SetFollowUnit");
static_assert(offsetof(UBTTask_SetFollowUnit, SpeedAdjustmentDistanceKey) == 0x0000A0, "Member 'UBTTask_SetFollowUnit::SpeedAdjustmentDistanceKey' has a wrong offset!");
static_assert(offsetof(UBTTask_SetFollowUnit, SpeedAdjustmentDistanceMultiplier) == 0x0000C8, "Member 'UBTTask_SetFollowUnit::SpeedAdjustmentDistanceMultiplier' has a wrong offset!");
static_assert(offsetof(UBTTask_SetFollowUnit, SpeedAdjustmentDistance) == 0x0000CC, "Member 'UBTTask_SetFollowUnit::SpeedAdjustmentDistance' has a wrong offset!");

// Class Tempest.BTTask_TedFollow
// 0x0008 (0x00C0 - 0x00B8)
class UBTTask_TedFollow final : public UBTTask_TedMoveTo
{
public:
	bool                                          bTestPreviousTargetLocation;                       // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_TedFollow">();
	}
	static class UBTTask_TedFollow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_TedFollow>();
	}
};
static_assert(alignof(UBTTask_TedFollow) == 0x000008, "Wrong alignment on UBTTask_TedFollow");
static_assert(sizeof(UBTTask_TedFollow) == 0x0000C0, "Wrong size on UBTTask_TedFollow");
static_assert(offsetof(UBTTask_TedFollow, bTestPreviousTargetLocation) == 0x0000B8, "Member 'UBTTask_TedFollow::bTestPreviousTargetLocation' has a wrong offset!");

// Class Tempest.TedGlobals
// 0x0160 (0x0188 - 0x0028)
class UTedGlobals final : public UObject
{
public:
	uint8                                         DifficultyOverride;                                // 0x0028(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0xEF];                                      // 0x0029(0x00EF)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   FoliageInteractionManagerClass;                    // 0x0118(0x0028)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   VehicleCrushEffectClass;                           // 0x0140(0x0028)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           MinimapForceOnTag;                                 // 0x0168(0x0008)(Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           MinimapForceOffTag;                                // 0x0170(0x0008)(Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           MinimapRequirementTag;                             // 0x0178(0x0008)(Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           MinimapIgnoreRequirementTag;                       // 0x0180(0x0008)(Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGlobals">();
	}
	static class UTedGlobals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedGlobals>();
	}
};
static_assert(alignof(UTedGlobals) == 0x000008, "Wrong alignment on UTedGlobals");
static_assert(sizeof(UTedGlobals) == 0x000188, "Wrong size on UTedGlobals");
static_assert(offsetof(UTedGlobals, DifficultyOverride) == 0x000028, "Member 'UTedGlobals::DifficultyOverride' has a wrong offset!");
static_assert(offsetof(UTedGlobals, FoliageInteractionManagerClass) == 0x000118, "Member 'UTedGlobals::FoliageInteractionManagerClass' has a wrong offset!");
static_assert(offsetof(UTedGlobals, VehicleCrushEffectClass) == 0x000140, "Member 'UTedGlobals::VehicleCrushEffectClass' has a wrong offset!");
static_assert(offsetof(UTedGlobals, MinimapForceOnTag) == 0x000168, "Member 'UTedGlobals::MinimapForceOnTag' has a wrong offset!");
static_assert(offsetof(UTedGlobals, MinimapForceOffTag) == 0x000170, "Member 'UTedGlobals::MinimapForceOffTag' has a wrong offset!");
static_assert(offsetof(UTedGlobals, MinimapRequirementTag) == 0x000178, "Member 'UTedGlobals::MinimapRequirementTag' has a wrong offset!");
static_assert(offsetof(UTedGlobals, MinimapIgnoreRequirementTag) == 0x000180, "Member 'UTedGlobals::MinimapIgnoreRequirementTag' has a wrong offset!");

// Class Tempest.TedProjectile_Tracer
// 0x0068 (0x04C8 - 0x0460)
class ATedProjectile_Tracer : public ATedProjectile
{
public:
	class UStaticMeshComponent*                   Mesh;                                              // 0x0460(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemAsset*                         TracerFX;                                          // 0x0468(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TracerEndParameterName;                            // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChanceToSpawnTracerFX;                             // 0x0478(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_47C[0x4C];                                     // 0x047C(0x004C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedProjectile_Tracer">();
	}
	static class ATedProjectile_Tracer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedProjectile_Tracer>();
	}
};
static_assert(alignof(ATedProjectile_Tracer) == 0x000008, "Wrong alignment on ATedProjectile_Tracer");
static_assert(sizeof(ATedProjectile_Tracer) == 0x0004C8, "Wrong size on ATedProjectile_Tracer");
static_assert(offsetof(ATedProjectile_Tracer, Mesh) == 0x000460, "Member 'ATedProjectile_Tracer::Mesh' has a wrong offset!");
static_assert(offsetof(ATedProjectile_Tracer, TracerFX) == 0x000468, "Member 'ATedProjectile_Tracer::TracerFX' has a wrong offset!");
static_assert(offsetof(ATedProjectile_Tracer, TracerEndParameterName) == 0x000470, "Member 'ATedProjectile_Tracer::TracerEndParameterName' has a wrong offset!");
static_assert(offsetof(ATedProjectile_Tracer, ChanceToSpawnTracerFX) == 0x000478, "Member 'ATedProjectile_Tracer::ChanceToSpawnTracerFX' has a wrong offset!");

// Class Tempest.BTTask_TryActivateAbility
// 0x0068 (0x00D8 - 0x0070)
class UBTTask_TryActivateAbility : public UBTTaskNode
{
public:
	uint8                                         bWaitTillAbilityEnd : 1;                           // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 TargetBlackboardKey;                               // 0x0078(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 CommandClassBlackboardKey;                         // 0x00A0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UTedAbilityBase>            AbilityClassToActivate;                            // 0x00C8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBehaviorTreeComponent*                 MyOwner;                                           // 0x00D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_TryActivateAbility">();
	}
	static class UBTTask_TryActivateAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_TryActivateAbility>();
	}
};
static_assert(alignof(UBTTask_TryActivateAbility) == 0x000008, "Wrong alignment on UBTTask_TryActivateAbility");
static_assert(sizeof(UBTTask_TryActivateAbility) == 0x0000D8, "Wrong size on UBTTask_TryActivateAbility");
static_assert(offsetof(UBTTask_TryActivateAbility, TargetBlackboardKey) == 0x000078, "Member 'UBTTask_TryActivateAbility::TargetBlackboardKey' has a wrong offset!");
static_assert(offsetof(UBTTask_TryActivateAbility, CommandClassBlackboardKey) == 0x0000A0, "Member 'UBTTask_TryActivateAbility::CommandClassBlackboardKey' has a wrong offset!");
static_assert(offsetof(UBTTask_TryActivateAbility, AbilityClassToActivate) == 0x0000C8, "Member 'UBTTask_TryActivateAbility::AbilityClassToActivate' has a wrong offset!");
static_assert(offsetof(UBTTask_TryActivateAbility, MyOwner) == 0x0000D0, "Member 'UBTTask_TryActivateAbility::MyOwner' has a wrong offset!");

// Class Tempest.TedWorkerButton
// 0x0038 (0x0438 - 0x0400)
class UTedWorkerButton : public UTedUserWidget
{
public:
	class ATedPlayerController*                   CachedPC;                                          // 0x0400(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_408[0x8];                                      // 0x0408(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 Abstract_Icon;                                     // 0x0410(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Unit_Icon;                                         // 0x0418(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Damage_Icon;                                       // 0x0420(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedWorkersWidget*                      CachedWorkersWidget;                               // 0x0428(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_430[0x8];                                      // 0x0430(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleDamageIcon();
	void K2_OnSingleWorkerHealthChanged(float OldValue, float NewValue);
	void SetWorkerData(class ATedPawn* WorkerPawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedWorkerButton">();
	}
	static class UTedWorkerButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedWorkerButton>();
	}
};
static_assert(alignof(UTedWorkerButton) == 0x000008, "Wrong alignment on UTedWorkerButton");
static_assert(sizeof(UTedWorkerButton) == 0x000438, "Wrong size on UTedWorkerButton");
static_assert(offsetof(UTedWorkerButton, CachedPC) == 0x000400, "Member 'UTedWorkerButton::CachedPC' has a wrong offset!");
static_assert(offsetof(UTedWorkerButton, Abstract_Icon) == 0x000410, "Member 'UTedWorkerButton::Abstract_Icon' has a wrong offset!");
static_assert(offsetof(UTedWorkerButton, Unit_Icon) == 0x000418, "Member 'UTedWorkerButton::Unit_Icon' has a wrong offset!");
static_assert(offsetof(UTedWorkerButton, Damage_Icon) == 0x000420, "Member 'UTedWorkerButton::Damage_Icon' has a wrong offset!");
static_assert(offsetof(UTedWorkerButton, CachedWorkersWidget) == 0x000428, "Member 'UTedWorkerButton::CachedWorkersWidget' has a wrong offset!");

// Class Tempest.BTTask_TryActivateAbilityBlackboard
// 0x0028 (0x0100 - 0x00D8)
class UBTTask_TryActivateAbilityBlackboard final : public UBTTask_TryActivateAbility
{
public:
	struct FBlackboardKeySelector                 AbilityBlackboardKey;                              // 0x00D8(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_TryActivateAbilityBlackboard">();
	}
	static class UBTTask_TryActivateAbilityBlackboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_TryActivateAbilityBlackboard>();
	}
};
static_assert(alignof(UBTTask_TryActivateAbilityBlackboard) == 0x000008, "Wrong alignment on UBTTask_TryActivateAbilityBlackboard");
static_assert(sizeof(UBTTask_TryActivateAbilityBlackboard) == 0x000100, "Wrong size on UBTTask_TryActivateAbilityBlackboard");
static_assert(offsetof(UBTTask_TryActivateAbilityBlackboard, AbilityBlackboardKey) == 0x0000D8, "Member 'UBTTask_TryActivateAbilityBlackboard::AbilityBlackboardKey' has a wrong offset!");

// Class Tempest.BTTask_TryActivateAbilityByClass
// 0x0008 (0x00E0 - 0x00D8)
class UBTTask_TryActivateAbilityByClass final : public UBTTask_TryActivateAbility
{
public:
	TSubclassOf<class UTedAbilityBase>            AbilityClass;                                      // 0x00D8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_TryActivateAbilityByClass">();
	}
	static class UBTTask_TryActivateAbilityByClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_TryActivateAbilityByClass>();
	}
};
static_assert(alignof(UBTTask_TryActivateAbilityByClass) == 0x000008, "Wrong alignment on UBTTask_TryActivateAbilityByClass");
static_assert(sizeof(UBTTask_TryActivateAbilityByClass) == 0x0000E0, "Wrong size on UBTTask_TryActivateAbilityByClass");
static_assert(offsetof(UBTTask_TryActivateAbilityByClass, AbilityClass) == 0x0000D8, "Member 'UBTTask_TryActivateAbilityByClass::AbilityClass' has a wrong offset!");

// Class Tempest.BTTask_TryActivateAbilityByTag
// 0x0020 (0x00F8 - 0x00D8)
class UBTTask_TryActivateAbilityByTag final : public UBTTask_TryActivateAbility
{
public:
	struct FGameplayTagContainer                  AbilityTags;                                       // 0x00D8(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_TryActivateAbilityByTag">();
	}
	static class UBTTask_TryActivateAbilityByTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_TryActivateAbilityByTag>();
	}
};
static_assert(alignof(UBTTask_TryActivateAbilityByTag) == 0x000008, "Wrong alignment on UBTTask_TryActivateAbilityByTag");
static_assert(sizeof(UBTTask_TryActivateAbilityByTag) == 0x0000F8, "Wrong size on UBTTask_TryActivateAbilityByTag");
static_assert(offsetof(UBTTask_TryActivateAbilityByTag, AbilityTags) == 0x0000D8, "Member 'UBTTask_TryActivateAbilityByTag::AbilityTags' has a wrong offset!");

// Class Tempest.TedHUDInstancedValueProcessor
// 0x0010 (0x0038 - 0x0028)
class UTedHUDInstancedValueProcessor : public UObject
{
public:
	bool                                          bDebugSelected;                                    // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedHUDInstancedBarWidget*              CachedOwner;                                       // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedHUDInstancedValueProcessor">();
	}
	static class UTedHUDInstancedValueProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedHUDInstancedValueProcessor>();
	}
};
static_assert(alignof(UTedHUDInstancedValueProcessor) == 0x000008, "Wrong alignment on UTedHUDInstancedValueProcessor");
static_assert(sizeof(UTedHUDInstancedValueProcessor) == 0x000038, "Wrong size on UTedHUDInstancedValueProcessor");
static_assert(offsetof(UTedHUDInstancedValueProcessor, bDebugSelected) == 0x000028, "Member 'UTedHUDInstancedValueProcessor::bDebugSelected' has a wrong offset!");
static_assert(offsetof(UTedHUDInstancedValueProcessor, CachedOwner) == 0x000030, "Member 'UTedHUDInstancedValueProcessor::CachedOwner' has a wrong offset!");

// Class Tempest.TedUnitAmmoProcessor
// 0x0008 (0x0040 - 0x0038)
class UTedUnitAmmoProcessor final : public UTedHUDInstancedValueProcessor
{
public:
	uint8                                         bAllowIrregularSegments : 1;                       // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitAmmoProcessor">();
	}
	static class UTedUnitAmmoProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUnitAmmoProcessor>();
	}
};
static_assert(alignof(UTedUnitAmmoProcessor) == 0x000008, "Wrong alignment on UTedUnitAmmoProcessor");
static_assert(sizeof(UTedUnitAmmoProcessor) == 0x000040, "Wrong size on UTedUnitAmmoProcessor");

// Class Tempest.BTTask_UpdateLeashLocation
// 0x0000 (0x0098 - 0x0098)
class UBTTask_UpdateLeashLocation final : public UBTTask_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_UpdateLeashLocation">();
	}
	static class UBTTask_UpdateLeashLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_UpdateLeashLocation>();
	}
};
static_assert(alignof(UBTTask_UpdateLeashLocation) == 0x000008, "Wrong alignment on UBTTask_UpdateLeashLocation");
static_assert(sizeof(UBTTask_UpdateLeashLocation) == 0x000098, "Wrong size on UBTTask_UpdateLeashLocation");

// Class Tempest.TedTextBlock_TypeWriter
// 0x0100 (0x0470 - 0x0370)
class UTedTextBlock_TypeWriter : public UTextBlock
{
public:
	TMulticastInlineDelegate<void(class UTedTextBlock_TypeWriter* InWidget)> OnStart;                // 0x0368(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTedTextBlock_TypeWriter* InWidget)> OnFinish;               // 0x0378(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTedTextBlock_TypeWriter* InWidget)> OnChange;               // 0x0388(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FText                                   ActualText;                                        // 0x0398(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         bAnimateDuringPause : 1;                           // 0x03A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3A9[0x3];                                      // 0x03A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x03AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bUseCurve : 1;                                     // 0x03B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3B1[0x7];                                      // 0x03B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     Curve;                                             // 0x03B8(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         StartTime;                                         // 0x0440(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LastDisplayedLettersNum;                           // 0x0444(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   LastDisplayedText;                                 // 0x0448(0x0010)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_458[0x18];                                     // 0x0458(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnableCurve(const bool bInEnable);
	void Finish();
	class FText GetCurrentText();
	void K2_SetActualText(const class FText& InText);
	void Reset();
	void SetCurve(const struct FRuntimeFloatCurve& InCurve);
	void SetCurveFromAsset(class UCurveFloat* InCurve);
	void SetDuration(const float InDuration);
	void Start();

	bool CanAnimateDuringPause() const;
	float GetDuration() const;
	float GetElapsedTime(const bool bInClampToDuration) const;
	float GetProgress() const;
	float GetRemainingTime() const;
	float GetStartTime() const;
	bool IsRunning() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedTextBlock_TypeWriter">();
	}
	static class UTedTextBlock_TypeWriter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedTextBlock_TypeWriter>();
	}
};
static_assert(alignof(UTedTextBlock_TypeWriter) == 0x000010, "Wrong alignment on UTedTextBlock_TypeWriter");
static_assert(sizeof(UTedTextBlock_TypeWriter) == 0x000470, "Wrong size on UTedTextBlock_TypeWriter");
static_assert(offsetof(UTedTextBlock_TypeWriter, OnStart) == 0x000368, "Member 'UTedTextBlock_TypeWriter::OnStart' has a wrong offset!");
static_assert(offsetof(UTedTextBlock_TypeWriter, OnFinish) == 0x000378, "Member 'UTedTextBlock_TypeWriter::OnFinish' has a wrong offset!");
static_assert(offsetof(UTedTextBlock_TypeWriter, OnChange) == 0x000388, "Member 'UTedTextBlock_TypeWriter::OnChange' has a wrong offset!");
static_assert(offsetof(UTedTextBlock_TypeWriter, ActualText) == 0x000398, "Member 'UTedTextBlock_TypeWriter::ActualText' has a wrong offset!");
static_assert(offsetof(UTedTextBlock_TypeWriter, Duration) == 0x0003AC, "Member 'UTedTextBlock_TypeWriter::Duration' has a wrong offset!");
static_assert(offsetof(UTedTextBlock_TypeWriter, Curve) == 0x0003B8, "Member 'UTedTextBlock_TypeWriter::Curve' has a wrong offset!");
static_assert(offsetof(UTedTextBlock_TypeWriter, StartTime) == 0x000440, "Member 'UTedTextBlock_TypeWriter::StartTime' has a wrong offset!");
static_assert(offsetof(UTedTextBlock_TypeWriter, LastDisplayedLettersNum) == 0x000444, "Member 'UTedTextBlock_TypeWriter::LastDisplayedLettersNum' has a wrong offset!");
static_assert(offsetof(UTedTextBlock_TypeWriter, LastDisplayedText) == 0x000448, "Member 'UTedTextBlock_TypeWriter::LastDisplayedText' has a wrong offset!");

// Class Tempest.TedTextBlock_TypeWriter_VO
// 0x0000 (0x0470 - 0x0470)
class UTedTextBlock_TypeWriter_VO final : public UTedTextBlock_TypeWriter
{
public:
	class UAudioComponent* StartVO(class USoundBase* InVO, const class FText& InText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedTextBlock_TypeWriter_VO">();
	}
	static class UTedTextBlock_TypeWriter_VO* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedTextBlock_TypeWriter_VO>();
	}
};
static_assert(alignof(UTedTextBlock_TypeWriter_VO) == 0x000010, "Wrong alignment on UTedTextBlock_TypeWriter_VO");
static_assert(sizeof(UTedTextBlock_TypeWriter_VO) == 0x000470, "Wrong size on UTedTextBlock_TypeWriter_VO");

// Class Tempest.TedHotspotConfig
// 0x0010 (0x0040 - 0x0030)
class UTedHotspotConfig final : public UDataAsset
{
public:
	float                                         Duration;                                          // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Priority;                                          // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HotspotRadius;                                     // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseTargetLocation;                                // 0x003C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetDuration() const;
	float GetHotspotRadius() const;
	int32 GetPriority() const;
	bool IsUsingTargetLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedHotspotConfig">();
	}
	static class UTedHotspotConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedHotspotConfig>();
	}
};
static_assert(alignof(UTedHotspotConfig) == 0x000008, "Wrong alignment on UTedHotspotConfig");
static_assert(sizeof(UTedHotspotConfig) == 0x000040, "Wrong size on UTedHotspotConfig");
static_assert(offsetof(UTedHotspotConfig, Duration) == 0x000030, "Member 'UTedHotspotConfig::Duration' has a wrong offset!");
static_assert(offsetof(UTedHotspotConfig, Priority) == 0x000034, "Member 'UTedHotspotConfig::Priority' has a wrong offset!");
static_assert(offsetof(UTedHotspotConfig, HotspotRadius) == 0x000038, "Member 'UTedHotspotConfig::HotspotRadius' has a wrong offset!");
static_assert(offsetof(UTedHotspotConfig, bUseTargetLocation) == 0x00003C, "Member 'UTedHotspotConfig::bUseTargetLocation' has a wrong offset!");

// Class Tempest.TedHealthBarsProxyWidget
// 0x0058 (0x0458 - 0x0400)
class UTedHealthBarsProxyWidget final : public UTedUserWidget
{
public:
	TArray<struct FTedHealthBarConfig>            Configs;                                           // 0x0400(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         FlashDuration;                                     // 0x0410(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_414[0x4];                                      // 0x0414(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              OffsetOnScreen;                                    // 0x0418(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        DataPackingPrecission;                             // 0x0428(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MinDisplayLengthParam;                             // 0x042C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MaxDisplayLengthParam;                             // 0x0434(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DisplayHeightParam;                                // 0x043C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DataPackingPrecissionParam;                        // 0x0444(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44C[0x4];                                      // 0x044C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedProceduralMeshWidget*               HealthBarsWidget;                                  // 0x0450(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedHealthBarsProxyWidget">();
	}
	static class UTedHealthBarsProxyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedHealthBarsProxyWidget>();
	}
};
static_assert(alignof(UTedHealthBarsProxyWidget) == 0x000008, "Wrong alignment on UTedHealthBarsProxyWidget");
static_assert(sizeof(UTedHealthBarsProxyWidget) == 0x000458, "Wrong size on UTedHealthBarsProxyWidget");
static_assert(offsetof(UTedHealthBarsProxyWidget, Configs) == 0x000400, "Member 'UTedHealthBarsProxyWidget::Configs' has a wrong offset!");
static_assert(offsetof(UTedHealthBarsProxyWidget, FlashDuration) == 0x000410, "Member 'UTedHealthBarsProxyWidget::FlashDuration' has a wrong offset!");
static_assert(offsetof(UTedHealthBarsProxyWidget, OffsetOnScreen) == 0x000418, "Member 'UTedHealthBarsProxyWidget::OffsetOnScreen' has a wrong offset!");
static_assert(offsetof(UTedHealthBarsProxyWidget, DataPackingPrecission) == 0x000428, "Member 'UTedHealthBarsProxyWidget::DataPackingPrecission' has a wrong offset!");
static_assert(offsetof(UTedHealthBarsProxyWidget, MinDisplayLengthParam) == 0x00042C, "Member 'UTedHealthBarsProxyWidget::MinDisplayLengthParam' has a wrong offset!");
static_assert(offsetof(UTedHealthBarsProxyWidget, MaxDisplayLengthParam) == 0x000434, "Member 'UTedHealthBarsProxyWidget::MaxDisplayLengthParam' has a wrong offset!");
static_assert(offsetof(UTedHealthBarsProxyWidget, DisplayHeightParam) == 0x00043C, "Member 'UTedHealthBarsProxyWidget::DisplayHeightParam' has a wrong offset!");
static_assert(offsetof(UTedHealthBarsProxyWidget, DataPackingPrecissionParam) == 0x000444, "Member 'UTedHealthBarsProxyWidget::DataPackingPrecissionParam' has a wrong offset!");
static_assert(offsetof(UTedHealthBarsProxyWidget, HealthBarsWidget) == 0x000450, "Member 'UTedHealthBarsProxyWidget::HealthBarsWidget' has a wrong offset!");

// Class Tempest.TedCampaignSlotsPanel
// 0x0018 (0x07C8 - 0x07B0)
class UTedCampaignSlotsPanel final : public UTedContentPanelDynamic
{
public:
	class UTedFactionCampaignWidget*              CachedFactionWidget;                               // 0x07B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTedSavedGameProfileInfo*>       content;                                           // 0x07B8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void SlotRequest_Delete(int32 SlotIndex);

	class UTedSavedGameProfileInfo* GetSlotContentData(int32 SlotIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCampaignSlotsPanel">();
	}
	static class UTedCampaignSlotsPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCampaignSlotsPanel>();
	}
};
static_assert(alignof(UTedCampaignSlotsPanel) == 0x000008, "Wrong alignment on UTedCampaignSlotsPanel");
static_assert(sizeof(UTedCampaignSlotsPanel) == 0x0007C8, "Wrong size on UTedCampaignSlotsPanel");
static_assert(offsetof(UTedCampaignSlotsPanel, CachedFactionWidget) == 0x0007B0, "Member 'UTedCampaignSlotsPanel::CachedFactionWidget' has a wrong offset!");
static_assert(offsetof(UTedCampaignSlotsPanel, content) == 0x0007B8, "Member 'UTedCampaignSlotsPanel::content' has a wrong offset!");

// Class Tempest.TedUIFunctionsLibrary
// 0x0000 (0x0028 - 0x0028)
class UTedUIFunctionsLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FText AbbreviateTextBeyondLength(const class FText& InText, const int32 InLength);
	static class FText BotDifficultyAsLocalizedText(const ETedBotDifficulty Difficulty);
	static ETedFaction BranchUITheme(const class UObject* WorldContext);
	static void CalculateMinimapLocation(const struct FBox& InWorldBounds, const struct FVector2D& InWorldLocation, const struct FVector2D& InMinimapSize, struct FVector2D* OutResult);
	static struct FVector2D CalculateTextSize(const class FText& InText, const struct FSlateFontInfo& InFont);
	static class FString CapitalizeFirstLetter(const class FString& InString);
	static class FText CleanupPlayerName(const class FString& InPlayerName, const uint8 InMaxLength);
	static class FText DifficultyAsText(ETedGameDifficulty Difficulty);
	static void EvaluateRowAndColumn_Columns(const int32 InSlotIndex, const int32 InColumns, int32* OutRow, int32* OutColumn);
	static void EvaluateRowAndColumn_Rows(const int32 InSlotIndex, const int32 InRows, int32* OutRow, int32* OutColumn);
	static TArray<class UWidget*> FindChildrenOfType(const class UUserWidget* Widget, TSubclassOf<class UWidget> Class_0);
	static class USlateBrushAsset* GetBrushFromSelector(const struct FTedContentSlotStateAssetSelector& InSelector, const ETedContentSlotState InState);
	static class USlateBrushAsset* GetBrushFromSelector_ContentSlot(const struct FTedContentSlotStateAssetSelector& InSelector, const class UTedContentPanelSlotBase* InWidget);
	static ETedGameDifficulty GetCampaignDifficulty(const class UObject* InWorldContext);
	static class FText GetChordDisplayText(const struct FInputChord& InChord, const bool bInLong);
	static class FText GetChordDisplayTextLoose(const struct FKey& InPrimaryKey, const struct FKey& InSecondaryKey, const bool bInShift, const bool bInCtrl, const bool bInAlt, const bool bInLong);
	static void GetCompletedMapRequisitionReward(const class UObject* InWorldContext, const class UTedMapInfo* MapInfo, int32* GainedRequisition, int32* TotalRequisition, ETedGameDifficulty Difficulty);
	static class FText GetDateTimeShort(const struct FDateTime& InDateTime);
	static class FText GetFactionName(const ETedFaction InFaction);
	static class FText GetFormattedText(const struct FTedFormattedText& InText);
	static ETedGameDifficulty GetHighestCompletedMapDifficulty(const class UObject* InWorldContext, const class UTedMapInfo* MapInfo);
	static struct FInputChord GetInputActionChord(const class FName InInputActionName);
	static class FText GetInputActionDisplayText(const class UInputAction* InputAction, const class ULocalPlayer* InLocalPlayer, const bool bInLong);
	static struct FKey GetInputActionKey(const class UInputAction* InputAction, const class ULocalPlayer* InLocalPlayer);
	static class FText GetInputActionMappingDisplayText(const struct FInputActionKeyMapping& InMapping, const bool bInLong);
	static struct FKey GetInputAxisKey(const class FName InInputAxisName);
	static class FText GetInputAxisMappingDisplayText(const struct FInputAxisKeyMapping& InMapping, const bool bInLong);
	static class FText GetInputDisplayText(const class FName& InInputName, const bool bInAction, const bool bInLong);
	static struct FKey GetInputMappingKey(const class FName InMappingName, const class ULocalPlayer* InLocalPlayer);
	static bool GetInputShortcut_Action(const class FName& InKeyBinding, struct FInputChord* OutShortcut);
	static class FText GetKeyDisplayText(const struct FKey& InKey, const bool bInLong);
	static void GetMapProgressData(const class UObject* InWorldContext, const class UTedMapInfo* MapInfo, struct FObjectivesData* OutObjectivesData);
	static class UMaterialInterface* GetMaterialFromSelector(const struct FTedContentSlotStateAssetSelector& InSelector, const ETedContentSlotState InState);
	static class UMaterialInterface* GetMaterialFromSelector_ContentSlot(const struct FTedContentSlotStateAssetSelector& InSelector, const class UTedContentPanelSlotBase* InWidget);
	static class FText GetNameForBot(const ETedBotDifficulty InDifficulty);
	static class UWidget* GetOuterWidget(const class UUserWidget* InChild, const TSubclassOf<class UWidget> OuterWidgetClass);
	static struct FMargin GetPanelSlotPadding(const class UWidget* InWidget);
	static struct FLinearColor GetPerceivedPlayerColor(const class UObject* InWorldContext, const ETedPlayerID PlayerID);
	static class FText GetPlayerName(const class UObject* InWorldContext, const int32 InPlayerIndex, const uint8 InMaxLength, const bool bShouldAddElipsis);
	static class FText GetPlayerNameFromPlayerState(const class APlayerState* InPlayerState, const uint8 InMaxLength, const bool bShouldAddElipsis);
	static class FText GetShortcutChordDisplayText(const struct FTedShortcutChordUI& InShortcutChord, const bool bInIgnoreSecondary, const bool bInLong);
	static class FText GetShortcutDisplayText(const struct FTedShortcutUI& InShortcut, const bool bInLong);
	static class USlateWidgetStyleAsset* GetStyleFromSelector(const struct FTedContentSlotStateAssetSelector& InSelector, const ETedContentSlotState InState);
	static class USlateWidgetStyleAsset* GetStyleFromSelector_ContentSlot(const struct FTedContentSlotStateAssetSelector& InSelector, const class UTedContentPanelSlotBase* InWidget);
	static class FText GetTeamName(const ETedTeamID InTeam);
	static class UTexture2D* GetTextureFromSelector(const struct FTedContentSlotStateAssetSelector& InSelector, const ETedContentSlotState InState);
	static class UTexture2D* GetTextureFromSelector_ContentSlot(const struct FTedContentSlotStateAssetSelector& InSelector, const class UTedContentPanelSlotBase* InWidget);
	static const class UFileMediaSource* GetThemedMovie(const class UObject* InWorldContext, const struct FTedThemeMovie& InMovie);
	static struct FMargin GetTotalPanelSlotPaddingBetween(const class UWidget* InWidget, const class UWidget* InRootWidget);
	static ETedFaction GetUITheme(const class UObject* WorldContext);
	static void GetUnitCardWeaponWidthWidth(float* OutFixedWidth, float* OutMinWidth, float* OutMaxWidth);
	static void HideMeshWidget(const class UObject* WorldContext, const struct FGameplayTag& Source);
	static bool IsAnyMoviePlaying(const class UObject* InWorldContext);
	static bool IsInputChordValid(const struct FInputChord& InChord);
	static bool IsMoviePlaying(const class UObject* InWorldContext, const ETedMovieType InMovieType);
	static bool IsSlateBrushDefault(const struct FSlateBrush& InBrush);
	static bool IsWidgetRendered(const class UWidget* Widget);
	static bool IsWidgetVisible(const class UWidget* Widget);
	static void MarkEULAAsRead();
	static void PauseMovie(const class UObject* InWorldContext, const ETedMovieType InMovieType);
	static void PopulatePanelWithUpgradeDescriptions(class UTedContentPanelInstanced* InPanel, const class UTedUpgrade* InUpgrade, const class ATedPlayerState* InContextPlayerState);
	static struct FTedTooltipDisplayParams ReplaceTooltipParamsHeaderAndDescription(struct FTedTooltipDisplayParams& InTooltip, const class FText& InHeader, const class FText& InDescription);
	static void ResumeMovie(const class UObject* InWorldContext, const ETedMovieType InMovieType);
	static bool ShouldAnyChildrenBeVisible(const class UPanelWidget* InPanel);
	static bool ShouldShowEULA();
	static void ShowMeshWidget(const class UObject* WorldContext, const struct FGameplayTag& Source, const struct FGameplayTag& Target, class UObject* ContextObject);
	static void StopMovie(const class UObject* InWorldContext, const ETedMovieType InMovieType);
	static void SynchronizeWrapAtWithSizeBoxWidth(class UTextBlock* InTextBlock, const class USizeBox* InSizeBox);
	static ETedUI_TransitionState Transition_GetState(const struct FTedUI_Transition_Tickable& InTransition);
	static ETedUI_TransitionState Transition_GetStateExec(const struct FTedUI_Transition_Tickable& InTransition);
	static void Transition_Reset(struct FTedUI_Transition_Tickable& Transition, const float InValue);
	static void Transition_SetDuration(struct FTedUI_Transition_Tickable& Transition, const float InDuration);
	static void Transition_SetTarget(struct FTedUI_Transition_Tickable& Transition, const float InTarget);
	static void Transition_SetTargetByDirection(struct FTedUI_Transition_Tickable& Transition, const bool bInForward);
	static ETedUI_TransitionState Transition_Tick(struct FTedUI_Transition_Tickable& Transition, const float InDeltaSeconds, float* OutCurrent);
	static ETedUI_TransitionState Transition_TickExec(struct FTedUI_Transition_Tickable& Transition, const float InDeltaSeconds, float* OutCurrent);
	static float TransitionCurve_GetValue(const struct FTedUI_TransitionCurve& InCurve, const float InAlpha);
	static float TransitionCurve_GetValueByTransition(const struct FTedUI_TransitionCurve& InCurve, const struct FTedUI_Transition_Tickable& InTransition);
	static ETedUI_TransitionState TransitionCurve_Tick(struct FTedUI_Transition_Tickable& Transition, const struct FTedUI_TransitionCurve& InCurve, const float InDeltaSeconds, float* OutCurrent, float* OutCurveValue);
	static ETedUI_TransitionState TransitionCurve_TickExec(struct FTedUI_Transition_Tickable& Transition, const struct FTedUI_TransitionCurve& InCurve, const float InDeltaSeconds, float* OutCurrent, float* OutCurveValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUIFunctionsLibrary">();
	}
	static class UTedUIFunctionsLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUIFunctionsLibrary>();
	}
};
static_assert(alignof(UTedUIFunctionsLibrary) == 0x000008, "Wrong alignment on UTedUIFunctionsLibrary");
static_assert(sizeof(UTedUIFunctionsLibrary) == 0x000028, "Wrong size on UTedUIFunctionsLibrary");

// Class Tempest.EffectsAnimationCurve
// 0x0180 (0x01B0 - 0x0030)
class UEffectsAnimationCurve final : public UCurveBase
{
public:
	struct FRichCurve                             FloatCurves[0x3];                                  // 0x0030(0x0080)(Protected, NativeAccessSpecifierProtected)

public:
	float GetAnimationTime() const;
	float GetDisplacementXValue(float InTime) const;
	float GetDisplacementYValue(float InTime) const;
	float GetOpacityValue(float InTime) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectsAnimationCurve">();
	}
	static class UEffectsAnimationCurve* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectsAnimationCurve>();
	}
};
static_assert(alignof(UEffectsAnimationCurve) == 0x000008, "Wrong alignment on UEffectsAnimationCurve");
static_assert(sizeof(UEffectsAnimationCurve) == 0x0001B0, "Wrong size on UEffectsAnimationCurve");
static_assert(offsetof(UEffectsAnimationCurve, FloatCurves) == 0x000030, "Member 'UEffectsAnimationCurve::FloatCurves' has a wrong offset!");

// Class Tempest.TedUnitHealthProcessor
// 0x0058 (0x0090 - 0x0038)
class UTedUnitHealthProcessor final : public UTedHUDInstancedValueProcessor
{
public:
	float                                         FlashDuration;                                     // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAllowIrregularSegments : 1;                       // 0x003C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETedPawnType, float>                     RuleRatios;                                        // 0x0040(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitHealthProcessor">();
	}
	static class UTedUnitHealthProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUnitHealthProcessor>();
	}
};
static_assert(alignof(UTedUnitHealthProcessor) == 0x000008, "Wrong alignment on UTedUnitHealthProcessor");
static_assert(sizeof(UTedUnitHealthProcessor) == 0x000090, "Wrong size on UTedUnitHealthProcessor");
static_assert(offsetof(UTedUnitHealthProcessor, FlashDuration) == 0x000038, "Member 'UTedUnitHealthProcessor::FlashDuration' has a wrong offset!");
static_assert(offsetof(UTedUnitHealthProcessor, RuleRatios) == 0x000040, "Member 'UTedUnitHealthProcessor::RuleRatios' has a wrong offset!");

// Class Tempest.TedMenuScreenWidget
// 0x0058 (0x0458 - 0x0400)
class UTedMenuScreenWidget : public UTedUserWidget
{
public:
	uint8                                         bPauseGameInSP : 1;                                // 0x0400(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCloseOnGoingBack : 1;                             // 0x0400(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_401[0x57];                                     // 0x0401(0x0057)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TMap<class UWidget*, uint8> GetWidgetBackPriorities();
	void GoBack(bool& bFoundWidgetWithGoBackPriority);
	void OnClose(const class UObject* InContext, bool bInInstant);
	void OnOpen(const class UObject* InContext, bool bInInstant);
	void OnWidgetHiddenOnGoBack(class UWidget* InWidget, const uint8 InPriority);
	void ShowCosmeticCinematicsBars(const bool ShowBar);

	bool CanClose(const class UObject* InContext) const;
	bool CanGoBack() const;
	bool CanOpen(const class UObject* InContext) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMenuScreenWidget">();
	}
	static class UTedMenuScreenWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMenuScreenWidget>();
	}
};
static_assert(alignof(UTedMenuScreenWidget) == 0x000008, "Wrong alignment on UTedMenuScreenWidget");
static_assert(sizeof(UTedMenuScreenWidget) == 0x000458, "Wrong size on UTedMenuScreenWidget");

// Class Tempest.TedFactionCampaignWidget
// 0x00A0 (0x04F8 - 0x0458)
class UTedFactionCampaignWidget final : public UTedMenuScreenWidget
{
public:
	class UTedCampaignSlotsPanel*                 CampaignSlots;                                     // 0x0458(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTedSaveLoadContentPanel*               SaveSlotsPanel;                                    // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTedContentPanelInstanced*              ButtonsPanel;                                      // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             Text_MissionTitle;                                 // 0x0470(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             Text_MissionLocation_Value;                        // 0x0478(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             Text_MissionObjective_Value;                       // 0x0480(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             Text_MissionTranscript;                            // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTedCampaignInfo*                       CachedSelectedCampaign;                            // 0x0490(0x0008)(BlueprintVisible, ZeroConstructor, Transient, DuplicateTransient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStringTable>            AttachedStringTable;                               // 0x0498(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTedSavedGameProfileInfo*               CachedProfileToRename;                             // 0x04C0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CachedSlotIndex;                                   // 0x04C8(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4CC[0x4];                                      // 0x04CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedPopup*                              Popup;                                             // 0x04D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTedPopup*                              Popup_LoadGame;                                    // 0x04D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTedDropDown*                           CachedDifficultyDropDown;                          // 0x04E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDeleteSaveGameConfirm;                           // 0x04E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	class FText DescribeDifficultyOptionsForPopup(const int32 Option);
	void HandlePopupCalled(EPopupAction Action);
	void HandleStartCampaignButtonPressed();
	void OnButtonsPanelSlotAction(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction);
	void OnCreateCampaignClicked(int32 Idx);
	void OnDeleteCampaignClicked(int32 Idx);
	void OnDeleteSaveClicked(int32 PopupButtonIdx);
	void OnRenameCampaignClicked(int32 Idx);
	void OnSaveSlotAction(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction);
	void PopupCancel(const int32 Idx);

	bool AreThereValidCampaignSlots() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedFactionCampaignWidget">();
	}
	static class UTedFactionCampaignWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedFactionCampaignWidget>();
	}
};
static_assert(alignof(UTedFactionCampaignWidget) == 0x000008, "Wrong alignment on UTedFactionCampaignWidget");
static_assert(sizeof(UTedFactionCampaignWidget) == 0x0004F8, "Wrong size on UTedFactionCampaignWidget");
static_assert(offsetof(UTedFactionCampaignWidget, CampaignSlots) == 0x000458, "Member 'UTedFactionCampaignWidget::CampaignSlots' has a wrong offset!");
static_assert(offsetof(UTedFactionCampaignWidget, SaveSlotsPanel) == 0x000460, "Member 'UTedFactionCampaignWidget::SaveSlotsPanel' has a wrong offset!");
static_assert(offsetof(UTedFactionCampaignWidget, ButtonsPanel) == 0x000468, "Member 'UTedFactionCampaignWidget::ButtonsPanel' has a wrong offset!");
static_assert(offsetof(UTedFactionCampaignWidget, Text_MissionTitle) == 0x000470, "Member 'UTedFactionCampaignWidget::Text_MissionTitle' has a wrong offset!");
static_assert(offsetof(UTedFactionCampaignWidget, Text_MissionLocation_Value) == 0x000478, "Member 'UTedFactionCampaignWidget::Text_MissionLocation_Value' has a wrong offset!");
static_assert(offsetof(UTedFactionCampaignWidget, Text_MissionObjective_Value) == 0x000480, "Member 'UTedFactionCampaignWidget::Text_MissionObjective_Value' has a wrong offset!");
static_assert(offsetof(UTedFactionCampaignWidget, Text_MissionTranscript) == 0x000488, "Member 'UTedFactionCampaignWidget::Text_MissionTranscript' has a wrong offset!");
static_assert(offsetof(UTedFactionCampaignWidget, CachedSelectedCampaign) == 0x000490, "Member 'UTedFactionCampaignWidget::CachedSelectedCampaign' has a wrong offset!");
static_assert(offsetof(UTedFactionCampaignWidget, AttachedStringTable) == 0x000498, "Member 'UTedFactionCampaignWidget::AttachedStringTable' has a wrong offset!");
static_assert(offsetof(UTedFactionCampaignWidget, CachedProfileToRename) == 0x0004C0, "Member 'UTedFactionCampaignWidget::CachedProfileToRename' has a wrong offset!");
static_assert(offsetof(UTedFactionCampaignWidget, CachedSlotIndex) == 0x0004C8, "Member 'UTedFactionCampaignWidget::CachedSlotIndex' has a wrong offset!");
static_assert(offsetof(UTedFactionCampaignWidget, Popup) == 0x0004D0, "Member 'UTedFactionCampaignWidget::Popup' has a wrong offset!");
static_assert(offsetof(UTedFactionCampaignWidget, Popup_LoadGame) == 0x0004D8, "Member 'UTedFactionCampaignWidget::Popup_LoadGame' has a wrong offset!");
static_assert(offsetof(UTedFactionCampaignWidget, CachedDifficultyDropDown) == 0x0004E0, "Member 'UTedFactionCampaignWidget::CachedDifficultyDropDown' has a wrong offset!");
static_assert(offsetof(UTedFactionCampaignWidget, OnDeleteSaveGameConfirm) == 0x0004E8, "Member 'UTedFactionCampaignWidget::OnDeleteSaveGameConfirm' has a wrong offset!");

// Class Tempest.TedUnitMovementComponent
// 0x0138 (0x02A0 - 0x0168)
class UTedUnitMovementComponent : public UPawnMovementComponent
{
public:
	class ATedUnitBase*                           UnitOwner;                                         // 0x0168(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMovementMode                                 MovementMode;                                      // 0x0170(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         CustomMovementMode;                                // 0x0171(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_172[0x2];                                      // 0x0172(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GroundFriction;                                    // 0x0174(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAcceleration;                                   // 0x0178(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxParachuteSpeed;                                 // 0x017C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BrakingFrictionFactor;                             // 0x0180(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BrakingFriction;                                   // 0x0184(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BrakingSubStepTime;                                // 0x0188(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BrakingDecelerationWalking;                        // 0x018C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BrakingDecelerationFlying;                         // 0x0190(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               RotationRate;                                      // 0x0198(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bUseSeparateBrakingFriction : 1;                   // 0x01B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseControllerDesiredRotation : 1;                 // 0x01B0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bOrientRotationToMovement : 1;                     // 0x01B0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bOrientRotationTowardsFocus : 1;                   // 0x01B0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bRunPhysicsWithNoController : 1;                   // 0x01B0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	EMovementMode                                 DefaultLandMovementMode;                           // 0x01B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B2[0x2];                                      // 0x01B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdjustmentToFloorInterpSpeed;                      // 0x01B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OutOfNavmeshExtentXY;                              // 0x01B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bProjectOnNavGrid;                                 // 0x01BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1BD[0x3];                                      // 0x01BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ValidGroundLocationOffset;                         // 0x01C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bMaintainHorizontalGroundVelocity : 1;             // 0x01C4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1C5[0xDB];                                     // 0x01C5(0x00DB)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CalcVelocity(float DeltaTime, float Friction, bool bFluid, float BrakingDeceleration);
	void DisableMovement();
	void SetMovementMode(EMovementMode NewMovementMode, uint8 NewCustomMode);

	struct FVector GetCurrentAcceleration() const;
	float GetMaxAcceleration() const;
	float GetMaxBrakingDeceleration() const;
	EMovementMode GetMovementMode() const;
	class ATedUnitBase* GetUnitOwner() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitMovementComponent">();
	}
	static class UTedUnitMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUnitMovementComponent>();
	}
};
static_assert(alignof(UTedUnitMovementComponent) == 0x000008, "Wrong alignment on UTedUnitMovementComponent");
static_assert(sizeof(UTedUnitMovementComponent) == 0x0002A0, "Wrong size on UTedUnitMovementComponent");
static_assert(offsetof(UTedUnitMovementComponent, UnitOwner) == 0x000168, "Member 'UTedUnitMovementComponent::UnitOwner' has a wrong offset!");
static_assert(offsetof(UTedUnitMovementComponent, MovementMode) == 0x000170, "Member 'UTedUnitMovementComponent::MovementMode' has a wrong offset!");
static_assert(offsetof(UTedUnitMovementComponent, CustomMovementMode) == 0x000171, "Member 'UTedUnitMovementComponent::CustomMovementMode' has a wrong offset!");
static_assert(offsetof(UTedUnitMovementComponent, GroundFriction) == 0x000174, "Member 'UTedUnitMovementComponent::GroundFriction' has a wrong offset!");
static_assert(offsetof(UTedUnitMovementComponent, MaxAcceleration) == 0x000178, "Member 'UTedUnitMovementComponent::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(UTedUnitMovementComponent, MaxParachuteSpeed) == 0x00017C, "Member 'UTedUnitMovementComponent::MaxParachuteSpeed' has a wrong offset!");
static_assert(offsetof(UTedUnitMovementComponent, BrakingFrictionFactor) == 0x000180, "Member 'UTedUnitMovementComponent::BrakingFrictionFactor' has a wrong offset!");
static_assert(offsetof(UTedUnitMovementComponent, BrakingFriction) == 0x000184, "Member 'UTedUnitMovementComponent::BrakingFriction' has a wrong offset!");
static_assert(offsetof(UTedUnitMovementComponent, BrakingSubStepTime) == 0x000188, "Member 'UTedUnitMovementComponent::BrakingSubStepTime' has a wrong offset!");
static_assert(offsetof(UTedUnitMovementComponent, BrakingDecelerationWalking) == 0x00018C, "Member 'UTedUnitMovementComponent::BrakingDecelerationWalking' has a wrong offset!");
static_assert(offsetof(UTedUnitMovementComponent, BrakingDecelerationFlying) == 0x000190, "Member 'UTedUnitMovementComponent::BrakingDecelerationFlying' has a wrong offset!");
static_assert(offsetof(UTedUnitMovementComponent, RotationRate) == 0x000198, "Member 'UTedUnitMovementComponent::RotationRate' has a wrong offset!");
static_assert(offsetof(UTedUnitMovementComponent, DefaultLandMovementMode) == 0x0001B1, "Member 'UTedUnitMovementComponent::DefaultLandMovementMode' has a wrong offset!");
static_assert(offsetof(UTedUnitMovementComponent, AdjustmentToFloorInterpSpeed) == 0x0001B4, "Member 'UTedUnitMovementComponent::AdjustmentToFloorInterpSpeed' has a wrong offset!");
static_assert(offsetof(UTedUnitMovementComponent, OutOfNavmeshExtentXY) == 0x0001B8, "Member 'UTedUnitMovementComponent::OutOfNavmeshExtentXY' has a wrong offset!");
static_assert(offsetof(UTedUnitMovementComponent, bProjectOnNavGrid) == 0x0001BC, "Member 'UTedUnitMovementComponent::bProjectOnNavGrid' has a wrong offset!");
static_assert(offsetof(UTedUnitMovementComponent, ValidGroundLocationOffset) == 0x0001C0, "Member 'UTedUnitMovementComponent::ValidGroundLocationOffset' has a wrong offset!");

// Class Tempest.TedInfantryMovementComponent
// 0x0000 (0x02A0 - 0x02A0)
class UTedInfantryMovementComponent final : public UTedUnitMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedInfantryMovementComponent">();
	}
	static class UTedInfantryMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedInfantryMovementComponent>();
	}
};
static_assert(alignof(UTedInfantryMovementComponent) == 0x000008, "Wrong alignment on UTedInfantryMovementComponent");
static_assert(sizeof(UTedInfantryMovementComponent) == 0x0002A0, "Wrong size on UTedInfantryMovementComponent");

// Class Tempest.FactionSelectionMenuScreenWidget
// 0x0018 (0x0470 - 0x0458)
class UFactionSelectionMenuScreenWidget final : public UTedMenuScreenWidget
{
public:
	bool                                          bWasCampaingStarted;                               // 0x0458(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_459[0x7];                                      // 0x0459(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedCampaignInfo*                       CachedSelectedCampaign;                            // 0x0460(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedGameDifficulty                            CachedDifficulty;                                  // 0x0468(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_469[0x7];                                      // 0x0469(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CacheSelectedCampaign(const class UTedCampaignInfo* InCampaign);
	void CacheSelectedDifficulty(const ETedGameDifficulty InDifficulty);

	const class UTedCampaignInfo* GetSelectedCampaign() const;
	bool WasAnyCampaignStarted() const;
	bool WasCampaignStarted(const class UTedCampaignInfo* InCampaign) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FactionSelectionMenuScreenWidget">();
	}
	static class UFactionSelectionMenuScreenWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFactionSelectionMenuScreenWidget>();
	}
};
static_assert(alignof(UFactionSelectionMenuScreenWidget) == 0x000008, "Wrong alignment on UFactionSelectionMenuScreenWidget");
static_assert(sizeof(UFactionSelectionMenuScreenWidget) == 0x000470, "Wrong size on UFactionSelectionMenuScreenWidget");
static_assert(offsetof(UFactionSelectionMenuScreenWidget, bWasCampaingStarted) == 0x000458, "Member 'UFactionSelectionMenuScreenWidget::bWasCampaingStarted' has a wrong offset!");
static_assert(offsetof(UFactionSelectionMenuScreenWidget, CachedSelectedCampaign) == 0x000460, "Member 'UFactionSelectionMenuScreenWidget::CachedSelectedCampaign' has a wrong offset!");
static_assert(offsetof(UFactionSelectionMenuScreenWidget, CachedDifficulty) == 0x000468, "Member 'UFactionSelectionMenuScreenWidget::CachedDifficulty' has a wrong offset!");

// Class Tempest.TedUnitCommand_AirMission
// 0x0008 (0x0578 - 0x0570)
class UTedUnitCommand_AirMission : public UTedPawnCommandWithBehavior
{
public:
	uint8                                         Pad_570[0x8];                                      // 0x0570(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitCommand_AirMission">();
	}
	static class UTedUnitCommand_AirMission* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUnitCommand_AirMission>();
	}
};
static_assert(alignof(UTedUnitCommand_AirMission) == 0x000008, "Wrong alignment on UTedUnitCommand_AirMission");
static_assert(sizeof(UTedUnitCommand_AirMission) == 0x000578, "Wrong size on UTedUnitCommand_AirMission");

// Class Tempest.TedUnitCommand_AirStrike
// 0x0000 (0x0578 - 0x0578)
class UTedUnitCommand_AirStrike : public UTedUnitCommand_AirMission
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitCommand_AirStrike">();
	}
	static class UTedUnitCommand_AirStrike* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUnitCommand_AirStrike>();
	}
};
static_assert(alignof(UTedUnitCommand_AirStrike) == 0x000008, "Wrong alignment on UTedUnitCommand_AirStrike");
static_assert(sizeof(UTedUnitCommand_AirStrike) == 0x000578, "Wrong size on UTedUnitCommand_AirStrike");

// Class Tempest.FoliageClusterActor
// 0x0098 (0x0328 - 0x0290)
class AFoliageClusterActor final : public AActor
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<uint32, struct FVector>                  ClusterTiles;                                      // 0x0298(0x0050)(Protected, NativeAccessSpecifierProtected)
	struct FBox                                   ClusterBounds;                                     // 0x02E8(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_320[0x8];                                      // 0x0320(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FoliageClusterActor">();
	}
	static class AFoliageClusterActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFoliageClusterActor>();
	}
};
static_assert(alignof(AFoliageClusterActor) == 0x000008, "Wrong alignment on AFoliageClusterActor");
static_assert(sizeof(AFoliageClusterActor) == 0x000328, "Wrong size on AFoliageClusterActor");
static_assert(offsetof(AFoliageClusterActor, ClusterTiles) == 0x000298, "Member 'AFoliageClusterActor::ClusterTiles' has a wrong offset!");
static_assert(offsetof(AFoliageClusterActor, ClusterBounds) == 0x0002E8, "Member 'AFoliageClusterActor::ClusterBounds' has a wrong offset!");

// Class Tempest.TedBuildSellCaptureTimedProcessor
// 0x0000 (0x0038 - 0x0038)
class UTedBuildSellCaptureTimedProcessor final : public UTedHUDInstancedValueProcessor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedBuildSellCaptureTimedProcessor">();
	}
	static class UTedBuildSellCaptureTimedProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedBuildSellCaptureTimedProcessor>();
	}
};
static_assert(alignof(UTedBuildSellCaptureTimedProcessor) == 0x000008, "Wrong alignment on UTedBuildSellCaptureTimedProcessor");
static_assert(sizeof(UTedBuildSellCaptureTimedProcessor) == 0x000038, "Wrong size on UTedBuildSellCaptureTimedProcessor");

// Class Tempest.FoliageInteractionManager
// 0x0040 (0x02D0 - 0x0290)
class AFoliageInteractionManager final : public AActor
{
public:
	int32                                         MaxFoliageInteractionSounds;                       // 0x0290(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_294[0x4];                                      // 0x0294(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FFoliageOverlapRequest>         FoliageOverlapRequests;                            // 0x02A0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFoliageChannelData>            FoliageChannelData;                                // 0x02B0(0x0010)(Net, ZeroConstructor, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UAudioComponent*>                SpawnedSounds;                                     // 0x02C0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnRep_FoliageChannelData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FoliageInteractionManager">();
	}
	static class AFoliageInteractionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFoliageInteractionManager>();
	}
};
static_assert(alignof(AFoliageInteractionManager) == 0x000008, "Wrong alignment on AFoliageInteractionManager");
static_assert(sizeof(AFoliageInteractionManager) == 0x0002D0, "Wrong size on AFoliageInteractionManager");
static_assert(offsetof(AFoliageInteractionManager, MaxFoliageInteractionSounds) == 0x000290, "Member 'AFoliageInteractionManager::MaxFoliageInteractionSounds' has a wrong offset!");
static_assert(offsetof(AFoliageInteractionManager, DefaultSceneRoot) == 0x000298, "Member 'AFoliageInteractionManager::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AFoliageInteractionManager, FoliageOverlapRequests) == 0x0002A0, "Member 'AFoliageInteractionManager::FoliageOverlapRequests' has a wrong offset!");
static_assert(offsetof(AFoliageInteractionManager, FoliageChannelData) == 0x0002B0, "Member 'AFoliageInteractionManager::FoliageChannelData' has a wrong offset!");
static_assert(offsetof(AFoliageInteractionManager, SpawnedSounds) == 0x0002C0, "Member 'AFoliageInteractionManager::SpawnedSounds' has a wrong offset!");

// Class Tempest.FoliageInteractionSettings
// 0x0008 (0x0030 - 0x0028)
class UFoliageInteractionSettings final : public UAssetUserData
{
public:
	class UTedFoliageInteractionConfig*           FoliageConfig;                                     // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FoliageInteractionSettings">();
	}
	static class UFoliageInteractionSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFoliageInteractionSettings>();
	}
};
static_assert(alignof(UFoliageInteractionSettings) == 0x000008, "Wrong alignment on UFoliageInteractionSettings");
static_assert(sizeof(UFoliageInteractionSettings) == 0x000030, "Wrong size on UFoliageInteractionSettings");
static_assert(offsetof(UFoliageInteractionSettings, FoliageConfig) == 0x000028, "Member 'UFoliageInteractionSettings::FoliageConfig' has a wrong offset!");

// Class Tempest.TedHUDInstancedBarWidget
// 0x0180 (0x0580 - 0x0400)
class UTedHUDInstancedBarWidget : public UTedUserWidget
{
public:
	TMap<ETedBarType, struct FTedBaseBarConfig>   Configs;                                           // 0x0400(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<ETedBarType>                           DisplayOrder;                                      // 0x0450(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<ETedPawnType, float>                     MinLength;                                         // 0x0460(0x0050)(Edit, NativeAccessSpecifierPublic)
	float                                         MaxLength;                                         // 0x04B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlashDuration;                                     // 0x04B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OffsetOnScreen;                                    // 0x04B8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        DataPackingPrecission;                             // 0x04C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ColorLookupTableWidthParam;                        // 0x04CC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ColorLookupTableParam;                             // 0x04D4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MinDisplayLengthParam;                             // 0x04DC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaxDisplayLengthParam;                             // 0x04E4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DisplayHeightParam;                                // 0x04EC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DisplayPaddingParam;                               // 0x04F4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DataPackingPrecissionParam;                        // 0x04FC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_504[0x4];                                      // 0x0504(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedProceduralMeshWidget*               BarWidget;                                         // 0x0508(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_510[0x60];                                     // 0x0510(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDrawPreview;                                      // 0x0570(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_571[0x3];                                      // 0x0571(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxPreviewLength;                                  // 0x0574(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             ColorLookupTexture;                                // 0x0578(0x0008)(Edit, ZeroConstructor, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ColorLookupResolved(const class URTSColorSubsystem* InSubsystem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedHUDInstancedBarWidget">();
	}
	static class UTedHUDInstancedBarWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedHUDInstancedBarWidget>();
	}
};
static_assert(alignof(UTedHUDInstancedBarWidget) == 0x000008, "Wrong alignment on UTedHUDInstancedBarWidget");
static_assert(sizeof(UTedHUDInstancedBarWidget) == 0x000580, "Wrong size on UTedHUDInstancedBarWidget");
static_assert(offsetof(UTedHUDInstancedBarWidget, Configs) == 0x000400, "Member 'UTedHUDInstancedBarWidget::Configs' has a wrong offset!");
static_assert(offsetof(UTedHUDInstancedBarWidget, DisplayOrder) == 0x000450, "Member 'UTedHUDInstancedBarWidget::DisplayOrder' has a wrong offset!");
static_assert(offsetof(UTedHUDInstancedBarWidget, MinLength) == 0x000460, "Member 'UTedHUDInstancedBarWidget::MinLength' has a wrong offset!");
static_assert(offsetof(UTedHUDInstancedBarWidget, MaxLength) == 0x0004B0, "Member 'UTedHUDInstancedBarWidget::MaxLength' has a wrong offset!");
static_assert(offsetof(UTedHUDInstancedBarWidget, FlashDuration) == 0x0004B4, "Member 'UTedHUDInstancedBarWidget::FlashDuration' has a wrong offset!");
static_assert(offsetof(UTedHUDInstancedBarWidget, OffsetOnScreen) == 0x0004B8, "Member 'UTedHUDInstancedBarWidget::OffsetOnScreen' has a wrong offset!");
static_assert(offsetof(UTedHUDInstancedBarWidget, DataPackingPrecission) == 0x0004C8, "Member 'UTedHUDInstancedBarWidget::DataPackingPrecission' has a wrong offset!");
static_assert(offsetof(UTedHUDInstancedBarWidget, ColorLookupTableWidthParam) == 0x0004CC, "Member 'UTedHUDInstancedBarWidget::ColorLookupTableWidthParam' has a wrong offset!");
static_assert(offsetof(UTedHUDInstancedBarWidget, ColorLookupTableParam) == 0x0004D4, "Member 'UTedHUDInstancedBarWidget::ColorLookupTableParam' has a wrong offset!");
static_assert(offsetof(UTedHUDInstancedBarWidget, MinDisplayLengthParam) == 0x0004DC, "Member 'UTedHUDInstancedBarWidget::MinDisplayLengthParam' has a wrong offset!");
static_assert(offsetof(UTedHUDInstancedBarWidget, MaxDisplayLengthParam) == 0x0004E4, "Member 'UTedHUDInstancedBarWidget::MaxDisplayLengthParam' has a wrong offset!");
static_assert(offsetof(UTedHUDInstancedBarWidget, DisplayHeightParam) == 0x0004EC, "Member 'UTedHUDInstancedBarWidget::DisplayHeightParam' has a wrong offset!");
static_assert(offsetof(UTedHUDInstancedBarWidget, DisplayPaddingParam) == 0x0004F4, "Member 'UTedHUDInstancedBarWidget::DisplayPaddingParam' has a wrong offset!");
static_assert(offsetof(UTedHUDInstancedBarWidget, DataPackingPrecissionParam) == 0x0004FC, "Member 'UTedHUDInstancedBarWidget::DataPackingPrecissionParam' has a wrong offset!");
static_assert(offsetof(UTedHUDInstancedBarWidget, BarWidget) == 0x000508, "Member 'UTedHUDInstancedBarWidget::BarWidget' has a wrong offset!");
static_assert(offsetof(UTedHUDInstancedBarWidget, bDrawPreview) == 0x000570, "Member 'UTedHUDInstancedBarWidget::bDrawPreview' has a wrong offset!");
static_assert(offsetof(UTedHUDInstancedBarWidget, MaxPreviewLength) == 0x000574, "Member 'UTedHUDInstancedBarWidget::MaxPreviewLength' has a wrong offset!");
static_assert(offsetof(UTedHUDInstancedBarWidget, ColorLookupTexture) == 0x000578, "Member 'UTedHUDInstancedBarWidget::ColorLookupTexture' has a wrong offset!");

// Class Tempest.GEARRepair
// 0x0130 (0x0158 - 0x0028)
class UGEARRepair : public UGameplayEffectCustomApplicationRequirement
{
public:
	struct FGameplayTagContainer                  EntityTypesToRepair;                               // 0x0028(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagRequirements               SourceTagRequirements;                             // 0x0048(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagRequirements               TargetTagsRequirements;                            // 0x00D0(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEARRepair">();
	}
	static class UGEARRepair* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEARRepair>();
	}
};
static_assert(alignof(UGEARRepair) == 0x000008, "Wrong alignment on UGEARRepair");
static_assert(sizeof(UGEARRepair) == 0x000158, "Wrong size on UGEARRepair");
static_assert(offsetof(UGEARRepair, EntityTypesToRepair) == 0x000028, "Member 'UGEARRepair::EntityTypesToRepair' has a wrong offset!");
static_assert(offsetof(UGEARRepair, SourceTagRequirements) == 0x000048, "Member 'UGEARRepair::SourceTagRequirements' has a wrong offset!");
static_assert(offsetof(UGEARRepair, TargetTagsRequirements) == 0x0000D0, "Member 'UGEARRepair::TargetTagsRequirements' has a wrong offset!");

// Class Tempest.TedPawnCommandWithBehavior_Ability
// 0x0050 (0x05C0 - 0x0570)
class UTedPawnCommandWithBehavior_Ability : public UTedPawnCommandWithBehavior
{
public:
	uint8                                         bUseCommandDataPayload : 1;                        // 0x0570(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseAbilityTags : 1;                               // 0x0570(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_571[0x7];                                      // 0x0571(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   AbilityClassToActivate;                            // 0x0578(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  AbilityTags;                                       // 0x05A0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommandWithBehavior_Ability">();
	}
	static class UTedPawnCommandWithBehavior_Ability* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnCommandWithBehavior_Ability>();
	}
};
static_assert(alignof(UTedPawnCommandWithBehavior_Ability) == 0x000008, "Wrong alignment on UTedPawnCommandWithBehavior_Ability");
static_assert(sizeof(UTedPawnCommandWithBehavior_Ability) == 0x0005C0, "Wrong size on UTedPawnCommandWithBehavior_Ability");
static_assert(offsetof(UTedPawnCommandWithBehavior_Ability, AbilityClassToActivate) == 0x000578, "Member 'UTedPawnCommandWithBehavior_Ability::AbilityClassToActivate' has a wrong offset!");
static_assert(offsetof(UTedPawnCommandWithBehavior_Ability, AbilityTags) == 0x0005A0, "Member 'UTedPawnCommandWithBehavior_Ability::AbilityTags' has a wrong offset!");

// Class Tempest.TedUnitCommand_DeployStructure
// 0x0008 (0x05C8 - 0x05C0)
class UTedUnitCommand_DeployStructure : public UTedPawnCommandWithBehavior_Ability
{
public:
	int32                                         MaxDeployNodeSearchDepth;                          // 0x05C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C4[0x4];                                      // 0x05C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitCommand_DeployStructure">();
	}
	static class UTedUnitCommand_DeployStructure* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUnitCommand_DeployStructure>();
	}
};
static_assert(alignof(UTedUnitCommand_DeployStructure) == 0x000008, "Wrong alignment on UTedUnitCommand_DeployStructure");
static_assert(sizeof(UTedUnitCommand_DeployStructure) == 0x0005C8, "Wrong size on UTedUnitCommand_DeployStructure");
static_assert(offsetof(UTedUnitCommand_DeployStructure, MaxDeployNodeSearchDepth) == 0x0005C0, "Member 'UTedUnitCommand_DeployStructure::MaxDeployNodeSearchDepth' has a wrong offset!");

// Class Tempest.GEARTempestDynamos
// 0x0008 (0x0030 - 0x0028)
class UGEARTempestDynamos : public UGameplayEffectCustomApplicationRequirement
{
public:
	float                                         HealthPctCutoff;                                   // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreLowPower;                                   // 0x002C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEARTempestDynamos">();
	}
	static class UGEARTempestDynamos* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEARTempestDynamos>();
	}
};
static_assert(alignof(UGEARTempestDynamos) == 0x000008, "Wrong alignment on UGEARTempestDynamos");
static_assert(sizeof(UGEARTempestDynamos) == 0x000030, "Wrong size on UGEARTempestDynamos");
static_assert(offsetof(UGEARTempestDynamos, HealthPctCutoff) == 0x000028, "Member 'UGEARTempestDynamos::HealthPctCutoff' has a wrong offset!");
static_assert(offsetof(UGEARTempestDynamos, bIgnoreLowPower) == 0x00002C, "Member 'UGEARTempestDynamos::bIgnoreLowPower' has a wrong offset!");

// Class Tempest.TedImageSequenceSource
// 0x0008 (0x00D8 - 0x00D0)
class UTedImageSequenceSource final : public UImgMediaSource
{
public:
	class USoundBase*                             Sound;                                             // 0x00D0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class USoundBase* GetSound() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedImageSequenceSource">();
	}
	static class UTedImageSequenceSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedImageSequenceSource>();
	}
};
static_assert(alignof(UTedImageSequenceSource) == 0x000008, "Wrong alignment on UTedImageSequenceSource");
static_assert(sizeof(UTedImageSequenceSource) == 0x0000D8, "Wrong size on UTedImageSequenceSource");
static_assert(offsetof(UTedImageSequenceSource, Sound) == 0x0000D0, "Member 'UTedImageSequenceSource::Sound' has a wrong offset!");

// Class Tempest.GEAR_OnTempestResource
// 0x0000 (0x0028 - 0x0028)
class UGEAR_OnTempestResource final : public UGameplayEffectCustomApplicationRequirement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEAR_OnTempestResource">();
	}
	static class UGEAR_OnTempestResource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEAR_OnTempestResource>();
	}
};
static_assert(alignof(UGEAR_OnTempestResource) == 0x000008, "Wrong alignment on UGEAR_OnTempestResource");
static_assert(sizeof(UGEAR_OnTempestResource) == 0x000028, "Wrong size on UGEAR_OnTempestResource");

// Class Tempest.GEAR_PlayerHasTags
// 0x0020 (0x0048 - 0x0028)
class UGEAR_PlayerHasTags : public UGameplayEffectCustomApplicationRequirement
{
public:
	struct FGameplayTagContainer                  RequiredTags;                                      // 0x0028(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEAR_PlayerHasTags">();
	}
	static class UGEAR_PlayerHasTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEAR_PlayerHasTags>();
	}
};
static_assert(alignof(UGEAR_PlayerHasTags) == 0x000008, "Wrong alignment on UGEAR_PlayerHasTags");
static_assert(sizeof(UGEAR_PlayerHasTags) == 0x000048, "Wrong size on UGEAR_PlayerHasTags");
static_assert(offsetof(UGEAR_PlayerHasTags, RequiredTags) == 0x000028, "Member 'UGEAR_PlayerHasTags::RequiredTags' has a wrong offset!");

// Class Tempest.TedInfluenceMap_Pawn
// 0x0010 (0x0038 - 0x0028)
class UTedInfluenceMap_Pawn : public UInfluenceMap
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedInfluenceMap_Pawn">();
	}
	static class UTedInfluenceMap_Pawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedInfluenceMap_Pawn>();
	}
};
static_assert(alignof(UTedInfluenceMap_Pawn) == 0x000008, "Wrong alignment on UTedInfluenceMap_Pawn");
static_assert(sizeof(UTedInfluenceMap_Pawn) == 0x000038, "Wrong size on UTedInfluenceMap_Pawn");

// Class Tempest.TedInfluenceMap_Threat
// 0x0000 (0x0038 - 0x0038)
class UTedInfluenceMap_Threat : public UTedInfluenceMap_Pawn
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedInfluenceMap_Threat">();
	}
	static class UTedInfluenceMap_Threat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedInfluenceMap_Threat>();
	}
};
static_assert(alignof(UTedInfluenceMap_Threat) == 0x000008, "Wrong alignment on UTedInfluenceMap_Threat");
static_assert(sizeof(UTedInfluenceMap_Threat) == 0x000038, "Wrong size on UTedInfluenceMap_Threat");

// Class Tempest.TedInfluenceMap_FriendlyThreat
// 0x0000 (0x0038 - 0x0038)
class UTedInfluenceMap_FriendlyThreat : public UTedInfluenceMap_Threat
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedInfluenceMap_FriendlyThreat">();
	}
	static class UTedInfluenceMap_FriendlyThreat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedInfluenceMap_FriendlyThreat>();
	}
};
static_assert(alignof(UTedInfluenceMap_FriendlyThreat) == 0x000008, "Wrong alignment on UTedInfluenceMap_FriendlyThreat");
static_assert(sizeof(UTedInfluenceMap_FriendlyThreat) == 0x000038, "Wrong size on UTedInfluenceMap_FriendlyThreat");

// Class Tempest.GECTedAttachCommand
// 0x0008 (0x0030 - 0x0028)
class UGECTedAttachCommand final : public UGameplayEffectUIData
{
public:
	TSubclassOf<class UTedCommand>                AttachedCommand;                                   // 0x0028(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GECTedAttachCommand">();
	}
	static class UGECTedAttachCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGECTedAttachCommand>();
	}
};
static_assert(alignof(UGECTedAttachCommand) == 0x000008, "Wrong alignment on UGECTedAttachCommand");
static_assert(sizeof(UGECTedAttachCommand) == 0x000030, "Wrong size on UGECTedAttachCommand");
static_assert(offsetof(UGECTedAttachCommand, AttachedCommand) == 0x000028, "Member 'UGECTedAttachCommand::AttachedCommand' has a wrong offset!");

// Class Tempest.UtilityAITargetFilter_Attitude
// 0x0008 (0x0030 - 0x0028)
class UUtilityAITargetFilter_Attitude final : public UUtilityAITargetFilter
{
public:
	struct FAISenseAffiliationFilter              AttitudeFilter;                                    // 0x0028(0x0004)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAITargetFilter_Attitude">();
	}
	static class UUtilityAITargetFilter_Attitude* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAITargetFilter_Attitude>();
	}
};
static_assert(alignof(UUtilityAITargetFilter_Attitude) == 0x000008, "Wrong alignment on UUtilityAITargetFilter_Attitude");
static_assert(sizeof(UUtilityAITargetFilter_Attitude) == 0x000030, "Wrong size on UUtilityAITargetFilter_Attitude");
static_assert(offsetof(UUtilityAITargetFilter_Attitude, AttitudeFilter) == 0x000028, "Member 'UUtilityAITargetFilter_Attitude::AttitudeFilter' has a wrong offset!");

// Class Tempest.GEECAmmoRechargeMultiplier
// 0x0098 (0x00D8 - 0x0040)
class UGEECAmmoRechargeMultiplier : public UGameplayModMagnitudeCalculation
{
public:
	bool                                          bUsePowerEfficiencyToRepairRateCurve;              // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     PowerEfficiencyToRechargeRate;                     // 0x0048(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         AmmoRechargeRateMultiplier;                        // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEECAmmoRechargeMultiplier">();
	}
	static class UGEECAmmoRechargeMultiplier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEECAmmoRechargeMultiplier>();
	}
};
static_assert(alignof(UGEECAmmoRechargeMultiplier) == 0x000008, "Wrong alignment on UGEECAmmoRechargeMultiplier");
static_assert(sizeof(UGEECAmmoRechargeMultiplier) == 0x0000D8, "Wrong size on UGEECAmmoRechargeMultiplier");
static_assert(offsetof(UGEECAmmoRechargeMultiplier, bUsePowerEfficiencyToRepairRateCurve) == 0x000040, "Member 'UGEECAmmoRechargeMultiplier::bUsePowerEfficiencyToRepairRateCurve' has a wrong offset!");
static_assert(offsetof(UGEECAmmoRechargeMultiplier, PowerEfficiencyToRechargeRate) == 0x000048, "Member 'UGEECAmmoRechargeMultiplier::PowerEfficiencyToRechargeRate' has a wrong offset!");
static_assert(offsetof(UGEECAmmoRechargeMultiplier, AmmoRechargeRateMultiplier) == 0x0000D0, "Member 'UGEECAmmoRechargeMultiplier::AmmoRechargeRateMultiplier' has a wrong offset!");

// Class Tempest.GEECApplyAoEDefinition
// 0x0008 (0x0048 - 0x0040)
class UGEECApplyAoEDefinition final : public UGameplayEffectExecutionCalculation
{
public:
	struct FGameplayTag                           AoEConfigAssetId;                                  // 0x0040(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEECApplyAoEDefinition">();
	}
	static class UGEECApplyAoEDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEECApplyAoEDefinition>();
	}
};
static_assert(alignof(UGEECApplyAoEDefinition) == 0x000008, "Wrong alignment on UGEECApplyAoEDefinition");
static_assert(sizeof(UGEECApplyAoEDefinition) == 0x000048, "Wrong size on UGEECApplyAoEDefinition");
static_assert(offsetof(UGEECApplyAoEDefinition, AoEConfigAssetId) == 0x000040, "Member 'UGEECApplyAoEDefinition::AoEConfigAssetId' has a wrong offset!");

// Class Tempest.GEECAwakening
// 0x0088 (0x00C8 - 0x0040)
class UGEECAwakening : public UGameplayModMagnitudeCalculation
{
public:
	TArray<struct FAwakeningLevel>                EnlightenedBuffValue;                              // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         DefaultValue;                                      // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  TargetMustHaveTags;                                // 0x0058(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bRequireAllTags;                                   // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_79[0x4F];                                      // 0x0079(0x004F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEECAwakening">();
	}
	static class UGEECAwakening* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEECAwakening>();
	}
};
static_assert(alignof(UGEECAwakening) == 0x000008, "Wrong alignment on UGEECAwakening");
static_assert(sizeof(UGEECAwakening) == 0x0000C8, "Wrong size on UGEECAwakening");
static_assert(offsetof(UGEECAwakening, EnlightenedBuffValue) == 0x000040, "Member 'UGEECAwakening::EnlightenedBuffValue' has a wrong offset!");
static_assert(offsetof(UGEECAwakening, DefaultValue) == 0x000050, "Member 'UGEECAwakening::DefaultValue' has a wrong offset!");
static_assert(offsetof(UGEECAwakening, TargetMustHaveTags) == 0x000058, "Member 'UGEECAwakening::TargetMustHaveTags' has a wrong offset!");
static_assert(offsetof(UGEECAwakening, bRequireAllTags) == 0x000078, "Member 'UGEECAwakening::bRequireAllTags' has a wrong offset!");

// Class Tempest.TedImage
// 0x0000 (0x02E0 - 0x02E0)
class UTedImage final : public UImage
{
public:
	class USlateBrushAsset*                       BrushAsset;                                        // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedImage">();
	}
	static class UTedImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedImage>();
	}
};
static_assert(alignof(UTedImage) == 0x000010, "Wrong alignment on UTedImage");
static_assert(sizeof(UTedImage) == 0x0002E0, "Wrong size on UTedImage");
static_assert(offsetof(UTedImage, BrushAsset) == 0x0002D8, "Member 'UTedImage::BrushAsset' has a wrong offset!");

// Class Tempest.GEECDamage
// 0x00E8 (0x0128 - 0x0040)
class UGEECDamage : public UGameplayEffectExecutionCalculation
{
public:
	TSubclassOf<class UTedDamageType>             DamageTypeOverride;                                // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageAmountOverride;                              // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeMod                          AttributeMod;                                      // 0x0050(0x0048)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0x90];                                      // 0x0098(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEECDamage">();
	}
	static class UGEECDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEECDamage>();
	}
};
static_assert(alignof(UGEECDamage) == 0x000008, "Wrong alignment on UGEECDamage");
static_assert(sizeof(UGEECDamage) == 0x000128, "Wrong size on UGEECDamage");
static_assert(offsetof(UGEECDamage, DamageTypeOverride) == 0x000040, "Member 'UGEECDamage::DamageTypeOverride' has a wrong offset!");
static_assert(offsetof(UGEECDamage, DamageAmountOverride) == 0x000048, "Member 'UGEECDamage::DamageAmountOverride' has a wrong offset!");
static_assert(offsetof(UGEECDamage, AttributeMod) == 0x000050, "Member 'UGEECDamage::AttributeMod' has a wrong offset!");

// Class Tempest.UtilityAITargetFilter_ValidAttackTarget
// 0x0000 (0x0028 - 0x0028)
class UUtilityAITargetFilter_ValidAttackTarget final : public UUtilityAITargetFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAITargetFilter_ValidAttackTarget">();
	}
	static class UUtilityAITargetFilter_ValidAttackTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAITargetFilter_ValidAttackTarget>();
	}
};
static_assert(alignof(UUtilityAITargetFilter_ValidAttackTarget) == 0x000008, "Wrong alignment on UUtilityAITargetFilter_ValidAttackTarget");
static_assert(sizeof(UUtilityAITargetFilter_ValidAttackTarget) == 0x000028, "Wrong size on UUtilityAITargetFilter_ValidAttackTarget");

// Class Tempest.GEECDamageArcing
// 0x0000 (0x0128 - 0x0128)
class UGEECDamageArcing : public UGEECDamage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEECDamageArcing">();
	}
	static class UGEECDamageArcing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEECDamageArcing>();
	}
};
static_assert(alignof(UGEECDamageArcing) == 0x000008, "Wrong alignment on UGEECDamageArcing");
static_assert(sizeof(UGEECDamageArcing) == 0x000128, "Wrong size on UGEECDamageArcing");

// Class Tempest.GEECReclaimUnitCostPct
// 0x0008 (0x0048 - 0x0040)
class UGEECReclaimUnitCostPct : public UGameplayEffectExecutionCalculation
{
public:
	float                                         ReclaimCostPct;                                    // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEECReclaimUnitCostPct">();
	}
	static class UGEECReclaimUnitCostPct* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEECReclaimUnitCostPct>();
	}
};
static_assert(alignof(UGEECReclaimUnitCostPct) == 0x000008, "Wrong alignment on UGEECReclaimUnitCostPct");
static_assert(sizeof(UGEECReclaimUnitCostPct) == 0x000048, "Wrong size on UGEECReclaimUnitCostPct");
static_assert(offsetof(UGEECReclaimUnitCostPct, ReclaimCostPct) == 0x000040, "Member 'UGEECReclaimUnitCostPct::ReclaimCostPct' has a wrong offset!");

// Class Tempest.GEECRemoveGEStack
// 0x01A0 (0x01E0 - 0x0040)
class UGEECRemoveGEStack : public UGameplayEffectExecutionCalculation
{
public:
	struct FGameplayEffectQuery                   GameplayEffectQuery;                               // 0x0040(0x0198)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	int32                                         StacksCountToRemove;                               // 0x01D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DC[0x4];                                      // 0x01DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEECRemoveGEStack">();
	}
	static class UGEECRemoveGEStack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEECRemoveGEStack>();
	}
};
static_assert(alignof(UGEECRemoveGEStack) == 0x000008, "Wrong alignment on UGEECRemoveGEStack");
static_assert(sizeof(UGEECRemoveGEStack) == 0x0001E0, "Wrong size on UGEECRemoveGEStack");
static_assert(offsetof(UGEECRemoveGEStack, GameplayEffectQuery) == 0x000040, "Member 'UGEECRemoveGEStack::GameplayEffectQuery' has a wrong offset!");
static_assert(offsetof(UGEECRemoveGEStack, StacksCountToRemove) == 0x0001D8, "Member 'UGEECRemoveGEStack::StacksCountToRemove' has a wrong offset!");

// Class Tempest.TedGameplayCueManager
// 0x0000 (0x02C0 - 0x02C0)
class UTedGameplayCueManager final : public UGameplayCueManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGameplayCueManager">();
	}
	static class UTedGameplayCueManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedGameplayCueManager>();
	}
};
static_assert(alignof(UTedGameplayCueManager) == 0x000008, "Wrong alignment on UTedGameplayCueManager");
static_assert(sizeof(UTedGameplayCueManager) == 0x0002C0, "Wrong size on UTedGameplayCueManager");

// Class Tempest.GEECRepair
// 0x00D8 (0x0118 - 0x0040)
class UGEECRepair : public UGameplayEffectExecutionCalculation
{
public:
	bool                                          bUsePowerEfficiencyToRepairRateCurve;              // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     PowerEfficiencyToRepairRate;                       // 0x0048(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x48];                                      // 0x00D0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEECRepair">();
	}
	static class UGEECRepair* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEECRepair>();
	}
};
static_assert(alignof(UGEECRepair) == 0x000008, "Wrong alignment on UGEECRepair");
static_assert(sizeof(UGEECRepair) == 0x000118, "Wrong size on UGEECRepair");
static_assert(offsetof(UGEECRepair, bUsePowerEfficiencyToRepairRateCurve) == 0x000040, "Member 'UGEECRepair::bUsePowerEfficiencyToRepairRateCurve' has a wrong offset!");
static_assert(offsetof(UGEECRepair, PowerEfficiencyToRepairRate) == 0x000048, "Member 'UGEECRepair::PowerEfficiencyToRepairRate' has a wrong offset!");

// Class Tempest.WorldBoundsActor
// 0x0008 (0x0298 - 0x0290)
class AWorldBoundsActor final : public AActor
{
public:
	class UBoxComponent*                          BoxComponent;                                      // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldBoundsActor">();
	}
	static class AWorldBoundsActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWorldBoundsActor>();
	}
};
static_assert(alignof(AWorldBoundsActor) == 0x000008, "Wrong alignment on AWorldBoundsActor");
static_assert(sizeof(AWorldBoundsActor) == 0x000298, "Wrong size on AWorldBoundsActor");
static_assert(offsetof(AWorldBoundsActor, BoxComponent) == 0x000290, "Member 'AWorldBoundsActor::BoxComponent' has a wrong offset!");

// Class Tempest.GEECTempestChargeDamage
// 0x0050 (0x0090 - 0x0040)
class UGEECTempestChargeDamage : public UGameplayEffectExecutionCalculation
{
public:
	TSubclassOf<class UTedDamageType>             DamageType;                                        // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x48];                                      // 0x0048(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEECTempestChargeDamage">();
	}
	static class UGEECTempestChargeDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEECTempestChargeDamage>();
	}
};
static_assert(alignof(UGEECTempestChargeDamage) == 0x000008, "Wrong alignment on UGEECTempestChargeDamage");
static_assert(sizeof(UGEECTempestChargeDamage) == 0x000090, "Wrong size on UGEECTempestChargeDamage");
static_assert(offsetof(UGEECTempestChargeDamage, DamageType) == 0x000040, "Member 'UGEECTempestChargeDamage::DamageType' has a wrong offset!");

// Class Tempest.TedGameMode_Lobby
// 0x0008 (0x03C8 - 0x03C0)
class ATedGameMode_Lobby final : public ATedGameModeBase
{
public:
	class UTedMapInfo*                            FallbackMapInfo;                                   // 0x03C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGameMode_Lobby">();
	}
	static class ATedGameMode_Lobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedGameMode_Lobby>();
	}
};
static_assert(alignof(ATedGameMode_Lobby) == 0x000008, "Wrong alignment on ATedGameMode_Lobby");
static_assert(sizeof(ATedGameMode_Lobby) == 0x0003C8, "Wrong size on ATedGameMode_Lobby");
static_assert(offsetof(ATedGameMode_Lobby, FallbackMapInfo) == 0x0003C0, "Member 'ATedGameMode_Lobby::FallbackMapInfo' has a wrong offset!");

// Class Tempest.GEECTempestDynamos
// 0x0050 (0x0090 - 0x0040)
class UGEECTempestDynamos : public UGameplayEffectExecutionCalculation
{
public:
	float                                         HealthPctCutoffThreshold;                          // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44[0x4C];                                      // 0x0044(0x004C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEECTempestDynamos">();
	}
	static class UGEECTempestDynamos* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEECTempestDynamos>();
	}
};
static_assert(alignof(UGEECTempestDynamos) == 0x000008, "Wrong alignment on UGEECTempestDynamos");
static_assert(sizeof(UGEECTempestDynamos) == 0x000090, "Wrong size on UGEECTempestDynamos");
static_assert(offsetof(UGEECTempestDynamos, HealthPctCutoffThreshold) == 0x000040, "Member 'UGEECTempestDynamos::HealthPctCutoffThreshold' has a wrong offset!");

// Class Tempest.GEEC_AutoHeal
// 0x0098 (0x01B0 - 0x0118)
class UGEEC_AutoHeal : public UGEECRepair
{
public:
	float                                         HealCapPct;                                        // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OutOfCombatDelay;                                  // 0x011C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagRequirements               AdditionalTagRequirements;                         // 0x0120(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bTagRequirementsExactMatch;                        // 0x01A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEEC_AutoHeal">();
	}
	static class UGEEC_AutoHeal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEEC_AutoHeal>();
	}
};
static_assert(alignof(UGEEC_AutoHeal) == 0x000008, "Wrong alignment on UGEEC_AutoHeal");
static_assert(sizeof(UGEEC_AutoHeal) == 0x0001B0, "Wrong size on UGEEC_AutoHeal");
static_assert(offsetof(UGEEC_AutoHeal, HealCapPct) == 0x000118, "Member 'UGEEC_AutoHeal::HealCapPct' has a wrong offset!");
static_assert(offsetof(UGEEC_AutoHeal, OutOfCombatDelay) == 0x00011C, "Member 'UGEEC_AutoHeal::OutOfCombatDelay' has a wrong offset!");
static_assert(offsetof(UGEEC_AutoHeal, AdditionalTagRequirements) == 0x000120, "Member 'UGEEC_AutoHeal::AdditionalTagRequirements' has a wrong offset!");
static_assert(offsetof(UGEEC_AutoHeal, bTagRequirementsExactMatch) == 0x0001A8, "Member 'UGEEC_AutoHeal::bTagRequirementsExactMatch' has a wrong offset!");

// Class Tempest.TedInfluenceMap_FriendlyProxy
// 0x0000 (0x0038 - 0x0038)
class UTedInfluenceMap_FriendlyProxy : public UTedInfluenceMap_Pawn
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedInfluenceMap_FriendlyProxy">();
	}
	static class UTedInfluenceMap_FriendlyProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedInfluenceMap_FriendlyProxy>();
	}
};
static_assert(alignof(UTedInfluenceMap_FriendlyProxy) == 0x000008, "Wrong alignment on UTedInfluenceMap_FriendlyProxy");
static_assert(sizeof(UTedInfluenceMap_FriendlyProxy) == 0x000038, "Wrong size on UTedInfluenceMap_FriendlyProxy");

// Class Tempest.TedInfluenceMap_FriendlyProxyWithoutOwner
// 0x0000 (0x0038 - 0x0038)
class UTedInfluenceMap_FriendlyProxyWithoutOwner final : public UTedInfluenceMap_FriendlyProxy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedInfluenceMap_FriendlyProxyWithoutOwner">();
	}
	static class UTedInfluenceMap_FriendlyProxyWithoutOwner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedInfluenceMap_FriendlyProxyWithoutOwner>();
	}
};
static_assert(alignof(UTedInfluenceMap_FriendlyProxyWithoutOwner) == 0x000008, "Wrong alignment on UTedInfluenceMap_FriendlyProxyWithoutOwner");
static_assert(sizeof(UTedInfluenceMap_FriendlyProxyWithoutOwner) == 0x000038, "Wrong size on UTedInfluenceMap_FriendlyProxyWithoutOwner");

// Class Tempest.GEEC_Marked
// 0x0010 (0x0050 - 0x0040)
class UGEEC_Marked : public UGameplayEffectExecutionCalculation
{
public:
	float                                         IntelPctOnEffectExpired;                           // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinimumIntelOnEffectExpired;                       // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           IntelOnEffectExpiredRequiredTag;                   // 0x0048(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEEC_Marked">();
	}
	static class UGEEC_Marked* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEEC_Marked>();
	}
};
static_assert(alignof(UGEEC_Marked) == 0x000008, "Wrong alignment on UGEEC_Marked");
static_assert(sizeof(UGEEC_Marked) == 0x000050, "Wrong size on UGEEC_Marked");
static_assert(offsetof(UGEEC_Marked, IntelPctOnEffectExpired) == 0x000040, "Member 'UGEEC_Marked::IntelPctOnEffectExpired' has a wrong offset!");
static_assert(offsetof(UGEEC_Marked, MinimumIntelOnEffectExpired) == 0x000044, "Member 'UGEEC_Marked::MinimumIntelOnEffectExpired' has a wrong offset!");
static_assert(offsetof(UGEEC_Marked, IntelOnEffectExpiredRequiredTag) == 0x000048, "Member 'UGEEC_Marked::IntelOnEffectExpiredRequiredTag' has a wrong offset!");

// Class Tempest.GEEC_RechargeAmmo
// 0x0058 (0x0098 - 0x0040)
class UGEEC_RechargeAmmo final : public UGameplayEffectExecutionCalculation
{
public:
	struct FAmmoRechargeData                      DefaultAmmoRechargeSetup;                          // 0x0040(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FAmmoRechargeData> CustomEntityAmmoRechargeSetup;               // 0x0048(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEEC_RechargeAmmo">();
	}
	static class UGEEC_RechargeAmmo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEEC_RechargeAmmo>();
	}
};
static_assert(alignof(UGEEC_RechargeAmmo) == 0x000008, "Wrong alignment on UGEEC_RechargeAmmo");
static_assert(sizeof(UGEEC_RechargeAmmo) == 0x000098, "Wrong size on UGEEC_RechargeAmmo");
static_assert(offsetof(UGEEC_RechargeAmmo, DefaultAmmoRechargeSetup) == 0x000040, "Member 'UGEEC_RechargeAmmo::DefaultAmmoRechargeSetup' has a wrong offset!");
static_assert(offsetof(UGEEC_RechargeAmmo, CustomEntityAmmoRechargeSetup) == 0x000048, "Member 'UGEEC_RechargeAmmo::CustomEntityAmmoRechargeSetup' has a wrong offset!");

// Class Tempest.TedGameMode_SP
// 0x0000 (0x0420 - 0x0420)
class ATedGameMode_SP : public ATedGameMode
{
public:
	void OnSpMatchEnded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGameMode_SP">();
	}
	static class ATedGameMode_SP* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedGameMode_SP>();
	}
};
static_assert(alignof(ATedGameMode_SP) == 0x000008, "Wrong alignment on ATedGameMode_SP");
static_assert(sizeof(ATedGameMode_SP) == 0x000420, "Wrong size on ATedGameMode_SP");

// Class Tempest.GEEC_RestoreHealthOnFatalDamage
// 0x0010 (0x0050 - 0x0040)
class UGEEC_RestoreHealthOnFatalDamage final : public UGameplayEffectExecutionCalculation
{
public:
	struct FGameplayCueTag                        TriggerEffectCue;                                  // 0x0040(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         RestoreHealthPct;                                  // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPawnTakeAnyDamage(class AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEEC_RestoreHealthOnFatalDamage">();
	}
	static class UGEEC_RestoreHealthOnFatalDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEEC_RestoreHealthOnFatalDamage>();
	}
};
static_assert(alignof(UGEEC_RestoreHealthOnFatalDamage) == 0x000008, "Wrong alignment on UGEEC_RestoreHealthOnFatalDamage");
static_assert(sizeof(UGEEC_RestoreHealthOnFatalDamage) == 0x000050, "Wrong size on UGEEC_RestoreHealthOnFatalDamage");
static_assert(offsetof(UGEEC_RestoreHealthOnFatalDamage, TriggerEffectCue) == 0x000040, "Member 'UGEEC_RestoreHealthOnFatalDamage::TriggerEffectCue' has a wrong offset!");
static_assert(offsetof(UGEEC_RestoreHealthOnFatalDamage, RestoreHealthPct) == 0x000048, "Member 'UGEEC_RestoreHealthOnFatalDamage::RestoreHealthPct' has a wrong offset!");

// Class Tempest.GEEC_SacrificialReaping
// 0x0008 (0x0048 - 0x0040)
class UGEEC_SacrificialReaping final : public UGameplayEffectExecutionCalculation
{
public:
	int32                                         Resources;                                         // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEEC_SacrificialReaping">();
	}
	static class UGEEC_SacrificialReaping* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEEC_SacrificialReaping>();
	}
};
static_assert(alignof(UGEEC_SacrificialReaping) == 0x000008, "Wrong alignment on UGEEC_SacrificialReaping");
static_assert(sizeof(UGEEC_SacrificialReaping) == 0x000048, "Wrong size on UGEEC_SacrificialReaping");
static_assert(offsetof(UGEEC_SacrificialReaping, Resources) == 0x000040, "Member 'UGEEC_SacrificialReaping::Resources' has a wrong offset!");

// Class Tempest.TedPlayerMappableKeySettings
// 0x0020 (0x0098 - 0x0078)
class UTedPlayerMappableKeySettings final : public UPlayerMappableKeySettings
{
public:
	EPlayerMappableKeySlot                        KeySlot;                                           // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description;                                       // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FIntPoint                              InputNameRange;                                    // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerMappableKeySettings">();
	}
	static class UTedPlayerMappableKeySettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerMappableKeySettings>();
	}
};
static_assert(alignof(UTedPlayerMappableKeySettings) == 0x000008, "Wrong alignment on UTedPlayerMappableKeySettings");
static_assert(sizeof(UTedPlayerMappableKeySettings) == 0x000098, "Wrong size on UTedPlayerMappableKeySettings");
static_assert(offsetof(UTedPlayerMappableKeySettings, KeySlot) == 0x000078, "Member 'UTedPlayerMappableKeySettings::KeySlot' has a wrong offset!");
static_assert(offsetof(UTedPlayerMappableKeySettings, Description) == 0x000080, "Member 'UTedPlayerMappableKeySettings::Description' has a wrong offset!");
static_assert(offsetof(UTedPlayerMappableKeySettings, InputNameRange) == 0x000090, "Member 'UTedPlayerMappableKeySettings::InputNameRange' has a wrong offset!");

// Class Tempest.GEEC_SacrificialServitor
// 0x0018 (0x0058 - 0x0040)
class UGEEC_SacrificialServitor final : public UGameplayEffectExecutionCalculation
{
public:
	struct FGameplayTag                           UnitDefinition;                                    // 0x0040(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayCueTag                        SpawnGameplayCue;                                  // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bTraceGroundForPhysMat;                            // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GEEC_SacrificialServitor">();
	}
	static class UGEEC_SacrificialServitor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGEEC_SacrificialServitor>();
	}
};
static_assert(alignof(UGEEC_SacrificialServitor) == 0x000008, "Wrong alignment on UGEEC_SacrificialServitor");
static_assert(sizeof(UGEEC_SacrificialServitor) == 0x000058, "Wrong size on UGEEC_SacrificialServitor");
static_assert(offsetof(UGEEC_SacrificialServitor, UnitDefinition) == 0x000040, "Member 'UGEEC_SacrificialServitor::UnitDefinition' has a wrong offset!");
static_assert(offsetof(UGEEC_SacrificialServitor, SpawnGameplayCue) == 0x000048, "Member 'UGEEC_SacrificialServitor::SpawnGameplayCue' has a wrong offset!");
static_assert(offsetof(UGEEC_SacrificialServitor, bTraceGroundForPhysMat) == 0x000050, "Member 'UGEEC_SacrificialServitor::bTraceGroundForPhysMat' has a wrong offset!");

// Class Tempest.TedMoviePlayerWidgetV2
// 0x0070 (0x0470 - 0x0400)
class UTedMoviePlayerWidgetV2 : public UTedUserWidget
{
public:
	TMulticastInlineDelegate<void(class UTedMoviePlayerWidgetV2* InWidget, const class UFileMediaSource* InSource)> OnStart; // 0x0400(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTedMoviePlayerWidgetV2* InWidget, const class UFileMediaSource* InSource)> OnFinish; // 0x0410(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTedMoviePlayerWidgetV2* InWidget, const class UFileMediaSource* InSource)> OnPause; // 0x0420(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTedMoviePlayerWidgetV2* InWidget, const class UFileMediaSource* InSource)> OnResume; // 0x0430(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	ESlateVisibility                              PlayingVisibility;                                 // 0x0440(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESlateVisibility                              PausedVisibility;                                  // 0x0441(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESlateVisibility                              NotOpenedVisibility;                               // 0x0442(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_443[0x5];                                      // 0x0443(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     MovieMaterial;                                     // 0x0448(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MovieMaterialTextureParam;                         // 0x0450(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedMoviePlayerConfig*                  DefaultMovieConfig;                                // 0x0458(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedMoviePlayerController*              MoviePlayerController;                             // 0x0460(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               MovieMaterialMID;                                  // 0x0468(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool Clear();
	bool Finish();
	void K2_OnFinish(const class UFileMediaSource* InMovie);
	void K2_OnPause(const class UFileMediaSource* InMovie);
	void K2_OnResume(const class UFileMediaSource* InMovie);
	void K2_OnStart(const class UFileMediaSource* InMovie);
	bool K2_Start(const class UFileMediaSource* InMovie, const bool bInLoop, const bool bInSilent, const ETedMovieGamePauseInteraction InPauseInteraction, const class UTedMoviePlayerConfig* InConfigOverride);
	bool K2_StartThemed(const struct FTedThemeMovie& InMovie, const bool bInLoop, const bool bInSilent, const ETedMovieGamePauseInteraction InPauseInteraction, const class UTedMoviePlayerConfig* InConfigOverride);
	bool Pause();
	bool Resume();

	struct FSlateBrush DetermineBrush() const;
	ESlateVisibility DetermineVisibility() const;
	class UMaterialInstanceDynamic* GetMovieMaterialMID() const;
	const class UFileMediaSource* GetStartedMovie() const;
	bool IsPaused() const;
	bool IsPlaying() const;
	bool IsPlayingEditorPreview() const;
	bool IsStarted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMoviePlayerWidgetV2">();
	}
	static class UTedMoviePlayerWidgetV2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMoviePlayerWidgetV2>();
	}
};
static_assert(alignof(UTedMoviePlayerWidgetV2) == 0x000008, "Wrong alignment on UTedMoviePlayerWidgetV2");
static_assert(sizeof(UTedMoviePlayerWidgetV2) == 0x000470, "Wrong size on UTedMoviePlayerWidgetV2");
static_assert(offsetof(UTedMoviePlayerWidgetV2, OnStart) == 0x000400, "Member 'UTedMoviePlayerWidgetV2::OnStart' has a wrong offset!");
static_assert(offsetof(UTedMoviePlayerWidgetV2, OnFinish) == 0x000410, "Member 'UTedMoviePlayerWidgetV2::OnFinish' has a wrong offset!");
static_assert(offsetof(UTedMoviePlayerWidgetV2, OnPause) == 0x000420, "Member 'UTedMoviePlayerWidgetV2::OnPause' has a wrong offset!");
static_assert(offsetof(UTedMoviePlayerWidgetV2, OnResume) == 0x000430, "Member 'UTedMoviePlayerWidgetV2::OnResume' has a wrong offset!");
static_assert(offsetof(UTedMoviePlayerWidgetV2, PlayingVisibility) == 0x000440, "Member 'UTedMoviePlayerWidgetV2::PlayingVisibility' has a wrong offset!");
static_assert(offsetof(UTedMoviePlayerWidgetV2, PausedVisibility) == 0x000441, "Member 'UTedMoviePlayerWidgetV2::PausedVisibility' has a wrong offset!");
static_assert(offsetof(UTedMoviePlayerWidgetV2, NotOpenedVisibility) == 0x000442, "Member 'UTedMoviePlayerWidgetV2::NotOpenedVisibility' has a wrong offset!");
static_assert(offsetof(UTedMoviePlayerWidgetV2, MovieMaterial) == 0x000448, "Member 'UTedMoviePlayerWidgetV2::MovieMaterial' has a wrong offset!");
static_assert(offsetof(UTedMoviePlayerWidgetV2, MovieMaterialTextureParam) == 0x000450, "Member 'UTedMoviePlayerWidgetV2::MovieMaterialTextureParam' has a wrong offset!");
static_assert(offsetof(UTedMoviePlayerWidgetV2, DefaultMovieConfig) == 0x000458, "Member 'UTedMoviePlayerWidgetV2::DefaultMovieConfig' has a wrong offset!");
static_assert(offsetof(UTedMoviePlayerWidgetV2, MoviePlayerController) == 0x000460, "Member 'UTedMoviePlayerWidgetV2::MoviePlayerController' has a wrong offset!");
static_assert(offsetof(UTedMoviePlayerWidgetV2, MovieMaterialMID) == 0x000468, "Member 'UTedMoviePlayerWidgetV2::MovieMaterialMID' has a wrong offset!");

// Class Tempest.GMMC_Aggregator
// 0x0018 (0x0058 - 0x0040)
class UGMMC_Aggregator : public UGameplayModMagnitudeCalculation
{
public:
	EAggregationMethod                            AggregationMethod;                                 // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayEffectModifierMagnitude> ModifierMagnitudes;                              // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GMMC_Aggregator">();
	}
	static class UGMMC_Aggregator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGMMC_Aggregator>();
	}
};
static_assert(alignof(UGMMC_Aggregator) == 0x000008, "Wrong alignment on UGMMC_Aggregator");
static_assert(sizeof(UGMMC_Aggregator) == 0x000058, "Wrong size on UGMMC_Aggregator");
static_assert(offsetof(UGMMC_Aggregator, AggregationMethod) == 0x000040, "Member 'UGMMC_Aggregator::AggregationMethod' has a wrong offset!");
static_assert(offsetof(UGMMC_Aggregator, ModifierMagnitudes) == 0x000048, "Member 'UGMMC_Aggregator::ModifierMagnitudes' has a wrong offset!");

// Class Tempest.GMMC_PlayerTagBased
// 0x0018 (0x0058 - 0x0040)
class UGMMC_PlayerTagBased : public UGameplayModMagnitudeCalculation
{
public:
	float                                         BaseValue;                                         // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedValueModsWithTagRequirements       ValueMods;                                         // 0x0048(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GMMC_PlayerTagBased">();
	}
	static class UGMMC_PlayerTagBased* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGMMC_PlayerTagBased>();
	}
};
static_assert(alignof(UGMMC_PlayerTagBased) == 0x000008, "Wrong alignment on UGMMC_PlayerTagBased");
static_assert(sizeof(UGMMC_PlayerTagBased) == 0x000058, "Wrong size on UGMMC_PlayerTagBased");
static_assert(offsetof(UGMMC_PlayerTagBased, BaseValue) == 0x000040, "Member 'UGMMC_PlayerTagBased::BaseValue' has a wrong offset!");
static_assert(offsetof(UGMMC_PlayerTagBased, ValueMods) == 0x000048, "Member 'UGMMC_PlayerTagBased::ValueMods' has a wrong offset!");

// Class Tempest.HintsSettings
// 0x0030 (0x0068 - 0x0038)
class UHintsSettings final : public UDeveloperSettings
{
public:
	TSoftClassPtr<class UClass>                   WorldDisplayDefaultClass;                          // 0x0038(0x0028)(Edit, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HintMaxLifetime;                                   // 0x0060(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetHintMaxLifetime() const;
	TSubclassOf<class ATedWorldHintActor> GetWorldDisplayDefaultClass() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HintsSettings">();
	}
	static class UHintsSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHintsSettings>();
	}
};
static_assert(alignof(UHintsSettings) == 0x000008, "Wrong alignment on UHintsSettings");
static_assert(sizeof(UHintsSettings) == 0x000068, "Wrong size on UHintsSettings");
static_assert(offsetof(UHintsSettings, WorldDisplayDefaultClass) == 0x000038, "Member 'UHintsSettings::WorldDisplayDefaultClass' has a wrong offset!");
static_assert(offsetof(UHintsSettings, HintMaxLifetime) == 0x000060, "Member 'UHintsSettings::HintMaxLifetime' has a wrong offset!");

// Class Tempest.TedGenericDataContentPanel
// 0x0058 (0x0808 - 0x07B0)
class UTedGenericDataContentPanel : public UTedContentPanelDynamic
{
public:
	uint8                                         Pad_7B0[0x30];                                     // 0x07B0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTedGenericDataContainer>       content;                                           // 0x07E0(0x0010)(Edit, ZeroConstructor, Transient, EditConst, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 ContentFiltered;                                   // 0x07F0(0x0010)(Edit, ZeroConstructor, Transient, EditConst, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	uint8                                         bBulkContentOperationActive : 1;                   // 0x0800(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Transient, EditConst, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_801[0x7];                                      // 0x0801(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddContent(const struct FTedGenericDataContainer& InEntry);
	void SetContent(const TArray<struct FTedGenericDataContainer>& InContent);

	bool GetContent(const int32 InSlotIndex, struct FTedGenericDataContainer* OutContent) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGenericDataContentPanel">();
	}
	static class UTedGenericDataContentPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedGenericDataContentPanel>();
	}
};
static_assert(alignof(UTedGenericDataContentPanel) == 0x000008, "Wrong alignment on UTedGenericDataContentPanel");
static_assert(sizeof(UTedGenericDataContentPanel) == 0x000808, "Wrong size on UTedGenericDataContentPanel");
static_assert(offsetof(UTedGenericDataContentPanel, content) == 0x0007E0, "Member 'UTedGenericDataContentPanel::content' has a wrong offset!");
static_assert(offsetof(UTedGenericDataContentPanel, ContentFiltered) == 0x0007F0, "Member 'UTedGenericDataContentPanel::ContentFiltered' has a wrong offset!");

// Class Tempest.TedPlayerProfileLeaderboardPositionsPanel
// 0x0028 (0x0830 - 0x0808)
class UTedPlayerProfileLeaderboardPositionsPanel final : public UTedGenericDataContentPanel
{
public:
	uint8                                         Pad_808[0x28];                                     // 0x0808(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetSlotContent(const int32 SlotIndex, ETedFaction* OutFaction, int32* OutLeaderboardPos1v1, int32* OutLeaderboardPos2v2, int32* OutRating1v1, int32* OutRating2v2, bool* bSuccess);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerProfileLeaderboardPositionsPanel">();
	}
	static class UTedPlayerProfileLeaderboardPositionsPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerProfileLeaderboardPositionsPanel>();
	}
};
static_assert(alignof(UTedPlayerProfileLeaderboardPositionsPanel) == 0x000008, "Wrong alignment on UTedPlayerProfileLeaderboardPositionsPanel");
static_assert(sizeof(UTedPlayerProfileLeaderboardPositionsPanel) == 0x000830, "Wrong size on UTedPlayerProfileLeaderboardPositionsPanel");

// Class Tempest.InputModifierOverride
// 0x0018 (0x0040 - 0x0028)
class UInputModifierOverride final : public UInputModifier
{
public:
	struct FVector                                Override;                                          // 0x0028(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputModifierOverride">();
	}
	static class UInputModifierOverride* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputModifierOverride>();
	}
};
static_assert(alignof(UInputModifierOverride) == 0x000008, "Wrong alignment on UInputModifierOverride");
static_assert(sizeof(UInputModifierOverride) == 0x000040, "Wrong size on UInputModifierOverride");
static_assert(offsetof(UInputModifierOverride, Override) == 0x000028, "Member 'UInputModifierOverride::Override' has a wrong offset!");

// Class Tempest.TedCommandCompoundScreen
// 0x0208 (0x0660 - 0x0458)
class UTedCommandCompoundScreen final : public UTedMenuScreenWidget
{
public:
	TMulticastInlineDelegate<void()>              OnSettingsOpened;                                  // 0x0458(0x0010)(ZeroConstructor, InstancedReference, Protected, BlueprintCallable, NativeAccessSpecifierProtected)
	struct FTedThemeMovie                         DesktopBackgroundAnimMovies[0x3];                  // 0x0468(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	class UTedMoviePlayerWidgetV2*                DesktopBackgroundAnimPlayer;                       // 0x0558(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class UTedUserWidget*>                   DesktopBackgroundRelevantWidgets;                  // 0x0560(0x0050)(BlueprintVisible, ExportObject, BlueprintReadOnly, Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSet<class UTedUserWidget*>                   DesktopBackgroundRelevantWidgetsShowing;           // 0x05B0(0x0050)(BlueprintVisible, ExportObject, BlueprintReadOnly, Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WidgetSwitcher_Pages;                              // 0x0600(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                Page_Default;                                      // 0x0608(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedCommandCompoundDoctrineScreen*      Page_Doctrine;                                     // 0x0610(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedCommandCompoundArmoryScreen*        Page_Armory;                                       // 0x0618(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                Page_Commissary;                                   // 0x0620(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                Page_MissionSelection;                             // 0x0628(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                Page_Codex;                                        // 0x0630(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                Page_MissionDescription;                           // 0x0638(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedCredits*                            Page_AcknowledgementCredits;                       // 0x0640(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedUserWidget*                         DeployButton_Frame;                                // 0x0648(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedCommandCompoundNavigation*          NavigationButtons;                                 // 0x0650(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldDeployButtonBeCollapsed;                    // 0x0658(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_659[0x7];                                      // 0x0659(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class FText GetEquipmentPointsValueText(const int32 InValue, const bool bInGroupped);
	static int32 GetRemainingDoctrinePoints(const class UObject* InWorldContext);
	static int32 GetRemainingDoctrineResetPoints(const class UObject* InWorldContext);
	static int32 GetRemainingEquipmentPoints(const class UObject* InWorldContext);
	static int32 GetRemainingEquipmentResetPoints(const class UObject* InWorldContext);
	static int32 GetRemainingEquipmentSpace(const class UObject* InWorldContext);
	static int32 GetTotalDoctrinePoints(const class UObject* InWorldContext);
	static int32 GetTotalDoctrineResetPoints(const class UObject* InWorldContext);
	static int32 GetTotalEquipmentPoints(const class UObject* InWorldContext);
	static int32 GetTotalEquipmentResetPoints(const class UObject* InWorldContext);
	static int32 GetTotalEquipmentSpace(const class UObject* InWorldContext);
	static int32 GetUsedDoctrinePoints(const class UObject* InWorldContext);
	static int32 GetUsedDoctrineResetPoints(const class UObject* InWorldContext);
	static int32 GetUsedEquipmentPoints(const class UObject* InWorldContext);
	static int32 GetUsedEquipmentResetPoints(const class UObject* InWorldContext);
	static int32 GetUsedEquipmentSpace(const class UObject* InWorldContext);
	static bool HasJustPlayedLastMap(const class UTedGameProgressSubsystem* GameProgress);

	void OnActivateNavigationSlotState(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotState InState, bool bInActivated);
	void OnDesktopBackgroundIntroFinished(class UTedMoviePlayerWidgetV2* InWidget, const class UFileMediaSource* InSource);
	void OnDesktopBackgroundRelevantWidgetAnimEnd(class UTedUserWidget* InWidget, const struct FGameplayTag& InAnimation);
	void OnDesktopBackgroundRelevantWidgetAnimStart(class UTedUserWidget* InWidget, const struct FGameplayTag& InAnimation);
	void OnPageOpened();
	void OpenPage(class UWidget* InPage);
	void OpenPage_Armory();
	void OpenPage_Commissary();
	void OpenPage_Default();
	void OpenPage_Doctrine();
	void OpenPage_MissionDescription();
	void OpenPage_MissionSelection();
	void PlayDesktopBackgroundAnim(const ETedCommandCompoundDesktopBackgroundAnim InAnim);
	void StartMission(const class UTedMapInfo* MapInfo);
	void TransitionIntoMapScreen();

	void GatherDesktopBackgroundRelevantWidgets(TArray<class UTedUserWidget*>* OutWidgets) const;
	bool ShouldAutoplayBriefing(class UTedMapInfo* MapInfo) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandCompoundScreen">();
	}
	static class UTedCommandCompoundScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCommandCompoundScreen>();
	}
};
static_assert(alignof(UTedCommandCompoundScreen) == 0x000008, "Wrong alignment on UTedCommandCompoundScreen");
static_assert(sizeof(UTedCommandCompoundScreen) == 0x000660, "Wrong size on UTedCommandCompoundScreen");
static_assert(offsetof(UTedCommandCompoundScreen, OnSettingsOpened) == 0x000458, "Member 'UTedCommandCompoundScreen::OnSettingsOpened' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundScreen, DesktopBackgroundAnimMovies) == 0x000468, "Member 'UTedCommandCompoundScreen::DesktopBackgroundAnimMovies' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundScreen, DesktopBackgroundAnimPlayer) == 0x000558, "Member 'UTedCommandCompoundScreen::DesktopBackgroundAnimPlayer' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundScreen, DesktopBackgroundRelevantWidgets) == 0x000560, "Member 'UTedCommandCompoundScreen::DesktopBackgroundRelevantWidgets' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundScreen, DesktopBackgroundRelevantWidgetsShowing) == 0x0005B0, "Member 'UTedCommandCompoundScreen::DesktopBackgroundRelevantWidgetsShowing' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundScreen, WidgetSwitcher_Pages) == 0x000600, "Member 'UTedCommandCompoundScreen::WidgetSwitcher_Pages' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundScreen, Page_Default) == 0x000608, "Member 'UTedCommandCompoundScreen::Page_Default' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundScreen, Page_Doctrine) == 0x000610, "Member 'UTedCommandCompoundScreen::Page_Doctrine' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundScreen, Page_Armory) == 0x000618, "Member 'UTedCommandCompoundScreen::Page_Armory' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundScreen, Page_Commissary) == 0x000620, "Member 'UTedCommandCompoundScreen::Page_Commissary' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundScreen, Page_MissionSelection) == 0x000628, "Member 'UTedCommandCompoundScreen::Page_MissionSelection' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundScreen, Page_Codex) == 0x000630, "Member 'UTedCommandCompoundScreen::Page_Codex' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundScreen, Page_MissionDescription) == 0x000638, "Member 'UTedCommandCompoundScreen::Page_MissionDescription' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundScreen, Page_AcknowledgementCredits) == 0x000640, "Member 'UTedCommandCompoundScreen::Page_AcknowledgementCredits' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundScreen, DeployButton_Frame) == 0x000648, "Member 'UTedCommandCompoundScreen::DeployButton_Frame' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundScreen, NavigationButtons) == 0x000650, "Member 'UTedCommandCompoundScreen::NavigationButtons' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundScreen, bShouldDeployButtonBeCollapsed) == 0x000658, "Member 'UTedCommandCompoundScreen::bShouldDeployButtonBeCollapsed' has a wrong offset!");

// Class Tempest.LightingBPBase
// 0x0010 (0x02A0 - 0x0290)
class ALightingBPBase : public AActor
{
public:
	class ALightingBPBase*                        BlueprintReference;                                // 0x0290(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULightingPresetData>        CurrentLightPreset;                                // 0x0298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool CheckIfSelected();
	void UpdateLightPreset(class ULightingPreset* LightPreset, class UDirectionalLightComponent* DirLight, class USkyLightComponent* SkyLight, class UExponentialHeightFogComponent* HeightFog);
	void UpdatePostProcessPreset(class UPostProcessPreset* PostProcessPreset, const struct FPostProcessSettings& PostProcessSettings);
	void UpdateSceneComponents(class ULightingPreset* LightPreset, class UDirectionalLightComponent* DirLight, class USkyLightComponent* SkyLight, class UExponentialHeightFogComponent* HeightFog);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightingBPBase">();
	}
	static class ALightingBPBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALightingBPBase>();
	}
};
static_assert(alignof(ALightingBPBase) == 0x000008, "Wrong alignment on ALightingBPBase");
static_assert(sizeof(ALightingBPBase) == 0x0002A0, "Wrong size on ALightingBPBase");
static_assert(offsetof(ALightingBPBase, BlueprintReference) == 0x000290, "Member 'ALightingBPBase::BlueprintReference' has a wrong offset!");
static_assert(offsetof(ALightingBPBase, CurrentLightPreset) == 0x000298, "Member 'ALightingBPBase::CurrentLightPreset' has a wrong offset!");

// Class Tempest.LightingPreset
// 0x0220 (0x0250 - 0x0030)
class ULightingPreset final : public UDataAsset
{
public:
	struct FDirectionalLightParameters            DirectionalLightParameters;                        // 0x0030(0x00F8)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FSkyLightParameters                    SkyLightParameters;                                // 0x0128(0x0078)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FExponentialHeightFogParameters        HeightFogParameters;                               // 0x01A0(0x00B0)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightingPreset">();
	}
	static class ULightingPreset* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightingPreset>();
	}
};
static_assert(alignof(ULightingPreset) == 0x000008, "Wrong alignment on ULightingPreset");
static_assert(sizeof(ULightingPreset) == 0x000250, "Wrong size on ULightingPreset");
static_assert(offsetof(ULightingPreset, DirectionalLightParameters) == 0x000030, "Member 'ULightingPreset::DirectionalLightParameters' has a wrong offset!");
static_assert(offsetof(ULightingPreset, SkyLightParameters) == 0x000128, "Member 'ULightingPreset::SkyLightParameters' has a wrong offset!");
static_assert(offsetof(ULightingPreset, HeightFogParameters) == 0x0001A0, "Member 'ULightingPreset::HeightFogParameters' has a wrong offset!");

// Class Tempest.TedMeshWidgetActor
// 0x0080 (0x0310 - 0x0290)
class ATedMeshWidgetActor : public AActor
{
public:
	class UTedMeshWidgetActorCaptureComponent*    Camera;                                            // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   Background;                                        // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           SourceTag;                                         // 0x02A8(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         ExternalActors;                                    // 0x02B0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           ActiveTargetTag;                                   // 0x02C0(0x0008)(Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                ActiveContextObject;                               // 0x02C8(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D0[0x30];                                     // 0x02D0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTedMeshWidgetActorCaptureComponent*> AvailableCameras;                             // 0x0300(0x0010)(ExportObject, ZeroConstructor, Transient, DuplicateTransient, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMeshWidgetActor">();
	}
	static class ATedMeshWidgetActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedMeshWidgetActor>();
	}
};
static_assert(alignof(ATedMeshWidgetActor) == 0x000008, "Wrong alignment on ATedMeshWidgetActor");
static_assert(sizeof(ATedMeshWidgetActor) == 0x000310, "Wrong size on ATedMeshWidgetActor");
static_assert(offsetof(ATedMeshWidgetActor, Camera) == 0x000290, "Member 'ATedMeshWidgetActor::Camera' has a wrong offset!");
static_assert(offsetof(ATedMeshWidgetActor, Mesh) == 0x000298, "Member 'ATedMeshWidgetActor::Mesh' has a wrong offset!");
static_assert(offsetof(ATedMeshWidgetActor, Background) == 0x0002A0, "Member 'ATedMeshWidgetActor::Background' has a wrong offset!");
static_assert(offsetof(ATedMeshWidgetActor, SourceTag) == 0x0002A8, "Member 'ATedMeshWidgetActor::SourceTag' has a wrong offset!");
static_assert(offsetof(ATedMeshWidgetActor, ExternalActors) == 0x0002B0, "Member 'ATedMeshWidgetActor::ExternalActors' has a wrong offset!");
static_assert(offsetof(ATedMeshWidgetActor, ActiveTargetTag) == 0x0002C0, "Member 'ATedMeshWidgetActor::ActiveTargetTag' has a wrong offset!");
static_assert(offsetof(ATedMeshWidgetActor, ActiveContextObject) == 0x0002C8, "Member 'ATedMeshWidgetActor::ActiveContextObject' has a wrong offset!");
static_assert(offsetof(ATedMeshWidgetActor, AvailableCameras) == 0x000300, "Member 'ATedMeshWidgetActor::AvailableCameras' has a wrong offset!");

// Class Tempest.TedCommandCompoundMeshWidgetActor
// 0x0010 (0x0320 - 0x0310)
class ATedCommandCompoundMeshWidgetActor final : public ATedMeshWidgetActor
{
public:
	class UTedMeshWidgetActorCaptureComponent*    Camera_Medium;                                     // 0x0310(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedMeshWidgetActorCaptureComponent*    Camera_Big;                                        // 0x0318(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandCompoundMeshWidgetActor">();
	}
	static class ATedCommandCompoundMeshWidgetActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedCommandCompoundMeshWidgetActor>();
	}
};
static_assert(alignof(ATedCommandCompoundMeshWidgetActor) == 0x000008, "Wrong alignment on ATedCommandCompoundMeshWidgetActor");
static_assert(sizeof(ATedCommandCompoundMeshWidgetActor) == 0x000320, "Wrong size on ATedCommandCompoundMeshWidgetActor");
static_assert(offsetof(ATedCommandCompoundMeshWidgetActor, Camera_Medium) == 0x000310, "Member 'ATedCommandCompoundMeshWidgetActor::Camera_Medium' has a wrong offset!");
static_assert(offsetof(ATedCommandCompoundMeshWidgetActor, Camera_Big) == 0x000318, "Member 'ATedCommandCompoundMeshWidgetActor::Camera_Big' has a wrong offset!");

// Class Tempest.LightingPresetData
// 0x0000 (0x0028 - 0x0028)
class ULightingPresetData final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightingPresetData">();
	}
	static class ULightingPresetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightingPresetData>();
	}
};
static_assert(alignof(ULightingPresetData) == 0x000008, "Wrong alignment on ULightingPresetData");
static_assert(sizeof(ULightingPresetData) == 0x000028, "Wrong size on ULightingPresetData");

// Class Tempest.TedPlayerProfileStatsPanel
// 0x0068 (0x0818 - 0x07B0)
class UTedPlayerProfileStatsPanel final : public UTedContentPanelDynamic
{
public:
	bool                                          bShowDetailsInTooltip;                             // 0x07B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B1[0x7];                                      // 0x07B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FSlateBrush>         QuickStatBrushes;                                  // 0x07B8(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	uint8                                         Pad_808[0x10];                                     // 0x0808(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerProfileStatsPanel">();
	}
	static class UTedPlayerProfileStatsPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerProfileStatsPanel>();
	}
};
static_assert(alignof(UTedPlayerProfileStatsPanel) == 0x000008, "Wrong alignment on UTedPlayerProfileStatsPanel");
static_assert(sizeof(UTedPlayerProfileStatsPanel) == 0x000818, "Wrong size on UTedPlayerProfileStatsPanel");
static_assert(offsetof(UTedPlayerProfileStatsPanel, bShowDetailsInTooltip) == 0x0007B0, "Member 'UTedPlayerProfileStatsPanel::bShowDetailsInTooltip' has a wrong offset!");
static_assert(offsetof(UTedPlayerProfileStatsPanel, QuickStatBrushes) == 0x0007B8, "Member 'UTedPlayerProfileStatsPanel::QuickStatBrushes' has a wrong offset!");

// Class Tempest.MinimapTextureCreator
// 0x0010 (0x02A0 - 0x0290)
class AMinimapTextureCreator final : public AActor
{
public:
	int32                                         TextureSize;                                       // 0x0290(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_294[0x4];                                      // 0x0294(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0298(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void GenerateTexture();
	void UpdateRenderTarget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MinimapTextureCreator">();
	}
	static class AMinimapTextureCreator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMinimapTextureCreator>();
	}
};
static_assert(alignof(AMinimapTextureCreator) == 0x000008, "Wrong alignment on AMinimapTextureCreator");
static_assert(sizeof(AMinimapTextureCreator) == 0x0002A0, "Wrong size on AMinimapTextureCreator");
static_assert(offsetof(AMinimapTextureCreator, TextureSize) == 0x000290, "Member 'AMinimapTextureCreator::TextureSize' has a wrong offset!");
static_assert(offsetof(AMinimapTextureCreator, RenderTarget) == 0x000298, "Member 'AMinimapTextureCreator::RenderTarget' has a wrong offset!");

// Class Tempest.TedAttributeSetBase
// 0x0000 (0x0030 - 0x0030)
class UTedAttributeSetBase : public UAttributeSet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAttributeSetBase">();
	}
	static class UTedAttributeSetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAttributeSetBase>();
	}
};
static_assert(alignof(UTedAttributeSetBase) == 0x000008, "Wrong alignment on UTedAttributeSetBase");
static_assert(sizeof(UTedAttributeSetBase) == 0x000030, "Wrong size on UTedAttributeSetBase");

// Class Tempest.MinimapCaptureComponent
// 0x0000 (0x0B00 - 0x0B00)
class UMinimapCaptureComponent final : public USceneCaptureComponent2D
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MinimapCaptureComponent">();
	}
	static class UMinimapCaptureComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMinimapCaptureComponent>();
	}
};
static_assert(alignof(UMinimapCaptureComponent) == 0x000010, "Wrong alignment on UMinimapCaptureComponent");
static_assert(sizeof(UMinimapCaptureComponent) == 0x000B00, "Wrong size on UMinimapCaptureComponent");

// Class Tempest.PostProcessPreset
// 0x06F0 (0x0720 - 0x0030)
class UPostProcessPreset final : public UDataAsset
{
public:
	uint8                                         Pad_30[0x6F0];                                     // 0x0030(0x06F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PostProcessPreset">();
	}
	static class UPostProcessPreset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPostProcessPreset>();
	}
};
static_assert(alignof(UPostProcessPreset) == 0x000008, "Wrong alignment on UPostProcessPreset");
static_assert(sizeof(UPostProcessPreset) == 0x000720, "Wrong size on UPostProcessPreset");

// Class Tempest.TedPlayerDataWidget
// 0x0010 (0x0410 - 0x0400)
class UTedPlayerDataWidget : public UTedUserWidget
{
public:
	uint8                                         bUseOwningPlayerData : 1;                          // 0x0400(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHandleResourceChangeEvent : 1;                    // 0x0400(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHandleLockedTechDataChangeEvent : 1;              // 0x0400(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHandleOwnedTagsChangeEvent : 1;                   // 0x0400(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHandleStructuresChangeEvent : 1;                  // 0x0400(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHandleUnitsChangeEvent : 1;                       // 0x0400(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHandleQueuesChangeEvent : 1;                      // 0x0400(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHandleDoctrineQueueChangeEvent : 1;               // 0x0400(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_401[0x7];                                      // 0x0401(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedPlayerData*                         TargetPlayerData;                                  // 0x0408(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnConstructionQueuesChange_Handler(class UTedPlayerData* InPlayerData, const struct FTedPlayerDataConstructionQueues& InPrevious, const struct FTedPlayerDataConstructionQueues& InCurrent);
	void OnConstructionQueuesChange_Handler_Native(class UTedPlayerData* InPlayerData, const struct FTedPlayerDataConstructionQueues& InPrevious, const struct FTedPlayerDataConstructionQueues& InCurrent);
	void OnDoctrineResearchQueueChange_Handler(class UTedPlayerData* InPlayerData, const struct FTedDoctrineResearchQueue& InPrevious, const struct FTedDoctrineResearchQueue& InCurrent);
	void OnDoctrineResearchQueueChange_Handler_Native(class UTedPlayerData* InPlayerData, const struct FTedDoctrineResearchQueue& InPrevious, const struct FTedDoctrineResearchQueue& InCurrent);
	void OnLockedTechDataChange_Handler(class UTedPlayerData* InPlayerData, const struct FTedPlayerLockedTechData& InPrevious, const struct FTedPlayerLockedTechData& InCurrent);
	void OnLockedTechDataChange_Handler_Native(class UTedPlayerData* InPlayerData, const struct FTedPlayerLockedTechData& InPrevious, const struct FTedPlayerLockedTechData& InCurrent);
	void OnOwnedTagsChange_Handler(class UTedPlayerData* InPlayerData);
	void OnOwnedTagsChange_Handler_Native(class UTedPlayerData* InPlayerData);
	void OnReplicatePlayerState_Handler(class ATedPlayerController* InPlayerController);
	void OnResourcesChange_Handler(class UTedPlayerData* InPlayerData, const struct FTedPlayerDataResources& InPrevious, const struct FTedPlayerDataResources& InCurrent);
	void OnResourcesChange_Handler_Native(class UTedPlayerData* InPlayerData, const struct FTedPlayerDataResources& InPrevious, const struct FTedPlayerDataResources& InCurrent);
	void OnStructuresChange_Handler(class UTedPlayerData* InPlayerData);
	void OnStructuresChange_Handler_Native(class UTedPlayerData* InPlayerData);
	void OnTargetPlayerDataChange(class UTedPlayerData* InPrevious, class UTedPlayerData* InCurrent);
	void OnUnitsChange_Handler(class UTedPlayerData* InPlayerData);
	void OnUnitsChange_Handler_Native(class UTedPlayerData* InPlayerData);
	void SetTargetPlayerData(class UTedPlayerData* InPlayerData);

	class UTedPlayerData* GetTargetPlayerData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerDataWidget">();
	}
	static class UTedPlayerDataWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerDataWidget>();
	}
};
static_assert(alignof(UTedPlayerDataWidget) == 0x000008, "Wrong alignment on UTedPlayerDataWidget");
static_assert(sizeof(UTedPlayerDataWidget) == 0x000410, "Wrong size on UTedPlayerDataWidget");
static_assert(offsetof(UTedPlayerDataWidget, TargetPlayerData) == 0x000408, "Member 'UTedPlayerDataWidget::TargetPlayerData' has a wrong offset!");

// Class Tempest.ProfanityData
// 0x0050 (0x0080 - 0x0030)
class UProfanityData final : public UDataAsset
{
public:
	TArray<class FString>                         WordList;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         WordAbbreviations;                                 // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         RegularExpressions;                                // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UProfanityProcessor>        Processor;                                         // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdditionalFilterSetsMinLen;                        // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UProfanityData*>                 AdditionalFilterSets;                              // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProfanityData">();
	}
	static class UProfanityData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProfanityData>();
	}
};
static_assert(alignof(UProfanityData) == 0x000008, "Wrong alignment on UProfanityData");
static_assert(sizeof(UProfanityData) == 0x000080, "Wrong size on UProfanityData");
static_assert(offsetof(UProfanityData, WordList) == 0x000030, "Member 'UProfanityData::WordList' has a wrong offset!");
static_assert(offsetof(UProfanityData, WordAbbreviations) == 0x000040, "Member 'UProfanityData::WordAbbreviations' has a wrong offset!");
static_assert(offsetof(UProfanityData, RegularExpressions) == 0x000050, "Member 'UProfanityData::RegularExpressions' has a wrong offset!");
static_assert(offsetof(UProfanityData, Processor) == 0x000060, "Member 'UProfanityData::Processor' has a wrong offset!");
static_assert(offsetof(UProfanityData, AdditionalFilterSetsMinLen) == 0x000068, "Member 'UProfanityData::AdditionalFilterSetsMinLen' has a wrong offset!");
static_assert(offsetof(UProfanityData, AdditionalFilterSets) == 0x000070, "Member 'UProfanityData::AdditionalFilterSets' has a wrong offset!");

// Class Tempest.TedPlayerStateBase
// 0x0000 (0x0348 - 0x0348)
class ATedPlayerStateBase : public APlayerState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerStateBase">();
	}
	static class ATedPlayerStateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedPlayerStateBase>();
	}
};
static_assert(alignof(ATedPlayerStateBase) == 0x000008, "Wrong alignment on ATedPlayerStateBase");
static_assert(sizeof(ATedPlayerStateBase) == 0x000348, "Wrong size on ATedPlayerStateBase");

// Class Tempest.ProfanityProcessor
// 0x0060 (0x0088 - 0x0028)
class UProfanityProcessor : public UObject
{
public:
	TMap<class FString, struct FProcessorDictionaryBody> Dictionary;                                 // 0x0028(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TArray<class FString>                         CompiledDictionary;                                // 0x0078(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProfanityProcessor">();
	}
	static class UProfanityProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProfanityProcessor>();
	}
};
static_assert(alignof(UProfanityProcessor) == 0x000008, "Wrong alignment on UProfanityProcessor");
static_assert(sizeof(UProfanityProcessor) == 0x000088, "Wrong size on UProfanityProcessor");
static_assert(offsetof(UProfanityProcessor, Dictionary) == 0x000028, "Member 'UProfanityProcessor::Dictionary' has a wrong offset!");
static_assert(offsetof(UProfanityProcessor, CompiledDictionary) == 0x000078, "Member 'UProfanityProcessor::CompiledDictionary' has a wrong offset!");

// Class Tempest.TedAwaitingOtherPlayers
// 0x0040 (0x0070 - 0x0030)
class UTedAwaitingOtherPlayers final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	EFTedGameStage                                GameState;                                         // 0x0050(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TotalWaitTime;                                     // 0x0054(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxWaitTime;                                       // 0x0058(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ATedGameMode_MP*                        CachedGameMode;                                    // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATedHUD*                                CachedHUD;                                         // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAwaitingOtherPlayers">();
	}
	static class UTedAwaitingOtherPlayers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAwaitingOtherPlayers>();
	}
};
static_assert(alignof(UTedAwaitingOtherPlayers) == 0x000008, "Wrong alignment on UTedAwaitingOtherPlayers");
static_assert(sizeof(UTedAwaitingOtherPlayers) == 0x000070, "Wrong size on UTedAwaitingOtherPlayers");
static_assert(offsetof(UTedAwaitingOtherPlayers, GameState) == 0x000050, "Member 'UTedAwaitingOtherPlayers::GameState' has a wrong offset!");
static_assert(offsetof(UTedAwaitingOtherPlayers, TotalWaitTime) == 0x000054, "Member 'UTedAwaitingOtherPlayers::TotalWaitTime' has a wrong offset!");
static_assert(offsetof(UTedAwaitingOtherPlayers, MaxWaitTime) == 0x000058, "Member 'UTedAwaitingOtherPlayers::MaxWaitTime' has a wrong offset!");
static_assert(offsetof(UTedAwaitingOtherPlayers, CachedGameMode) == 0x000060, "Member 'UTedAwaitingOtherPlayers::CachedGameMode' has a wrong offset!");
static_assert(offsetof(UTedAwaitingOtherPlayers, CachedHUD) == 0x000068, "Member 'UTedAwaitingOtherPlayers::CachedHUD' has a wrong offset!");

// Class Tempest.ProfanityRegExProcessor
// 0x0000 (0x0088 - 0x0088)
class UProfanityRegExProcessor : public UProfanityProcessor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProfanityRegExProcessor">();
	}
	static class UProfanityRegExProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProfanityRegExProcessor>();
	}
};
static_assert(alignof(UProfanityRegExProcessor) == 0x000008, "Wrong alignment on UProfanityRegExProcessor");
static_assert(sizeof(UProfanityRegExProcessor) == 0x000088, "Wrong size on UProfanityRegExProcessor");

// Class Tempest.ProfanitySettings
// 0x0088 (0x00C0 - 0x0038)
class UProfanitySettings final : public UDeveloperSettings
{
public:
	class FString                                 Replacement;                                       // 0x0038(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UProfanityData>          DefaultFilter;                                     // 0x0048(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, TSoftObjectPtr<class UProfanityData>> Internationalization;                  // 0x0070(0x0050)(Edit, Config, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	TArray<class FString> GetCultures();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProfanitySettings">();
	}
	static class UProfanitySettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProfanitySettings>();
	}
};
static_assert(alignof(UProfanitySettings) == 0x000008, "Wrong alignment on UProfanitySettings");
static_assert(sizeof(UProfanitySettings) == 0x0000C0, "Wrong size on UProfanitySettings");
static_assert(offsetof(UProfanitySettings, Replacement) == 0x000038, "Member 'UProfanitySettings::Replacement' has a wrong offset!");
static_assert(offsetof(UProfanitySettings, DefaultFilter) == 0x000048, "Member 'UProfanitySettings::DefaultFilter' has a wrong offset!");
static_assert(offsetof(UProfanitySettings, Internationalization) == 0x000070, "Member 'UProfanitySettings::Internationalization' has a wrong offset!");

// Class Tempest.TedAttackTargetQueryManager
// 0x0058 (0x0088 - 0x0030)
class UTedAttackTargetQueryManager final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x58];                                      // 0x0030(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAttackTargetQueryManager">();
	}
	static class UTedAttackTargetQueryManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAttackTargetQueryManager>();
	}
};
static_assert(alignof(UTedAttackTargetQueryManager) == 0x000008, "Wrong alignment on UTedAttackTargetQueryManager");
static_assert(sizeof(UTedAttackTargetQueryManager) == 0x000088, "Wrong size on UTedAttackTargetQueryManager");

// Class Tempest.ProfanitySystem
// 0x0038 (0x0068 - 0x0030)
class UProfanitySystem final : public UGameInstanceSubsystem
{
public:
	struct FProfanityInstance                     ProfanityInstance;                                 // 0x0030(0x0010)(NoDestructor, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UProfanityData>          PendingProfanityData;                              // 0x0040(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool CensorString(const class FString& InString, class FString* OutString);
	bool CensorText(const class FText& InText, class FText* OutText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProfanitySystem">();
	}
	static class UProfanitySystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProfanitySystem>();
	}
};
static_assert(alignof(UProfanitySystem) == 0x000008, "Wrong alignment on UProfanitySystem");
static_assert(sizeof(UProfanitySystem) == 0x000068, "Wrong size on UProfanitySystem");
static_assert(offsetof(UProfanitySystem, ProfanityInstance) == 0x000030, "Member 'UProfanitySystem::ProfanityInstance' has a wrong offset!");
static_assert(offsetof(UProfanitySystem, PendingProfanityData) == 0x000040, "Member 'UProfanitySystem::PendingProfanityData' has a wrong offset!");

// Class Tempest.TedSettingsSlot
// 0x0060 (0x0490 - 0x0430)
class UTedSettingsSlot : public UTedContentPanelSlotButton
{
public:
	class FText                                   Label;                                             // 0x0430(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0440(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          Subcategory;                                       // 0x0450(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_451[0x3];                                      // 0x0451(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMargin                                IndentMargin;                                      // 0x0454(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FMargin                                NormalMargin;                                      // 0x0464(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_474[0x4];                                      // 0x0474(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             Label_TextBlock;                                   // 0x0478(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Description_TextBlock;                             // 0x0480(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_BG;                                          // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void RefreshBackground();
	void RefreshNativeStyles();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSettingsSlot">();
	}
	static class UTedSettingsSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSettingsSlot>();
	}
};
static_assert(alignof(UTedSettingsSlot) == 0x000008, "Wrong alignment on UTedSettingsSlot");
static_assert(sizeof(UTedSettingsSlot) == 0x000490, "Wrong size on UTedSettingsSlot");
static_assert(offsetof(UTedSettingsSlot, Label) == 0x000430, "Member 'UTedSettingsSlot::Label' has a wrong offset!");
static_assert(offsetof(UTedSettingsSlot, Description) == 0x000440, "Member 'UTedSettingsSlot::Description' has a wrong offset!");
static_assert(offsetof(UTedSettingsSlot, Subcategory) == 0x000450, "Member 'UTedSettingsSlot::Subcategory' has a wrong offset!");
static_assert(offsetof(UTedSettingsSlot, IndentMargin) == 0x000454, "Member 'UTedSettingsSlot::IndentMargin' has a wrong offset!");
static_assert(offsetof(UTedSettingsSlot, NormalMargin) == 0x000464, "Member 'UTedSettingsSlot::NormalMargin' has a wrong offset!");
static_assert(offsetof(UTedSettingsSlot, Label_TextBlock) == 0x000478, "Member 'UTedSettingsSlot::Label_TextBlock' has a wrong offset!");
static_assert(offsetof(UTedSettingsSlot, Description_TextBlock) == 0x000480, "Member 'UTedSettingsSlot::Description_TextBlock' has a wrong offset!");
static_assert(offsetof(UTedSettingsSlot, Image_BG) == 0x000488, "Member 'UTedSettingsSlot::Image_BG' has a wrong offset!");

// Class Tempest.TedSettingsSlot_Button
// 0x0018 (0x04A8 - 0x0490)
class UTedSettingsSlot_Button : public UTedSettingsSlot
{
public:
	class UTedGlowingButton*                      Value_GlowingButton;                               // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_498[0x10];                                     // 0x0498(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSettingsSlot_Button">();
	}
	static class UTedSettingsSlot_Button* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSettingsSlot_Button>();
	}
};
static_assert(alignof(UTedSettingsSlot_Button) == 0x000008, "Wrong alignment on UTedSettingsSlot_Button");
static_assert(sizeof(UTedSettingsSlot_Button) == 0x0004A8, "Wrong size on UTedSettingsSlot_Button");
static_assert(offsetof(UTedSettingsSlot_Button, Value_GlowingButton) == 0x000490, "Member 'UTedSettingsSlot_Button::Value_GlowingButton' has a wrong offset!");

// Class Tempest.TedPlayerControllerBase
// 0x0068 (0x08C0 - 0x0858)
class ATedPlayerControllerBase : public APlayerController
{
public:
	uint8                                         Pad_858[0x8];                                      // 0x0858(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UInputMappingContext*, int32>      DefaultInputMappingContexts;                       // 0x0860(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UInputMappingContext*                   ClassicControlsMappingContext;                     // 0x08B0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATedPlayerState*                        TedPlayerState;                                    // 0x08B8(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ServerDebugAddExperience(const float experience);
	void ServerDebugRestartLevel();
	void ServerDebugSpawnUnit(TSubclassOf<class ATedUnitBase> UnitClass, const int32 NumToSpawn, const struct FVector& Location, const ETedPlayerID PlayerID);
	void ServerDebugTeleportSelectedUnits(const struct FVector2D& CursorLocation, const TArray<class ATedUnitBase*>& Units);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerControllerBase">();
	}
	static class ATedPlayerControllerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedPlayerControllerBase>();
	}
};
static_assert(alignof(ATedPlayerControllerBase) == 0x000008, "Wrong alignment on ATedPlayerControllerBase");
static_assert(sizeof(ATedPlayerControllerBase) == 0x0008C0, "Wrong size on ATedPlayerControllerBase");
static_assert(offsetof(ATedPlayerControllerBase, DefaultInputMappingContexts) == 0x000860, "Member 'ATedPlayerControllerBase::DefaultInputMappingContexts' has a wrong offset!");
static_assert(offsetof(ATedPlayerControllerBase, ClassicControlsMappingContext) == 0x0008B0, "Member 'ATedPlayerControllerBase::ClassicControlsMappingContext' has a wrong offset!");
static_assert(offsetof(ATedPlayerControllerBase, TedPlayerState) == 0x0008B8, "Member 'ATedPlayerControllerBase::TedPlayerState' has a wrong offset!");

// Class Tempest.TedPlayerController
// 0x0F60 (0x1820 - 0x08C0)
class ATedPlayerController : public ATedPlayerControllerBase
{
public:
	uint8                                         Pad_8C0[0x48];                                     // 0x08C0(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bCanClearSelection : 1;                            // 0x0908(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanSelectEnemy : 1;                               // 0x0908(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bTriggerSideBarActionForLastPress : 1;             // 0x0908(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_909[0x7];                                      // 0x0909(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UTedPlayerCommand_StructureBase> SellStructureCommandClass;                    // 0x0910(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTedPlayerCommand_StructureBase> RepairStructureCommandClass;                  // 0x0918(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTedPlayerCommand_StructureBase> TogglePowerStructureCommandClass;             // 0x0920(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   RallyPtClass;                                      // 0x0928(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedCommandComponent*                   CommandComponent;                                  // 0x0950(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATedUnitMovementReplicationManager*     UnitMovementReplicationManager;                    // 0x0958(0x0008)(Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_960[0x20];                                     // 0x0960(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PreCinematicModeLocation;                          // 0x0980(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreCinematicModeZoomPct;                           // 0x0998(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExitOnSurrender;                                  // 0x099C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShutdownOnSurrender;                              // 0x099D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_99E[0xA];                                      // 0x099E(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpectatorSpawnLocation;                            // 0x09A8(0x0018)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9C0[0x20];                                     // 0x09C0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class ATedPawn*>                         HoveredPawns;                                      // 0x09E0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TSet<class ATedPawn*>                         SelectedPawns;                                     // 0x0A30(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TSet<class ATedPawn*>                         PreviouslySelectedPawns;                           // 0x0A80(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TSet<class ATedStructureBase*>                SelectedStructures;                                // 0x0AD0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TSet<class ATedUnitBase*>                     SelectedUnits;                                     // 0x0B20(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         CommandExecutionIt;                                // 0x0B70(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B74[0x1C];                                     // 0x0B74(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              SelectionChangedDelegateK2;                        // 0x0B90(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_BA0[0x8];                                      // 0x0BA0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTedPawnGroup>                  PawnGroups;                                        // 0x0BA8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_BB8[0x20];                                     // 0x0BB8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATedRallyPoint*>                 RallyPoints;                                       // 0x0BD8(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_BE8[0x28];                                     // 0x0BE8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UTedPlayerCommand_Ping>     PingCommandClass;                                  // 0x0C10(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATedPingActor>              PingActorClass;                                    // 0x0C18(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPingLimiter                           PingLimiter;                                       // 0x0C20(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C38[0x18];                                     // 0x0C38(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FInputActionOptions> InputActions;                                      // 0x0C50(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FAggregatedInputActionOptions> AggregatedInputActions;                  // 0x0CA0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FInputActionOptions> SpectatorInputActions;                             // 0x0CF0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D40[0x8C];                                     // 0x0D40(0x008C)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         BaseCameraIt;                                      // 0x0DCC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         HotspotIt;                                         // 0x0DCD(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DCE[0x2];                                      // 0x0DCE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        CameraLocations;                                   // 0x0DD0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bCameraRotateLeft;                                 // 0x0DE0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCameraRotateRight;                                // 0x0DE1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DE2[0x66];                                     // 0x0DE2(0x0066)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TSubclassOf<class UGameplayCommand>>     SupportedCommands;                                 // 0x0E48(0x0050)(Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FTedCommandRequest>             ClientRequestedCommands;                           // 0x0E98(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCommandData                   HoveredCommandData;                                // 0x0EA8(0x0048)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCommandData                   SelectedCommandData;                               // 0x0EF0(0x0048)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_F38[0x8];                                      // 0x0F38(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayCommandData                   PendingCommandData;                                // 0x0F40(0x0048)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCommandErrorTags              PendingErrorTags;                                  // 0x0F88(0x0060)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_FE8[0x600];                                    // 0x0FE8(0x0600)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FGameplayCommandID>               SyncedCommandIDs;                                  // 0x15E8(0x0050)(Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           SyncMovementSpeedForCommandIDs_Handle;             // 0x1638(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayCommandExecutionInfo          CommandExecutionInfo;                              // 0x1640(0x0060)(Net, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGameplayCommandCooldowns              CommandCooldowns;                                  // 0x16A0(0x0070)(Net, Transient, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayCommandID, struct FTedCommandPendingExecuteData> PlayerCommandsPendingExecution; // 0x1710(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class ATedPlayerController* InPlayerController)> OnReplicatePlayerState; // 0x1760(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1770[0x10];                                    // 0x1770(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCursorTraceResult                     CursorTraceResult;                                 // 0x1780(0x0048)(Transient, DuplicateTransient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UTedAnnouncer*                          Announcer;                                         // 0x17C8(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedPawnSoundManager*                   PawnSoundManager;                                  // 0x17D0(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17D8[0x40];                                    // 0x17D8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UAICommander*                           AICommander;                                       // 0x1818(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Action_AddPawnGroupToSelection(const struct FInputActionValue& Value);
	void Action_BaseCamera();
	void Action_BuildingGridSlot(const struct FInputActionValue& Value);
	void Action_Camera_Rotate_Left(const struct FInputActionValue& Value);
	void Action_Camera_Rotate_Right(const struct FInputActionValue& Value);
	void Action_ChangePrimarySelectionOrder();
	void Action_ChangePrimarySelectionType();
	void Action_CreatePawnGroup(const struct FInputActionValue& Value);
	void Action_CreateUniquePawnGroup(const struct FInputActionValue& Value);
	void Action_FreeLook(const struct FInputActionValue& Value);
	void Action_IssueCommand(const struct FInputActionValue& Value);
	void Action_IssueCommand_DoubleClick();
	void Action_JumpToCameraLocation(const struct FInputActionValue& Value);
	void Action_Modifier_Alt(const struct FInputActionValue& Value);
	void Action_Modifier_Ctrl(const struct FInputActionValue& Value);
	void Action_Modifier_Shift(const struct FInputActionValue& Value);
	void Action_MoveCamera(const struct FInputActionValue& Value);
	void Action_MoveCameraFreeLook(const struct FInputActionValue& Value);
	void Action_OpenChat(const struct FInputActionValue& Value);
	void Action_PingClearSelection(const struct FInputActionValue& Value);
	void Action_PlacePing(const struct FInputActionValue& Value);
	void Action_RepairCommand(const struct FInputActionValue& Value);
	void Action_RotateStructure(const struct FInputActionValue& Value);
	void Action_Select(const struct FInputActionValue& Value);
	void Action_Select_DoubleClick();
	void Action_SelectAllUnits(const struct FInputActionValue& Value);
	void Action_SelectAllUnitsOnScreen(const struct FInputActionValue& Value);
	void Action_SelectBuildingGridCategory(const struct FInputActionValue& InValue, const struct FGameplayTag& InCategory);
	void Action_SelectPawnGroup(const struct FInputActionValue& Value);
	void Action_SellCommand(const struct FInputActionValue& Value);
	void Action_SetRallyPoint_BuildingGridCategory(const struct FInputActionValue& InValue, const struct FGameplayTag& InCategory);
	void Action_ShowControlsInfo(const struct FInputActionValue& Value);
	void Action_SwitchChatMode(const struct FInputActionValue& Value);
	void Action_TeleportCameraToHotspot();
	void Action_TeleportToPawnGroup(const struct FInputActionValue& Value);
	void Action_TogglePowerCommand(const struct FInputActionValue& Value);
	void ChangePrimarySelectionType(bool bPrimaryToLast);
	void Client_MatchEnded(const class FString& InMatchID, class AActor* InEndGameFocusActor, const bool bIsWinner);
	void Client_MatchStarted(const class FString& InMatchID);
	void Client_ToggleWaitingForOtherPlayersPopup(bool bShow, float Timeout, const class FString& InMatchID);
	void ClientAcceptCommandRequest(const struct FTedCommandRequestID& RequestId);
	void ClientCommandFinished(const class AActor* CommandActor, class UClass* Command, int32 CommandActorsNum, EOnTedCommandExecutedResult Result);
	void ClientDenyCommandRequest(const struct FTedCommandRequestID& RequestId);
	void ClientRefreshMatchHistoryData(class AActor* EndGameFocus, bool bIsWinner);
	void ClientReportServerTime(double RequestWorldTime, double ServerTime);
	void ClientReturnPing(double Timestamp);
	void DebugActivateUpgrade(class FName UpgradeName, bool bEnable, uint8 OwningPlayerID);
	void DebugSpawnPawn(class FName PawnDefinitionID, uint8 OwningPlayerID, uint8 Amount);
	void ExitCurrentGame(const bool bShutdown);
	void InputRedirect(const struct FInputActionInstance& InInputActionInstance, const class FName InAssociatedFunctionName, const struct FGameplayTag& InAssociatedGameplayTag);
	void KillAllPawns(const TArray<class ATedPawn*>& InPawns);
	void OnRep_SpectatorSpawnLocation();
	void PreloadAssets(const TArray<TSoftClassPtr<class UClass>>& Class_0);
	void Server_PlacePing(const struct FVector2D_NetQuantize& InPlace);
	void ServerBouncePing(double Timestamp);
	void ServerDebugActivateUpgrade(const class UTedUpgrade* Upgrade, bool bEnable, const class ATedPlayerState* OwningPlayerState);
	void ServerDebugSpawnPawn(TSubclassOf<class ATedPawn> PawnClass, const struct FVector& Location, const ETedPlayerID OwningPlayerID, uint8 Amount);
	void ServerIssueCommandRequest(const struct FTedCommandRequest& CommandRequest);
	void ServerRequestServerTime(double RequestWorldTime);
	void ServerSelectionChanged(const TArray<class ATedPawn*>& Pawns, const ETedSelectionOp Op);
	void ServerSetAutocastCommandEnabled(TSubclassOf<class UTedCommand> CommandClass, const bool bEnabled);
	void ServerSetIsDeliDisc();
	void ServerSurrender();
	void ServerUpdatePing(float ExactPing);

	void CacheReconnectMatchConfig(const struct FTedReconnectMatchConfig& InRMC) const;
	void CacheTeamID(const ETedTeamID InTeamID) const;
	void Client_OnPlayersRatingsUpdated(const TArray<struct FTedLeaderboardUserRep>& InUserRatingsBeforeMatch, const TArray<struct FTedLeaderboardUserRep>& InUserRatingsAfterMatch) const;
	void ClientDebugSetCVarTimers(const struct FTedReconnectTimers& InCVarTimers) const;
	const TSet<class ATedPawn*> GetHoveredPawns() const;
	class UTedPlayerData* GetPlayerData() const;
	ETedFaction GetPlayerFaction() const;
	class ATedHUD* GetPlayerHUD() const;
	ETedPlayerID GetPlayerId() const;
	const TSet<class ATedPawn*> GetSelectedPawns() const;
	const TSet<class ATedStructureBase*> GetSelectedStructures() const;
	const TSet<class ATedUnitBase*> GetSelectedUnits() const;
	bool HasAnythingSelected() const;
	bool HasMatchEnded() const;
	bool HasMatchStarted() const;
	bool IsOnlyASpectator() const;
	bool IsSpectator() const;
	bool IsWinner() const;
	void ServerDebugConnect() const;
	void ServerDebugDisconnect() const;
	void ServerDebugDisconnectPrintMark() const;
	void ServerDebugForceNetUpdatePlayerArray() const;
	void ServerDebugKillEnemyPawns(const int32 InOpt) const;
	void ServerDebugKillEnemyStructures(const int32 InOpt) const;
	void ServerDebugKillEnemyUnits(const int32 InOpt) const;
	void ServerDebugKillOwnedPawns(const int32 InOpt) const;
	void ServerDebugPrintConstructionQueues() const;
	void ServerDebugPrintOptionsString() const;
	void ServerDebugPrintPausers() const;
	void ServerDebugPrintPawnOwners() const;
	void ServerDebugPrintPlayerStates(const class FString& FuncName, const int32 InOnlyPlayers, const int32 InOnlyArrays) const;
	void ServerDebugSetCVarTimers(const struct FTedReconnectTimers& InCVarTimers) const;
	void ServerDebugSetNetSim(const TArray<class FString>& InArgs, class UWorld* InWorld) const;
	void ServerDestroyDeliDiscPlayer(const class ATedPlayerController* InTedPC) const;
	void ServerDestroyExpiredInactivePlayers() const;
	void ServerSyncPlayerStateNetGUIDs(const class ATedPlayerController* InTedPC) const;
	void ServerSyncStateValidate(const ETedReconnectState InState, const float InSyncTime) const;
	void SetReconnectState(const ETedReconnectState InState) const;
	void SetTimersConfig() const;
	void StartServerAckCheck() const;
	void SyncPlayerStateNetGUIDs(const TArray<uint64>& InPlayerStateNetGUIDs) const;
	void SyncStateExecute(const ETedReconnectState InState, const float InSyncTime) const;
	void SyncStateQuery() const;
	void UpdateSpectatorInviteInRichPresence(const int32 InSpectatorsNum, const int32 InSpectatorsMax) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerController">();
	}
	static class ATedPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedPlayerController>();
	}
};
static_assert(alignof(ATedPlayerController) == 0x000008, "Wrong alignment on ATedPlayerController");
static_assert(sizeof(ATedPlayerController) == 0x001820, "Wrong size on ATedPlayerController");
static_assert(offsetof(ATedPlayerController, SellStructureCommandClass) == 0x000910, "Member 'ATedPlayerController::SellStructureCommandClass' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, RepairStructureCommandClass) == 0x000918, "Member 'ATedPlayerController::RepairStructureCommandClass' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, TogglePowerStructureCommandClass) == 0x000920, "Member 'ATedPlayerController::TogglePowerStructureCommandClass' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, RallyPtClass) == 0x000928, "Member 'ATedPlayerController::RallyPtClass' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, CommandComponent) == 0x000950, "Member 'ATedPlayerController::CommandComponent' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, UnitMovementReplicationManager) == 0x000958, "Member 'ATedPlayerController::UnitMovementReplicationManager' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, PreCinematicModeLocation) == 0x000980, "Member 'ATedPlayerController::PreCinematicModeLocation' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, PreCinematicModeZoomPct) == 0x000998, "Member 'ATedPlayerController::PreCinematicModeZoomPct' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, bExitOnSurrender) == 0x00099C, "Member 'ATedPlayerController::bExitOnSurrender' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, bShutdownOnSurrender) == 0x00099D, "Member 'ATedPlayerController::bShutdownOnSurrender' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, SpectatorSpawnLocation) == 0x0009A8, "Member 'ATedPlayerController::SpectatorSpawnLocation' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, HoveredPawns) == 0x0009E0, "Member 'ATedPlayerController::HoveredPawns' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, SelectedPawns) == 0x000A30, "Member 'ATedPlayerController::SelectedPawns' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, PreviouslySelectedPawns) == 0x000A80, "Member 'ATedPlayerController::PreviouslySelectedPawns' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, SelectedStructures) == 0x000AD0, "Member 'ATedPlayerController::SelectedStructures' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, SelectedUnits) == 0x000B20, "Member 'ATedPlayerController::SelectedUnits' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, CommandExecutionIt) == 0x000B70, "Member 'ATedPlayerController::CommandExecutionIt' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, SelectionChangedDelegateK2) == 0x000B90, "Member 'ATedPlayerController::SelectionChangedDelegateK2' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, PawnGroups) == 0x000BA8, "Member 'ATedPlayerController::PawnGroups' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, RallyPoints) == 0x000BD8, "Member 'ATedPlayerController::RallyPoints' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, PingCommandClass) == 0x000C10, "Member 'ATedPlayerController::PingCommandClass' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, PingActorClass) == 0x000C18, "Member 'ATedPlayerController::PingActorClass' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, PingLimiter) == 0x000C20, "Member 'ATedPlayerController::PingLimiter' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, InputActions) == 0x000C50, "Member 'ATedPlayerController::InputActions' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, AggregatedInputActions) == 0x000CA0, "Member 'ATedPlayerController::AggregatedInputActions' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, SpectatorInputActions) == 0x000CF0, "Member 'ATedPlayerController::SpectatorInputActions' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, BaseCameraIt) == 0x000DCC, "Member 'ATedPlayerController::BaseCameraIt' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, HotspotIt) == 0x000DCD, "Member 'ATedPlayerController::HotspotIt' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, CameraLocations) == 0x000DD0, "Member 'ATedPlayerController::CameraLocations' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, bCameraRotateLeft) == 0x000DE0, "Member 'ATedPlayerController::bCameraRotateLeft' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, bCameraRotateRight) == 0x000DE1, "Member 'ATedPlayerController::bCameraRotateRight' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, SupportedCommands) == 0x000E48, "Member 'ATedPlayerController::SupportedCommands' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, ClientRequestedCommands) == 0x000E98, "Member 'ATedPlayerController::ClientRequestedCommands' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, HoveredCommandData) == 0x000EA8, "Member 'ATedPlayerController::HoveredCommandData' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, SelectedCommandData) == 0x000EF0, "Member 'ATedPlayerController::SelectedCommandData' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, PendingCommandData) == 0x000F40, "Member 'ATedPlayerController::PendingCommandData' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, PendingErrorTags) == 0x000F88, "Member 'ATedPlayerController::PendingErrorTags' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, SyncedCommandIDs) == 0x0015E8, "Member 'ATedPlayerController::SyncedCommandIDs' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, SyncMovementSpeedForCommandIDs_Handle) == 0x001638, "Member 'ATedPlayerController::SyncMovementSpeedForCommandIDs_Handle' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, CommandExecutionInfo) == 0x001640, "Member 'ATedPlayerController::CommandExecutionInfo' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, CommandCooldowns) == 0x0016A0, "Member 'ATedPlayerController::CommandCooldowns' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, PlayerCommandsPendingExecution) == 0x001710, "Member 'ATedPlayerController::PlayerCommandsPendingExecution' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, OnReplicatePlayerState) == 0x001760, "Member 'ATedPlayerController::OnReplicatePlayerState' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, CursorTraceResult) == 0x001780, "Member 'ATedPlayerController::CursorTraceResult' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, Announcer) == 0x0017C8, "Member 'ATedPlayerController::Announcer' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, PawnSoundManager) == 0x0017D0, "Member 'ATedPlayerController::PawnSoundManager' has a wrong offset!");
static_assert(offsetof(ATedPlayerController, AICommander) == 0x001818, "Member 'ATedPlayerController::AICommander' has a wrong offset!");

// Class Tempest.TedBotPlayerController
// 0x0008 (0x1828 - 0x1820)
class ATedBotPlayerController : public ATedPlayerController
{
public:
	TSubclassOf<class UAICommander>               AICommanderClass;                                  // 0x1820(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class ATedBotPlayerController* GetBotPC(const class UObject* WorldContextObject, const ETedPlayerID PlayerID);
	static void TEMP_IssueAICommand(const class UObject* WorldContextObject, class ATedUnitBase* Unit, const ETedAICommandType CommadType, const class AActor* Target, const struct FVector& TargetLocation);
	static void TEMP_IssueAICommandByClass(const class UObject* WorldContextObject, class ATedUnitBase* Unit, TSubclassOf<class UTedCommand> Class_0, const class AActor* Target, const struct FVector& TargetLocation);
	static void TEMP_IssueBatchAICommand(const class UObject* WorldContextObject, const TArray<class ATedUnitBase*>& Units, const ETedAICommandType CommadType, const class AActor* Target, const struct FVector& TargetLocation);
	static void TEMP_IssueBatchAICommandByClass(const class UObject* WorldContextObject, const TArray<class ATedUnitBase*>& Units, TSubclassOf<class UTedCommand> Class_0, const class AActor* Target, const struct FVector& TargetLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedBotPlayerController">();
	}
	static class ATedBotPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedBotPlayerController>();
	}
};
static_assert(alignof(ATedBotPlayerController) == 0x000008, "Wrong alignment on ATedBotPlayerController");
static_assert(sizeof(ATedBotPlayerController) == 0x001828, "Wrong size on ATedBotPlayerController");
static_assert(offsetof(ATedBotPlayerController, AICommanderClass) == 0x001820, "Member 'ATedBotPlayerController::AICommanderClass' has a wrong offset!");

// Class Tempest.ResourcesTooltipWidget
// 0x0000 (0x04A0 - 0x04A0)
class UResourcesTooltipWidget : public UTedTooltipWidget
{
public:
	void OnReplicatePlayerState_Handler(class ATedPlayerController* InPlayerController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResourcesTooltipWidget">();
	}
	static class UResourcesTooltipWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResourcesTooltipWidget>();
	}
};
static_assert(alignof(UResourcesTooltipWidget) == 0x000008, "Wrong alignment on UResourcesTooltipWidget");
static_assert(sizeof(UResourcesTooltipWidget) == 0x0004A0, "Wrong size on UResourcesTooltipWidget");

// Class Tempest.SkirmishAICommander
// 0x0780 (0x0800 - 0x0080)
class USkirmishAICommander final : public UAICommander
{
public:
	uint8                                         Pad_80[0x760];                                     // 0x0080(0x0760)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USkirmishDoctrinesPreset*>       DoctrinePresetsGDF;                                // 0x07E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class USkirmishDoctrinesPreset*>       DoctrinePresetsDYN;                                // 0x07F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void OnPawnDestroyed(class AActor* InActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkirmishAICommander">();
	}
	static class USkirmishAICommander* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkirmishAICommander>();
	}
};
static_assert(alignof(USkirmishAICommander) == 0x000008, "Wrong alignment on USkirmishAICommander");
static_assert(sizeof(USkirmishAICommander) == 0x000800, "Wrong size on USkirmishAICommander");
static_assert(offsetof(USkirmishAICommander, DoctrinePresetsGDF) == 0x0007E0, "Member 'USkirmishAICommander::DoctrinePresetsGDF' has a wrong offset!");
static_assert(offsetof(USkirmishAICommander, DoctrinePresetsDYN) == 0x0007F0, "Member 'USkirmishAICommander::DoctrinePresetsDYN' has a wrong offset!");

// Class Tempest.TedRequirementsTooltipDisplay
// 0x0080 (0x0490 - 0x0410)
class UTedRequirementsTooltipDisplay : public UTedPlayerDataWidget
{
public:
	struct FSlateColor                            DefaultColor;                                      // 0x0410(0x0014)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            NotEnoughResourcesColor;                           // 0x0424(0x0014)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UImage*                                 Image_CostIcon_Credits;                            // 0x0438(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_CostValue_Credits;                       // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_CostIcon_Power;                              // 0x0448(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             TextBlock_CostValue_Power;                         // 0x0450(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Image_CostIcon_Intel;                              // 0x0458(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             TextBlock_CostValue_Intel;                         // 0x0460(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Image_CostIcon_Population;                         // 0x0468(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             TextBlock_CostValue_Population;                    // 0x0470(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSlateColor                            LimitedPowerAmountColor;                           // 0x0478(0x0014)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48C[0x4];                                      // 0x048C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedRequirementsTooltipDisplay">();
	}
	static class UTedRequirementsTooltipDisplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedRequirementsTooltipDisplay>();
	}
};
static_assert(alignof(UTedRequirementsTooltipDisplay) == 0x000008, "Wrong alignment on UTedRequirementsTooltipDisplay");
static_assert(sizeof(UTedRequirementsTooltipDisplay) == 0x000490, "Wrong size on UTedRequirementsTooltipDisplay");
static_assert(offsetof(UTedRequirementsTooltipDisplay, DefaultColor) == 0x000410, "Member 'UTedRequirementsTooltipDisplay::DefaultColor' has a wrong offset!");
static_assert(offsetof(UTedRequirementsTooltipDisplay, NotEnoughResourcesColor) == 0x000424, "Member 'UTedRequirementsTooltipDisplay::NotEnoughResourcesColor' has a wrong offset!");
static_assert(offsetof(UTedRequirementsTooltipDisplay, Image_CostIcon_Credits) == 0x000438, "Member 'UTedRequirementsTooltipDisplay::Image_CostIcon_Credits' has a wrong offset!");
static_assert(offsetof(UTedRequirementsTooltipDisplay, TextBlock_CostValue_Credits) == 0x000440, "Member 'UTedRequirementsTooltipDisplay::TextBlock_CostValue_Credits' has a wrong offset!");
static_assert(offsetof(UTedRequirementsTooltipDisplay, Image_CostIcon_Power) == 0x000448, "Member 'UTedRequirementsTooltipDisplay::Image_CostIcon_Power' has a wrong offset!");
static_assert(offsetof(UTedRequirementsTooltipDisplay, TextBlock_CostValue_Power) == 0x000450, "Member 'UTedRequirementsTooltipDisplay::TextBlock_CostValue_Power' has a wrong offset!");
static_assert(offsetof(UTedRequirementsTooltipDisplay, Image_CostIcon_Intel) == 0x000458, "Member 'UTedRequirementsTooltipDisplay::Image_CostIcon_Intel' has a wrong offset!");
static_assert(offsetof(UTedRequirementsTooltipDisplay, TextBlock_CostValue_Intel) == 0x000460, "Member 'UTedRequirementsTooltipDisplay::TextBlock_CostValue_Intel' has a wrong offset!");
static_assert(offsetof(UTedRequirementsTooltipDisplay, Image_CostIcon_Population) == 0x000468, "Member 'UTedRequirementsTooltipDisplay::Image_CostIcon_Population' has a wrong offset!");
static_assert(offsetof(UTedRequirementsTooltipDisplay, TextBlock_CostValue_Population) == 0x000470, "Member 'UTedRequirementsTooltipDisplay::TextBlock_CostValue_Population' has a wrong offset!");
static_assert(offsetof(UTedRequirementsTooltipDisplay, LimitedPowerAmountColor) == 0x000478, "Member 'UTedRequirementsTooltipDisplay::LimitedPowerAmountColor' has a wrong offset!");

// Class Tempest.TedBuildingGridSlotTooltipDisplay
// 0x00A8 (0x0538 - 0x0490)
class UTedBuildingGridSlotTooltipDisplay : public UTedRequirementsTooltipDisplay
{
public:
	class ATedStructureBase*                      ContextFactory;                                    // 0x0490(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTedConstructionElementType            ContextElement;                                    // 0x0498(0x0028)(Transient, DuplicateTransient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FInputActionKeyMapping                 ContextShortcutMapping;                            // 0x04C0(0x0028)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_CostValue_AdditionalCost;                // 0x04E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Image_CostIcon_Specialist;                         // 0x04F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             TextBlock_CostValue_Specialist;                    // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Image_CostIcon_Commando;                           // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             TextBlock_CostValue_Commando;                      // 0x0508(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTagToLocalization>     GameplayTagsToLocalization;                        // 0x0510(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	uint8                                         Pad_520[0x18];                                     // 0x0520(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRefreshPrerequisites(const TArray<class FText>& InNotOwnedPrerequisites, const TArray<class FText>& InOwnedPrerequisites);

	class FText GetCostText_AdditionalCredits() const;
	class FText GetCostText_AdditionalTime() const;
	class FText GetCostText_Credits() const;
	class FText GetCostText_Intel() const;
	class FText GetCostText_Population() const;
	class FText GetCostText_Power() const;
	class FText GetCostText_Time() const;
	int32 GetCostValue_AdditionalCredits() const;
	float GetCostValue_AdditionalTime() const;
	int32 GetCostValue_Credits() const;
	int32 GetCostValue_Intel() const;
	float GetCostValue_Time() const;
	ESlateVisibility GetCostVisibility_AdditionalCredits() const;
	ESlateVisibility GetCostVisibility_AdditionalTime() const;
	ESlateVisibility GetCostVisibility_Commando() const;
	ESlateVisibility GetCostVisibility_Credits() const;
	ESlateVisibility GetCostVisibility_Intel() const;
	ESlateVisibility GetCostVisibility_Population() const;
	ESlateVisibility GetCostVisibility_Power() const;
	ESlateVisibility GetCostVisibility_Specialist() const;
	ESlateVisibility GetCostVisibility_Time() const;
	class FText GetDescription() const;
	const class FText GetDisplayName() const;
	class UTexture2D* GetIcon() const;
	bool GetIssueValue_CommandoLimitReached() const;
	bool GetIssueValue_MissingTech() const;
	bool GetIssueValue_NoConstruction() const;
	bool GetIssueValue_NoPower() const;
	bool GetIssueValue_PopulationFull() const;
	bool GetIssueValue_SpecialistLimitReached() const;
	ESlateVisibility GetIssueVisibility_CommandoLimitReached() const;
	ESlateVisibility GetIssueVisibility_MissingIntel() const;
	ESlateVisibility GetIssueVisibility_MissingTech() const;
	ESlateVisibility GetIssueVisibility_NoConstruction() const;
	ESlateVisibility GetIssueVisibility_NoPower() const;
	ESlateVisibility GetIssueVisibility_PopulationFull() const;
	ESlateVisibility GetIssueVisibility_SpecialistLimitReached() const;
	ESlateVisibility GetMissingAirPadsIssueVisibility() const;
	int32 GetPopulationCost() const;
	int32 GetPowerCost() const;
	class FText GetShortcutText() const;
	bool HasPlayerInsufficientIntel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedBuildingGridSlotTooltipDisplay">();
	}
	static class UTedBuildingGridSlotTooltipDisplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedBuildingGridSlotTooltipDisplay>();
	}
};
static_assert(alignof(UTedBuildingGridSlotTooltipDisplay) == 0x000008, "Wrong alignment on UTedBuildingGridSlotTooltipDisplay");
static_assert(sizeof(UTedBuildingGridSlotTooltipDisplay) == 0x000538, "Wrong size on UTedBuildingGridSlotTooltipDisplay");
static_assert(offsetof(UTedBuildingGridSlotTooltipDisplay, ContextFactory) == 0x000490, "Member 'UTedBuildingGridSlotTooltipDisplay::ContextFactory' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridSlotTooltipDisplay, ContextElement) == 0x000498, "Member 'UTedBuildingGridSlotTooltipDisplay::ContextElement' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridSlotTooltipDisplay, ContextShortcutMapping) == 0x0004C0, "Member 'UTedBuildingGridSlotTooltipDisplay::ContextShortcutMapping' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridSlotTooltipDisplay, TextBlock_CostValue_AdditionalCost) == 0x0004E8, "Member 'UTedBuildingGridSlotTooltipDisplay::TextBlock_CostValue_AdditionalCost' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridSlotTooltipDisplay, Image_CostIcon_Specialist) == 0x0004F0, "Member 'UTedBuildingGridSlotTooltipDisplay::Image_CostIcon_Specialist' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridSlotTooltipDisplay, TextBlock_CostValue_Specialist) == 0x0004F8, "Member 'UTedBuildingGridSlotTooltipDisplay::TextBlock_CostValue_Specialist' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridSlotTooltipDisplay, Image_CostIcon_Commando) == 0x000500, "Member 'UTedBuildingGridSlotTooltipDisplay::Image_CostIcon_Commando' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridSlotTooltipDisplay, TextBlock_CostValue_Commando) == 0x000508, "Member 'UTedBuildingGridSlotTooltipDisplay::TextBlock_CostValue_Commando' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridSlotTooltipDisplay, GameplayTagsToLocalization) == 0x000510, "Member 'UTedBuildingGridSlotTooltipDisplay::GameplayTagsToLocalization' has a wrong offset!");

// Class Tempest.SkirmishDoctrinesPreset
// 0x0020 (0x0050 - 0x0030)
class USkirmishDoctrinesPreset final : public UDataAsset
{
public:
	class FText                                   Title;                                             // 0x0030(0x0010)(Edit, NativeAccessSpecifierPrivate)
	TArray<class UTedDoctrineDefinition*>         Doctrines;                                         // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkirmishDoctrinesPreset">();
	}
	static class USkirmishDoctrinesPreset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkirmishDoctrinesPreset>();
	}
};
static_assert(alignof(USkirmishDoctrinesPreset) == 0x000008, "Wrong alignment on USkirmishDoctrinesPreset");
static_assert(sizeof(USkirmishDoctrinesPreset) == 0x000050, "Wrong size on USkirmishDoctrinesPreset");
static_assert(offsetof(USkirmishDoctrinesPreset, Title) == 0x000030, "Member 'USkirmishDoctrinesPreset::Title' has a wrong offset!");
static_assert(offsetof(USkirmishDoctrinesPreset, Doctrines) == 0x000040, "Member 'USkirmishDoctrinesPreset::Doctrines' has a wrong offset!");

// Class Tempest.TedSettingsSlot_InputAction
// 0x00D8 (0x0568 - 0x0490)
class UTedSettingsSlot_InputAction : public UTedSettingsSlot
{
public:
	class FName                                   InputName;                                         // 0x0490(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_498[0x40];                                     // 0x0498(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedInputMappingPanel*                  Value_MappingPanel;                                // 0x04D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E0[0x88];                                     // 0x04E0(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearSourceValue(const struct FPlayerKeyMapping& InValue);
	void OnTriggerMappingSlotAction(class UTedContentPanelBase* InPanel, class UTedContentPanelSlotBase* InSlot, const ETedContentSlotAction InAction);
	void SetSourceValue(const struct FPlayerKeyMapping& InValue);

	struct FPlayerKeyMapping GetSourceValue(const int32 InMappingIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSettingsSlot_InputAction">();
	}
	static class UTedSettingsSlot_InputAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSettingsSlot_InputAction>();
	}
};
static_assert(alignof(UTedSettingsSlot_InputAction) == 0x000008, "Wrong alignment on UTedSettingsSlot_InputAction");
static_assert(sizeof(UTedSettingsSlot_InputAction) == 0x000568, "Wrong size on UTedSettingsSlot_InputAction");
static_assert(offsetof(UTedSettingsSlot_InputAction, InputName) == 0x000490, "Member 'UTedSettingsSlot_InputAction::InputName' has a wrong offset!");
static_assert(offsetof(UTedSettingsSlot_InputAction, Value_MappingPanel) == 0x0004D8, "Member 'UTedSettingsSlot_InputAction::Value_MappingPanel' has a wrong offset!");

// Class Tempest.SoftActorPtrFunctions
// 0x0000 (0x0028 - 0x0028)
class USoftActorPtrFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class AActor* GetActor(const struct FSoftActorPtr& Actor);
	static void GetActorOfClass(const struct FSoftActorPtr& Actor, TSubclassOf<class AActor> Class_0, class AActor** Out);
	static bool IsEmpty(const struct FSoftActorPtr& Actor);
	static void MakeLiteralSoftActorPtr(const struct FSoftActorPtr& Actor, struct FSoftActorPtr* Out);
	static class FString ToString(const struct FSoftActorPtr& Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoftActorPtrFunctions">();
	}
	static class USoftActorPtrFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoftActorPtrFunctions>();
	}
};
static_assert(alignof(USoftActorPtrFunctions) == 0x000008, "Wrong alignment on USoftActorPtrFunctions");
static_assert(sizeof(USoftActorPtrFunctions) == 0x000028, "Wrong size on USoftActorPtrFunctions");

// Class Tempest.TedBuildingGridFactoryTypesPanel
// 0x0018 (0x07C8 - 0x07B0)
class UTedBuildingGridFactoryTypesPanel : public UTedContentPanelDynamic
{
public:
	TArray<struct FTedBuildingGridFactoryTypesPanelContent> content;                                 // 0x07B0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UTedPlayerData*                         TargetPlayerData;                                  // 0x07C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ActivateSlotByFactoryType(const struct FGameplayTag& InFactoryType, const ETedContentSlotState InState, const bool bInActivate);
	void SelectFirstAvailableSlot();

	bool GetContent(const int32 InSlotIndex, struct FTedBuildingGridFactoryTypesPanelContent* OutContent) const;
	int32 GetFactoryTypeIndex(const struct FGameplayTag& InFactoryType) const;
	bool GetSelectedContent(struct FTedBuildingGridFactoryTypesPanelContent* OutContent) const;
	class UTedPlayerData* GetTargetPlayerData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedBuildingGridFactoryTypesPanel">();
	}
	static class UTedBuildingGridFactoryTypesPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedBuildingGridFactoryTypesPanel>();
	}
};
static_assert(alignof(UTedBuildingGridFactoryTypesPanel) == 0x000008, "Wrong alignment on UTedBuildingGridFactoryTypesPanel");
static_assert(sizeof(UTedBuildingGridFactoryTypesPanel) == 0x0007C8, "Wrong size on UTedBuildingGridFactoryTypesPanel");
static_assert(offsetof(UTedBuildingGridFactoryTypesPanel, content) == 0x0007B0, "Member 'UTedBuildingGridFactoryTypesPanel::content' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridFactoryTypesPanel, TargetPlayerData) == 0x0007C0, "Member 'UTedBuildingGridFactoryTypesPanel::TargetPlayerData' has a wrong offset!");

// Class Tempest.TedAbilityBase
// 0x0030 (0x03E0 - 0x03B0)
class UTedAbilityBase : public UGameplayAbility
{
public:
	ETedAbilityEvent                              FinishCommandAbilityEvent;                         // 0x03B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRespondToStructures;                              // 0x03B1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B2[0x2];                                      // 0x03B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           EventTag;                                          // 0x03B4(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedAbilityEvent                              CommandCooldownApplicationRule;                    // 0x03BC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedAbilityEvent                              CommandCostApplicationRule;                        // 0x03BD(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3BE[0x2];                                      // 0x03BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayCommand>           SourceCommand;                                     // 0x03C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedAbilityRangeType                          AbilityRangeType;                                  // 0x03C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseTargetLocation;                                // 0x03C9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3CA[0x2];                                      // 0x03CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AbilityRange;                                      // 0x03CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bLockAILogic : 1;                                  // 0x03D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3D1[0xF];                                      // 0x03D1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyCommandCooldown();
	void ApplyCommandCost(bool bApply);
	void FinishCommand(bool bSuccess);
	float MontagePlay(class UAnimMontage* AnimMontage, float PlayRate, class FName StartSectionName);

	void GetPawnsInRange(const class AActor* AvatarActor, const float Range, const struct FTedUtilsPawnFilter& Filter, TArray<class ATedPawn*>* OutPawns, const struct FVector& Location) const;
	class UTedAbilityComponent* GetTedAbilityComponentFromActorInfo() const;
	class ATedAIController* GetTedAIControllerFromActorInfo() const;
	class ATedPawn* GetTedPawnFromActorInfo() const;
	class ATedStructureBase* GetTedStructureFromActorInfo() const;
	class ATedUnitBase* GetTedUnitFromActorInfo() const;
	bool K2_IsActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbilityBase">();
	}
	static class UTedAbilityBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbilityBase>();
	}
};
static_assert(alignof(UTedAbilityBase) == 0x000008, "Wrong alignment on UTedAbilityBase");
static_assert(sizeof(UTedAbilityBase) == 0x0003E0, "Wrong size on UTedAbilityBase");
static_assert(offsetof(UTedAbilityBase, FinishCommandAbilityEvent) == 0x0003B0, "Member 'UTedAbilityBase::FinishCommandAbilityEvent' has a wrong offset!");
static_assert(offsetof(UTedAbilityBase, bRespondToStructures) == 0x0003B1, "Member 'UTedAbilityBase::bRespondToStructures' has a wrong offset!");
static_assert(offsetof(UTedAbilityBase, EventTag) == 0x0003B4, "Member 'UTedAbilityBase::EventTag' has a wrong offset!");
static_assert(offsetof(UTedAbilityBase, CommandCooldownApplicationRule) == 0x0003BC, "Member 'UTedAbilityBase::CommandCooldownApplicationRule' has a wrong offset!");
static_assert(offsetof(UTedAbilityBase, CommandCostApplicationRule) == 0x0003BD, "Member 'UTedAbilityBase::CommandCostApplicationRule' has a wrong offset!");
static_assert(offsetof(UTedAbilityBase, SourceCommand) == 0x0003C0, "Member 'UTedAbilityBase::SourceCommand' has a wrong offset!");
static_assert(offsetof(UTedAbilityBase, AbilityRangeType) == 0x0003C8, "Member 'UTedAbilityBase::AbilityRangeType' has a wrong offset!");
static_assert(offsetof(UTedAbilityBase, bUseTargetLocation) == 0x0003C9, "Member 'UTedAbilityBase::bUseTargetLocation' has a wrong offset!");
static_assert(offsetof(UTedAbilityBase, AbilityRange) == 0x0003CC, "Member 'UTedAbilityBase::AbilityRange' has a wrong offset!");

// Class Tempest.TedAbilityComponent
// 0x0018 (0x1270 - 0x1258)
class UTedAbilityComponent final : public UAbilitySystemComponent
{
public:
	uint8                                         Pad_1258[0x18];                                    // 0x1258(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters);
	void ExecuteDamageGameplayCueLocal(const TSubclassOf<class UTedDamageType> DamageTypeClass, const struct FGameplayCueParameters& GameplayCueParameters);
	void ExecuteGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters);
	void RemoveGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters);

	bool IsAbilityActive(const struct FGameplayTag& AbilityTag, const bool bExactMatch) const;
	bool IsAnyAbilityActive(const struct FGameplayTagContainer& AbilityTags, const bool bExactMatch) const;
	struct FGameplayEffectContextHandle MakeDamageEffectContext(const TSubclassOf<class UTedDamageType> DamageType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbilityComponent">();
	}
	static class UTedAbilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbilityComponent>();
	}
};
static_assert(alignof(UTedAbilityComponent) == 0x000008, "Wrong alignment on UTedAbilityComponent");
static_assert(sizeof(UTedAbilityComponent) == 0x001270, "Wrong size on UTedAbilityComponent");

// Class Tempest.TedAbilityHelpers
// 0x0000 (0x0028 - 0x0028)
class UTedAbilityHelpers final : public UBlueprintFunctionLibrary
{
public:
	static TSubclassOf<class UTedDamageType> EffectContextGetDamageTypeClass(const struct FGameplayEffectContextHandle& EffectContext);
	static bool EffectContextHasDamageTypeClass(const struct FGameplayEffectContextHandle& EffectContext);
	static struct FGameplayEffectContextHandle EffectContextSetDamageTypeClass(const struct FGameplayEffectContextHandle& EffectContext, TSubclassOf<class UTedDamageType> DamageTypeClass);
	static class FName GetLastTagName(const struct FGameplayTag& Tag);
	static class UTedAbilityComponent* GetTedAbilitySystemComponent(const class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbilityHelpers">();
	}
	static class UTedAbilityHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbilityHelpers>();
	}
};
static_assert(alignof(UTedAbilityHelpers) == 0x000008, "Wrong alignment on UTedAbilityHelpers");
static_assert(sizeof(UTedAbilityHelpers) == 0x000028, "Wrong size on UTedAbilityHelpers");

// Class Tempest.TedSettingsSlot_Slider
// 0x0080 (0x0510 - 0x0490)
class UTedSettingsSlot_Slider : public UTedSettingsSlot
{
public:
	float                                         min_0;                                             // 0x0490(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         max_0;                                             // 0x0494(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Step;                                              // 0x0498(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49C[0x4C];                                     // 0x049C(0x004C)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bFractional : 1;                                   // 0x04E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_4E9[0x7];                                      // 0x04E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USlider*                                Value_Slider;                                      // 0x04F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEditableText*                          Value_EditableText;                                // 0x04F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEditableTextBox*                       Value_EditableTextBox;                             // 0x0500(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Value_Text;                                        // 0x0508(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnEditableTextBoxChange(const class FText& InText);
	void OnEditableTextBoxCommited(const class FText& InText, ETextCommit InCommitMethod);
	void OnEditableTextChange(const class FText& InText);
	void OnEditableTextCommited(const class FText& InText, ETextCommit InCommitMethod);
	void OnSlideMouseCaptureEnd();
	void OnSlideValueChange(float InValue);
	void OnValueChange(const float InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSettingsSlot_Slider">();
	}
	static class UTedSettingsSlot_Slider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSettingsSlot_Slider>();
	}
};
static_assert(alignof(UTedSettingsSlot_Slider) == 0x000008, "Wrong alignment on UTedSettingsSlot_Slider");
static_assert(sizeof(UTedSettingsSlot_Slider) == 0x000510, "Wrong size on UTedSettingsSlot_Slider");
static_assert(offsetof(UTedSettingsSlot_Slider, min_0) == 0x000490, "Member 'UTedSettingsSlot_Slider::min_0' has a wrong offset!");
static_assert(offsetof(UTedSettingsSlot_Slider, max_0) == 0x000494, "Member 'UTedSettingsSlot_Slider::max_0' has a wrong offset!");
static_assert(offsetof(UTedSettingsSlot_Slider, Step) == 0x000498, "Member 'UTedSettingsSlot_Slider::Step' has a wrong offset!");
static_assert(offsetof(UTedSettingsSlot_Slider, Value_Slider) == 0x0004F0, "Member 'UTedSettingsSlot_Slider::Value_Slider' has a wrong offset!");
static_assert(offsetof(UTedSettingsSlot_Slider, Value_EditableText) == 0x0004F8, "Member 'UTedSettingsSlot_Slider::Value_EditableText' has a wrong offset!");
static_assert(offsetof(UTedSettingsSlot_Slider, Value_EditableTextBox) == 0x000500, "Member 'UTedSettingsSlot_Slider::Value_EditableTextBox' has a wrong offset!");
static_assert(offsetof(UTedSettingsSlot_Slider, Value_Text) == 0x000508, "Member 'UTedSettingsSlot_Slider::Value_Text' has a wrong offset!");

// Class Tempest.TedAbilitySystemGlobals
// 0x0000 (0x02F8 - 0x02F8)
class UTedAbilitySystemGlobals final : public UAbilitySystemGlobals
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbilitySystemGlobals">();
	}
	static class UTedAbilitySystemGlobals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbilitySystemGlobals>();
	}
};
static_assert(alignof(UTedAbilitySystemGlobals) == 0x000008, "Wrong alignment on UTedAbilitySystemGlobals");
static_assert(sizeof(UTedAbilitySystemGlobals) == 0x0002F8, "Wrong size on UTedAbilitySystemGlobals");

// Class Tempest.TedBuildingGridSlotTooltip
// 0x0008 (0x04A8 - 0x04A0)
class UTedBuildingGridSlotTooltip : public UTedTooltipWidget
{
public:
	class UTedBuildingGridSlotTooltipDisplay*     DisplayWidget;                                     // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedBuildingGridSlotTooltip">();
	}
	static class UTedBuildingGridSlotTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedBuildingGridSlotTooltip>();
	}
};
static_assert(alignof(UTedBuildingGridSlotTooltip) == 0x000008, "Wrong alignment on UTedBuildingGridSlotTooltip");
static_assert(sizeof(UTedBuildingGridSlotTooltip) == 0x0004A8, "Wrong size on UTedBuildingGridSlotTooltip");
static_assert(offsetof(UTedBuildingGridSlotTooltip, DisplayWidget) == 0x0004A0, "Member 'UTedBuildingGridSlotTooltip::DisplayWidget' has a wrong offset!");

// Class Tempest.TedAbilityTask_PlayMontageAndWaitForEvent
// 0x00C0 (0x0140 - 0x0080)
class UTedAbilityTask_PlayMontageAndWaitForEvent final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)> OnCompleted; // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)> OnBlendOut; // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)> OnInterrupted; // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)> OnCancelled; // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)> EventReceived; // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlay;                                     // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  EventTags;                                         // 0x00D8(0x0020)(NativeAccessSpecifierPrivate)
	float                                         Rate;                                              // 0x00F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   StartSection;                                      // 0x00FC(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnimRootMotionTranslationScale;                    // 0x0104(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStopWhenAbilityEnds;                              // 0x0108(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_109[0x37];                                     // 0x0109(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTedAbilityTask_PlayMontageAndWaitForEvent* PlayMontageAndWaitForEvent(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class UAnimMontage* MontageToPlay_0, const struct FGameplayTagContainer& EventTags_0, float Rate_0, class FName StartSection_0, bool bStopWhenAbilityEnds_0, float AnimRootMotionTranslationScale_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbilityTask_PlayMontageAndWaitForEvent">();
	}
	static class UTedAbilityTask_PlayMontageAndWaitForEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbilityTask_PlayMontageAndWaitForEvent>();
	}
};
static_assert(alignof(UTedAbilityTask_PlayMontageAndWaitForEvent) == 0x000008, "Wrong alignment on UTedAbilityTask_PlayMontageAndWaitForEvent");
static_assert(sizeof(UTedAbilityTask_PlayMontageAndWaitForEvent) == 0x000140, "Wrong size on UTedAbilityTask_PlayMontageAndWaitForEvent");
static_assert(offsetof(UTedAbilityTask_PlayMontageAndWaitForEvent, OnCompleted) == 0x000080, "Member 'UTedAbilityTask_PlayMontageAndWaitForEvent::OnCompleted' has a wrong offset!");
static_assert(offsetof(UTedAbilityTask_PlayMontageAndWaitForEvent, OnBlendOut) == 0x000090, "Member 'UTedAbilityTask_PlayMontageAndWaitForEvent::OnBlendOut' has a wrong offset!");
static_assert(offsetof(UTedAbilityTask_PlayMontageAndWaitForEvent, OnInterrupted) == 0x0000A0, "Member 'UTedAbilityTask_PlayMontageAndWaitForEvent::OnInterrupted' has a wrong offset!");
static_assert(offsetof(UTedAbilityTask_PlayMontageAndWaitForEvent, OnCancelled) == 0x0000B0, "Member 'UTedAbilityTask_PlayMontageAndWaitForEvent::OnCancelled' has a wrong offset!");
static_assert(offsetof(UTedAbilityTask_PlayMontageAndWaitForEvent, EventReceived) == 0x0000C0, "Member 'UTedAbilityTask_PlayMontageAndWaitForEvent::EventReceived' has a wrong offset!");
static_assert(offsetof(UTedAbilityTask_PlayMontageAndWaitForEvent, MontageToPlay) == 0x0000D0, "Member 'UTedAbilityTask_PlayMontageAndWaitForEvent::MontageToPlay' has a wrong offset!");
static_assert(offsetof(UTedAbilityTask_PlayMontageAndWaitForEvent, EventTags) == 0x0000D8, "Member 'UTedAbilityTask_PlayMontageAndWaitForEvent::EventTags' has a wrong offset!");
static_assert(offsetof(UTedAbilityTask_PlayMontageAndWaitForEvent, Rate) == 0x0000F8, "Member 'UTedAbilityTask_PlayMontageAndWaitForEvent::Rate' has a wrong offset!");
static_assert(offsetof(UTedAbilityTask_PlayMontageAndWaitForEvent, StartSection) == 0x0000FC, "Member 'UTedAbilityTask_PlayMontageAndWaitForEvent::StartSection' has a wrong offset!");
static_assert(offsetof(UTedAbilityTask_PlayMontageAndWaitForEvent, AnimRootMotionTranslationScale) == 0x000104, "Member 'UTedAbilityTask_PlayMontageAndWaitForEvent::AnimRootMotionTranslationScale' has a wrong offset!");
static_assert(offsetof(UTedAbilityTask_PlayMontageAndWaitForEvent, bStopWhenAbilityEnds) == 0x000108, "Member 'UTedAbilityTask_PlayMontageAndWaitForEvent::bStopWhenAbilityEnds' has a wrong offset!");

// Class Tempest.TedAbility_ActivateUpgrade
// 0x0028 (0x0408 - 0x03E0)
class UTedAbility_ActivateUpgrade : public UTedAbilityBase
{
public:
	TSoftObjectPtr<class UTedUpgrade>             Upgrade;                                           // 0x03E0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_ActivateUpgrade">();
	}
	static class UTedAbility_ActivateUpgrade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_ActivateUpgrade>();
	}
};
static_assert(alignof(UTedAbility_ActivateUpgrade) == 0x000008, "Wrong alignment on UTedAbility_ActivateUpgrade");
static_assert(sizeof(UTedAbility_ActivateUpgrade) == 0x000408, "Wrong size on UTedAbility_ActivateUpgrade");
static_assert(offsetof(UTedAbility_ActivateUpgrade, Upgrade) == 0x0003E0, "Member 'UTedAbility_ActivateUpgrade::Upgrade' has a wrong offset!");

// Class Tempest.TedChatMessageAssembler
// 0x0070 (0x0098 - 0x0028)
class UTedChatMessageAssembler final : public UObject
{
public:
	uint8                                         Pad_28[0x70];                                      // 0x0028(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedChatMessageAssembler">();
	}
	static class UTedChatMessageAssembler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedChatMessageAssembler>();
	}
};
static_assert(alignof(UTedChatMessageAssembler) == 0x000008, "Wrong alignment on UTedChatMessageAssembler");
static_assert(sizeof(UTedChatMessageAssembler) == 0x000098, "Wrong size on UTedChatMessageAssembler");

// Class Tempest.TedAbility_Aircraft_Land
// 0x0018 (0x03F8 - 0x03E0)
class UTedAbility_Aircraft_Land : public UTedAbilityBase
{
public:
	bool                                          bAirfieldLanding;                                  // 0x03E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E1[0x7];                                      // 0x03E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class ITedAirpadInterface>   CachedAirpadInterface;                             // 0x03E8(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_Aircraft_Land">();
	}
	static class UTedAbility_Aircraft_Land* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_Aircraft_Land>();
	}
};
static_assert(alignof(UTedAbility_Aircraft_Land) == 0x000008, "Wrong alignment on UTedAbility_Aircraft_Land");
static_assert(sizeof(UTedAbility_Aircraft_Land) == 0x0003F8, "Wrong size on UTedAbility_Aircraft_Land");
static_assert(offsetof(UTedAbility_Aircraft_Land, bAirfieldLanding) == 0x0003E0, "Member 'UTedAbility_Aircraft_Land::bAirfieldLanding' has a wrong offset!");
static_assert(offsetof(UTedAbility_Aircraft_Land, CachedAirpadInterface) == 0x0003E8, "Member 'UTedAbility_Aircraft_Land::CachedAirpadInterface' has a wrong offset!");

// Class Tempest.TedSkirmishCreationScreen
// 0x0170 (0x05C8 - 0x0458)
class UTedSkirmishCreationScreen final : public UTedMenuScreenWidget
{
public:
	TMulticastInlineDelegate<void()>              OnShow;                                            // 0x0458(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnHide;                                            // 0x0468(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UTedMenuScreenPage*                     Frame;                                             // 0x0478(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FrameButton_Back;                                  // 0x0480(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FrameButton_ChangeMap;                             // 0x0488(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FrameButton_LoadGame;                              // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FrameButton_StartGame;                             // 0x0498(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAllowNoEnemy : 1;                                 // 0x04A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSwapUniqueValues : 1;                             // 0x04A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_4A1[0x7];                                      // 0x04A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTedGameCreationPlayersPanel*>   PlayerPanels;                                      // 0x04A8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSet<ETedSessionMemberSettingKey>             UniquePlayerSettings;                              // 0x04B8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	class UTedSettingsPanel*                      GameSettingsPanel;                                 // 0x0508(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTedGameCreationSettings               GameSettings;                                      // 0x0510(0x0010)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_520[0x18];                                     // 0x0520(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bFilterMapSelectionBasedOnPlayers : 1;             // 0x0538(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_539[0x7];                                      // 0x0539(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidget*                                Widget_MapSelector;                                // 0x0540(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedMapInfo*                            SelectedMap;                                       // 0x0548(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<ETedBranch, class UTedMapInfo*>          GameBranchDefaultMaps;                             // 0x0550(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UTedSaveLoadMenuScreen*                 Widget_LoadGame;                                   // 0x05A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasAnySkirmishSaves;                              // 0x05A8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A9[0x7];                                      // 0x05A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedPopup*                              Popup;                                             // 0x05B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTedPopupButton>                PopupButtons_SingleOk;                             // 0x05B8(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void CloseMapSelector();
	void HandlePopupButtonClick_Ok(const int32 InButtonIndex);
	void Hide();
	void K2_CloseMapSelector();
	void K2_OpenMapSelector();
	void K2_SelectMap();
	void K2_SetMapSelectorFilter(const struct FInt32Range& InRange);
	void OnFrameButtonTriggerSlotAction(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction);
	void OnPlayerSettingChange(class UTedGameCreationPlayersPanel* InPlayersPanel, const int32 InContentSlotIndex, const ETedSessionMemberSettingKey InKey, const int32 InNewValue, const int32 InOldValue);
	void OnRequestAddBotPlayer(class UTedGameCreationPlayersPanel* InPlayersPanel);
	void OnRequestAddHumanPlayer(class UTedGameCreationPlayersPanel* InPlayersPanel);
	void OnRequestRemovePlayer(class UTedGameCreationPlayersPanel* InPlayersPanel, const int32 InContentSlotIndex);
	void OpenLoadGameMenu();
	void OpenMapSelector();
	void RefreshAnySkirmishSavesAvailable(bool bSuccess);
	void SelectMap(const class UTedMapInfo* InMap);
	void Show();

	int32 GetCurrentPlayersNum() const;
	const struct FTedGameCreationSettings GetGameSettings() const;
	bool GetGameSettingValue(const ETedSessionSettingKey InKey, int32* OutValue) const;
	int32 GetMaxPlayersInGame() const;
	int32 GetMaxPlayersOnCurrentMap() const;
	const class UTedMapInfo* GetSelectedMap() const;
	bool HasGameSetting(const ETedSessionSettingKey InKey) const;
	bool IsSelectingMap() const;
	const class UTedMapInfo* K2_GetDefaultMap() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSkirmishCreationScreen">();
	}
	static class UTedSkirmishCreationScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSkirmishCreationScreen>();
	}
};
static_assert(alignof(UTedSkirmishCreationScreen) == 0x000008, "Wrong alignment on UTedSkirmishCreationScreen");
static_assert(sizeof(UTedSkirmishCreationScreen) == 0x0005C8, "Wrong size on UTedSkirmishCreationScreen");
static_assert(offsetof(UTedSkirmishCreationScreen, OnShow) == 0x000458, "Member 'UTedSkirmishCreationScreen::OnShow' has a wrong offset!");
static_assert(offsetof(UTedSkirmishCreationScreen, OnHide) == 0x000468, "Member 'UTedSkirmishCreationScreen::OnHide' has a wrong offset!");
static_assert(offsetof(UTedSkirmishCreationScreen, Frame) == 0x000478, "Member 'UTedSkirmishCreationScreen::Frame' has a wrong offset!");
static_assert(offsetof(UTedSkirmishCreationScreen, FrameButton_Back) == 0x000480, "Member 'UTedSkirmishCreationScreen::FrameButton_Back' has a wrong offset!");
static_assert(offsetof(UTedSkirmishCreationScreen, FrameButton_ChangeMap) == 0x000488, "Member 'UTedSkirmishCreationScreen::FrameButton_ChangeMap' has a wrong offset!");
static_assert(offsetof(UTedSkirmishCreationScreen, FrameButton_LoadGame) == 0x000490, "Member 'UTedSkirmishCreationScreen::FrameButton_LoadGame' has a wrong offset!");
static_assert(offsetof(UTedSkirmishCreationScreen, FrameButton_StartGame) == 0x000498, "Member 'UTedSkirmishCreationScreen::FrameButton_StartGame' has a wrong offset!");
static_assert(offsetof(UTedSkirmishCreationScreen, PlayerPanels) == 0x0004A8, "Member 'UTedSkirmishCreationScreen::PlayerPanels' has a wrong offset!");
static_assert(offsetof(UTedSkirmishCreationScreen, UniquePlayerSettings) == 0x0004B8, "Member 'UTedSkirmishCreationScreen::UniquePlayerSettings' has a wrong offset!");
static_assert(offsetof(UTedSkirmishCreationScreen, GameSettingsPanel) == 0x000508, "Member 'UTedSkirmishCreationScreen::GameSettingsPanel' has a wrong offset!");
static_assert(offsetof(UTedSkirmishCreationScreen, GameSettings) == 0x000510, "Member 'UTedSkirmishCreationScreen::GameSettings' has a wrong offset!");
static_assert(offsetof(UTedSkirmishCreationScreen, Widget_MapSelector) == 0x000540, "Member 'UTedSkirmishCreationScreen::Widget_MapSelector' has a wrong offset!");
static_assert(offsetof(UTedSkirmishCreationScreen, SelectedMap) == 0x000548, "Member 'UTedSkirmishCreationScreen::SelectedMap' has a wrong offset!");
static_assert(offsetof(UTedSkirmishCreationScreen, GameBranchDefaultMaps) == 0x000550, "Member 'UTedSkirmishCreationScreen::GameBranchDefaultMaps' has a wrong offset!");
static_assert(offsetof(UTedSkirmishCreationScreen, Widget_LoadGame) == 0x0005A0, "Member 'UTedSkirmishCreationScreen::Widget_LoadGame' has a wrong offset!");
static_assert(offsetof(UTedSkirmishCreationScreen, bHasAnySkirmishSaves) == 0x0005A8, "Member 'UTedSkirmishCreationScreen::bHasAnySkirmishSaves' has a wrong offset!");
static_assert(offsetof(UTedSkirmishCreationScreen, Popup) == 0x0005B0, "Member 'UTedSkirmishCreationScreen::Popup' has a wrong offset!");
static_assert(offsetof(UTedSkirmishCreationScreen, PopupButtons_SingleOk) == 0x0005B8, "Member 'UTedSkirmishCreationScreen::PopupButtons_SingleOk' has a wrong offset!");

// Class Tempest.TedAbility_Aircraft_TakeOff
// 0x0000 (0x03E0 - 0x03E0)
class UTedAbility_Aircraft_TakeOff : public UTedAbilityBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_Aircraft_TakeOff">();
	}
	static class UTedAbility_Aircraft_TakeOff* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_Aircraft_TakeOff>();
	}
};
static_assert(alignof(UTedAbility_Aircraft_TakeOff) == 0x000008, "Wrong alignment on UTedAbility_Aircraft_TakeOff");
static_assert(sizeof(UTedAbility_Aircraft_TakeOff) == 0x0003E0, "Wrong size on UTedAbility_Aircraft_TakeOff");

// Class Tempest.TedCampaignInfo
// 0x0018 (0x0048 - 0x0030)
class UTedCampaignInfo final : public UPrimaryDataAsset
{
public:
	ETedFaction                                   Faction;                                           // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTedMapInfo*>                    Maps;                                              // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCampaignInfo">();
	}
	static class UTedCampaignInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCampaignInfo>();
	}
};
static_assert(alignof(UTedCampaignInfo) == 0x000008, "Wrong alignment on UTedCampaignInfo");
static_assert(sizeof(UTedCampaignInfo) == 0x000048, "Wrong size on UTedCampaignInfo");
static_assert(offsetof(UTedCampaignInfo, Faction) == 0x000030, "Member 'UTedCampaignInfo::Faction' has a wrong offset!");
static_assert(offsetof(UTedCampaignInfo, Maps) == 0x000038, "Member 'UTedCampaignInfo::Maps' has a wrong offset!");

// Class Tempest.TedAbility_ApplyAoEGE
// 0x0010 (0x03F0 - 0x03E0)
class UTedAbility_ApplyAoEGE final : public UTedAbilityBase
{
public:
	TArray<struct FApplyAoEGEConfig>              GEConfigs;                                         // 0x03E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void ApplyGEToPawnsInRange(const struct FVector& EffectLocation, const float EffectRadius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_ApplyAoEGE">();
	}
	static class UTedAbility_ApplyAoEGE* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_ApplyAoEGE>();
	}
};
static_assert(alignof(UTedAbility_ApplyAoEGE) == 0x000008, "Wrong alignment on UTedAbility_ApplyAoEGE");
static_assert(sizeof(UTedAbility_ApplyAoEGE) == 0x0003F0, "Wrong size on UTedAbility_ApplyAoEGE");
static_assert(offsetof(UTedAbility_ApplyAoEGE, GEConfigs) == 0x0003E0, "Member 'UTedAbility_ApplyAoEGE::GEConfigs' has a wrong offset!");

// Class Tempest.TedAbility_Montage
// 0x0030 (0x0410 - 0x03E0)
class UTedAbility_Montage : public UTedAbilityBase
{
public:
	EMontageAbilityType                           AnimMontageType;                                   // 0x03E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E1[0x3];                                      // 0x03E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           DefaultMontageId;                                  // 0x03E4(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3EC[0x4];                                      // 0x03EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAbilityMontageData                    DefaultMontageData;                                // 0x03F0(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EMontageAbilityEndRule                        EndAbilityRule;                                    // 0x0408(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bStopMontageWhenAbilityEnds : 1;                   // 0x0409(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_40A[0x6];                                      // 0x040A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleMontageNotifyBegin(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointPayload);
	void HandleMontageNotifyEnd(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointPayload);
	void OnMontageNotifyBegin(class FName NotifyName);
	void OnMontageNotifyEnd(class FName NotifyName);

	struct FAbilityMontageData GetMontageData(const struct FGameplayAbilityActorInfo& ActorInfo) const;
	struct FAbilityMontageData K2_GetMontageData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_Montage">();
	}
	static class UTedAbility_Montage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_Montage>();
	}
};
static_assert(alignof(UTedAbility_Montage) == 0x000008, "Wrong alignment on UTedAbility_Montage");
static_assert(sizeof(UTedAbility_Montage) == 0x000410, "Wrong size on UTedAbility_Montage");
static_assert(offsetof(UTedAbility_Montage, AnimMontageType) == 0x0003E0, "Member 'UTedAbility_Montage::AnimMontageType' has a wrong offset!");
static_assert(offsetof(UTedAbility_Montage, DefaultMontageId) == 0x0003E4, "Member 'UTedAbility_Montage::DefaultMontageId' has a wrong offset!");
static_assert(offsetof(UTedAbility_Montage, DefaultMontageData) == 0x0003F0, "Member 'UTedAbility_Montage::DefaultMontageData' has a wrong offset!");
static_assert(offsetof(UTedAbility_Montage, EndAbilityRule) == 0x000408, "Member 'UTedAbility_Montage::EndAbilityRule' has a wrong offset!");

// Class Tempest.TedAbility_Attack
// 0x0000 (0x0410 - 0x0410)
class UTedAbility_Attack : public UTedAbility_Montage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_Attack">();
	}
	static class UTedAbility_Attack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_Attack>();
	}
};
static_assert(alignof(UTedAbility_Attack) == 0x000008, "Wrong alignment on UTedAbility_Attack");
static_assert(sizeof(UTedAbility_Attack) == 0x000410, "Wrong size on UTedAbility_Attack");

// Class Tempest.TedRallyPoint
// 0x0068 (0x02F8 - 0x0290)
class ATedRallyPoint : public AActor
{
public:
	class UStaticMeshComponent*                   StaticMesh;                                        // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         BeamIndicator;                                     // 0x0298(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BeamIndicatorColor;                                // 0x02A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BeamIndicatorSourceParamaterName;                  // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BeamIndicatorTargetParamaterName;                  // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BeamIndicatorColorParamaterName;                   // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ATedStructureBase*>              ConnectedStructures;                               // 0x02C8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UFXSystemComponent*>             BeamIndicators;                                    // 0x02D8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 Target;                                            // 0x02E8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ForceVisibleFor;                                   // 0x02F0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedRallyPoint">();
	}
	static class ATedRallyPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedRallyPoint>();
	}
};
static_assert(alignof(ATedRallyPoint) == 0x000008, "Wrong alignment on ATedRallyPoint");
static_assert(sizeof(ATedRallyPoint) == 0x0002F8, "Wrong size on ATedRallyPoint");
static_assert(offsetof(ATedRallyPoint, StaticMesh) == 0x000290, "Member 'ATedRallyPoint::StaticMesh' has a wrong offset!");
static_assert(offsetof(ATedRallyPoint, BeamIndicator) == 0x000298, "Member 'ATedRallyPoint::BeamIndicator' has a wrong offset!");
static_assert(offsetof(ATedRallyPoint, BeamIndicatorColor) == 0x0002A0, "Member 'ATedRallyPoint::BeamIndicatorColor' has a wrong offset!");
static_assert(offsetof(ATedRallyPoint, BeamIndicatorSourceParamaterName) == 0x0002B0, "Member 'ATedRallyPoint::BeamIndicatorSourceParamaterName' has a wrong offset!");
static_assert(offsetof(ATedRallyPoint, BeamIndicatorTargetParamaterName) == 0x0002B8, "Member 'ATedRallyPoint::BeamIndicatorTargetParamaterName' has a wrong offset!");
static_assert(offsetof(ATedRallyPoint, BeamIndicatorColorParamaterName) == 0x0002C0, "Member 'ATedRallyPoint::BeamIndicatorColorParamaterName' has a wrong offset!");
static_assert(offsetof(ATedRallyPoint, ConnectedStructures) == 0x0002C8, "Member 'ATedRallyPoint::ConnectedStructures' has a wrong offset!");
static_assert(offsetof(ATedRallyPoint, BeamIndicators) == 0x0002D8, "Member 'ATedRallyPoint::BeamIndicators' has a wrong offset!");
static_assert(offsetof(ATedRallyPoint, Target) == 0x0002E8, "Member 'ATedRallyPoint::Target' has a wrong offset!");
static_assert(offsetof(ATedRallyPoint, ForceVisibleFor) == 0x0002F0, "Member 'ATedRallyPoint::ForceVisibleFor' has a wrong offset!");

// Class Tempest.TedAbility_Attack_Infantry
// 0x0000 (0x0410 - 0x0410)
class UTedAbility_Attack_Infantry : public UTedAbility_Attack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_Attack_Infantry">();
	}
	static class UTedAbility_Attack_Infantry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_Attack_Infantry>();
	}
};
static_assert(alignof(UTedAbility_Attack_Infantry) == 0x000008, "Wrong alignment on UTedAbility_Attack_Infantry");
static_assert(sizeof(UTedAbility_Attack_Infantry) == 0x000410, "Wrong size on UTedAbility_Attack_Infantry");

// Class Tempest.TedWorkersWidget
// 0x0098 (0x04A8 - 0x0410)
class UTedWorkersWidget : public UTedPlayerDataWidget
{
public:
	uint8                                         bCollapseAutomatically : 1;                        // 0x0410(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_411[0x3];                                      // 0x0411(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinWorkersForCounter;                              // 0x0414(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinWorkersForExpansionButton;                      // 0x0418(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   Icon_TextureParam;                                 // 0x041C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_424[0x4];                                      // 0x0424(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedPawnsPanel*                         WorkersPanel;                                      // 0x0428(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                Counter_Root;                                      // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Counter_Text;                                      // 0x0438(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedContentPanelBase*                   ExpansionButtonPanel;                              // 0x0440(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                ExpansionArea;                                     // 0x0448(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                MultiDisplay;                                      // 0x0450(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedWorkerButton*                       WorkerButton;                                      // 0x0458(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(bool bWasExpanded, class UTedWorkersWidget* WorkerWidget)> OnWorkersWidgetExpanded; // 0x0460(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_470[0x8];                                      // 0x0470(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UInputAction>            CollapseInputAction;                               // 0x0478(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A0[0x8];                                      // 0x04A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCollapseButtonPanelActivateSlotState(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotState InState, bool bInActivated);
	void OnCollapseButtonPanelTriggerSlotAction(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction);
	void OnWorkersPanelContentChange(class UTedContentPanelDynamic* InContentPanel);
	void OnWorkersPanelTriggerSlotAction(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction);
	void RefreshPawns();
	void SetExpansion(const bool bInExpanded);
	void ShowResourcesAnimationStarted();

	int32 GetWorkersCount() const;
	bool IsExpanded() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedWorkersWidget">();
	}
	static class UTedWorkersWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedWorkersWidget>();
	}
};
static_assert(alignof(UTedWorkersWidget) == 0x000008, "Wrong alignment on UTedWorkersWidget");
static_assert(sizeof(UTedWorkersWidget) == 0x0004A8, "Wrong size on UTedWorkersWidget");
static_assert(offsetof(UTedWorkersWidget, MinWorkersForCounter) == 0x000414, "Member 'UTedWorkersWidget::MinWorkersForCounter' has a wrong offset!");
static_assert(offsetof(UTedWorkersWidget, MinWorkersForExpansionButton) == 0x000418, "Member 'UTedWorkersWidget::MinWorkersForExpansionButton' has a wrong offset!");
static_assert(offsetof(UTedWorkersWidget, Icon_TextureParam) == 0x00041C, "Member 'UTedWorkersWidget::Icon_TextureParam' has a wrong offset!");
static_assert(offsetof(UTedWorkersWidget, WorkersPanel) == 0x000428, "Member 'UTedWorkersWidget::WorkersPanel' has a wrong offset!");
static_assert(offsetof(UTedWorkersWidget, Counter_Root) == 0x000430, "Member 'UTedWorkersWidget::Counter_Root' has a wrong offset!");
static_assert(offsetof(UTedWorkersWidget, Counter_Text) == 0x000438, "Member 'UTedWorkersWidget::Counter_Text' has a wrong offset!");
static_assert(offsetof(UTedWorkersWidget, ExpansionButtonPanel) == 0x000440, "Member 'UTedWorkersWidget::ExpansionButtonPanel' has a wrong offset!");
static_assert(offsetof(UTedWorkersWidget, ExpansionArea) == 0x000448, "Member 'UTedWorkersWidget::ExpansionArea' has a wrong offset!");
static_assert(offsetof(UTedWorkersWidget, MultiDisplay) == 0x000450, "Member 'UTedWorkersWidget::MultiDisplay' has a wrong offset!");
static_assert(offsetof(UTedWorkersWidget, WorkerButton) == 0x000458, "Member 'UTedWorkersWidget::WorkerButton' has a wrong offset!");
static_assert(offsetof(UTedWorkersWidget, OnWorkersWidgetExpanded) == 0x000460, "Member 'UTedWorkersWidget::OnWorkersWidgetExpanded' has a wrong offset!");
static_assert(offsetof(UTedWorkersWidget, CollapseInputAction) == 0x000478, "Member 'UTedWorkersWidget::CollapseInputAction' has a wrong offset!");

// Class Tempest.TedWorkersWidget_Specialists
// 0x0000 (0x04A8 - 0x04A8)
class UTedWorkersWidget_Specialists : public UTedWorkersWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedWorkersWidget_Specialists">();
	}
	static class UTedWorkersWidget_Specialists* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedWorkersWidget_Specialists>();
	}
};
static_assert(alignof(UTedWorkersWidget_Specialists) == 0x000008, "Wrong alignment on UTedWorkersWidget_Specialists");
static_assert(sizeof(UTedWorkersWidget_Specialists) == 0x0004A8, "Wrong size on UTedWorkersWidget_Specialists");

// Class Tempest.TedAbility_Attack_RiotTrooper
// 0x0008 (0x0418 - 0x0410)
class UTedAbility_Attack_RiotTrooper final : public UTedAbility_Attack
{
public:
	float                                         ConeHalfAngle;                                     // 0x0410(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFriendlyFire;                                     // 0x0414(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_415[0x3];                                      // 0x0415(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PerformConeAttack();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_Attack_RiotTrooper">();
	}
	static class UTedAbility_Attack_RiotTrooper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_Attack_RiotTrooper>();
	}
};
static_assert(alignof(UTedAbility_Attack_RiotTrooper) == 0x000008, "Wrong alignment on UTedAbility_Attack_RiotTrooper");
static_assert(sizeof(UTedAbility_Attack_RiotTrooper) == 0x000418, "Wrong size on UTedAbility_Attack_RiotTrooper");
static_assert(offsetof(UTedAbility_Attack_RiotTrooper, ConeHalfAngle) == 0x000410, "Member 'UTedAbility_Attack_RiotTrooper::ConeHalfAngle' has a wrong offset!");
static_assert(offsetof(UTedAbility_Attack_RiotTrooper, bFriendlyFire) == 0x000414, "Member 'UTedAbility_Attack_RiotTrooper::bFriendlyFire' has a wrong offset!");

// Class Tempest.TedAbility_Attack_SpecialistBureau
// 0x0008 (0x03E8 - 0x03E0)
class UTedAbility_Attack_SpecialistBureau final : public UTedAbilityBase
{
public:
	float                                         ConeHalfAngle;                                     // 0x03E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFriendlyFire;                                     // 0x03E4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E5[0x3];                                      // 0x03E5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PerformConeAttack();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_Attack_SpecialistBureau">();
	}
	static class UTedAbility_Attack_SpecialistBureau* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_Attack_SpecialistBureau>();
	}
};
static_assert(alignof(UTedAbility_Attack_SpecialistBureau) == 0x000008, "Wrong alignment on UTedAbility_Attack_SpecialistBureau");
static_assert(sizeof(UTedAbility_Attack_SpecialistBureau) == 0x0003E8, "Wrong size on UTedAbility_Attack_SpecialistBureau");
static_assert(offsetof(UTedAbility_Attack_SpecialistBureau, ConeHalfAngle) == 0x0003E0, "Member 'UTedAbility_Attack_SpecialistBureau::ConeHalfAngle' has a wrong offset!");
static_assert(offsetof(UTedAbility_Attack_SpecialistBureau, bFriendlyFire) == 0x0003E4, "Member 'UTedAbility_Attack_SpecialistBureau::bFriendlyFire' has a wrong offset!");

// Class Tempest.TedResizableBox
// 0x0058 (0x0458 - 0x0400)
class UTedResizableBox : public UTedUserWidget
{
public:
	struct FVector2D                              InitialSize;                                       // 0x0400(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GridSize;                                          // 0x0410(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_414[0x4];                                      // 0x0414(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedResizableBoxControl*                Dragger;                                           // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTedResizableBoxControl*                ResizeIndicator;                                   // 0x0420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResizingEnabled;                                  // 0x0428(0x0001)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDebugBox;                                     // 0x0429(0x0001)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42A[0x2E];                                     // 0x042A(0x002E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector2D GetBoxPosition();
	struct FVector2D GetBoxSize();
	struct FVector2D GetInnerContentDesiredSize();
	void SetBoxPosition(const struct FVector2D& NewPosition);
	void SetBoxSize(const struct FVector2D& NewSize);
	void SetBoxToInnerContentDesiredSize();
	void SetResizingEnabled(const bool bEnabled);

	class UTedResizableBoxControl* GetDragger() const;
	class UTedResizableBoxControl* GetResizeIndicator() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedResizableBox">();
	}
	static class UTedResizableBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedResizableBox>();
	}
};
static_assert(alignof(UTedResizableBox) == 0x000008, "Wrong alignment on UTedResizableBox");
static_assert(sizeof(UTedResizableBox) == 0x000458, "Wrong size on UTedResizableBox");
static_assert(offsetof(UTedResizableBox, InitialSize) == 0x000400, "Member 'UTedResizableBox::InitialSize' has a wrong offset!");
static_assert(offsetof(UTedResizableBox, GridSize) == 0x000410, "Member 'UTedResizableBox::GridSize' has a wrong offset!");
static_assert(offsetof(UTedResizableBox, Dragger) == 0x000418, "Member 'UTedResizableBox::Dragger' has a wrong offset!");
static_assert(offsetof(UTedResizableBox, ResizeIndicator) == 0x000420, "Member 'UTedResizableBox::ResizeIndicator' has a wrong offset!");
static_assert(offsetof(UTedResizableBox, bResizingEnabled) == 0x000428, "Member 'UTedResizableBox::bResizingEnabled' has a wrong offset!");
static_assert(offsetof(UTedResizableBox, bShowDebugBox) == 0x000429, "Member 'UTedResizableBox::bShowDebugBox' has a wrong offset!");

// Class Tempest.TedChatPartyWidget
// 0x0050 (0x04A8 - 0x0458)
class UTedChatPartyWidget : public UTedResizableBox
{
public:
	ETedChatPartyStartPosition                    StartPosition;                                     // 0x0458(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_459[0x7];                                      // 0x0459(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(EChatMessageDestination NewDestination)> OnChatDestinationChanged; // 0x0460(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UWidget*                                Header;                                            // 0x0470(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTedChatWindow*                         ChatWindow;                                        // 0x0478(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTedChatSubsystem*                      ChatSubsystem;                                     // 0x0480(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_488[0x20];                                     // 0x0488(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UTedChatWindow* GetChatWindow();
	void K2_OnGameViewportResized();
	void MoveToStartPosition();
	void OnChatMessageCommitted(const class FText& TextCommitted, ETextCommit CommitMethod);
	void OnChatMessageReceived(const struct FTedChatMessage& Message, const int32 position);
	void OnChatMessageRemoved(const struct FTedChatMessage& Message, const int32 position);
	void ToggleChatDestination_TeamAll();

	class UWidget* GetHeader() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedChatPartyWidget">();
	}
	static class UTedChatPartyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedChatPartyWidget>();
	}
};
static_assert(alignof(UTedChatPartyWidget) == 0x000008, "Wrong alignment on UTedChatPartyWidget");
static_assert(sizeof(UTedChatPartyWidget) == 0x0004A8, "Wrong size on UTedChatPartyWidget");
static_assert(offsetof(UTedChatPartyWidget, StartPosition) == 0x000458, "Member 'UTedChatPartyWidget::StartPosition' has a wrong offset!");
static_assert(offsetof(UTedChatPartyWidget, OnChatDestinationChanged) == 0x000460, "Member 'UTedChatPartyWidget::OnChatDestinationChanged' has a wrong offset!");
static_assert(offsetof(UTedChatPartyWidget, Header) == 0x000470, "Member 'UTedChatPartyWidget::Header' has a wrong offset!");
static_assert(offsetof(UTedChatPartyWidget, ChatWindow) == 0x000478, "Member 'UTedChatPartyWidget::ChatWindow' has a wrong offset!");
static_assert(offsetof(UTedChatPartyWidget, ChatSubsystem) == 0x000480, "Member 'UTedChatPartyWidget::ChatSubsystem' has a wrong offset!");

// Class Tempest.TedChatPartyWidget_InGame
// 0x0028 (0x04D0 - 0x04A8)
class UTedChatPartyWidget_InGame final : public UTedChatPartyWidget
{
public:
	class UTedPlayerStatePanel*                   InGamePlayers;                                     // 0x04A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTedContentPanelDynamic*                InGamePings;                                       // 0x04B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B8[0x18];                                     // 0x04B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UTedContentPanelInstanced* GetHeaderButtonsPanel();
	void OnEnterPressed();
	void OnHeaderButtonSlotAction(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction);
	void OnHeaderButtonStateActivated(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotState InState, bool bInActivated);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedChatPartyWidget_InGame">();
	}
	static class UTedChatPartyWidget_InGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedChatPartyWidget_InGame>();
	}
};
static_assert(alignof(UTedChatPartyWidget_InGame) == 0x000008, "Wrong alignment on UTedChatPartyWidget_InGame");
static_assert(sizeof(UTedChatPartyWidget_InGame) == 0x0004D0, "Wrong size on UTedChatPartyWidget_InGame");
static_assert(offsetof(UTedChatPartyWidget_InGame, InGamePlayers) == 0x0004A8, "Member 'UTedChatPartyWidget_InGame::InGamePlayers' has a wrong offset!");
static_assert(offsetof(UTedChatPartyWidget_InGame, InGamePings) == 0x0004B0, "Member 'UTedChatPartyWidget_InGame::InGamePings' has a wrong offset!");

// Class Tempest.TedAbility_CaptureStructure
// 0x0008 (0x0418 - 0x0410)
class UTedAbility_CaptureStructure : public UTedAbility_Montage
{
public:
	class ATedStructureBase*                      CachedTargetStructure;                             // 0x0410(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CaptureStructure(class ATedStructureBase* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_CaptureStructure">();
	}
	static class UTedAbility_CaptureStructure* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_CaptureStructure>();
	}
};
static_assert(alignof(UTedAbility_CaptureStructure) == 0x000008, "Wrong alignment on UTedAbility_CaptureStructure");
static_assert(sizeof(UTedAbility_CaptureStructure) == 0x000418, "Wrong size on UTedAbility_CaptureStructure");
static_assert(offsetof(UTedAbility_CaptureStructure, CachedTargetStructure) == 0x000410, "Member 'UTedAbility_CaptureStructure::CachedTargetStructure' has a wrong offset!");

// Class Tempest.TedReplicationGraph
// 0x0120 (0x0690 - 0x0570)
class UTedReplicationGraph final : public UReplicationGraph
{
public:
	TArray<class UClass*>                         SpatializedClasses;                                // 0x0570(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UClass*>                         NonSpatializedChildClasses;                        // 0x0580(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UClass*>                         AlwaysRelevantClasses;                             // 0x0590(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UReplicationGraphNode_GridSpatialization2D* GridNode;                                      // 0x05A0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReplicationGraphNode_ActorList*        AlwaysRelevantNode;                                // 0x05A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B0[0xE0];                                     // 0x05B0(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedReplicationGraph">();
	}
	static class UTedReplicationGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedReplicationGraph>();
	}
};
static_assert(alignof(UTedReplicationGraph) == 0x000010, "Wrong alignment on UTedReplicationGraph");
static_assert(sizeof(UTedReplicationGraph) == 0x000690, "Wrong size on UTedReplicationGraph");
static_assert(offsetof(UTedReplicationGraph, SpatializedClasses) == 0x000570, "Member 'UTedReplicationGraph::SpatializedClasses' has a wrong offset!");
static_assert(offsetof(UTedReplicationGraph, NonSpatializedChildClasses) == 0x000580, "Member 'UTedReplicationGraph::NonSpatializedChildClasses' has a wrong offset!");
static_assert(offsetof(UTedReplicationGraph, AlwaysRelevantClasses) == 0x000590, "Member 'UTedReplicationGraph::AlwaysRelevantClasses' has a wrong offset!");
static_assert(offsetof(UTedReplicationGraph, GridNode) == 0x0005A0, "Member 'UTedReplicationGraph::GridNode' has a wrong offset!");
static_assert(offsetof(UTedReplicationGraph, AlwaysRelevantNode) == 0x0005A8, "Member 'UTedReplicationGraph::AlwaysRelevantNode' has a wrong offset!");

// Class Tempest.TedAbility_CommandeerPawn
// 0x0080 (0x0460 - 0x03E0)
class UTedAbility_CommandeerPawn final : public UTedAbilityBase
{
public:
	struct FGameplayTagContainer                  WhitelistPawnTypeTags;                             // 0x03E0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  BlacklistPawnTypeTags;                             // 0x0400(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  BlacklistGameplayTags;                             // 0x0420(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         DistanceToTargetLimit;                             // 0x0440(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_444[0x4];                                      // 0x0444(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            CommandeerGE;                                      // 0x0448(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ATedPawn>                CommandeeredPawn;                                  // 0x0450(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OriginalGainedExperience;                          // 0x0458(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_45C[0x4];                                      // 0x045C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_CommandeerPawn">();
	}
	static class UTedAbility_CommandeerPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_CommandeerPawn>();
	}
};
static_assert(alignof(UTedAbility_CommandeerPawn) == 0x000008, "Wrong alignment on UTedAbility_CommandeerPawn");
static_assert(sizeof(UTedAbility_CommandeerPawn) == 0x000460, "Wrong size on UTedAbility_CommandeerPawn");
static_assert(offsetof(UTedAbility_CommandeerPawn, WhitelistPawnTypeTags) == 0x0003E0, "Member 'UTedAbility_CommandeerPawn::WhitelistPawnTypeTags' has a wrong offset!");
static_assert(offsetof(UTedAbility_CommandeerPawn, BlacklistPawnTypeTags) == 0x000400, "Member 'UTedAbility_CommandeerPawn::BlacklistPawnTypeTags' has a wrong offset!");
static_assert(offsetof(UTedAbility_CommandeerPawn, BlacklistGameplayTags) == 0x000420, "Member 'UTedAbility_CommandeerPawn::BlacklistGameplayTags' has a wrong offset!");
static_assert(offsetof(UTedAbility_CommandeerPawn, DistanceToTargetLimit) == 0x000440, "Member 'UTedAbility_CommandeerPawn::DistanceToTargetLimit' has a wrong offset!");
static_assert(offsetof(UTedAbility_CommandeerPawn, CommandeerGE) == 0x000448, "Member 'UTedAbility_CommandeerPawn::CommandeerGE' has a wrong offset!");
static_assert(offsetof(UTedAbility_CommandeerPawn, CommandeeredPawn) == 0x000450, "Member 'UTedAbility_CommandeerPawn::CommandeeredPawn' has a wrong offset!");
static_assert(offsetof(UTedAbility_CommandeerPawn, OriginalGainedExperience) == 0x000458, "Member 'UTedAbility_CommandeerPawn::OriginalGainedExperience' has a wrong offset!");

// Class Tempest.TedWorldSettings
// 0x00F8 (0x05A8 - 0x04B0)
class ATedWorldSettings final : public AWorldSettings
{
public:
	class AWorldBoundsActor*                      WorldBoundsActor;                                  // 0x04B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFogOfWarInitMode                             FogOfWarInitMode;                                  // 0x04B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B9[0x3];                                      // 0x04B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TerrainLevelZSpan;                                 // 0x04BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TerrainLevelZMin;                                  // 0x04C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TerrainLevelZMax;                                  // 0x04C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bLimitMinTerrainLevelZ : 1;                        // 0x04C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bLimitMaxTerrainLevelZ : 1;                        // 0x04C8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDebugDrawTerrainHeights : 1;                      // 0x04C8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	EMinimapStateMode                             MinimapStateSettings;                              // 0x04C9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bMinimapIgnoresPermanentFoW : 1;                   // 0x04CA(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAllowPlayerCommands : 1;                          // 0x04CA(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BitPad_4CA_2 : 6;                                  // 0x04CA(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         Pad_4CB[0x45];                                     // 0x04CB(0x0045)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bUseMapInfo : 1;                                   // 0x0510(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_511[0x7];                                      // 0x0511(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedMapInfo*                            MapInfo;                                           // 0x0518(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             MinimapTerrainTexture;                             // 0x0520(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTedPlayerLockedTechData               TechConstruction;                                  // 0x0528(0x0028)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FTedPlayerDataInitConfig               InitResources;                                     // 0x0550(0x0058)(Edit, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedWorldSettings">();
	}
	static class ATedWorldSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedWorldSettings>();
	}
};
static_assert(alignof(ATedWorldSettings) == 0x000008, "Wrong alignment on ATedWorldSettings");
static_assert(sizeof(ATedWorldSettings) == 0x0005A8, "Wrong size on ATedWorldSettings");
static_assert(offsetof(ATedWorldSettings, WorldBoundsActor) == 0x0004B0, "Member 'ATedWorldSettings::WorldBoundsActor' has a wrong offset!");
static_assert(offsetof(ATedWorldSettings, FogOfWarInitMode) == 0x0004B8, "Member 'ATedWorldSettings::FogOfWarInitMode' has a wrong offset!");
static_assert(offsetof(ATedWorldSettings, TerrainLevelZSpan) == 0x0004BC, "Member 'ATedWorldSettings::TerrainLevelZSpan' has a wrong offset!");
static_assert(offsetof(ATedWorldSettings, TerrainLevelZMin) == 0x0004C0, "Member 'ATedWorldSettings::TerrainLevelZMin' has a wrong offset!");
static_assert(offsetof(ATedWorldSettings, TerrainLevelZMax) == 0x0004C4, "Member 'ATedWorldSettings::TerrainLevelZMax' has a wrong offset!");
static_assert(offsetof(ATedWorldSettings, MinimapStateSettings) == 0x0004C9, "Member 'ATedWorldSettings::MinimapStateSettings' has a wrong offset!");
static_assert(offsetof(ATedWorldSettings, MapInfo) == 0x000518, "Member 'ATedWorldSettings::MapInfo' has a wrong offset!");
static_assert(offsetof(ATedWorldSettings, MinimapTerrainTexture) == 0x000520, "Member 'ATedWorldSettings::MinimapTerrainTexture' has a wrong offset!");
static_assert(offsetof(ATedWorldSettings, TechConstruction) == 0x000528, "Member 'ATedWorldSettings::TechConstruction' has a wrong offset!");
static_assert(offsetof(ATedWorldSettings, InitResources) == 0x000550, "Member 'ATedWorldSettings::InitResources' has a wrong offset!");

// Class Tempest.TedAbility_ConsumeGarrisonedUnitBuff
// 0x0068 (0x0448 - 0x03E0)
class UTedAbility_ConsumeGarrisonedUnitBuff final : public UTedAbilityBase
{
public:
	TSubclassOf<class UGameplayEffect>            ApplyToOwnerEffectClass;                           // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, int32>              UnitsToConsumeNum;                                 // 0x03E8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bAutoCast;                                         // 0x0438(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_439[0x3];                                      // 0x0439(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TryApplyEffectFrequency;                           // 0x043C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           AutoCast_TimerHandle;                              // 0x0440(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnEffectApplied();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_ConsumeGarrisonedUnitBuff">();
	}
	static class UTedAbility_ConsumeGarrisonedUnitBuff* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_ConsumeGarrisonedUnitBuff>();
	}
};
static_assert(alignof(UTedAbility_ConsumeGarrisonedUnitBuff) == 0x000008, "Wrong alignment on UTedAbility_ConsumeGarrisonedUnitBuff");
static_assert(sizeof(UTedAbility_ConsumeGarrisonedUnitBuff) == 0x000448, "Wrong size on UTedAbility_ConsumeGarrisonedUnitBuff");
static_assert(offsetof(UTedAbility_ConsumeGarrisonedUnitBuff, ApplyToOwnerEffectClass) == 0x0003E0, "Member 'UTedAbility_ConsumeGarrisonedUnitBuff::ApplyToOwnerEffectClass' has a wrong offset!");
static_assert(offsetof(UTedAbility_ConsumeGarrisonedUnitBuff, UnitsToConsumeNum) == 0x0003E8, "Member 'UTedAbility_ConsumeGarrisonedUnitBuff::UnitsToConsumeNum' has a wrong offset!");
static_assert(offsetof(UTedAbility_ConsumeGarrisonedUnitBuff, bAutoCast) == 0x000438, "Member 'UTedAbility_ConsumeGarrisonedUnitBuff::bAutoCast' has a wrong offset!");
static_assert(offsetof(UTedAbility_ConsumeGarrisonedUnitBuff, TryApplyEffectFrequency) == 0x00043C, "Member 'UTedAbility_ConsumeGarrisonedUnitBuff::TryApplyEffectFrequency' has a wrong offset!");
static_assert(offsetof(UTedAbility_ConsumeGarrisonedUnitBuff, AutoCast_TimerHandle) == 0x000440, "Member 'UTedAbility_ConsumeGarrisonedUnitBuff::AutoCast_TimerHandle' has a wrong offset!");

// Class Tempest.TedAbility_ControlDrone
// 0x0010 (0x0420 - 0x0410)
class UTedAbility_ControlDrone : public UTedAbility_Montage
{
public:
	class UBehaviorTree*                          IdleBehaviourOverride;                             // 0x0410(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           AbilityEndingEventTag;                             // 0x0418(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_ControlDrone">();
	}
	static class UTedAbility_ControlDrone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_ControlDrone>();
	}
};
static_assert(alignof(UTedAbility_ControlDrone) == 0x000008, "Wrong alignment on UTedAbility_ControlDrone");
static_assert(sizeof(UTedAbility_ControlDrone) == 0x000420, "Wrong size on UTedAbility_ControlDrone");
static_assert(offsetof(UTedAbility_ControlDrone, IdleBehaviourOverride) == 0x000410, "Member 'UTedAbility_ControlDrone::IdleBehaviourOverride' has a wrong offset!");
static_assert(offsetof(UTedAbility_ControlDrone, AbilityEndingEventTag) == 0x000418, "Member 'UTedAbility_ControlDrone::AbilityEndingEventTag' has a wrong offset!");

// Class Tempest.TedAbility_Death
// 0x0000 (0x0410 - 0x0410)
class UTedAbility_Death : public UTedAbility_Montage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_Death">();
	}
	static class UTedAbility_Death* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_Death>();
	}
};
static_assert(alignof(UTedAbility_Death) == 0x000008, "Wrong alignment on UTedAbility_Death");
static_assert(sizeof(UTedAbility_Death) == 0x000410, "Wrong size on UTedAbility_Death");

// Class Tempest.TedReplicationGraphNode_FogOfWar
// 0x0110 (0x01E0 - 0x00D0)
class UTedReplicationGraphNode_FogOfWar final : public UReplicationGraphNode_ActorList
{
public:
	bool                                          bFogOfWarBasedClientSidePreload;                   // 0x00D0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x17];                                      // 0x00D1(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AActor*>                           WasEverVisible;                                    // 0x00E8(0x0050)(NativeAccessSpecifierPrivate)
	TSet<class AActor*>                           WasRecentlyVisible;                                // 0x0138(0x0050)(NativeAccessSpecifierPrivate)
	TSet<TSubclassOf<class AActor>>               WasEverCached;                                     // 0x0188(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D8[0x8];                                      // 0x01D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedReplicationGraphNode_FogOfWar">();
	}
	static class UTedReplicationGraphNode_FogOfWar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedReplicationGraphNode_FogOfWar>();
	}
};
static_assert(alignof(UTedReplicationGraphNode_FogOfWar) == 0x000008, "Wrong alignment on UTedReplicationGraphNode_FogOfWar");
static_assert(sizeof(UTedReplicationGraphNode_FogOfWar) == 0x0001E0, "Wrong size on UTedReplicationGraphNode_FogOfWar");
static_assert(offsetof(UTedReplicationGraphNode_FogOfWar, bFogOfWarBasedClientSidePreload) == 0x0000D0, "Member 'UTedReplicationGraphNode_FogOfWar::bFogOfWarBasedClientSidePreload' has a wrong offset!");
static_assert(offsetof(UTedReplicationGraphNode_FogOfWar, WasEverVisible) == 0x0000E8, "Member 'UTedReplicationGraphNode_FogOfWar::WasEverVisible' has a wrong offset!");
static_assert(offsetof(UTedReplicationGraphNode_FogOfWar, WasRecentlyVisible) == 0x000138, "Member 'UTedReplicationGraphNode_FogOfWar::WasRecentlyVisible' has a wrong offset!");
static_assert(offsetof(UTedReplicationGraphNode_FogOfWar, WasEverCached) == 0x000188, "Member 'UTedReplicationGraphNode_FogOfWar::WasEverCached' has a wrong offset!");

// Class Tempest.TedAbility_Death_Infantry
// 0x0000 (0x0410 - 0x0410)
class UTedAbility_Death_Infantry : public UTedAbility_Death
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_Death_Infantry">();
	}
	static class UTedAbility_Death_Infantry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_Death_Infantry>();
	}
};
static_assert(alignof(UTedAbility_Death_Infantry) == 0x000008, "Wrong alignment on UTedAbility_Death_Infantry");
static_assert(sizeof(UTedAbility_Death_Infantry) == 0x000410, "Wrong size on UTedAbility_Death_Infantry");

// Class Tempest.TempestFieldBuildConfigAsset
// 0x00A0 (0x00D0 - 0x0030)
class UTempestFieldBuildConfigAsset final : public UDataAsset
{
public:
	struct FTempestFieldBuildConfig               Data;                                              // 0x0030(0x00A0)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TempestFieldBuildConfigAsset">();
	}
	static class UTempestFieldBuildConfigAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTempestFieldBuildConfigAsset>();
	}
};
static_assert(alignof(UTempestFieldBuildConfigAsset) == 0x000008, "Wrong alignment on UTempestFieldBuildConfigAsset");
static_assert(sizeof(UTempestFieldBuildConfigAsset) == 0x0000D0, "Wrong size on UTempestFieldBuildConfigAsset");
static_assert(offsetof(UTempestFieldBuildConfigAsset, Data) == 0x000030, "Member 'UTempestFieldBuildConfigAsset::Data' has a wrong offset!");

// Class Tempest.TedAbility_DeployStructure
// 0x0110 (0x0520 - 0x0410)
#pragma pack(push, 0x1)
class alignas(0x10) UTedAbility_DeployStructure : public UTedAbility_Montage
{
public:
	TSubclassOf<class ATedStructureBase>          StructureClassToDeploy;                            // 0x0410(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bReplacePawn : 1;                                  // 0x0418(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bInterpolateTransformToMatchStructure : 1;         // 0x0418(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPreserveHealthPct : 1;                            // 0x0418(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_419[0x3];                                      // 0x0419(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AlignmentDistanceTolerance;                        // 0x041C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UNavArea>                   ReservedNavAreaClass;                              // 0x0420(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedStructureAlignment                        DeployAlignment;                                   // 0x0428(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_429[0x7];                                      // 0x0429(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInterpolationData                     InterpolationData;                                 // 0x0430(0x00E0)(NoDestructor, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          NavArea;                                           // 0x0510(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_DeployStructure">();
	}
	static class UTedAbility_DeployStructure* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_DeployStructure>();
	}
};
#pragma pack(pop)
static_assert(alignof(UTedAbility_DeployStructure) == 0x000010, "Wrong alignment on UTedAbility_DeployStructure");
static_assert(sizeof(UTedAbility_DeployStructure) == 0x000520, "Wrong size on UTedAbility_DeployStructure");
static_assert(offsetof(UTedAbility_DeployStructure, StructureClassToDeploy) == 0x000410, "Member 'UTedAbility_DeployStructure::StructureClassToDeploy' has a wrong offset!");
static_assert(offsetof(UTedAbility_DeployStructure, AlignmentDistanceTolerance) == 0x00041C, "Member 'UTedAbility_DeployStructure::AlignmentDistanceTolerance' has a wrong offset!");
static_assert(offsetof(UTedAbility_DeployStructure, ReservedNavAreaClass) == 0x000420, "Member 'UTedAbility_DeployStructure::ReservedNavAreaClass' has a wrong offset!");
static_assert(offsetof(UTedAbility_DeployStructure, DeployAlignment) == 0x000428, "Member 'UTedAbility_DeployStructure::DeployAlignment' has a wrong offset!");
static_assert(offsetof(UTedAbility_DeployStructure, InterpolationData) == 0x000430, "Member 'UTedAbility_DeployStructure::InterpolationData' has a wrong offset!");
static_assert(offsetof(UTedAbility_DeployStructure, NavArea) == 0x000510, "Member 'UTedAbility_DeployStructure::NavArea' has a wrong offset!");

// Class Tempest.TedAbility_DeployStructure_Refinery
// 0x0000 (0x0520 - 0x0520)
class UTedAbility_DeployStructure_Refinery : public UTedAbility_DeployStructure
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_DeployStructure_Refinery">();
	}
	static class UTedAbility_DeployStructure_Refinery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_DeployStructure_Refinery>();
	}
};
static_assert(alignof(UTedAbility_DeployStructure_Refinery) == 0x000010, "Wrong alignment on UTedAbility_DeployStructure_Refinery");
static_assert(sizeof(UTedAbility_DeployStructure_Refinery) == 0x000520, "Wrong size on UTedAbility_DeployStructure_Refinery");

// Class Tempest.TedMenuScreenPage
// 0x0088 (0x0488 - 0x0400)
class UTedMenuScreenPage : public UTedUserWidget
{
public:
	class USlateBrushAsset*                       Background;                                        // 0x0400(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FText>                           Titles;                                            // 0x0408(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotState InState, bool bInActivated)> OnActivateTabState; // 0x0418(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction)> OnTriggetTabAction; // 0x0428(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UTedUI_InstancedContent*>        Tabs;                                              // 0x0438(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UTedContentPanelInstanced*              TabsPanel;                                         // 0x0448(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotState InState, bool bInActivated)> OnActivateButtonState; // 0x0450(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction)> OnTriggetButtonAction; // 0x0460(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UTedUI_InstancedContent*>        Buttons;                                           // 0x0470(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UTedContentPanelInstanced*              ButtonsPanel;                                      // 0x0480(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnActivateButtonState_Handler(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotState InState, bool bInActivated);
	void OnActivateTabState_Handler(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotState InState, bool bInActivated);
	void OnClose(const class UObject* InContext, const bool bInInstant);
	void OnInnerPanelContentChange_Handler(class UTedContentPanelDynamic* InContentPanel);
	void OnOpen(const class UObject* InContext, const bool bInInstant);
	void OnRefreshBackground(const class USlateBrushAsset* InBackground);
	void OnRefreshTitles();
	void OnTriggetButtonAction_Handler(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction);
	void OnTriggetTabAction_Handler(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction);
	void SetBackground(const class USlateBrushAsset* InBackground);
	void SetButtons(const TArray<class UTedUI_InstancedContent*>& InButtons);
	void SetTabs(const TArray<class UTedUI_InstancedContent*>& InTabs);
	void SetTitle(const class FText& InTitle);
	void SetTitles(const TArray<class FText>& InTitles);

	const class USlateBrushAsset* GetBackground() const;
	class UTedContentPanelInstanced* GetButtonsPanel() const;
	class UTedContentPanelInstanced* GetTabsPanel() const;
	const class FText GetTitle(const int32 InIndex) const;
	const TArray<class FText> GetTitles() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMenuScreenPage">();
	}
	static class UTedMenuScreenPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMenuScreenPage>();
	}
};
static_assert(alignof(UTedMenuScreenPage) == 0x000008, "Wrong alignment on UTedMenuScreenPage");
static_assert(sizeof(UTedMenuScreenPage) == 0x000488, "Wrong size on UTedMenuScreenPage");
static_assert(offsetof(UTedMenuScreenPage, Background) == 0x000400, "Member 'UTedMenuScreenPage::Background' has a wrong offset!");
static_assert(offsetof(UTedMenuScreenPage, Titles) == 0x000408, "Member 'UTedMenuScreenPage::Titles' has a wrong offset!");
static_assert(offsetof(UTedMenuScreenPage, OnActivateTabState) == 0x000418, "Member 'UTedMenuScreenPage::OnActivateTabState' has a wrong offset!");
static_assert(offsetof(UTedMenuScreenPage, OnTriggetTabAction) == 0x000428, "Member 'UTedMenuScreenPage::OnTriggetTabAction' has a wrong offset!");
static_assert(offsetof(UTedMenuScreenPage, Tabs) == 0x000438, "Member 'UTedMenuScreenPage::Tabs' has a wrong offset!");
static_assert(offsetof(UTedMenuScreenPage, TabsPanel) == 0x000448, "Member 'UTedMenuScreenPage::TabsPanel' has a wrong offset!");
static_assert(offsetof(UTedMenuScreenPage, OnActivateButtonState) == 0x000450, "Member 'UTedMenuScreenPage::OnActivateButtonState' has a wrong offset!");
static_assert(offsetof(UTedMenuScreenPage, OnTriggetButtonAction) == 0x000460, "Member 'UTedMenuScreenPage::OnTriggetButtonAction' has a wrong offset!");
static_assert(offsetof(UTedMenuScreenPage, Buttons) == 0x000470, "Member 'UTedMenuScreenPage::Buttons' has a wrong offset!");
static_assert(offsetof(UTedMenuScreenPage, ButtonsPanel) == 0x000480, "Member 'UTedMenuScreenPage::ButtonsPanel' has a wrong offset!");

// Class Tempest.TedAbility_DisarmMine
// 0x0020 (0x0430 - 0x0410)
class UTedAbility_DisarmMine : public UTedAbility_Montage
{
public:
	float                                         DistanceLimit;                                     // 0x0410(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DisarmTime;                                        // 0x0414(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATedMineActor*                          CachedMineTarget;                                  // 0x0418(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           DisarmMineHandle;                                  // 0x0420(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           ValidateAbilityHandle;                             // 0x0428(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_DisarmMine">();
	}
	static class UTedAbility_DisarmMine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_DisarmMine>();
	}
};
static_assert(alignof(UTedAbility_DisarmMine) == 0x000008, "Wrong alignment on UTedAbility_DisarmMine");
static_assert(sizeof(UTedAbility_DisarmMine) == 0x000430, "Wrong size on UTedAbility_DisarmMine");
static_assert(offsetof(UTedAbility_DisarmMine, DistanceLimit) == 0x000410, "Member 'UTedAbility_DisarmMine::DistanceLimit' has a wrong offset!");
static_assert(offsetof(UTedAbility_DisarmMine, DisarmTime) == 0x000414, "Member 'UTedAbility_DisarmMine::DisarmTime' has a wrong offset!");
static_assert(offsetof(UTedAbility_DisarmMine, CachedMineTarget) == 0x000418, "Member 'UTedAbility_DisarmMine::CachedMineTarget' has a wrong offset!");
static_assert(offsetof(UTedAbility_DisarmMine, DisarmMineHandle) == 0x000420, "Member 'UTedAbility_DisarmMine::DisarmMineHandle' has a wrong offset!");
static_assert(offsetof(UTedAbility_DisarmMine, ValidateAbilityHandle) == 0x000428, "Member 'UTedAbility_DisarmMine::ValidateAbilityHandle' has a wrong offset!");

// Class Tempest.TedNewReplicationGraphSettings
// 0x0100 (0x0138 - 0x0038)
class UTedNewReplicationGraphSettings final : public UDeveloperSettings
{
public:
	bool                                          bEnableReplicationGraph;                           // 0x0038(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFOWBehaviour                                 FogOfWarBehaviourForStructures;                    // 0x0039(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFOWBehaviour                                 FogOfWarBehaviourForUnits;                         // 0x003A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFOWBehaviour                                 FogOfWarBehaviourForGhostStructures;               // 0x003B(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSoftObjectPath>                AlwaysLoadedClientAssets;                          // 0x0040(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	bool                                          bFogOfWarBasedClientSidePreload;                   // 0x0050(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTedPreloadScenario>            PreloadScenarios;                                  // 0x0058(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TMap<TSoftObjectPtr<class UTedMapInfo>, struct FTedLevelPreloadScenario> LevelPreloadScenario;   // 0x0068(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	TMap<class FString, struct FTedLevelPreloadScenario> BriefingPreloadScenario;                    // 0x00B8(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	bool                                          bPreloadAssetsOnDedicatedServer;                   // 0x0108(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreloadAssetsOnClient;                            // 0x0109(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreloadAssetsOnStandalone;                        // 0x010A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyDormantDynamicActorsInSpatialGrid;         // 0x010B(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestructionInfoMaxDist;                            // 0x010C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpatialGridCellSize;                               // 0x0110(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpatialBiasX;                                      // 0x0114(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpatialBiasY;                                      // 0x0118(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableSpatialRebuilds;                           // 0x011C(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11D[0x3];                                      // 0x011D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DynamicActorFrequencyBuckets;                      // 0x0120(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRepGraphActorClassSettings>    ClassSettings;                                     // 0x0128(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedNewReplicationGraphSettings">();
	}
	static class UTedNewReplicationGraphSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedNewReplicationGraphSettings>();
	}
};
static_assert(alignof(UTedNewReplicationGraphSettings) == 0x000008, "Wrong alignment on UTedNewReplicationGraphSettings");
static_assert(sizeof(UTedNewReplicationGraphSettings) == 0x000138, "Wrong size on UTedNewReplicationGraphSettings");
static_assert(offsetof(UTedNewReplicationGraphSettings, bEnableReplicationGraph) == 0x000038, "Member 'UTedNewReplicationGraphSettings::bEnableReplicationGraph' has a wrong offset!");
static_assert(offsetof(UTedNewReplicationGraphSettings, FogOfWarBehaviourForStructures) == 0x000039, "Member 'UTedNewReplicationGraphSettings::FogOfWarBehaviourForStructures' has a wrong offset!");
static_assert(offsetof(UTedNewReplicationGraphSettings, FogOfWarBehaviourForUnits) == 0x00003A, "Member 'UTedNewReplicationGraphSettings::FogOfWarBehaviourForUnits' has a wrong offset!");
static_assert(offsetof(UTedNewReplicationGraphSettings, FogOfWarBehaviourForGhostStructures) == 0x00003B, "Member 'UTedNewReplicationGraphSettings::FogOfWarBehaviourForGhostStructures' has a wrong offset!");
static_assert(offsetof(UTedNewReplicationGraphSettings, AlwaysLoadedClientAssets) == 0x000040, "Member 'UTedNewReplicationGraphSettings::AlwaysLoadedClientAssets' has a wrong offset!");
static_assert(offsetof(UTedNewReplicationGraphSettings, bFogOfWarBasedClientSidePreload) == 0x000050, "Member 'UTedNewReplicationGraphSettings::bFogOfWarBasedClientSidePreload' has a wrong offset!");
static_assert(offsetof(UTedNewReplicationGraphSettings, PreloadScenarios) == 0x000058, "Member 'UTedNewReplicationGraphSettings::PreloadScenarios' has a wrong offset!");
static_assert(offsetof(UTedNewReplicationGraphSettings, LevelPreloadScenario) == 0x000068, "Member 'UTedNewReplicationGraphSettings::LevelPreloadScenario' has a wrong offset!");
static_assert(offsetof(UTedNewReplicationGraphSettings, BriefingPreloadScenario) == 0x0000B8, "Member 'UTedNewReplicationGraphSettings::BriefingPreloadScenario' has a wrong offset!");
static_assert(offsetof(UTedNewReplicationGraphSettings, bPreloadAssetsOnDedicatedServer) == 0x000108, "Member 'UTedNewReplicationGraphSettings::bPreloadAssetsOnDedicatedServer' has a wrong offset!");
static_assert(offsetof(UTedNewReplicationGraphSettings, bPreloadAssetsOnClient) == 0x000109, "Member 'UTedNewReplicationGraphSettings::bPreloadAssetsOnClient' has a wrong offset!");
static_assert(offsetof(UTedNewReplicationGraphSettings, bPreloadAssetsOnStandalone) == 0x00010A, "Member 'UTedNewReplicationGraphSettings::bPreloadAssetsOnStandalone' has a wrong offset!");
static_assert(offsetof(UTedNewReplicationGraphSettings, bDestroyDormantDynamicActorsInSpatialGrid) == 0x00010B, "Member 'UTedNewReplicationGraphSettings::bDestroyDormantDynamicActorsInSpatialGrid' has a wrong offset!");
static_assert(offsetof(UTedNewReplicationGraphSettings, DestructionInfoMaxDist) == 0x00010C, "Member 'UTedNewReplicationGraphSettings::DestructionInfoMaxDist' has a wrong offset!");
static_assert(offsetof(UTedNewReplicationGraphSettings, SpatialGridCellSize) == 0x000110, "Member 'UTedNewReplicationGraphSettings::SpatialGridCellSize' has a wrong offset!");
static_assert(offsetof(UTedNewReplicationGraphSettings, SpatialBiasX) == 0x000114, "Member 'UTedNewReplicationGraphSettings::SpatialBiasX' has a wrong offset!");
static_assert(offsetof(UTedNewReplicationGraphSettings, SpatialBiasY) == 0x000118, "Member 'UTedNewReplicationGraphSettings::SpatialBiasY' has a wrong offset!");
static_assert(offsetof(UTedNewReplicationGraphSettings, bDisableSpatialRebuilds) == 0x00011C, "Member 'UTedNewReplicationGraphSettings::bDisableSpatialRebuilds' has a wrong offset!");
static_assert(offsetof(UTedNewReplicationGraphSettings, DynamicActorFrequencyBuckets) == 0x000120, "Member 'UTedNewReplicationGraphSettings::DynamicActorFrequencyBuckets' has a wrong offset!");
static_assert(offsetof(UTedNewReplicationGraphSettings, ClassSettings) == 0x000128, "Member 'UTedNewReplicationGraphSettings::ClassSettings' has a wrong offset!");

// Class Tempest.TedAbility_DismantleStructure
// 0x0038 (0x0418 - 0x03E0)
class UTedAbility_DismantleStructure : public UTedAbilityBase
{
public:
	uint8                                         bPreserveHealthPct : 1;                            // 0x03E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3E1[0x7];                                      // 0x03E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ATedUnitBase>               UnitClass;                                         // 0x03E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ServerExtraTimeKeepAlive;                          // 0x03F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpawnUnitManually;                                // 0x03F4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F5[0x3];                                      // 0x03F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ExplicitSpawnOffset;                               // 0x03F8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAdjustToGroundOnSpawn;                            // 0x0410(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_411[0x3];                                      // 0x0411(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdjustToGroundOnSpawnDelay;                        // 0x0414(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class ATedUnitBase* SpawnUnit(const bool bFinishSpawningManually);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_DismantleStructure">();
	}
	static class UTedAbility_DismantleStructure* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_DismantleStructure>();
	}
};
static_assert(alignof(UTedAbility_DismantleStructure) == 0x000008, "Wrong alignment on UTedAbility_DismantleStructure");
static_assert(sizeof(UTedAbility_DismantleStructure) == 0x000418, "Wrong size on UTedAbility_DismantleStructure");
static_assert(offsetof(UTedAbility_DismantleStructure, UnitClass) == 0x0003E8, "Member 'UTedAbility_DismantleStructure::UnitClass' has a wrong offset!");
static_assert(offsetof(UTedAbility_DismantleStructure, ServerExtraTimeKeepAlive) == 0x0003F0, "Member 'UTedAbility_DismantleStructure::ServerExtraTimeKeepAlive' has a wrong offset!");
static_assert(offsetof(UTedAbility_DismantleStructure, bSpawnUnitManually) == 0x0003F4, "Member 'UTedAbility_DismantleStructure::bSpawnUnitManually' has a wrong offset!");
static_assert(offsetof(UTedAbility_DismantleStructure, ExplicitSpawnOffset) == 0x0003F8, "Member 'UTedAbility_DismantleStructure::ExplicitSpawnOffset' has a wrong offset!");
static_assert(offsetof(UTedAbility_DismantleStructure, bAdjustToGroundOnSpawn) == 0x000410, "Member 'UTedAbility_DismantleStructure::bAdjustToGroundOnSpawn' has a wrong offset!");
static_assert(offsetof(UTedAbility_DismantleStructure, AdjustToGroundOnSpawnDelay) == 0x000414, "Member 'UTedAbility_DismantleStructure::AdjustToGroundOnSpawnDelay' has a wrong offset!");

// Class Tempest.TedChatSubsystem
// 0x0180 (0x01B0 - 0x0030)
class alignas(0x10) UTedChatSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FTedChatMessage& Message, const int32 position)> OnMessageReceivedDelegate; // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FTedChatMessage& Message, const int32 position)> OnMessageRemovedDelegate; // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x150];                                     // 0x0058(0x0150)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedChatMessageAssembler*               MessageAssembler;                                  // 0x01A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool AddLocalMarketingMessage(const class FString& Message);
	bool AddLocalMessage(const EChatMessageSender Sender, const class FText& SenderName, const class FString& Message);
	bool AddLocalSystemMessage(const class FString& Message);
	TArray<struct FTedChatMessage> GetMessageHistory();
	bool SendMessage(const EChatMessageSender Sender, const class FString& InMessage);
	bool SendTeamMessage(const class FString& InMessage);
	bool SendWhisper(const class FString& DestinationPlayerId, const class FString& InMessage);
	void SetSenderType(EChatMessageSender InSenderType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedChatSubsystem">();
	}
	static class UTedChatSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedChatSubsystem>();
	}
};
static_assert(alignof(UTedChatSubsystem) == 0x000010, "Wrong alignment on UTedChatSubsystem");
static_assert(sizeof(UTedChatSubsystem) == 0x0001B0, "Wrong size on UTedChatSubsystem");
static_assert(offsetof(UTedChatSubsystem, OnMessageReceivedDelegate) == 0x000038, "Member 'UTedChatSubsystem::OnMessageReceivedDelegate' has a wrong offset!");
static_assert(offsetof(UTedChatSubsystem, OnMessageRemovedDelegate) == 0x000048, "Member 'UTedChatSubsystem::OnMessageRemovedDelegate' has a wrong offset!");
static_assert(offsetof(UTedChatSubsystem, MessageAssembler) == 0x0001A8, "Member 'UTedChatSubsystem::MessageAssembler' has a wrong offset!");

// Class Tempest.UIDataProvider
// 0x0090 (0x00C8 - 0x0038)
class UUIDataProvider final : public UDeveloperSettings
{
public:
	struct FUIData_NameAndDescription             Credits;                                           // 0x0038(0x0020)(Edit, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUIData_NameAndDescription             Power;                                             // 0x0058(0x0020)(Edit, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUIData_NameAndDescription             PowerConsumption;                                  // 0x0078(0x0020)(Edit, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUIData_NameAndDescription             Intel;                                             // 0x0098(0x0020)(Edit, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FUIData_PlayerDataStat>         PlayerDataStats;                                   // 0x00B8(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	const struct FUIData_NameAndDescription GetCreditsUIData() const;
	const struct FUIData_NameAndDescription GetIntelUIData() const;
	bool GetPlayerDataStatUIData(const ETedPlayerDataStat InStat, struct FUIData_NameAndDescription* Out) const;
	const struct FUIData_NameAndDescription GetPowerConsumptionUIData() const;
	const struct FUIData_NameAndDescription GetPowerUIData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDataProvider">();
	}
	static class UUIDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDataProvider>();
	}
};
static_assert(alignof(UUIDataProvider) == 0x000008, "Wrong alignment on UUIDataProvider");
static_assert(sizeof(UUIDataProvider) == 0x0000C8, "Wrong size on UUIDataProvider");
static_assert(offsetof(UUIDataProvider, Credits) == 0x000038, "Member 'UUIDataProvider::Credits' has a wrong offset!");
static_assert(offsetof(UUIDataProvider, Power) == 0x000058, "Member 'UUIDataProvider::Power' has a wrong offset!");
static_assert(offsetof(UUIDataProvider, PowerConsumption) == 0x000078, "Member 'UUIDataProvider::PowerConsumption' has a wrong offset!");
static_assert(offsetof(UUIDataProvider, Intel) == 0x000098, "Member 'UUIDataProvider::Intel' has a wrong offset!");
static_assert(offsetof(UUIDataProvider, PlayerDataStats) == 0x0000B8, "Member 'UUIDataProvider::PlayerDataStats' has a wrong offset!");

// Class Tempest.TedAbility_DismantleStructure_Refinery
// 0x0008 (0x0420 - 0x0418)
class UTedAbility_DismantleStructure_Refinery : public UTedAbility_DismantleStructure
{
public:
	struct FGameplayTag                           EnterContainerCommandType;                         // 0x0418(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_DismantleStructure_Refinery">();
	}
	static class UTedAbility_DismantleStructure_Refinery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_DismantleStructure_Refinery>();
	}
};
static_assert(alignof(UTedAbility_DismantleStructure_Refinery) == 0x000008, "Wrong alignment on UTedAbility_DismantleStructure_Refinery");
static_assert(sizeof(UTedAbility_DismantleStructure_Refinery) == 0x000420, "Wrong size on UTedAbility_DismantleStructure_Refinery");
static_assert(offsetof(UTedAbility_DismantleStructure_Refinery, EnterContainerCommandType) == 0x000418, "Member 'UTedAbility_DismantleStructure_Refinery::EnterContainerCommandType' has a wrong offset!");

// Class Tempest.TedAbility_DismantleStructure_RefineryV2
// 0x0000 (0x0420 - 0x0420)
class UTedAbility_DismantleStructure_RefineryV2 : public UTedAbility_DismantleStructure_Refinery
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_DismantleStructure_RefineryV2">();
	}
	static class UTedAbility_DismantleStructure_RefineryV2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_DismantleStructure_RefineryV2>();
	}
};
static_assert(alignof(UTedAbility_DismantleStructure_RefineryV2) == 0x000008, "Wrong alignment on UTedAbility_DismantleStructure_RefineryV2");
static_assert(sizeof(UTedAbility_DismantleStructure_RefineryV2) == 0x000420, "Wrong size on UTedAbility_DismantleStructure_RefineryV2");

// Class Tempest.TedChatPartyDecorator_Message
// 0x0000 (0x0028 - 0x0028)
class UTedChatPartyDecorator_Message final : public URichTextBlockDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedChatPartyDecorator_Message">();
	}
	static class UTedChatPartyDecorator_Message* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedChatPartyDecorator_Message>();
	}
};
static_assert(alignof(UTedChatPartyDecorator_Message) == 0x000008, "Wrong alignment on UTedChatPartyDecorator_Message");
static_assert(sizeof(UTedChatPartyDecorator_Message) == 0x000028, "Wrong size on UTedChatPartyDecorator_Message");

// Class Tempest.TedAbility_DumpResource_Harvester
// 0x0040 (0x0420 - 0x03E0)
class UTedAbility_DumpResource_Harvester : public UTedAbilityBase
{
public:
	struct FHarvesterAbilityInfo                  HarvestAbiiltyInfo;                                // 0x03E0(0x0040)(NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void OnResourceDumpFinished();
	void OnResourceDumpStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_DumpResource_Harvester">();
	}
	static class UTedAbility_DumpResource_Harvester* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_DumpResource_Harvester>();
	}
};
static_assert(alignof(UTedAbility_DumpResource_Harvester) == 0x000008, "Wrong alignment on UTedAbility_DumpResource_Harvester");
static_assert(sizeof(UTedAbility_DumpResource_Harvester) == 0x000420, "Wrong size on UTedAbility_DumpResource_Harvester");
static_assert(offsetof(UTedAbility_DumpResource_Harvester, HarvestAbiiltyInfo) == 0x0003E0, "Member 'UTedAbility_DumpResource_Harvester::HarvestAbiiltyInfo' has a wrong offset!");

// Class Tempest.TedPlayerCommand
// 0x0038 (0x0570 - 0x0538)
class UTedPlayerCommand : public UTedCommand
{
public:
	bool                                          bFactionSpecific;                                  // 0x0538(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedFaction                                   CommandFaction;                                    // 0x0539(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequireFullVisionOfTargetLocation;                // 0x053A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasCallInTime;                                    // 0x053B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CallInTime;                                        // 0x053C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   CallInVisualActorClass;                            // 0x0540(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IgnoreUpcomingPopulation;                          // 0x0568(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExplicitTelemetryHandling;                        // 0x0569(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_56A[0x6];                                      // 0x056A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetCallInTime() const;
	bool HasCallInTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerCommand">();
	}
	static class UTedPlayerCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerCommand>();
	}
};
static_assert(alignof(UTedPlayerCommand) == 0x000008, "Wrong alignment on UTedPlayerCommand");
static_assert(sizeof(UTedPlayerCommand) == 0x000570, "Wrong size on UTedPlayerCommand");
static_assert(offsetof(UTedPlayerCommand, bFactionSpecific) == 0x000538, "Member 'UTedPlayerCommand::bFactionSpecific' has a wrong offset!");
static_assert(offsetof(UTedPlayerCommand, CommandFaction) == 0x000539, "Member 'UTedPlayerCommand::CommandFaction' has a wrong offset!");
static_assert(offsetof(UTedPlayerCommand, bRequireFullVisionOfTargetLocation) == 0x00053A, "Member 'UTedPlayerCommand::bRequireFullVisionOfTargetLocation' has a wrong offset!");
static_assert(offsetof(UTedPlayerCommand, bHasCallInTime) == 0x00053B, "Member 'UTedPlayerCommand::bHasCallInTime' has a wrong offset!");
static_assert(offsetof(UTedPlayerCommand, CallInTime) == 0x00053C, "Member 'UTedPlayerCommand::CallInTime' has a wrong offset!");
static_assert(offsetof(UTedPlayerCommand, CallInVisualActorClass) == 0x000540, "Member 'UTedPlayerCommand::CallInVisualActorClass' has a wrong offset!");
static_assert(offsetof(UTedPlayerCommand, IgnoreUpcomingPopulation) == 0x000568, "Member 'UTedPlayerCommand::IgnoreUpcomingPopulation' has a wrong offset!");
static_assert(offsetof(UTedPlayerCommand, bExplicitTelemetryHandling) == 0x000569, "Member 'UTedPlayerCommand::bExplicitTelemetryHandling' has a wrong offset!");

// Class Tempest.TedPlayerCommand_Ping
// 0x0008 (0x0578 - 0x0570)
class UTedPlayerCommand_Ping : public UTedPlayerCommand
{
public:
	TSubclassOf<class ATedPingActor>              PingActorClass;                                    // 0x0570(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerCommand_Ping">();
	}
	static class UTedPlayerCommand_Ping* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerCommand_Ping>();
	}
};
static_assert(alignof(UTedPlayerCommand_Ping) == 0x000008, "Wrong alignment on UTedPlayerCommand_Ping");
static_assert(sizeof(UTedPlayerCommand_Ping) == 0x000578, "Wrong size on UTedPlayerCommand_Ping");
static_assert(offsetof(UTedPlayerCommand_Ping, PingActorClass) == 0x000570, "Member 'UTedPlayerCommand_Ping::PingActorClass' has a wrong offset!");

// Class Tempest.TedAbility_DumpResource_Refinery
// 0x0000 (0x0410 - 0x0410)
class UTedAbility_DumpResource_Refinery final : public UTedAbility_Montage
{
public:
	void OnDumpFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_DumpResource_Refinery">();
	}
	static class UTedAbility_DumpResource_Refinery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_DumpResource_Refinery>();
	}
};
static_assert(alignof(UTedAbility_DumpResource_Refinery) == 0x000008, "Wrong alignment on UTedAbility_DumpResource_Refinery");
static_assert(sizeof(UTedAbility_DumpResource_Refinery) == 0x000410, "Wrong size on UTedAbility_DumpResource_Refinery");

// Class Tempest.TedAbility_EnqueueUnit
// 0x0010 (0x03F0 - 0x03E0)
class UTedAbility_EnqueueUnit final : public UTedAbilityBase
{
public:
	TScriptInterface<class ITedUnitQueueInterface> CachedQueueInterface;                             // 0x03E0(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_EnqueueUnit">();
	}
	static class UTedAbility_EnqueueUnit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_EnqueueUnit>();
	}
};
static_assert(alignof(UTedAbility_EnqueueUnit) == 0x000008, "Wrong alignment on UTedAbility_EnqueueUnit");
static_assert(sizeof(UTedAbility_EnqueueUnit) == 0x0003F0, "Wrong size on UTedAbility_EnqueueUnit");
static_assert(offsetof(UTedAbility_EnqueueUnit, CachedQueueInterface) == 0x0003E0, "Member 'UTedAbility_EnqueueUnit::CachedQueueInterface' has a wrong offset!");

// Class Tempest.TedAbility_FireProjectilesInAoE
// 0x0048 (0x0458 - 0x0410)
class UTedAbility_FireProjectilesInAoE final : public UTedAbility_Montage
{
public:
	struct FGameplayTag                           ShootProjectileNotifyEventTag;                     // 0x0410(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseDefinitionTag;                                 // 0x0418(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_419[0x3];                                      // 0x0419(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           WeaponDefinitionAssetTag;                          // 0x041C(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_424[0x4];                                      // 0x0424(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  WeaponOwnedTags;                                   // 0x0428(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UTedWeapon>                 CachedCurrentWeaponClass;                          // 0x0448(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_450[0x8];                                      // 0x0450(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_FireProjectilesInAoE">();
	}
	static class UTedAbility_FireProjectilesInAoE* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_FireProjectilesInAoE>();
	}
};
static_assert(alignof(UTedAbility_FireProjectilesInAoE) == 0x000008, "Wrong alignment on UTedAbility_FireProjectilesInAoE");
static_assert(sizeof(UTedAbility_FireProjectilesInAoE) == 0x000458, "Wrong size on UTedAbility_FireProjectilesInAoE");
static_assert(offsetof(UTedAbility_FireProjectilesInAoE, ShootProjectileNotifyEventTag) == 0x000410, "Member 'UTedAbility_FireProjectilesInAoE::ShootProjectileNotifyEventTag' has a wrong offset!");
static_assert(offsetof(UTedAbility_FireProjectilesInAoE, bUseDefinitionTag) == 0x000418, "Member 'UTedAbility_FireProjectilesInAoE::bUseDefinitionTag' has a wrong offset!");
static_assert(offsetof(UTedAbility_FireProjectilesInAoE, WeaponDefinitionAssetTag) == 0x00041C, "Member 'UTedAbility_FireProjectilesInAoE::WeaponDefinitionAssetTag' has a wrong offset!");
static_assert(offsetof(UTedAbility_FireProjectilesInAoE, WeaponOwnedTags) == 0x000428, "Member 'UTedAbility_FireProjectilesInAoE::WeaponOwnedTags' has a wrong offset!");
static_assert(offsetof(UTedAbility_FireProjectilesInAoE, CachedCurrentWeaponClass) == 0x000448, "Member 'UTedAbility_FireProjectilesInAoE::CachedCurrentWeaponClass' has a wrong offset!");

// Class Tempest.TedCommandCompoundMapScreenComponent
// 0x0018 (0x0418 - 0x0400)
class UTedCommandCompoundMapScreenComponent : public UTedUserWidget
{
public:
	TMulticastInlineDelegate<void(class UTedCommandCompoundMapScreenComponent* InComponent)> OnTrigger; // 0x0400(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ComponentType;                                     // 0x0410(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void NotifyOnTrigger();
	void OnMapScreenClosed(const class UTedCommandCompoundMapScreen* InMapScreen, const class UObject* InContext);
	void OnMapScreenOpened(const class UTedCommandCompoundMapScreen* InMapScreen, const class UObject* InContext);
	void OnSetVisibilityForStage(const class UTedCommandCompoundMapScreen* InMapScreen, const ETedCommandCompoundMapScreenVisibilityAction InAction, const ETedCommandCompoundMapScreenStage InStage, const struct FTedCommandCompoundMapScreenStageSetup& InStageSetup);

	class FString GetAnimDebugString(class UWidgetAnimation* InAnimation) const;
	const struct FGameplayTag GetComponentType() const;
	void OnAppendDebugStrings(const class FString& InPrefix, TArray<class FString>& Out) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandCompoundMapScreenComponent">();
	}
	static class UTedCommandCompoundMapScreenComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCommandCompoundMapScreenComponent>();
	}
};
static_assert(alignof(UTedCommandCompoundMapScreenComponent) == 0x000008, "Wrong alignment on UTedCommandCompoundMapScreenComponent");
static_assert(sizeof(UTedCommandCompoundMapScreenComponent) == 0x000418, "Wrong size on UTedCommandCompoundMapScreenComponent");
static_assert(offsetof(UTedCommandCompoundMapScreenComponent, OnTrigger) == 0x000400, "Member 'UTedCommandCompoundMapScreenComponent::OnTrigger' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundMapScreenComponent, ComponentType) == 0x000410, "Member 'UTedCommandCompoundMapScreenComponent::ComponentType' has a wrong offset!");

// Class Tempest.TedCommandCompoundMapScreenComponent_Missions
// 0x0020 (0x0438 - 0x0418)
class UTedCommandCompoundMapScreenComponent_Missions final : public UTedCommandCompoundMapScreenComponent
{
public:
	class UTedMapInfo*                            RelevantMission;                                   // 0x0418(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AsyncLoadPriority;                                 // 0x0420(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_424[0x14];                                     // 0x0424(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UTexture2D* GetRelevantMissionDetailsDataBoxTexture();
	class UTexture2D* GetRelevantMissionDetailsTextBoxTexture();
	class USoundBase* GetRelevantMissionDetailsVO();

	const class FText GetRelevantMissionDetailsText() const;
	const class UFileMediaSource* GetRelevantMissionMovie(const ETedCommandCompoundMapScreenMovieType InType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandCompoundMapScreenComponent_Missions">();
	}
	static class UTedCommandCompoundMapScreenComponent_Missions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCommandCompoundMapScreenComponent_Missions>();
	}
};
static_assert(alignof(UTedCommandCompoundMapScreenComponent_Missions) == 0x000008, "Wrong alignment on UTedCommandCompoundMapScreenComponent_Missions");
static_assert(sizeof(UTedCommandCompoundMapScreenComponent_Missions) == 0x000438, "Wrong size on UTedCommandCompoundMapScreenComponent_Missions");
static_assert(offsetof(UTedCommandCompoundMapScreenComponent_Missions, RelevantMission) == 0x000418, "Member 'UTedCommandCompoundMapScreenComponent_Missions::RelevantMission' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundMapScreenComponent_Missions, AsyncLoadPriority) == 0x000420, "Member 'UTedCommandCompoundMapScreenComponent_Missions::AsyncLoadPriority' has a wrong offset!");

// Class Tempest.TedAbility_HarvestResource_Harvester
// 0x0048 (0x0428 - 0x03E0)
class UTedAbility_HarvestResource_Harvester : public UTedAbilityBase
{
public:
	struct FHarvesterAbilityInfo                  HarvestAbiiltyInfo;                                // 0x03E0(0x0040)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         HarvestDistanceAcceptance;                         // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_424[0x4];                                      // 0x0424(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHarvestingFinish();
	void OnHarvestingStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_HarvestResource_Harvester">();
	}
	static class UTedAbility_HarvestResource_Harvester* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_HarvestResource_Harvester>();
	}
};
static_assert(alignof(UTedAbility_HarvestResource_Harvester) == 0x000008, "Wrong alignment on UTedAbility_HarvestResource_Harvester");
static_assert(sizeof(UTedAbility_HarvestResource_Harvester) == 0x000428, "Wrong size on UTedAbility_HarvestResource_Harvester");
static_assert(offsetof(UTedAbility_HarvestResource_Harvester, HarvestAbiiltyInfo) == 0x0003E0, "Member 'UTedAbility_HarvestResource_Harvester::HarvestAbiiltyInfo' has a wrong offset!");
static_assert(offsetof(UTedAbility_HarvestResource_Harvester, HarvestDistanceAcceptance) == 0x000420, "Member 'UTedAbility_HarvestResource_Harvester::HarvestDistanceAcceptance' has a wrong offset!");

// Class Tempest.TedPlayerCommand_Proxy
// 0x0020 (0x0590 - 0x0570)
class UTedPlayerCommand_Proxy : public UTedPlayerCommand
{
public:
	uint8                                         bUseCommandType : 1;                               // 0x0570(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_571[0x7];                                      // 0x0571(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UTedCommand>                CommandClassToSelect;                              // 0x0578(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           CommandTypeToSelect;                               // 0x0580(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_588[0x8];                                      // 0x0588(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerCommand_Proxy">();
	}
	static class UTedPlayerCommand_Proxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerCommand_Proxy>();
	}
};
static_assert(alignof(UTedPlayerCommand_Proxy) == 0x000008, "Wrong alignment on UTedPlayerCommand_Proxy");
static_assert(sizeof(UTedPlayerCommand_Proxy) == 0x000590, "Wrong size on UTedPlayerCommand_Proxy");
static_assert(offsetof(UTedPlayerCommand_Proxy, CommandClassToSelect) == 0x000578, "Member 'UTedPlayerCommand_Proxy::CommandClassToSelect' has a wrong offset!");
static_assert(offsetof(UTedPlayerCommand_Proxy, CommandTypeToSelect) == 0x000580, "Member 'UTedPlayerCommand_Proxy::CommandTypeToSelect' has a wrong offset!");

// Class Tempest.TedAbility_HarvestResource_StructureHarvester
// 0x0008 (0x03E8 - 0x03E0)
class UTedAbility_HarvestResource_StructureHarvester : public UTedAbilityBase
{
public:
	class ATempestFieldVolume*                    CachedTargetResourceVolume;                        // 0x03E0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_HarvestResource_StructureHarvester">();
	}
	static class UTedAbility_HarvestResource_StructureHarvester* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_HarvestResource_StructureHarvester>();
	}
};
static_assert(alignof(UTedAbility_HarvestResource_StructureHarvester) == 0x000008, "Wrong alignment on UTedAbility_HarvestResource_StructureHarvester");
static_assert(sizeof(UTedAbility_HarvestResource_StructureHarvester) == 0x0003E8, "Wrong size on UTedAbility_HarvestResource_StructureHarvester");
static_assert(offsetof(UTedAbility_HarvestResource_StructureHarvester, CachedTargetResourceVolume) == 0x0003E0, "Member 'UTedAbility_HarvestResource_StructureHarvester::CachedTargetResourceVolume' has a wrong offset!");

// Class Tempest.TedCommandCompoundDialoguePanel
// 0x0058 (0x0808 - 0x07B0)
class UTedCommandCompoundDialoguePanel final : public UTedContentPanelDynamic
{
public:
	TMulticastInlineDelegate<void(class UTedCommandCompoundDialoguePanel* InContentPanel, const int32 InContentIndex, const int32 InSlotIndex, const struct FTedDialogueLine& InDialogueOption)> OnDialogueLinePlayed; // 0x07B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTedCommandCompoundDialoguePanel* InContentPanel, const int32 InContentIndex, const int32 InSlotIndex, const struct FTedDialogueLine& InDialogueOption, const ETedDialogueLineEndReason InReason)> OnDialogueLineEnded; // 0x07C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTedCommandCompoundDialoguePanel* InContentPanel)> OnBriefingEnded; // 0x07D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UTedBriefing*                           Briefing;                                          // 0x07E0(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTedDialogueLine>               content;                                           // 0x07E8(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 DisplayedContent;                                  // 0x07F8(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)

public:
	static ETedContentSlotState GetDialogueReadState();

	void PlayIntroResponse();
	void SetBriefing(const class UTedBriefing* InBriefing);
	void SetContent(const TArray<struct FTedDialogueLine>& InContent);

	const class UTedBriefing* GetBriefing() const;
	bool GetContent(const int32 InContentIndex, struct FTedDialogueLine* OutContent) const;
	int32 GetContentIndex(const int32 InSlotIndex) const;
	int32 GetPlayingResponseIndex() const;
	int32 GetSlotIndex(const int32 InContentIndex) const;
	bool IsFinishingOption(const int32 InContentIndex) const;
	bool IsPlayingResponse() const;
	bool IsPlayingResponseOfType(const ETedDialogueLineType InType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandCompoundDialoguePanel">();
	}
	static class UTedCommandCompoundDialoguePanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCommandCompoundDialoguePanel>();
	}
};
static_assert(alignof(UTedCommandCompoundDialoguePanel) == 0x000008, "Wrong alignment on UTedCommandCompoundDialoguePanel");
static_assert(sizeof(UTedCommandCompoundDialoguePanel) == 0x000808, "Wrong size on UTedCommandCompoundDialoguePanel");
static_assert(offsetof(UTedCommandCompoundDialoguePanel, OnDialogueLinePlayed) == 0x0007B0, "Member 'UTedCommandCompoundDialoguePanel::OnDialogueLinePlayed' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundDialoguePanel, OnDialogueLineEnded) == 0x0007C0, "Member 'UTedCommandCompoundDialoguePanel::OnDialogueLineEnded' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundDialoguePanel, OnBriefingEnded) == 0x0007D0, "Member 'UTedCommandCompoundDialoguePanel::OnBriefingEnded' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundDialoguePanel, Briefing) == 0x0007E0, "Member 'UTedCommandCompoundDialoguePanel::Briefing' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundDialoguePanel, content) == 0x0007E8, "Member 'UTedCommandCompoundDialoguePanel::content' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundDialoguePanel, DisplayedContent) == 0x0007F8, "Member 'UTedCommandCompoundDialoguePanel::DisplayedContent' has a wrong offset!");

// Class Tempest.TedAbility_IssueCommandToPawnsInAoE
// 0x0038 (0x0418 - 0x03E0)
class UTedAbility_IssueCommandToPawnsInAoE final : public UTedAbilityBase
{
public:
	TSubclassOf<class UGameplayCommand>           CommandClass;                                      // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  ApplyToEntityTags;                                 // 0x03E8(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         Radius;                                            // 0x0408(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RateSeconds;                                       // 0x040C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           IssueCommand_TimerHandle;                          // 0x0410(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_IssueCommandToPawnsInAoE">();
	}
	static class UTedAbility_IssueCommandToPawnsInAoE* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_IssueCommandToPawnsInAoE>();
	}
};
static_assert(alignof(UTedAbility_IssueCommandToPawnsInAoE) == 0x000008, "Wrong alignment on UTedAbility_IssueCommandToPawnsInAoE");
static_assert(sizeof(UTedAbility_IssueCommandToPawnsInAoE) == 0x000418, "Wrong size on UTedAbility_IssueCommandToPawnsInAoE");
static_assert(offsetof(UTedAbility_IssueCommandToPawnsInAoE, CommandClass) == 0x0003E0, "Member 'UTedAbility_IssueCommandToPawnsInAoE::CommandClass' has a wrong offset!");
static_assert(offsetof(UTedAbility_IssueCommandToPawnsInAoE, ApplyToEntityTags) == 0x0003E8, "Member 'UTedAbility_IssueCommandToPawnsInAoE::ApplyToEntityTags' has a wrong offset!");
static_assert(offsetof(UTedAbility_IssueCommandToPawnsInAoE, Radius) == 0x000408, "Member 'UTedAbility_IssueCommandToPawnsInAoE::Radius' has a wrong offset!");
static_assert(offsetof(UTedAbility_IssueCommandToPawnsInAoE, RateSeconds) == 0x00040C, "Member 'UTedAbility_IssueCommandToPawnsInAoE::RateSeconds' has a wrong offset!");
static_assert(offsetof(UTedAbility_IssueCommandToPawnsInAoE, IssueCommand_TimerHandle) == 0x000410, "Member 'UTedAbility_IssueCommandToPawnsInAoE::IssueCommand_TimerHandle' has a wrong offset!");

// Class Tempest.TedAbility_LayMines
// 0x0008 (0x03E8 - 0x03E0)
class UTedAbility_LayMines : public UTedAbilityBase
{
public:
	TSubclassOf<class UTedMinefieldProxy>         MinefieldProxy;                                    // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void LayMinefield(const struct FVector& InLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_LayMines">();
	}
	static class UTedAbility_LayMines* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_LayMines>();
	}
};
static_assert(alignof(UTedAbility_LayMines) == 0x000008, "Wrong alignment on UTedAbility_LayMines");
static_assert(sizeof(UTedAbility_LayMines) == 0x0003E8, "Wrong size on UTedAbility_LayMines");
static_assert(offsetof(UTedAbility_LayMines, MinefieldProxy) == 0x0003E0, "Member 'UTedAbility_LayMines::MinefieldProxy' has a wrong offset!");

// Class Tempest.TedCheatManager
// 0x0018 (0x00B8 - 0x00A0)
class UTedCheatManager : public USgCheatManager
{
public:
	class UUserWidget*                            DebugBlueprintWidget;                              // 0x00A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDebugSpawnNameToClass>         DebugSpawnUnitNameToClass;                         // 0x00A8(0x0010)(Edit, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)

public:
	static TArray<class UTedObjectiveObj*> Objective_ListAvailable(const bool bLog);

	void ActivateAllySpectatorUI();
	void AddCash(int32 Value);
	void AddCashCap(int32 Value);
	void AddIntel(int32 Value);
	void AddPower(int32 Value);
	void BlockBotUnitDamage();
	void BlockPlayerUnitDamage(bool bEnable);
	void ChangeDifficulty(uint8 InDifficulty);
	void CloseMenuScreen();
	void CopyHydraInfoToClipboard();
	void DeactivateSpectatorUI();
	void DealDamageToSelectedPawns(float DamageAmount);
	void DebugAddExperience(const float experience);
	void DebugAutosave();
	void DebugCamera();
	void DebugConstructBlueprintWidget(const class FString& WidgetPath, int32 ZOrder);
	void DebugDestroySelectedPawns();
	void DebugEndMission(bool bVictory);
	void DebugKillSelectedPawns();
	void DebugLogUnitNames();
	void DebugPlayFullscreenMovie(const class FString& InAssetName);
	void DebugPlayMissionDialogue(const class FString& InAssetName);
	void DebugPlayMovie(const class FString& InAssetName, const ETedMovieType InMovieType, const bool bInSilent, const bool bInLoop, const float InFadeIn, const float InFadeOut, const ETedMovieGamePauseInteraction InPauseInteraction);
	void DebugQuicksave();
	void DebugRemoveBlueprintWidget();
	void DebugRestartLevel();
	void DebugSetActorComponentTickEnabled(TSubclassOf<class AActor> ActorClass, TSubclassOf<class UActorComponent> ComponentClass, bool bEnable);
	void DebugSetActorTickEnabled(TSubclassOf<class AActor> ActorClass, bool bEnable);
	void DebugSetAllowPlayerCommands(const uint8 PlayerID, const bool bAllow);
	void DebugSetComponentTickEnabled(TSubclassOf<class UActorComponent> ComponentClass, bool bEnable);
	void DebugSetLockedSupportPower(const uint8 PlayerID, const bool bLock, const class FString& SupportPowerCommandType);
	void DebugSoundCues();
	void DebugSoundMixes();
	void DebugSoundReverb();
	void DebugSoundWaves();
	void DebugSpawnUnit(TSoftClassPtr<class UClass> UnitClass, const int32 NumToSpawn, ETedPlayerID PlayerID);
	void DebugSpawnUnitByName(class FName UnitName, const int32 NumToSpawn, const ETedPlayerID PlayerID);
	void DebugSpawnUnitDistributed(TSoftClassPtr<class UClass> UnitClass, const int32 NumToSpawn, int32 RandomSeed, ETedPlayerID PlayerID);
	void DebugTeleportSelectedUnits();
	void DebugToggleShowDebug_Movies();
	void DebugToggleShowDebugCategory(class FName Category);
	void DisableFogOfWar();
	void FreeProduction();
	void IgnoreBuildPrerequisites();
	void IgnoreBuildRadius();
	void InstantProduction();
	void InstantUpgrades();
	void KillUnitsOnScreen(const EKillAllPawns Type, const bool IncludeStructures);
	void LoadGame(const class FName SlotName, const class FString& ProfileName, const class FString& SubDir);
	void MakeSelectedPawnsInvincible();
	void MakeShitloadOfSaves(int32 Amount);
	void Objective_Activate(const class FString& InObjectiveSubstring);
	void Objective_Deactivate(const class FString& InObjectiveSubstring);
	void Objective_Fail(const class FString& InObjectiveSubstring);
	void Objective_Succeed(const class FString& InObjectiveSubstring);
	void OpenMenuScreen(const class FString& ScreenSubstring);
	void PrintAllAchievements();
	void ResetAllAchievements();
	void SaveGame(const class FName SlotName);
	void ServerDebugAddExperience(const float experience);
	void ServerDebugRestartLevel();
	void ServerDebugSpawnUnit(TSubclassOf<class ATedUnitBase> UnitClass, int32 NumToSpawn, const struct FVector& Location, const ETedPlayerID PlayerID);
	void ServerDebugTeleportSelectedUnits(const struct FVector2D& CursorLocation, const TArray<class ATedUnitBase*>& Units);
	void SetMinimapState(uint8 InMode);
	void SetUnitCardWeaponWidth(const int32 FixedWidth);
	void SetUnitCardWeaponWidthRange(const int32 min_0, const int32 max_0);
	void ToggleGameMenuScreen();
	void TopDownCamera();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCheatManager">();
	}
	static class UTedCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCheatManager>();
	}
};
static_assert(alignof(UTedCheatManager) == 0x000008, "Wrong alignment on UTedCheatManager");
static_assert(sizeof(UTedCheatManager) == 0x0000B8, "Wrong size on UTedCheatManager");
static_assert(offsetof(UTedCheatManager, DebugBlueprintWidget) == 0x0000A0, "Member 'UTedCheatManager::DebugBlueprintWidget' has a wrong offset!");
static_assert(offsetof(UTedCheatManager, DebugSpawnUnitNameToClass) == 0x0000A8, "Member 'UTedCheatManager::DebugSpawnUnitNameToClass' has a wrong offset!");

// Class Tempest.TedAbility_Override
// 0x0068 (0x0448 - 0x03E0)
class UTedAbility_Override final : public UTedAbilityBase
{
public:
	struct FGameplayTagContainer                  WhitelistTargetFactoryTypeTags;                    // 0x03E0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  BlacklistTargetEntityTags;                         // 0x0400(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  BlacklistTargetGameplayTags;                       // 0x0420(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            OverrideGE;                                        // 0x0440(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_Override">();
	}
	static class UTedAbility_Override* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_Override>();
	}
};
static_assert(alignof(UTedAbility_Override) == 0x000008, "Wrong alignment on UTedAbility_Override");
static_assert(sizeof(UTedAbility_Override) == 0x000448, "Wrong size on UTedAbility_Override");
static_assert(offsetof(UTedAbility_Override, WhitelistTargetFactoryTypeTags) == 0x0003E0, "Member 'UTedAbility_Override::WhitelistTargetFactoryTypeTags' has a wrong offset!");
static_assert(offsetof(UTedAbility_Override, BlacklistTargetEntityTags) == 0x000400, "Member 'UTedAbility_Override::BlacklistTargetEntityTags' has a wrong offset!");
static_assert(offsetof(UTedAbility_Override, BlacklistTargetGameplayTags) == 0x000420, "Member 'UTedAbility_Override::BlacklistTargetGameplayTags' has a wrong offset!");
static_assert(offsetof(UTedAbility_Override, OverrideGE) == 0x000440, "Member 'UTedAbility_Override::OverrideGE' has a wrong offset!");

// Class Tempest.TedPlayerCommand_SpawnUnits
// 0x0010 (0x0580 - 0x0570)
class UTedPlayerCommand_SpawnUnits : public UTedPlayerCommand
{
public:
	TArray<struct FUnitToSpawnData>               UnitsToSpawnData;                                  // 0x0570(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerCommand_SpawnUnits">();
	}
	static class UTedPlayerCommand_SpawnUnits* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerCommand_SpawnUnits>();
	}
};
static_assert(alignof(UTedPlayerCommand_SpawnUnits) == 0x000008, "Wrong alignment on UTedPlayerCommand_SpawnUnits");
static_assert(sizeof(UTedPlayerCommand_SpawnUnits) == 0x000580, "Wrong size on UTedPlayerCommand_SpawnUnits");
static_assert(offsetof(UTedPlayerCommand_SpawnUnits, UnitsToSpawnData) == 0x000570, "Member 'UTedPlayerCommand_SpawnUnits::UnitsToSpawnData' has a wrong offset!");

// Class Tempest.TedAbility_Ram
// 0x0038 (0x0418 - 0x03E0)
class UTedAbility_Ram final : public UTedAbilityBase
{
public:
	struct FVector2D                              Range;                                             // 0x03E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageMultiplier;                                  // 0x03F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AbilityTimeout;                                    // 0x03F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CachedTargetLocation;                              // 0x03F8(0x0018)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           AbilityTimeout_Handle;                             // 0x0410(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_Ram">();
	}
	static class UTedAbility_Ram* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_Ram>();
	}
};
static_assert(alignof(UTedAbility_Ram) == 0x000008, "Wrong alignment on UTedAbility_Ram");
static_assert(sizeof(UTedAbility_Ram) == 0x000418, "Wrong size on UTedAbility_Ram");
static_assert(offsetof(UTedAbility_Ram, Range) == 0x0003E0, "Member 'UTedAbility_Ram::Range' has a wrong offset!");
static_assert(offsetof(UTedAbility_Ram, DamageMultiplier) == 0x0003F0, "Member 'UTedAbility_Ram::DamageMultiplier' has a wrong offset!");
static_assert(offsetof(UTedAbility_Ram, AbilityTimeout) == 0x0003F4, "Member 'UTedAbility_Ram::AbilityTimeout' has a wrong offset!");
static_assert(offsetof(UTedAbility_Ram, CachedTargetLocation) == 0x0003F8, "Member 'UTedAbility_Ram::CachedTargetLocation' has a wrong offset!");
static_assert(offsetof(UTedAbility_Ram, AbilityTimeout_Handle) == 0x000410, "Member 'UTedAbility_Ram::AbilityTimeout_Handle' has a wrong offset!");

// Class Tempest.TedAbility_RecallHarvesters_Refinery
// 0x0000 (0x03E0 - 0x03E0)
class UTedAbility_RecallHarvesters_Refinery : public UTedAbilityBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_RecallHarvesters_Refinery">();
	}
	static class UTedAbility_RecallHarvesters_Refinery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_RecallHarvesters_Refinery>();
	}
};
static_assert(alignof(UTedAbility_RecallHarvesters_Refinery) == 0x000008, "Wrong alignment on UTedAbility_RecallHarvesters_Refinery");
static_assert(sizeof(UTedAbility_RecallHarvesters_Refinery) == 0x0003E0, "Wrong size on UTedAbility_RecallHarvesters_Refinery");

// Class Tempest.TedAbility_Recall_Harvester
// 0x0000 (0x03E0 - 0x03E0)
class UTedAbility_Recall_Harvester : public UTedAbilityBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_Recall_Harvester">();
	}
	static class UTedAbility_Recall_Harvester* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_Recall_Harvester>();
	}
};
static_assert(alignof(UTedAbility_Recall_Harvester) == 0x000008, "Wrong alignment on UTedAbility_Recall_Harvester");
static_assert(sizeof(UTedAbility_Recall_Harvester) == 0x0003E0, "Wrong size on UTedAbility_Recall_Harvester");

// Class Tempest.TedCommandCompoundNavigation
// 0x0050 (0x0450 - 0x0400)
class UTedCommandCompoundNavigation final : public UTedUserWidget
{
public:
	TMulticastInlineDelegate<void(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction)> OnTriggerTabSlotAction; // 0x0400(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotState InState, bool bInActivated)> OnActivateTabSlotState; // 0x0410(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UTedContentPanelBase*                   TabsPanel;                                         // 0x0420(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UWidget*>                        TabPages;                                          // 0x0428(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UTedContentPanelSlotButton*             Tab_MissionDescription;                            // 0x0438(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTedContentPanelSlotButton*             Tab_AcknowledgmentCredits;                         // 0x0440(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_448[0x8];                                      // 0x0448(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateTabSlotStateByPage(class UWidget* InPage, const ETedContentSlotState InState, const bool bInActivate);
	void OnActivateTabSlotStateHandler(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotState InState, bool bInActivated);
	void OnTriggerTabSlotActionHandler(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction);

	int32 GetSelectedTabIndex() const;
	class UWidget* GetSelectedTabPage() const;
	class UTedContentPanelSlotBase* GetSelectedTabSlot() const;
	class UWidget* GetTabPage(const int32 InTabIndex) const;
	class UTedContentPanelBase* GetTabsPanel() const;
	void HandleDisabled(const bool bInActivated, const class UTedContentPanelSlotBase* InSlot) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandCompoundNavigation">();
	}
	static class UTedCommandCompoundNavigation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCommandCompoundNavigation>();
	}
};
static_assert(alignof(UTedCommandCompoundNavigation) == 0x000008, "Wrong alignment on UTedCommandCompoundNavigation");
static_assert(sizeof(UTedCommandCompoundNavigation) == 0x000450, "Wrong size on UTedCommandCompoundNavigation");
static_assert(offsetof(UTedCommandCompoundNavigation, OnTriggerTabSlotAction) == 0x000400, "Member 'UTedCommandCompoundNavigation::OnTriggerTabSlotAction' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundNavigation, OnActivateTabSlotState) == 0x000410, "Member 'UTedCommandCompoundNavigation::OnActivateTabSlotState' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundNavigation, TabsPanel) == 0x000420, "Member 'UTedCommandCompoundNavigation::TabsPanel' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundNavigation, TabPages) == 0x000428, "Member 'UTedCommandCompoundNavigation::TabPages' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundNavigation, Tab_MissionDescription) == 0x000438, "Member 'UTedCommandCompoundNavigation::Tab_MissionDescription' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundNavigation, Tab_AcknowledgmentCredits) == 0x000440, "Member 'UTedCommandCompoundNavigation::Tab_AcknowledgmentCredits' has a wrong offset!");

// Class Tempest.TedAbility_ReleaseHarvesters_Refinery
// 0x0000 (0x03E0 - 0x03E0)
class UTedAbility_ReleaseHarvesters_Refinery : public UTedAbilityBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_ReleaseHarvesters_Refinery">();
	}
	static class UTedAbility_ReleaseHarvesters_Refinery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_ReleaseHarvesters_Refinery>();
	}
};
static_assert(alignof(UTedAbility_ReleaseHarvesters_Refinery) == 0x000008, "Wrong alignment on UTedAbility_ReleaseHarvesters_Refinery");
static_assert(sizeof(UTedAbility_ReleaseHarvesters_Refinery) == 0x0003E0, "Wrong size on UTedAbility_ReleaseHarvesters_Refinery");

// Class Tempest.TedPlayerController_Spectator
// 0x0018 (0x1838 - 0x1820)
class ATedPlayerController_Spectator : public ATedPlayerController
{
public:
	float                                         FollowCameraInterpolationSpeed;                    // 0x1820(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1824[0x4];                                     // 0x1824(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ATedPlayerState*                        FocusedPlayer;                                     // 0x1828(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FocusedPlayerIt;                                   // 0x1830(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1834[0x4];                                     // 0x1834(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Action_SelectPlayerView();
	void Action_SwapTeams();
	void Server_R_SwapTeams();

	void ReturnToMainMenu() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerController_Spectator">();
	}
	static class ATedPlayerController_Spectator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedPlayerController_Spectator>();
	}
};
static_assert(alignof(ATedPlayerController_Spectator) == 0x000008, "Wrong alignment on ATedPlayerController_Spectator");
static_assert(sizeof(ATedPlayerController_Spectator) == 0x001838, "Wrong size on ATedPlayerController_Spectator");
static_assert(offsetof(ATedPlayerController_Spectator, FollowCameraInterpolationSpeed) == 0x001820, "Member 'ATedPlayerController_Spectator::FollowCameraInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(ATedPlayerController_Spectator, FocusedPlayer) == 0x001828, "Member 'ATedPlayerController_Spectator::FocusedPlayer' has a wrong offset!");
static_assert(offsetof(ATedPlayerController_Spectator, FocusedPlayerIt) == 0x001830, "Member 'ATedPlayerController_Spectator::FocusedPlayerIt' has a wrong offset!");

// Class Tempest.TedAbility_Repair
// 0x0088 (0x0498 - 0x0410)
class UTedAbility_Repair : public UTedAbility_Montage
{
public:
	struct FGameplayTagContainer                  WhitelistPawnTypeTags;                             // 0x0410(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  BlacklistPawnTypeTags;                             // 0x0430(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  BlacklistGameplayTags;                             // 0x0450(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         FallbackDistanceLimit;                             // 0x0470(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_474[0x4];                                      // 0x0474(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            RepairGE;                                          // 0x0478(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATedPawn*                               CachedRepairedPawn;                                // 0x0480(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           ValidateAbilityHandle;                             // 0x0488(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastActivationTime;                                // 0x0490(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_494[0x4];                                      // 0x0494(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_Repair">();
	}
	static class UTedAbility_Repair* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_Repair>();
	}
};
static_assert(alignof(UTedAbility_Repair) == 0x000008, "Wrong alignment on UTedAbility_Repair");
static_assert(sizeof(UTedAbility_Repair) == 0x000498, "Wrong size on UTedAbility_Repair");
static_assert(offsetof(UTedAbility_Repair, WhitelistPawnTypeTags) == 0x000410, "Member 'UTedAbility_Repair::WhitelistPawnTypeTags' has a wrong offset!");
static_assert(offsetof(UTedAbility_Repair, BlacklistPawnTypeTags) == 0x000430, "Member 'UTedAbility_Repair::BlacklistPawnTypeTags' has a wrong offset!");
static_assert(offsetof(UTedAbility_Repair, BlacklistGameplayTags) == 0x000450, "Member 'UTedAbility_Repair::BlacklistGameplayTags' has a wrong offset!");
static_assert(offsetof(UTedAbility_Repair, FallbackDistanceLimit) == 0x000470, "Member 'UTedAbility_Repair::FallbackDistanceLimit' has a wrong offset!");
static_assert(offsetof(UTedAbility_Repair, RepairGE) == 0x000478, "Member 'UTedAbility_Repair::RepairGE' has a wrong offset!");
static_assert(offsetof(UTedAbility_Repair, CachedRepairedPawn) == 0x000480, "Member 'UTedAbility_Repair::CachedRepairedPawn' has a wrong offset!");
static_assert(offsetof(UTedAbility_Repair, ValidateAbilityHandle) == 0x000488, "Member 'UTedAbility_Repair::ValidateAbilityHandle' has a wrong offset!");
static_assert(offsetof(UTedAbility_Repair, LastActivationTime) == 0x000490, "Member 'UTedAbility_Repair::LastActivationTime' has a wrong offset!");

// Class Tempest.TedCommandCompoundMapScreenSetup
// 0x00C0 (0x00F0 - 0x0030)
class UTedCommandCompoundMapScreenSetup final : public UPrimaryDataAsset
{
public:
	class UFileMediaSource*                       Intro;                                             // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFileMediaSource*                       DetailsLoop;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              DetailsVO;                                         // 0x0040(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DetailsVOText;                                     // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UFileMediaSource*                       Outro;                                             // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFileMediaSource*                       CinematicIntro;                                    // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              TextBoxTexture;                                    // 0x0088(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFileMediaSource*                       TextBox;                                           // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              DataBoxTexture;                                    // 0x00B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFileMediaSource*                       DataBox;                                           // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFileMediaSource*                       Logo;                                              // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandCompoundMapScreenSetup">();
	}
	static class UTedCommandCompoundMapScreenSetup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCommandCompoundMapScreenSetup>();
	}
};
static_assert(alignof(UTedCommandCompoundMapScreenSetup) == 0x000008, "Wrong alignment on UTedCommandCompoundMapScreenSetup");
static_assert(sizeof(UTedCommandCompoundMapScreenSetup) == 0x0000F0, "Wrong size on UTedCommandCompoundMapScreenSetup");
static_assert(offsetof(UTedCommandCompoundMapScreenSetup, Intro) == 0x000030, "Member 'UTedCommandCompoundMapScreenSetup::Intro' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundMapScreenSetup, DetailsLoop) == 0x000038, "Member 'UTedCommandCompoundMapScreenSetup::DetailsLoop' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundMapScreenSetup, DetailsVO) == 0x000040, "Member 'UTedCommandCompoundMapScreenSetup::DetailsVO' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundMapScreenSetup, DetailsVOText) == 0x000068, "Member 'UTedCommandCompoundMapScreenSetup::DetailsVOText' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundMapScreenSetup, Outro) == 0x000078, "Member 'UTedCommandCompoundMapScreenSetup::Outro' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundMapScreenSetup, CinematicIntro) == 0x000080, "Member 'UTedCommandCompoundMapScreenSetup::CinematicIntro' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundMapScreenSetup, TextBoxTexture) == 0x000088, "Member 'UTedCommandCompoundMapScreenSetup::TextBoxTexture' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundMapScreenSetup, TextBox) == 0x0000B0, "Member 'UTedCommandCompoundMapScreenSetup::TextBox' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundMapScreenSetup, DataBoxTexture) == 0x0000B8, "Member 'UTedCommandCompoundMapScreenSetup::DataBoxTexture' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundMapScreenSetup, DataBox) == 0x0000E0, "Member 'UTedCommandCompoundMapScreenSetup::DataBox' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundMapScreenSetup, Logo) == 0x0000E8, "Member 'UTedCommandCompoundMapScreenSetup::Logo' has a wrong offset!");

// Class Tempest.TedAbility_RevealStealth
// 0x0010 (0x03F0 - 0x03E0)
class UTedAbility_RevealStealth final : public UTedAbilityBase
{
public:
	TSubclassOf<class UGameplayEffect>            DurationGE;                                        // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RevealRadius;                                      // 0x03E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3EC[0x4];                                      // 0x03EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_RevealStealth">();
	}
	static class UTedAbility_RevealStealth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_RevealStealth>();
	}
};
static_assert(alignof(UTedAbility_RevealStealth) == 0x000008, "Wrong alignment on UTedAbility_RevealStealth");
static_assert(sizeof(UTedAbility_RevealStealth) == 0x0003F0, "Wrong size on UTedAbility_RevealStealth");
static_assert(offsetof(UTedAbility_RevealStealth, DurationGE) == 0x0003E0, "Member 'UTedAbility_RevealStealth::DurationGE' has a wrong offset!");
static_assert(offsetof(UTedAbility_RevealStealth, RevealRadius) == 0x0003E8, "Member 'UTedAbility_RevealStealth::RevealRadius' has a wrong offset!");

// Class Tempest.TedAbility_Sacrifice
// 0x0000 (0x03E0 - 0x03E0)
class UTedAbility_Sacrifice final : public UTedAbilityBase
{
public:
	void SacrificePawn();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_Sacrifice">();
	}
	static class UTedAbility_Sacrifice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_Sacrifice>();
	}
};
static_assert(alignof(UTedAbility_Sacrifice) == 0x000008, "Wrong alignment on UTedAbility_Sacrifice");
static_assert(sizeof(UTedAbility_Sacrifice) == 0x0003E0, "Wrong size on UTedAbility_Sacrifice");

// Class Tempest.TedCommandCompoundLoadoutSocketSlot
// 0x0048 (0x0448 - 0x0400)
class UTedCommandCompoundLoadoutSocketSlot final : public UTedUserWidget
{
public:
	uint8                                         TargetContentSlotIndex;                            // 0x0400(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_401[0x3];                                      // 0x0401(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ParamName_Equipped;                                // 0x0404(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ParamName_Disabled;                                // 0x040C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SpaceIndicatorActiveParamName;                     // 0x0414(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41C[0x4];                                      // 0x041C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPanelWidget*                           Panel_SocketRootPanel;                             // 0x0420(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_Connector_Previous;                          // 0x0428(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_Connector_Next;                              // 0x0430(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_SpaceIndicator;                              // 0x0438(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedContentPanelBase*                   TargetContentPanel;                                // 0x0440(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnActivateSlotState(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotState InState, bool bInActivated);
	void OnContentPanelChange(class UTedContentPanelDynamic* InContentPanel);
	void SetTargetContentPanel(class UTedContentPanelBase* InTargetPanel);
	void SetTargetContentSlotIndex(const uint8 InTargetIndex);

	class UPanelWidget* GetSocketRootPanel() const;
	class UTedContentPanelBase* GetTargetContentPanel() const;
	class UTedContentPanelSlotBase* GetTargetContentSlot() const;
	int32 GetTargetContentSlotIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandCompoundLoadoutSocketSlot">();
	}
	static class UTedCommandCompoundLoadoutSocketSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCommandCompoundLoadoutSocketSlot>();
	}
};
static_assert(alignof(UTedCommandCompoundLoadoutSocketSlot) == 0x000008, "Wrong alignment on UTedCommandCompoundLoadoutSocketSlot");
static_assert(sizeof(UTedCommandCompoundLoadoutSocketSlot) == 0x000448, "Wrong size on UTedCommandCompoundLoadoutSocketSlot");
static_assert(offsetof(UTedCommandCompoundLoadoutSocketSlot, TargetContentSlotIndex) == 0x000400, "Member 'UTedCommandCompoundLoadoutSocketSlot::TargetContentSlotIndex' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundLoadoutSocketSlot, ParamName_Equipped) == 0x000404, "Member 'UTedCommandCompoundLoadoutSocketSlot::ParamName_Equipped' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundLoadoutSocketSlot, ParamName_Disabled) == 0x00040C, "Member 'UTedCommandCompoundLoadoutSocketSlot::ParamName_Disabled' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundLoadoutSocketSlot, SpaceIndicatorActiveParamName) == 0x000414, "Member 'UTedCommandCompoundLoadoutSocketSlot::SpaceIndicatorActiveParamName' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundLoadoutSocketSlot, Panel_SocketRootPanel) == 0x000420, "Member 'UTedCommandCompoundLoadoutSocketSlot::Panel_SocketRootPanel' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundLoadoutSocketSlot, Image_Connector_Previous) == 0x000428, "Member 'UTedCommandCompoundLoadoutSocketSlot::Image_Connector_Previous' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundLoadoutSocketSlot, Image_Connector_Next) == 0x000430, "Member 'UTedCommandCompoundLoadoutSocketSlot::Image_Connector_Next' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundLoadoutSocketSlot, Image_SpaceIndicator) == 0x000438, "Member 'UTedCommandCompoundLoadoutSocketSlot::Image_SpaceIndicator' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundLoadoutSocketSlot, TargetContentPanel) == 0x000440, "Member 'UTedCommandCompoundLoadoutSocketSlot::TargetContentPanel' has a wrong offset!");

// Class Tempest.TedAbility_SpawnUnit
// 0x0030 (0x0410 - 0x03E0)
class UTedAbility_SpawnUnit final : public UTedAbilityBase
{
public:
	TArray<struct FUnitToSpawnData>               UnitsToSpawnData;                                  // 0x03E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueTag                        SpawnGameplayCue;                                  // 0x03F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bTraceGroundForPhysMat;                            // 0x03F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F9[0x7];                                      // 0x03F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              CachedTargetLocation;                              // 0x0400(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ReceiveSpawnedUnit(class ATedUnitBase* Unit);
	void SpawnUnits(const struct FVector2D& LocationOverride);

	TArray<struct FUnitToSpawnData> GetUnitToSpawnData(const struct FGameplayAbilityActorInfo& ActorInfo) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_SpawnUnit">();
	}
	static class UTedAbility_SpawnUnit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_SpawnUnit>();
	}
};
static_assert(alignof(UTedAbility_SpawnUnit) == 0x000008, "Wrong alignment on UTedAbility_SpawnUnit");
static_assert(sizeof(UTedAbility_SpawnUnit) == 0x000410, "Wrong size on UTedAbility_SpawnUnit");
static_assert(offsetof(UTedAbility_SpawnUnit, UnitsToSpawnData) == 0x0003E0, "Member 'UTedAbility_SpawnUnit::UnitsToSpawnData' has a wrong offset!");
static_assert(offsetof(UTedAbility_SpawnUnit, SpawnGameplayCue) == 0x0003F0, "Member 'UTedAbility_SpawnUnit::SpawnGameplayCue' has a wrong offset!");
static_assert(offsetof(UTedAbility_SpawnUnit, bTraceGroundForPhysMat) == 0x0003F8, "Member 'UTedAbility_SpawnUnit::bTraceGroundForPhysMat' has a wrong offset!");
static_assert(offsetof(UTedAbility_SpawnUnit, CachedTargetLocation) == 0x000400, "Member 'UTedAbility_SpawnUnit::CachedTargetLocation' has a wrong offset!");

// Class Tempest.TedSelectionDetailsController
// 0x0018 (0x0418 - 0x0400)
class UTedSelectionDetailsController : public UTedUserWidget
{
public:
	uint8                                         bSingleSelectionOwnershipChangeRelevant : 1;       // 0x0400(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bMultiSelectionOwnershipChangeRelevant : 1;        // 0x0400(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_401[0x7];                                      // 0x0401(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATedPawn*>                       SelectedPawns;                                     // 0x0408(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)

public:
	void K2_OnMultiSelectionOwnershipChange(class ATedPawn* InSelectedPawn);
	void K2_OnSelectionChange();
	void K2_OnSingleSelectionOwnershipChange(class ATedPawn* InSelectedPawn);

	const class ATedPawn* GetFirstSelectedPawn() const;
	class ATedPlayerController* GetPlayerController() const;
	const TArray<class ATedPawn*> GetSelectedPawns() const;
	int32 GetSelectionSize() const;
	bool IsAnythingSelected() const;
	bool IsMultiSelection() const;
	bool IsSingleSelection() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSelectionDetailsController">();
	}
	static class UTedSelectionDetailsController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSelectionDetailsController>();
	}
};
static_assert(alignof(UTedSelectionDetailsController) == 0x000008, "Wrong alignment on UTedSelectionDetailsController");
static_assert(sizeof(UTedSelectionDetailsController) == 0x000418, "Wrong size on UTedSelectionDetailsController");
static_assert(offsetof(UTedSelectionDetailsController, SelectedPawns) == 0x000408, "Member 'UTedSelectionDetailsController::SelectedPawns' has a wrong offset!");

// Class Tempest.TedAbility_Stealth
// 0x0018 (0x03F8 - 0x03E0)
class UTedAbility_Stealth : public UTedAbilityBase
{
public:
	TSubclassOf<class UEcsTypeDesc>               StealthEntityDescriptor;                           // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBehaviorTree*                          OptionalIdleTreeOverride;                          // 0x03E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNoFireTargetRequired;                             // 0x03F0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F1[0x7];                                      // 0x03F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnableStealth(const bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_Stealth">();
	}
	static class UTedAbility_Stealth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_Stealth>();
	}
};
static_assert(alignof(UTedAbility_Stealth) == 0x000008, "Wrong alignment on UTedAbility_Stealth");
static_assert(sizeof(UTedAbility_Stealth) == 0x0003F8, "Wrong size on UTedAbility_Stealth");
static_assert(offsetof(UTedAbility_Stealth, StealthEntityDescriptor) == 0x0003E0, "Member 'UTedAbility_Stealth::StealthEntityDescriptor' has a wrong offset!");
static_assert(offsetof(UTedAbility_Stealth, OptionalIdleTreeOverride) == 0x0003E8, "Member 'UTedAbility_Stealth::OptionalIdleTreeOverride' has a wrong offset!");
static_assert(offsetof(UTedAbility_Stealth, bNoFireTargetRequired) == 0x0003F0, "Member 'UTedAbility_Stealth::bNoFireTargetRequired' has a wrong offset!");

// Class Tempest.TedUpgrade
// 0x00A0 (0x00D8 - 0x0038)
class UTedUpgrade : public USmartDataAsset
{
public:
	TArray<struct FTedInstancedStruct>            UpgradeProcessors;                                 // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         ProcessorFlags;                                    // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Icon;                                              // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   Title;                                             // 0x0058(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTedFormattedText                      Description;                                       // 0x0068(0x0060)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTedUpgradeExtendedDescriptionCreator> ExtendedDescriptions;                       // 0x00C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUpgrade">();
	}
	static class UTedUpgrade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUpgrade>();
	}
};
static_assert(alignof(UTedUpgrade) == 0x000008, "Wrong alignment on UTedUpgrade");
static_assert(sizeof(UTedUpgrade) == 0x0000D8, "Wrong size on UTedUpgrade");
static_assert(offsetof(UTedUpgrade, UpgradeProcessors) == 0x000038, "Member 'UTedUpgrade::UpgradeProcessors' has a wrong offset!");
static_assert(offsetof(UTedUpgrade, ProcessorFlags) == 0x000048, "Member 'UTedUpgrade::ProcessorFlags' has a wrong offset!");
static_assert(offsetof(UTedUpgrade, Icon) == 0x000050, "Member 'UTedUpgrade::Icon' has a wrong offset!");
static_assert(offsetof(UTedUpgrade, Title) == 0x000058, "Member 'UTedUpgrade::Title' has a wrong offset!");
static_assert(offsetof(UTedUpgrade, Description) == 0x000068, "Member 'UTedUpgrade::Description' has a wrong offset!");
static_assert(offsetof(UTedUpgrade, ExtendedDescriptions) == 0x0000C8, "Member 'UTedUpgrade::ExtendedDescriptions' has a wrong offset!");

// Class Tempest.TedAbility_TeleportStructure
// 0x0000 (0x0520 - 0x0520)
class UTedAbility_TeleportStructure final : public UTedAbility_DeployStructure
{
public:
	float                                         EndAbilityDelay;                                   // 0x0518(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_51C[0x4];                                      // 0x051C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_TeleportStructure">();
	}
	static class UTedAbility_TeleportStructure* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_TeleportStructure>();
	}
};
static_assert(alignof(UTedAbility_TeleportStructure) == 0x000010, "Wrong alignment on UTedAbility_TeleportStructure");
static_assert(sizeof(UTedAbility_TeleportStructure) == 0x000520, "Wrong size on UTedAbility_TeleportStructure");
static_assert(offsetof(UTedAbility_TeleportStructure, EndAbilityDelay) == 0x000518, "Member 'UTedAbility_TeleportStructure::EndAbilityDelay' has a wrong offset!");

// Class Tempest.TedAbility_TeleportUnit
// 0x0008 (0x03E8 - 0x03E0)
class UTedAbility_TeleportUnit final : public UTedAbilityBase
{
public:
	bool                                          bRequirePlayerInfluenceArea;                       // 0x03E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E1[0x7];                                      // 0x03E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Teleport();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_TeleportUnit">();
	}
	static class UTedAbility_TeleportUnit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_TeleportUnit>();
	}
};
static_assert(alignof(UTedAbility_TeleportUnit) == 0x000008, "Wrong alignment on UTedAbility_TeleportUnit");
static_assert(sizeof(UTedAbility_TeleportUnit) == 0x0003E8, "Wrong size on UTedAbility_TeleportUnit");
static_assert(offsetof(UTedAbility_TeleportUnit, bRequirePlayerInfluenceArea) == 0x0003E0, "Member 'UTedAbility_TeleportUnit::bRequirePlayerInfluenceArea' has a wrong offset!");

// Class Tempest.TedCommandCustomRequirement
// 0x0000 (0x0028 - 0x0028)
class UTedCommandCustomRequirement : public UGameplayCommandCustomRequirement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandCustomRequirement">();
	}
	static class UTedCommandCustomRequirement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCommandCustomRequirement>();
	}
};
static_assert(alignof(UTedCommandCustomRequirement) == 0x000008, "Wrong alignment on UTedCommandCustomRequirement");
static_assert(sizeof(UTedCommandCustomRequirement) == 0x000028, "Wrong size on UTedCommandCustomRequirement");

// Class Tempest.TedCommandCustomRequirement_PawnsInRange
// 0x0018 (0x0040 - 0x0028)
class UTedCommandCustomRequirement_PawnsInRange final : public UTedCommandCustomRequirement
{
public:
	struct FGameplayTag                           TechTag;                                           // 0x0028(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RequiredNumber;                                    // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTedAttitudeFilter                     AttitudeFilter;                                    // 0x0034(0x0002)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Range;                                             // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandCustomRequirement_PawnsInRange">();
	}
	static class UTedCommandCustomRequirement_PawnsInRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCommandCustomRequirement_PawnsInRange>();
	}
};
static_assert(alignof(UTedCommandCustomRequirement_PawnsInRange) == 0x000008, "Wrong alignment on UTedCommandCustomRequirement_PawnsInRange");
static_assert(sizeof(UTedCommandCustomRequirement_PawnsInRange) == 0x000040, "Wrong size on UTedCommandCustomRequirement_PawnsInRange");
static_assert(offsetof(UTedCommandCustomRequirement_PawnsInRange, TechTag) == 0x000028, "Member 'UTedCommandCustomRequirement_PawnsInRange::TechTag' has a wrong offset!");
static_assert(offsetof(UTedCommandCustomRequirement_PawnsInRange, RequiredNumber) == 0x000030, "Member 'UTedCommandCustomRequirement_PawnsInRange::RequiredNumber' has a wrong offset!");
static_assert(offsetof(UTedCommandCustomRequirement_PawnsInRange, AttitudeFilter) == 0x000034, "Member 'UTedCommandCustomRequirement_PawnsInRange::AttitudeFilter' has a wrong offset!");
static_assert(offsetof(UTedCommandCustomRequirement_PawnsInRange, Range) == 0x000038, "Member 'UTedCommandCustomRequirement_PawnsInRange::Range' has a wrong offset!");

// Class Tempest.TedAbility_TempestChargeOverflow
// 0x0020 (0x0400 - 0x03E0)
class UTedAbility_TempestChargeOverflow final : public UTedAbilityBase
{
public:
	float                                         Range;                                             // 0x03E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageAmount;                                      // 0x03E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAISenseAffiliationFilter              AttitudeFilter;                                    // 0x03E8(0x0004)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3EC[0x4];                                      // 0x03EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UTedDamageType>             DamageTypeClass;                                   // 0x03F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayCueTag                        HitGameplayCue;                                    // 0x03F8(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void OnTakeAnyDamage(class AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_TempestChargeOverflow">();
	}
	static class UTedAbility_TempestChargeOverflow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_TempestChargeOverflow>();
	}
};
static_assert(alignof(UTedAbility_TempestChargeOverflow) == 0x000008, "Wrong alignment on UTedAbility_TempestChargeOverflow");
static_assert(sizeof(UTedAbility_TempestChargeOverflow) == 0x000400, "Wrong size on UTedAbility_TempestChargeOverflow");
static_assert(offsetof(UTedAbility_TempestChargeOverflow, Range) == 0x0003E0, "Member 'UTedAbility_TempestChargeOverflow::Range' has a wrong offset!");
static_assert(offsetof(UTedAbility_TempestChargeOverflow, DamageAmount) == 0x0003E4, "Member 'UTedAbility_TempestChargeOverflow::DamageAmount' has a wrong offset!");
static_assert(offsetof(UTedAbility_TempestChargeOverflow, AttitudeFilter) == 0x0003E8, "Member 'UTedAbility_TempestChargeOverflow::AttitudeFilter' has a wrong offset!");
static_assert(offsetof(UTedAbility_TempestChargeOverflow, DamageTypeClass) == 0x0003F0, "Member 'UTedAbility_TempestChargeOverflow::DamageTypeClass' has a wrong offset!");
static_assert(offsetof(UTedAbility_TempestChargeOverflow, HitGameplayCue) == 0x0003F8, "Member 'UTedAbility_TempestChargeOverflow::HitGameplayCue' has a wrong offset!");

// Class Tempest.TedSelectionDetails_InfoSlots_Slot_Attack
// 0x0000 (0x0410 - 0x0410)
class UTedSelectionDetails_InfoSlots_Slot_Attack : public UTedContentPanelSlotBase
{
public:
	void OnContextChange(class UTedContentPanelStatic* InContentPanel, class UObject* InPrevContext, class UObject* InNewContext);
	void RefreshDisabledState();

	class ATedPawn* GetContextPawn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSelectionDetails_InfoSlots_Slot_Attack">();
	}
	static class UTedSelectionDetails_InfoSlots_Slot_Attack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSelectionDetails_InfoSlots_Slot_Attack>();
	}
};
static_assert(alignof(UTedSelectionDetails_InfoSlots_Slot_Attack) == 0x000008, "Wrong alignment on UTedSelectionDetails_InfoSlots_Slot_Attack");
static_assert(sizeof(UTedSelectionDetails_InfoSlots_Slot_Attack) == 0x000410, "Wrong size on UTedSelectionDetails_InfoSlots_Slot_Attack");

// Class Tempest.TedAbility_UnloadPawns
// 0x0000 (0x03E0 - 0x03E0)
class UTedAbility_UnloadPawns : public UTedAbilityBase
{
public:
	void UnloadPawns(const struct FVector2D& LocationOverride);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAbility_UnloadPawns">();
	}
	static class UTedAbility_UnloadPawns* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAbility_UnloadPawns>();
	}
};
static_assert(alignof(UTedAbility_UnloadPawns) == 0x000008, "Wrong alignment on UTedAbility_UnloadPawns");
static_assert(sizeof(UTedAbility_UnloadPawns) == 0x0003E0, "Wrong size on UTedAbility_UnloadPawns");

// Class Tempest.TedAchievementConditionBase
// 0x0030 (0x0058 - 0x0028)
class UTedAchievementConditionBase : public UObject
{
public:
	bool                                          bWorldBound;                                       // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImplementTest;                                    // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DeveloperNote;                                     // 0x0030(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAchievementConditionBase">();
	}
	static class UTedAchievementConditionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAchievementConditionBase>();
	}
};
static_assert(alignof(UTedAchievementConditionBase) == 0x000008, "Wrong alignment on UTedAchievementConditionBase");
static_assert(sizeof(UTedAchievementConditionBase) == 0x000058, "Wrong size on UTedAchievementConditionBase");
static_assert(offsetof(UTedAchievementConditionBase, bWorldBound) == 0x000028, "Member 'UTedAchievementConditionBase::bWorldBound' has a wrong offset!");
static_assert(offsetof(UTedAchievementConditionBase, bImplementTest) == 0x000029, "Member 'UTedAchievementConditionBase::bImplementTest' has a wrong offset!");
static_assert(offsetof(UTedAchievementConditionBase, DeveloperNote) == 0x000030, "Member 'UTedAchievementConditionBase::DeveloperNote' has a wrong offset!");

// Class Tempest.TedAchCond_ActiveConstructionSites
// 0x0008 (0x0060 - 0x0058)
class UTedAchCond_ActiveConstructionSites final : public UTedAchievementConditionBase
{
public:
	int32                                         MinSites;                                          // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActiveSites;                                       // 0x005C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAchCond_ActiveConstructionSites">();
	}
	static class UTedAchCond_ActiveConstructionSites* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAchCond_ActiveConstructionSites>();
	}
};
static_assert(alignof(UTedAchCond_ActiveConstructionSites) == 0x000008, "Wrong alignment on UTedAchCond_ActiveConstructionSites");
static_assert(sizeof(UTedAchCond_ActiveConstructionSites) == 0x000060, "Wrong size on UTedAchCond_ActiveConstructionSites");
static_assert(offsetof(UTedAchCond_ActiveConstructionSites, MinSites) == 0x000058, "Member 'UTedAchCond_ActiveConstructionSites::MinSites' has a wrong offset!");
static_assert(offsetof(UTedAchCond_ActiveConstructionSites, ActiveSites) == 0x00005C, "Member 'UTedAchCond_ActiveConstructionSites::ActiveSites' has a wrong offset!");

// Class Tempest.TedDoctrineSlotTooltip
// 0x0008 (0x04A8 - 0x04A0)
class UTedDoctrineSlotTooltip : public UTedTooltipWidget
{
public:
	class UTedContentPanelInstanced*              Panel_ExtendedDescriptions;                        // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class FText GetDescription() const;
	const class UTedDoctrineSlot* GetDoctrineSlot() const;
	class UTexture2D* GetIcon() const;
	int32 GetOnSellRefundedCredits() const;
	int32 GetResearchCostCredits() const;
	float GetResearchTime() const;
	const class FText GetTitle() const;
	bool IsResearchRelevant() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedDoctrineSlotTooltip">();
	}
	static class UTedDoctrineSlotTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedDoctrineSlotTooltip>();
	}
};
static_assert(alignof(UTedDoctrineSlotTooltip) == 0x000008, "Wrong alignment on UTedDoctrineSlotTooltip");
static_assert(sizeof(UTedDoctrineSlotTooltip) == 0x0004A8, "Wrong size on UTedDoctrineSlotTooltip");
static_assert(offsetof(UTedDoctrineSlotTooltip, Panel_ExtendedDescriptions) == 0x0004A0, "Member 'UTedDoctrineSlotTooltip::Panel_ExtendedDescriptions' has a wrong offset!");

// Class Tempest.TedAchCond_Campaign
// 0x0010 (0x0068 - 0x0058)
class UTedAchCond_Campaign final : public UTedAchievementConditionBase
{
public:
	class UTedCampaignInfo*                       RequiredCampaign;                                  // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETedGameDifficulty                            MinimumDifficulty;                                 // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAchCond_Campaign">();
	}
	static class UTedAchCond_Campaign* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAchCond_Campaign>();
	}
};
static_assert(alignof(UTedAchCond_Campaign) == 0x000008, "Wrong alignment on UTedAchCond_Campaign");
static_assert(sizeof(UTedAchCond_Campaign) == 0x000068, "Wrong size on UTedAchCond_Campaign");
static_assert(offsetof(UTedAchCond_Campaign, RequiredCampaign) == 0x000058, "Member 'UTedAchCond_Campaign::RequiredCampaign' has a wrong offset!");
static_assert(offsetof(UTedAchCond_Campaign, MinimumDifficulty) == 0x000060, "Member 'UTedAchCond_Campaign::MinimumDifficulty' has a wrong offset!");

// Class Tempest.TedSelectionDetails_InfoSlots_Tooltip_Perks
// 0x0008 (0x04A8 - 0x04A0)
class UTedSelectionDetails_InfoSlots_Tooltip_Perks : public UTedTooltipWidget
{
public:
	class UTedPassiveAbilityPanel*                PassiveAbilities;                                  // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSelectionDetails_InfoSlots_Tooltip_Perks">();
	}
	static class UTedSelectionDetails_InfoSlots_Tooltip_Perks* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSelectionDetails_InfoSlots_Tooltip_Perks>();
	}
};
static_assert(alignof(UTedSelectionDetails_InfoSlots_Tooltip_Perks) == 0x000008, "Wrong alignment on UTedSelectionDetails_InfoSlots_Tooltip_Perks");
static_assert(sizeof(UTedSelectionDetails_InfoSlots_Tooltip_Perks) == 0x0004A8, "Wrong size on UTedSelectionDetails_InfoSlots_Tooltip_Perks");
static_assert(offsetof(UTedSelectionDetails_InfoSlots_Tooltip_Perks, PassiveAbilities) == 0x0004A0, "Member 'UTedSelectionDetails_InfoSlots_Tooltip_Perks::PassiveAbilities' has a wrong offset!");

// Class Tempest.TedAchCond_Deprived
// 0x0010 (0x0068 - 0x0058)
class UTedAchCond_Deprived final : public UTedAchievementConditionBase
{
public:
	TArray<class UTedCampaignInfo*>               RequiredCampaign;                                  // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAchCond_Deprived">();
	}
	static class UTedAchCond_Deprived* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAchCond_Deprived>();
	}
};
static_assert(alignof(UTedAchCond_Deprived) == 0x000008, "Wrong alignment on UTedAchCond_Deprived");
static_assert(sizeof(UTedAchCond_Deprived) == 0x000068, "Wrong size on UTedAchCond_Deprived");
static_assert(offsetof(UTedAchCond_Deprived, RequiredCampaign) == 0x000058, "Member 'UTedAchCond_Deprived::RequiredCampaign' has a wrong offset!");

// Class Tempest.TedCommandCustomMultiplayerRequirement
// 0x0000 (0x0028 - 0x0028)
class UTedCommandCustomMultiplayerRequirement : public UTedCommandCustomRequirement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandCustomMultiplayerRequirement">();
	}
	static class UTedCommandCustomMultiplayerRequirement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCommandCustomMultiplayerRequirement>();
	}
};
static_assert(alignof(UTedCommandCustomMultiplayerRequirement) == 0x000008, "Wrong alignment on UTedCommandCustomMultiplayerRequirement");
static_assert(sizeof(UTedCommandCustomMultiplayerRequirement) == 0x000028, "Wrong size on UTedCommandCustomMultiplayerRequirement");

// Class Tempest.TedCommandCustomMultiplayerRequirement_PlayerOwnsTechs
// 0x0020 (0x0048 - 0x0028)
class UTedCommandCustomMultiplayerRequirement_PlayerOwnsTechs final : public UTedCommandCustomMultiplayerRequirement
{
public:
	struct FGameplayTagContainer                  TechTags;                                          // 0x0028(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandCustomMultiplayerRequirement_PlayerOwnsTechs">();
	}
	static class UTedCommandCustomMultiplayerRequirement_PlayerOwnsTechs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCommandCustomMultiplayerRequirement_PlayerOwnsTechs>();
	}
};
static_assert(alignof(UTedCommandCustomMultiplayerRequirement_PlayerOwnsTechs) == 0x000008, "Wrong alignment on UTedCommandCustomMultiplayerRequirement_PlayerOwnsTechs");
static_assert(sizeof(UTedCommandCustomMultiplayerRequirement_PlayerOwnsTechs) == 0x000048, "Wrong size on UTedCommandCustomMultiplayerRequirement_PlayerOwnsTechs");
static_assert(offsetof(UTedCommandCustomMultiplayerRequirement_PlayerOwnsTechs, TechTags) == 0x000028, "Member 'UTedCommandCustomMultiplayerRequirement_PlayerOwnsTechs::TechTags' has a wrong offset!");

// Class Tempest.TedAchCond_FinishMission
// 0x0010 (0x0068 - 0x0058)
class UTedAchCond_FinishMission final : public UTedAchievementConditionBase
{
public:
	class UTedMapInfo*                            Mission;                                           // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequireAllObjectivesFinished;                     // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETedGameDifficulty                            MinimumDifficulty;                                 // 0x0061(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x6];                                       // 0x0062(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAchCond_FinishMission">();
	}
	static class UTedAchCond_FinishMission* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAchCond_FinishMission>();
	}
};
static_assert(alignof(UTedAchCond_FinishMission) == 0x000008, "Wrong alignment on UTedAchCond_FinishMission");
static_assert(sizeof(UTedAchCond_FinishMission) == 0x000068, "Wrong size on UTedAchCond_FinishMission");
static_assert(offsetof(UTedAchCond_FinishMission, Mission) == 0x000058, "Member 'UTedAchCond_FinishMission::Mission' has a wrong offset!");
static_assert(offsetof(UTedAchCond_FinishMission, bRequireAllObjectivesFinished) == 0x000060, "Member 'UTedAchCond_FinishMission::bRequireAllObjectivesFinished' has a wrong offset!");
static_assert(offsetof(UTedAchCond_FinishMission, MinimumDifficulty) == 0x000061, "Member 'UTedAchCond_FinishMission::MinimumDifficulty' has a wrong offset!");

// Class Tempest.TedAchCond_GameMode
// 0x0030 (0x0088 - 0x0058)
class UTedAchCond_GameMode final : public UTedAchievementConditionBase
{
public:
	TSubclassOf<class AGameModeBase>              RequiredGameMode;                                  // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequireGameDifficulty;                            // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETedGameDifficulty                            MinimumGameDifficulty;                             // 0x0061(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequireBotDifficulty;                             // 0x0062(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETedBotDifficulty                             MinimumBotDifficulty;                              // 0x0063(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiredNumberOfBots;                             // 0x0064(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinimumNumberOfBots;                               // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBotsOnTheSameTeam;                                // 0x006C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFactionRequirement;                               // 0x006D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETedFaction                                   RequiredFaction;                                   // 0x006E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECG_TriggerType                               TriggerType;                                       // 0x006F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECG_GameModeType                              GameModeType;                                      // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECG_MatchState                                MatchState;                                        // 0x0071(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFilterByTrainedUnits;                             // 0x0072(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_73[0x5];                                       // 0x0073(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ETedPawnType>                          AllowedPlayerPawnTypes;                            // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAchCond_GameMode">();
	}
	static class UTedAchCond_GameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAchCond_GameMode>();
	}
};
static_assert(alignof(UTedAchCond_GameMode) == 0x000008, "Wrong alignment on UTedAchCond_GameMode");
static_assert(sizeof(UTedAchCond_GameMode) == 0x000088, "Wrong size on UTedAchCond_GameMode");
static_assert(offsetof(UTedAchCond_GameMode, RequiredGameMode) == 0x000058, "Member 'UTedAchCond_GameMode::RequiredGameMode' has a wrong offset!");
static_assert(offsetof(UTedAchCond_GameMode, bRequireGameDifficulty) == 0x000060, "Member 'UTedAchCond_GameMode::bRequireGameDifficulty' has a wrong offset!");
static_assert(offsetof(UTedAchCond_GameMode, MinimumGameDifficulty) == 0x000061, "Member 'UTedAchCond_GameMode::MinimumGameDifficulty' has a wrong offset!");
static_assert(offsetof(UTedAchCond_GameMode, bRequireBotDifficulty) == 0x000062, "Member 'UTedAchCond_GameMode::bRequireBotDifficulty' has a wrong offset!");
static_assert(offsetof(UTedAchCond_GameMode, MinimumBotDifficulty) == 0x000063, "Member 'UTedAchCond_GameMode::MinimumBotDifficulty' has a wrong offset!");
static_assert(offsetof(UTedAchCond_GameMode, bRequiredNumberOfBots) == 0x000064, "Member 'UTedAchCond_GameMode::bRequiredNumberOfBots' has a wrong offset!");
static_assert(offsetof(UTedAchCond_GameMode, MinimumNumberOfBots) == 0x000068, "Member 'UTedAchCond_GameMode::MinimumNumberOfBots' has a wrong offset!");
static_assert(offsetof(UTedAchCond_GameMode, bBotsOnTheSameTeam) == 0x00006C, "Member 'UTedAchCond_GameMode::bBotsOnTheSameTeam' has a wrong offset!");
static_assert(offsetof(UTedAchCond_GameMode, bFactionRequirement) == 0x00006D, "Member 'UTedAchCond_GameMode::bFactionRequirement' has a wrong offset!");
static_assert(offsetof(UTedAchCond_GameMode, RequiredFaction) == 0x00006E, "Member 'UTedAchCond_GameMode::RequiredFaction' has a wrong offset!");
static_assert(offsetof(UTedAchCond_GameMode, TriggerType) == 0x00006F, "Member 'UTedAchCond_GameMode::TriggerType' has a wrong offset!");
static_assert(offsetof(UTedAchCond_GameMode, GameModeType) == 0x000070, "Member 'UTedAchCond_GameMode::GameModeType' has a wrong offset!");
static_assert(offsetof(UTedAchCond_GameMode, MatchState) == 0x000071, "Member 'UTedAchCond_GameMode::MatchState' has a wrong offset!");
static_assert(offsetof(UTedAchCond_GameMode, bFilterByTrainedUnits) == 0x000072, "Member 'UTedAchCond_GameMode::bFilterByTrainedUnits' has a wrong offset!");
static_assert(offsetof(UTedAchCond_GameMode, AllowedPlayerPawnTypes) == 0x000078, "Member 'UTedAchCond_GameMode::AllowedPlayerPawnTypes' has a wrong offset!");

// Class Tempest.TedCommandValueCalculation_PawnTagBased
// 0x0018 (0x0040 - 0x0028)
class UTedCommandValueCalculation_PawnTagBased final : public UGameplayCommandValueCalculation
{
public:
	float                                         BaseValue;                                         // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedValueModsWithTagRequirements       ValueMods;                                         // 0x0030(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandValueCalculation_PawnTagBased">();
	}
	static class UTedCommandValueCalculation_PawnTagBased* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCommandValueCalculation_PawnTagBased>();
	}
};
static_assert(alignof(UTedCommandValueCalculation_PawnTagBased) == 0x000008, "Wrong alignment on UTedCommandValueCalculation_PawnTagBased");
static_assert(sizeof(UTedCommandValueCalculation_PawnTagBased) == 0x000040, "Wrong size on UTedCommandValueCalculation_PawnTagBased");
static_assert(offsetof(UTedCommandValueCalculation_PawnTagBased, BaseValue) == 0x000028, "Member 'UTedCommandValueCalculation_PawnTagBased::BaseValue' has a wrong offset!");
static_assert(offsetof(UTedCommandValueCalculation_PawnTagBased, ValueMods) == 0x000030, "Member 'UTedCommandValueCalculation_PawnTagBased::ValueMods' has a wrong offset!");

// Class Tempest.TedAchCond_HarvesterCashflow
// 0x0000 (0x0058 - 0x0058)
class UTedAchCond_HarvesterCashflow final : public UTedAchievementConditionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAchCond_HarvesterCashflow">();
	}
	static class UTedAchCond_HarvesterCashflow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAchCond_HarvesterCashflow>();
	}
};
static_assert(alignof(UTedAchCond_HarvesterCashflow) == 0x000008, "Wrong alignment on UTedAchCond_HarvesterCashflow");
static_assert(sizeof(UTedAchCond_HarvesterCashflow) == 0x000058, "Wrong size on UTedAchCond_HarvesterCashflow");

// Class Tempest.TedSettingsScreen
// 0x0038 (0x0438 - 0x0400)
class UTedSettingsScreen : public UTedUserWidget
{
public:
	uint8                                         Pad_400[0x8];                                      // 0x0400(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UTedSettingsScreen* InSettingsScreen)> OnGoBack;             // 0x0408(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UScrollBox*                             ScrollBox_Content;                                 // 0x0418(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedContentPanelBase*                   TabsPanel;                                         // 0x0420(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTedSettingsPanel*>              SettingsPanels;                                    // 0x0428(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void GoBack();
	void Hide();
	void K2_OnActivateTabState(class UTedContentPanelBase* InPanel, class UTedContentPanelSlotBase* InSlot, const ETedContentSlotState InState, const bool bInActivated);
	void K2_OnGoBack();
	void OnActivateTabState(class UTedContentPanelBase* InPanel, class UTedContentPanelSlotBase* InSlot, const ETedContentSlotState InState, const bool bInActivated);
	void Show();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSettingsScreen">();
	}
	static class UTedSettingsScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSettingsScreen>();
	}
};
static_assert(alignof(UTedSettingsScreen) == 0x000008, "Wrong alignment on UTedSettingsScreen");
static_assert(sizeof(UTedSettingsScreen) == 0x000438, "Wrong size on UTedSettingsScreen");
static_assert(offsetof(UTedSettingsScreen, OnGoBack) == 0x000408, "Member 'UTedSettingsScreen::OnGoBack' has a wrong offset!");
static_assert(offsetof(UTedSettingsScreen, ScrollBox_Content) == 0x000418, "Member 'UTedSettingsScreen::ScrollBox_Content' has a wrong offset!");
static_assert(offsetof(UTedSettingsScreen, TabsPanel) == 0x000420, "Member 'UTedSettingsScreen::TabsPanel' has a wrong offset!");
static_assert(offsetof(UTedSettingsScreen, SettingsPanels) == 0x000428, "Member 'UTedSettingsScreen::SettingsPanels' has a wrong offset!");

// Class Tempest.TedAchCond_MultiMissionBitmask
// 0x0010 (0x0068 - 0x0058)
class UTedAchCond_MultiMissionBitmask final : public UTedAchievementConditionBase
{
public:
	TArray<struct FTedMissionFinishReq>           Missions;                                          // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAchCond_MultiMissionBitmask">();
	}
	static class UTedAchCond_MultiMissionBitmask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAchCond_MultiMissionBitmask>();
	}
};
static_assert(alignof(UTedAchCond_MultiMissionBitmask) == 0x000008, "Wrong alignment on UTedAchCond_MultiMissionBitmask");
static_assert(sizeof(UTedAchCond_MultiMissionBitmask) == 0x000068, "Wrong size on UTedAchCond_MultiMissionBitmask");
static_assert(offsetof(UTedAchCond_MultiMissionBitmask, Missions) == 0x000058, "Member 'UTedAchCond_MultiMissionBitmask::Missions' has a wrong offset!");

// Class Tempest.TedCommandPreview_Ram
// 0x0038 (0x03A0 - 0x0368)
class ATedCommandPreview_Ram : public AGameplayCommandPreviewActor
{
public:
	class UNiagaraComponent*                      MoveFX;                                            // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      DirectionalBeamFX;                                 // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecalRadiusScale;                                  // 0x0378(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_37C[0x4];                                      // 0x037C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     DecalMaterial;                                     // 0x0380(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DirectionBeamStartParamName;                       // 0x0388(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DirectionBeamEndParamName;                         // 0x0390(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDecalComponent*                        DecalComponent;                                    // 0x0398(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandPreview_Ram">();
	}
	static class ATedCommandPreview_Ram* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedCommandPreview_Ram>();
	}
};
static_assert(alignof(ATedCommandPreview_Ram) == 0x000008, "Wrong alignment on ATedCommandPreview_Ram");
static_assert(sizeof(ATedCommandPreview_Ram) == 0x0003A0, "Wrong size on ATedCommandPreview_Ram");
static_assert(offsetof(ATedCommandPreview_Ram, MoveFX) == 0x000368, "Member 'ATedCommandPreview_Ram::MoveFX' has a wrong offset!");
static_assert(offsetof(ATedCommandPreview_Ram, DirectionalBeamFX) == 0x000370, "Member 'ATedCommandPreview_Ram::DirectionalBeamFX' has a wrong offset!");
static_assert(offsetof(ATedCommandPreview_Ram, DecalRadiusScale) == 0x000378, "Member 'ATedCommandPreview_Ram::DecalRadiusScale' has a wrong offset!");
static_assert(offsetof(ATedCommandPreview_Ram, DecalMaterial) == 0x000380, "Member 'ATedCommandPreview_Ram::DecalMaterial' has a wrong offset!");
static_assert(offsetof(ATedCommandPreview_Ram, DirectionBeamStartParamName) == 0x000388, "Member 'ATedCommandPreview_Ram::DirectionBeamStartParamName' has a wrong offset!");
static_assert(offsetof(ATedCommandPreview_Ram, DirectionBeamEndParamName) == 0x000390, "Member 'ATedCommandPreview_Ram::DirectionBeamEndParamName' has a wrong offset!");
static_assert(offsetof(ATedCommandPreview_Ram, DecalComponent) == 0x000398, "Member 'ATedCommandPreview_Ram::DecalComponent' has a wrong offset!");

// Class Tempest.TedAchCond_OnCommandExecuted
// 0x0068 (0x00C0 - 0x0058)
class UTedAchCond_OnCommandExecuted final : public UTedAchievementConditionBase
{
public:
	TArray<TSubclassOf<class UGameplayCommand>>   RequiredCommands;                                  // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bIncludeSuperClasses;                              // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  RequiredTags;                                      // 0x0070(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EOnTedCommandExecutedRule                     CommandExecutedRule;                               // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  CommandActorDefinitionIDs;                         // 0x0098(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         ValueIncrease;                                     // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncreaseValueByUnitCount;                         // 0x00BC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAchCond_OnCommandExecuted">();
	}
	static class UTedAchCond_OnCommandExecuted* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAchCond_OnCommandExecuted>();
	}
};
static_assert(alignof(UTedAchCond_OnCommandExecuted) == 0x000008, "Wrong alignment on UTedAchCond_OnCommandExecuted");
static_assert(sizeof(UTedAchCond_OnCommandExecuted) == 0x0000C0, "Wrong size on UTedAchCond_OnCommandExecuted");
static_assert(offsetof(UTedAchCond_OnCommandExecuted, RequiredCommands) == 0x000058, "Member 'UTedAchCond_OnCommandExecuted::RequiredCommands' has a wrong offset!");
static_assert(offsetof(UTedAchCond_OnCommandExecuted, bIncludeSuperClasses) == 0x000068, "Member 'UTedAchCond_OnCommandExecuted::bIncludeSuperClasses' has a wrong offset!");
static_assert(offsetof(UTedAchCond_OnCommandExecuted, RequiredTags) == 0x000070, "Member 'UTedAchCond_OnCommandExecuted::RequiredTags' has a wrong offset!");
static_assert(offsetof(UTedAchCond_OnCommandExecuted, CommandExecutedRule) == 0x000090, "Member 'UTedAchCond_OnCommandExecuted::CommandExecutedRule' has a wrong offset!");
static_assert(offsetof(UTedAchCond_OnCommandExecuted, CommandActorDefinitionIDs) == 0x000098, "Member 'UTedAchCond_OnCommandExecuted::CommandActorDefinitionIDs' has a wrong offset!");
static_assert(offsetof(UTedAchCond_OnCommandExecuted, ValueIncrease) == 0x0000B8, "Member 'UTedAchCond_OnCommandExecuted::ValueIncrease' has a wrong offset!");
static_assert(offsetof(UTedAchCond_OnCommandExecuted, bIncreaseValueByUnitCount) == 0x0000BC, "Member 'UTedAchCond_OnCommandExecuted::bIncreaseValueByUnitCount' has a wrong offset!");

// Class Tempest.TedAchCond_OnEntityConstructed
// 0x0028 (0x0080 - 0x0058)
class UTedAchCond_OnEntityConstructed final : public UTedAchievementConditionBase
{
public:
	struct FGameplayTagContainer                  RequiredTags;                                      // 0x0058(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bUseConstructionCount;                             // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAchCond_OnEntityConstructed">();
	}
	static class UTedAchCond_OnEntityConstructed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAchCond_OnEntityConstructed>();
	}
};
static_assert(alignof(UTedAchCond_OnEntityConstructed) == 0x000008, "Wrong alignment on UTedAchCond_OnEntityConstructed");
static_assert(sizeof(UTedAchCond_OnEntityConstructed) == 0x000080, "Wrong size on UTedAchCond_OnEntityConstructed");
static_assert(offsetof(UTedAchCond_OnEntityConstructed, RequiredTags) == 0x000058, "Member 'UTedAchCond_OnEntityConstructed::RequiredTags' has a wrong offset!");
static_assert(offsetof(UTedAchCond_OnEntityConstructed, bUseConstructionCount) == 0x000078, "Member 'UTedAchCond_OnEntityConstructed::bUseConstructionCount' has a wrong offset!");

// Class Tempest.TedAchCond_OnGameplayEffectStackChanged
// 0x0058 (0x00B0 - 0x0058)
class UTedAchCond_OnGameplayEffectStackChanged final : public UTedAchievementConditionBase
{
public:
	TMap<TSubclassOf<class UGameplayEffect>, int32> RequiredEffects;                                 // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bRequireAll;                                       // 0x00A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAchCond_OnGameplayEffectStackChanged">();
	}
	static class UTedAchCond_OnGameplayEffectStackChanged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAchCond_OnGameplayEffectStackChanged>();
	}
};
static_assert(alignof(UTedAchCond_OnGameplayEffectStackChanged) == 0x000008, "Wrong alignment on UTedAchCond_OnGameplayEffectStackChanged");
static_assert(sizeof(UTedAchCond_OnGameplayEffectStackChanged) == 0x0000B0, "Wrong size on UTedAchCond_OnGameplayEffectStackChanged");
static_assert(offsetof(UTedAchCond_OnGameplayEffectStackChanged, RequiredEffects) == 0x000058, "Member 'UTedAchCond_OnGameplayEffectStackChanged::RequiredEffects' has a wrong offset!");
static_assert(offsetof(UTedAchCond_OnGameplayEffectStackChanged, bRequireAll) == 0x0000A8, "Member 'UTedAchCond_OnGameplayEffectStackChanged::bRequireAll' has a wrong offset!");

// Class Tempest.TedUnitCommand_EnterExitRefinery
// 0x0000 (0x0540 - 0x0540)
class UTedUnitCommand_EnterExitRefinery final : public UTedUnitCommand_MoveAlongSpline
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitCommand_EnterExitRefinery">();
	}
	static class UTedUnitCommand_EnterExitRefinery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUnitCommand_EnterExitRefinery>();
	}
};
static_assert(alignof(UTedUnitCommand_EnterExitRefinery) == 0x000008, "Wrong alignment on UTedUnitCommand_EnterExitRefinery");
static_assert(sizeof(UTedUnitCommand_EnterExitRefinery) == 0x000540, "Wrong size on UTedUnitCommand_EnterExitRefinery");

// Class Tempest.TedAchCond_OnIntelMarked
// 0x0010 (0x0068 - 0x0058)
class UTedAchCond_OnIntelMarked final : public UTedAchievementConditionBase
{
public:
	TArray<class FString>                         MarkedPawns;                                       // 0x0058(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAchCond_OnIntelMarked">();
	}
	static class UTedAchCond_OnIntelMarked* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAchCond_OnIntelMarked>();
	}
};
static_assert(alignof(UTedAchCond_OnIntelMarked) == 0x000008, "Wrong alignment on UTedAchCond_OnIntelMarked");
static_assert(sizeof(UTedAchCond_OnIntelMarked) == 0x000068, "Wrong size on UTedAchCond_OnIntelMarked");
static_assert(offsetof(UTedAchCond_OnIntelMarked, MarkedPawns) == 0x000058, "Member 'UTedAchCond_OnIntelMarked::MarkedPawns' has a wrong offset!");

// Class Tempest.TedCommandsTooltipDisplay
// 0x0068 (0x04F8 - 0x0490)
class UTedCommandsTooltipDisplay : public UTedRequirementsTooltipDisplay
{
public:
	TMulticastInlineDelegate<void()>              OnContentIsEmpty;                                  // 0x0490(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	class UWidget*                                TargetWidget;                                      // 0x04A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class ATedPawn*>                         ContextPawns;                                      // 0x04A8(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)

public:
	void OnRefreshRequirements(const TArray<class FText>& InNotOwnedRequirements, const TArray<class FText>& InOwnedRequirements);

	class FText GetAltShortcutText_Hint() const;
	ESlateVisibility GetAltShortcutVisibility_HasAutoCast() const;
	const class UTedCommand* GetCommandCDO() const;
	const class UTedCommandsPanel* GetCommandsPanel() const;
	class FText GetCostText_Credits() const;
	class FText GetCostText_Intel() const;
	class FText GetCostText_Population() const;
	class FText GetCostText_Power() const;
	class FText GetCostText_Time() const;
	int32 GetCostValue_Credits() const;
	int32 GetCostValue_Intel() const;
	float GetCostValue_Time() const;
	ESlateVisibility GetCostVisibility_Credits() const;
	ESlateVisibility GetCostVisibility_Intel() const;
	ESlateVisibility GetCostVisibility_Population() const;
	ESlateVisibility GetCostVisibility_Power() const;
	ESlateVisibility GetCostVisibility_Time() const;
	class FText GetDescription() const;
	class FText GetDisplayName() const;
	class UTexture2D* GetIcon() const;
	bool GetIssueValue_AbilityBlocked() const;
	bool GetIssueValue_DisabledInfo() const;
	bool GetIssueValue_LowPower() const;
	bool GetIssueValue_MissingPlayerTags() const;
	bool GetIssueValue_PopulationFull() const;
	ESlateVisibility GetIssueVisibility_AbilityBlocked() const;
	ESlateVisibility GetIssueVisibility_DisabledInfo() const;
	ESlateVisibility GetIssueVisibility_InsufficientCredits() const;
	ESlateVisibility GetIssueVisibility_InsufficientIntel() const;
	ESlateVisibility GetIssueVisibility_LowPower() const;
	ESlateVisibility GetIssueVisibility_MissingPlayerTags() const;
	ESlateVisibility GetIssueVisibility_PopulationFull() const;
	int32 GetPopulationCost() const;
	int32 GetPowerCost() const;
	class FText GetShortcutText() const;
	const class FText GetValue_DisabledInfo() const;
	bool HasPlayerInsufficientCredits() const;
	bool HasPlayerInsufficientIntel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandsTooltipDisplay">();
	}
	static class UTedCommandsTooltipDisplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCommandsTooltipDisplay>();
	}
};
static_assert(alignof(UTedCommandsTooltipDisplay) == 0x000008, "Wrong alignment on UTedCommandsTooltipDisplay");
static_assert(sizeof(UTedCommandsTooltipDisplay) == 0x0004F8, "Wrong size on UTedCommandsTooltipDisplay");
static_assert(offsetof(UTedCommandsTooltipDisplay, OnContentIsEmpty) == 0x000490, "Member 'UTedCommandsTooltipDisplay::OnContentIsEmpty' has a wrong offset!");
static_assert(offsetof(UTedCommandsTooltipDisplay, TargetWidget) == 0x0004A0, "Member 'UTedCommandsTooltipDisplay::TargetWidget' has a wrong offset!");
static_assert(offsetof(UTedCommandsTooltipDisplay, ContextPawns) == 0x0004A8, "Member 'UTedCommandsTooltipDisplay::ContextPawns' has a wrong offset!");

// Class Tempest.TedAchCond_OnTagGranted
// 0x00F0 (0x0148 - 0x0058)
class UTedAchCond_OnTagGranted final : public UTedAchievementConditionBase
{
public:
	struct FGameplayTagContainer                  RequiredTags;                                      // 0x0058(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bOnlyOwningPawns;                                  // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAISenseAffiliationFilter              AttitudeFilter;                                    // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class ATedPawn>                   ClassFilter;                                       // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AllowedDefinitions;                                // 0x0088(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ExtraTags;                                         // 0x00A8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bExtraTagsRequireAll;                              // 0x00C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBannedTagsRequireAll;                             // 0x00C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA[0x6];                                       // 0x00CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  BannedTags;                                        // 0x00D0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bFilterDomain;                                     // 0x00F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  Domain;                                            // 0x00F8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bFilterWeapon;                                     // 0x0118(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UTedWeapon>>         RequiredWeapon;                                    // 0x0120(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bUniquePawns;                                      // 0x0130(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         MarkedPawns;                                       // 0x0138(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAchCond_OnTagGranted">();
	}
	static class UTedAchCond_OnTagGranted* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAchCond_OnTagGranted>();
	}
};
static_assert(alignof(UTedAchCond_OnTagGranted) == 0x000008, "Wrong alignment on UTedAchCond_OnTagGranted");
static_assert(sizeof(UTedAchCond_OnTagGranted) == 0x000148, "Wrong size on UTedAchCond_OnTagGranted");
static_assert(offsetof(UTedAchCond_OnTagGranted, RequiredTags) == 0x000058, "Member 'UTedAchCond_OnTagGranted::RequiredTags' has a wrong offset!");
static_assert(offsetof(UTedAchCond_OnTagGranted, bOnlyOwningPawns) == 0x000078, "Member 'UTedAchCond_OnTagGranted::bOnlyOwningPawns' has a wrong offset!");
static_assert(offsetof(UTedAchCond_OnTagGranted, AttitudeFilter) == 0x00007C, "Member 'UTedAchCond_OnTagGranted::AttitudeFilter' has a wrong offset!");
static_assert(offsetof(UTedAchCond_OnTagGranted, ClassFilter) == 0x000080, "Member 'UTedAchCond_OnTagGranted::ClassFilter' has a wrong offset!");
static_assert(offsetof(UTedAchCond_OnTagGranted, AllowedDefinitions) == 0x000088, "Member 'UTedAchCond_OnTagGranted::AllowedDefinitions' has a wrong offset!");
static_assert(offsetof(UTedAchCond_OnTagGranted, ExtraTags) == 0x0000A8, "Member 'UTedAchCond_OnTagGranted::ExtraTags' has a wrong offset!");
static_assert(offsetof(UTedAchCond_OnTagGranted, bExtraTagsRequireAll) == 0x0000C8, "Member 'UTedAchCond_OnTagGranted::bExtraTagsRequireAll' has a wrong offset!");
static_assert(offsetof(UTedAchCond_OnTagGranted, bBannedTagsRequireAll) == 0x0000C9, "Member 'UTedAchCond_OnTagGranted::bBannedTagsRequireAll' has a wrong offset!");
static_assert(offsetof(UTedAchCond_OnTagGranted, BannedTags) == 0x0000D0, "Member 'UTedAchCond_OnTagGranted::BannedTags' has a wrong offset!");
static_assert(offsetof(UTedAchCond_OnTagGranted, bFilterDomain) == 0x0000F0, "Member 'UTedAchCond_OnTagGranted::bFilterDomain' has a wrong offset!");
static_assert(offsetof(UTedAchCond_OnTagGranted, Domain) == 0x0000F8, "Member 'UTedAchCond_OnTagGranted::Domain' has a wrong offset!");
static_assert(offsetof(UTedAchCond_OnTagGranted, bFilterWeapon) == 0x000118, "Member 'UTedAchCond_OnTagGranted::bFilterWeapon' has a wrong offset!");
static_assert(offsetof(UTedAchCond_OnTagGranted, RequiredWeapon) == 0x000120, "Member 'UTedAchCond_OnTagGranted::RequiredWeapon' has a wrong offset!");
static_assert(offsetof(UTedAchCond_OnTagGranted, bUniquePawns) == 0x000130, "Member 'UTedAchCond_OnTagGranted::bUniquePawns' has a wrong offset!");
static_assert(offsetof(UTedAchCond_OnTagGranted, MarkedPawns) == 0x000138, "Member 'UTedAchCond_OnTagGranted::MarkedPawns' has a wrong offset!");

// Class Tempest.TedAchCond_PawnDied
// 0x0178 (0x01D0 - 0x0058)
class UTedAchCond_PawnDied final : public UTedAchievementConditionBase
{
public:
	TSubclassOf<class ATedPawn>                   VictimClassFilter;                                 // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVictimIsOwnedUnit;                                // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  VictimAllowedDefinitions;                          // 0x0068(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  VictimExtraTags;                                   // 0x0088(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bVictimExtraTagsRequireAll;                        // 0x00A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVictimBannedTagsRequireAll;                       // 0x00A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  VictimBannedTags;                                  // 0x00B0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bFilterVictimDomain;                               // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequireContainerFilledWithUnits;                  // 0x00D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D2[0x6];                                       // 0x00D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  VictimDomain;                                      // 0x00D8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                DamageTypeFilter;                                  // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowFriendlyFire;                                // 0x0100(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFilterKiller;                                     // 0x0101(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKillerIsOwnedUnit;                                // 0x0102(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_103[0x5];                                      // 0x0103(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ATedPawn>                   KillerClassFilter;                                 // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  KillerAllowedDefinitions;                          // 0x0110(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  KillerExtraTags;                                   // 0x0130(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bKillerExtraTagsRequireAll;                        // 0x0150(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  KillerBannedTags;                                  // 0x0158(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bKillerBannedTagsRequireAll;                       // 0x0178(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFilterKillerDomain;                               // 0x0179(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17A[0x6];                                      // 0x017A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  KillerDomain;                                      // 0x0180(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bFilterKillerWeapon;                               // 0x01A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UTedWeapon>>         KillerWeapon;                                      // 0x01A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bFilterKillerPassiveWeaponAbilities;               // 0x01B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B9[0x7];                                      // 0x01B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTedPassiveAbilityDefinitionAsset*> PassiveWeaponAbilities;                         // 0x01C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAchCond_PawnDied">();
	}
	static class UTedAchCond_PawnDied* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAchCond_PawnDied>();
	}
};
static_assert(alignof(UTedAchCond_PawnDied) == 0x000008, "Wrong alignment on UTedAchCond_PawnDied");
static_assert(sizeof(UTedAchCond_PawnDied) == 0x0001D0, "Wrong size on UTedAchCond_PawnDied");
static_assert(offsetof(UTedAchCond_PawnDied, VictimClassFilter) == 0x000058, "Member 'UTedAchCond_PawnDied::VictimClassFilter' has a wrong offset!");
static_assert(offsetof(UTedAchCond_PawnDied, bVictimIsOwnedUnit) == 0x000060, "Member 'UTedAchCond_PawnDied::bVictimIsOwnedUnit' has a wrong offset!");
static_assert(offsetof(UTedAchCond_PawnDied, VictimAllowedDefinitions) == 0x000068, "Member 'UTedAchCond_PawnDied::VictimAllowedDefinitions' has a wrong offset!");
static_assert(offsetof(UTedAchCond_PawnDied, VictimExtraTags) == 0x000088, "Member 'UTedAchCond_PawnDied::VictimExtraTags' has a wrong offset!");
static_assert(offsetof(UTedAchCond_PawnDied, bVictimExtraTagsRequireAll) == 0x0000A8, "Member 'UTedAchCond_PawnDied::bVictimExtraTagsRequireAll' has a wrong offset!");
static_assert(offsetof(UTedAchCond_PawnDied, bVictimBannedTagsRequireAll) == 0x0000A9, "Member 'UTedAchCond_PawnDied::bVictimBannedTagsRequireAll' has a wrong offset!");
static_assert(offsetof(UTedAchCond_PawnDied, VictimBannedTags) == 0x0000B0, "Member 'UTedAchCond_PawnDied::VictimBannedTags' has a wrong offset!");
static_assert(offsetof(UTedAchCond_PawnDied, bFilterVictimDomain) == 0x0000D0, "Member 'UTedAchCond_PawnDied::bFilterVictimDomain' has a wrong offset!");
static_assert(offsetof(UTedAchCond_PawnDied, bRequireContainerFilledWithUnits) == 0x0000D1, "Member 'UTedAchCond_PawnDied::bRequireContainerFilledWithUnits' has a wrong offset!");
static_assert(offsetof(UTedAchCond_PawnDied, VictimDomain) == 0x0000D8, "Member 'UTedAchCond_PawnDied::VictimDomain' has a wrong offset!");
static_assert(offsetof(UTedAchCond_PawnDied, DamageTypeFilter) == 0x0000F8, "Member 'UTedAchCond_PawnDied::DamageTypeFilter' has a wrong offset!");
static_assert(offsetof(UTedAchCond_PawnDied, bAllowFriendlyFire) == 0x000100, "Member 'UTedAchCond_PawnDied::bAllowFriendlyFire' has a wrong offset!");
static_assert(offsetof(UTedAchCond_PawnDied, bFilterKiller) == 0x000101, "Member 'UTedAchCond_PawnDied::bFilterKiller' has a wrong offset!");
static_assert(offsetof(UTedAchCond_PawnDied, bKillerIsOwnedUnit) == 0x000102, "Member 'UTedAchCond_PawnDied::bKillerIsOwnedUnit' has a wrong offset!");
static_assert(offsetof(UTedAchCond_PawnDied, KillerClassFilter) == 0x000108, "Member 'UTedAchCond_PawnDied::KillerClassFilter' has a wrong offset!");
static_assert(offsetof(UTedAchCond_PawnDied, KillerAllowedDefinitions) == 0x000110, "Member 'UTedAchCond_PawnDied::KillerAllowedDefinitions' has a wrong offset!");
static_assert(offsetof(UTedAchCond_PawnDied, KillerExtraTags) == 0x000130, "Member 'UTedAchCond_PawnDied::KillerExtraTags' has a wrong offset!");
static_assert(offsetof(UTedAchCond_PawnDied, bKillerExtraTagsRequireAll) == 0x000150, "Member 'UTedAchCond_PawnDied::bKillerExtraTagsRequireAll' has a wrong offset!");
static_assert(offsetof(UTedAchCond_PawnDied, KillerBannedTags) == 0x000158, "Member 'UTedAchCond_PawnDied::KillerBannedTags' has a wrong offset!");
static_assert(offsetof(UTedAchCond_PawnDied, bKillerBannedTagsRequireAll) == 0x000178, "Member 'UTedAchCond_PawnDied::bKillerBannedTagsRequireAll' has a wrong offset!");
static_assert(offsetof(UTedAchCond_PawnDied, bFilterKillerDomain) == 0x000179, "Member 'UTedAchCond_PawnDied::bFilterKillerDomain' has a wrong offset!");
static_assert(offsetof(UTedAchCond_PawnDied, KillerDomain) == 0x000180, "Member 'UTedAchCond_PawnDied::KillerDomain' has a wrong offset!");
static_assert(offsetof(UTedAchCond_PawnDied, bFilterKillerWeapon) == 0x0001A0, "Member 'UTedAchCond_PawnDied::bFilterKillerWeapon' has a wrong offset!");
static_assert(offsetof(UTedAchCond_PawnDied, KillerWeapon) == 0x0001A8, "Member 'UTedAchCond_PawnDied::KillerWeapon' has a wrong offset!");
static_assert(offsetof(UTedAchCond_PawnDied, bFilterKillerPassiveWeaponAbilities) == 0x0001B8, "Member 'UTedAchCond_PawnDied::bFilterKillerPassiveWeaponAbilities' has a wrong offset!");
static_assert(offsetof(UTedAchCond_PawnDied, PassiveWeaponAbilities) == 0x0001C0, "Member 'UTedAchCond_PawnDied::PassiveWeaponAbilities' has a wrong offset!");

// Class Tempest.TedPopup
// 0x0088 (0x0488 - 0x0400)
class UTedPopup : public UTedUserWidget
{
public:
	class UTedUserWidget*                         Text_Header_Glow;                                  // 0x0400(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                HeaderTextWidget;                                  // 0x0408(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Body;                                         // 0x0410(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                BodyTextWidget;                                    // 0x0418(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Error;                                        // 0x0420(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                ErrorTextWidget;                                   // 0x0428(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedPopupButtonsPanel*                  ButtonsPanel;                                      // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedEditableTextBox*                    TextBox;                                           // 0x0438(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedDropDown*                           DropDown;                                          // 0x0440(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_DropDownTitle;                                // 0x0448(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                DropDownTitleTextWidget;                           // 0x0450(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                Image_Working;                                     // 0x0458(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                Image_BackgroundTint;                              // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                Blur_Background;                                   // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedPopupContext*                       Context;                                           // 0x0470(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   Identifier;                                        // 0x0478(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETedPopupGoBackBehavior                       GoBackBehavior;                                    // 0x0480(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_481[0x7];                                      // 0x0481(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanHide();
	void CollapseAllSpacerWidgets();
	void HideError();
	void K2_OnErrorShown(const class FText& ErrorMessage);
	void K2_OnHide();
	void K2_OnShow();
	void SetIdentifier(class FName InIdentifier);
	void ShowError(const class FText& ErrorMessage);

	const class FText GetBodyText() const;
	const class FText GetDropDownTitleText() const;
	const class FText GetHeaderText() const;
	class FName GetIdentifier() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPopup">();
	}
	static class UTedPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPopup>();
	}
};
static_assert(alignof(UTedPopup) == 0x000008, "Wrong alignment on UTedPopup");
static_assert(sizeof(UTedPopup) == 0x000488, "Wrong size on UTedPopup");
static_assert(offsetof(UTedPopup, Text_Header_Glow) == 0x000400, "Member 'UTedPopup::Text_Header_Glow' has a wrong offset!");
static_assert(offsetof(UTedPopup, HeaderTextWidget) == 0x000408, "Member 'UTedPopup::HeaderTextWidget' has a wrong offset!");
static_assert(offsetof(UTedPopup, Text_Body) == 0x000410, "Member 'UTedPopup::Text_Body' has a wrong offset!");
static_assert(offsetof(UTedPopup, BodyTextWidget) == 0x000418, "Member 'UTedPopup::BodyTextWidget' has a wrong offset!");
static_assert(offsetof(UTedPopup, Text_Error) == 0x000420, "Member 'UTedPopup::Text_Error' has a wrong offset!");
static_assert(offsetof(UTedPopup, ErrorTextWidget) == 0x000428, "Member 'UTedPopup::ErrorTextWidget' has a wrong offset!");
static_assert(offsetof(UTedPopup, ButtonsPanel) == 0x000430, "Member 'UTedPopup::ButtonsPanel' has a wrong offset!");
static_assert(offsetof(UTedPopup, TextBox) == 0x000438, "Member 'UTedPopup::TextBox' has a wrong offset!");
static_assert(offsetof(UTedPopup, DropDown) == 0x000440, "Member 'UTedPopup::DropDown' has a wrong offset!");
static_assert(offsetof(UTedPopup, Text_DropDownTitle) == 0x000448, "Member 'UTedPopup::Text_DropDownTitle' has a wrong offset!");
static_assert(offsetof(UTedPopup, DropDownTitleTextWidget) == 0x000450, "Member 'UTedPopup::DropDownTitleTextWidget' has a wrong offset!");
static_assert(offsetof(UTedPopup, Image_Working) == 0x000458, "Member 'UTedPopup::Image_Working' has a wrong offset!");
static_assert(offsetof(UTedPopup, Image_BackgroundTint) == 0x000460, "Member 'UTedPopup::Image_BackgroundTint' has a wrong offset!");
static_assert(offsetof(UTedPopup, Blur_Background) == 0x000468, "Member 'UTedPopup::Blur_Background' has a wrong offset!");
static_assert(offsetof(UTedPopup, Context) == 0x000470, "Member 'UTedPopup::Context' has a wrong offset!");
static_assert(offsetof(UTedPopup, Identifier) == 0x000478, "Member 'UTedPopup::Identifier' has a wrong offset!");
static_assert(offsetof(UTedPopup, GoBackBehavior) == 0x000480, "Member 'UTedPopup::GoBackBehavior' has a wrong offset!");

// Class Tempest.TedConformationBase
// 0x0100 (0x1B00 - 0x1A00)
class ATedConformationBase : public ATedStructureBase
{
public:
	class UBoxComponent*                          HitBox;                                            // 0x19F8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          CollapsedArea;                                     // 0x1A00(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   DestroyedMesh;                                     // 0x1A08(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNavModifierComponent*                  NavAreaModifier;                                   // 0x1A10(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHidePawnsWhenDestroyed;                           // 0x1A18(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseCollapsedAreaForPawnDetection;                 // 0x1A19(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A1A[0x6];                                     // 0x1A1A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FConformationStateData>         AvailableStates;                                   // 0x1A20(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, float>              InitStatesValues;                                  // 0x1A30(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<struct FConformationStateData>         CurrentStates;                                     // 0x1A80(0x0010)(Net, ZeroConstructor, Transient, DuplicateTransient, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         bChangeOwnerOnStateChange : 1;                     // 0x1A90(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1A91[0x7];                                     // 0x1A91(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, float>              OwnerChangeStates;                                 // 0x1A98(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 LastFrameStateValues;                              // 0x1AE8(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	uint8                                         bDestroyOverlappingUnitsUponDeath : 1;             // 0x1AF8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsPlayerSelectable : 1;                           // 0x1AF8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsPlayerHoverable : 1;                            // 0x1AF8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsSelectableWhenDestroyed : 1;                    // 0x1AF8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	bool                                          bDied;                                             // 0x1AF9(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1AFA[0x6];                                     // 0x1AFA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeState(class AActor* InInstigator, const struct FGameplayTag& InState, const float InValue, const float InDelay);
	void HidePreview();
	void K2_ChangeState(class AActor* InInstigator, const struct FGameplayTag& InState, const float InValue, const float InDelay);
	void K2_RequestChangeState(class AActor* InInstigator, const struct FGameplayTag& InState, const float InValue);
	void K2_ShowPreview(const class AActor* InInstigator, const struct FGameplayTag& InState, const float InValue);
	void OnRep_CurrentStates();
	void OnRequestChangeState(class AActor* InInstigator, const struct FGameplayTag& InState, const float InValue);
	void OnStateChangeCosmetic(const struct FGameplayTag& InState, const float InValue);
	bool RequestChangeState(class AActor* InInstigator, const struct FGameplayTag& InState, const float InValue);
	void SetDestroyedMeshOnVisibilityChange();
	void ShowPreview(const class AActor* InInstigator, const struct FGameplayTag& InState, const float InValue);

	bool CanChangeState(const class AActor* InInstigator, const struct FGameplayTag& InState, const float InValue) const;
	class UStreamableRenderAsset* GetConformationPreviewMesh(struct FTransform* Offset) const;
	void GetLocationsForActivator(TArray<struct FVector>* OutLocations) const;
	class UNavModifierComponent* GetNavAreaModifier() const;
	bool GetStateCurve(const struct FGameplayTag& InState, struct FRepCurve_Float* OutData) const;
	float GetStateValue(const struct FGameplayTag& InState) const;
	bool HasBegunPlay() const;
	bool IsStateChangeInProgress(const struct FGameplayTag& InState) const;
	bool IsStateSupported(const struct FGameplayTag& InState) const;
	bool K2_CanChangeState(const class AActor* InInstigator, const struct FGameplayTag& InState, const float InValue) const;
	bool K2_GetStateCurve(const struct FGameplayTag& InState, struct FRepCurve_Float* OutData) const;
	float K2_GetStateValue(const struct FGameplayTag& InState) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedConformationBase">();
	}
	static class ATedConformationBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedConformationBase>();
	}
};
static_assert(alignof(ATedConformationBase) == 0x000010, "Wrong alignment on ATedConformationBase");
static_assert(sizeof(ATedConformationBase) == 0x001B00, "Wrong size on ATedConformationBase");
static_assert(offsetof(ATedConformationBase, HitBox) == 0x0019F8, "Member 'ATedConformationBase::HitBox' has a wrong offset!");
static_assert(offsetof(ATedConformationBase, CollapsedArea) == 0x001A00, "Member 'ATedConformationBase::CollapsedArea' has a wrong offset!");
static_assert(offsetof(ATedConformationBase, DestroyedMesh) == 0x001A08, "Member 'ATedConformationBase::DestroyedMesh' has a wrong offset!");
static_assert(offsetof(ATedConformationBase, NavAreaModifier) == 0x001A10, "Member 'ATedConformationBase::NavAreaModifier' has a wrong offset!");
static_assert(offsetof(ATedConformationBase, bHidePawnsWhenDestroyed) == 0x001A18, "Member 'ATedConformationBase::bHidePawnsWhenDestroyed' has a wrong offset!");
static_assert(offsetof(ATedConformationBase, bUseCollapsedAreaForPawnDetection) == 0x001A19, "Member 'ATedConformationBase::bUseCollapsedAreaForPawnDetection' has a wrong offset!");
static_assert(offsetof(ATedConformationBase, AvailableStates) == 0x001A20, "Member 'ATedConformationBase::AvailableStates' has a wrong offset!");
static_assert(offsetof(ATedConformationBase, InitStatesValues) == 0x001A30, "Member 'ATedConformationBase::InitStatesValues' has a wrong offset!");
static_assert(offsetof(ATedConformationBase, CurrentStates) == 0x001A80, "Member 'ATedConformationBase::CurrentStates' has a wrong offset!");
static_assert(offsetof(ATedConformationBase, OwnerChangeStates) == 0x001A98, "Member 'ATedConformationBase::OwnerChangeStates' has a wrong offset!");
static_assert(offsetof(ATedConformationBase, LastFrameStateValues) == 0x001AE8, "Member 'ATedConformationBase::LastFrameStateValues' has a wrong offset!");
static_assert(offsetof(ATedConformationBase, bDied) == 0x001AF9, "Member 'ATedConformationBase::bDied' has a wrong offset!");

// Class Tempest.TedAchCond_StealthUnitChangedState
// 0x0018 (0x0070 - 0x0058)
class UTedAchCond_StealthUnitChangedState final : public UTedAchievementConditionBase
{
public:
	int32                                         MinUnits;                                          // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         UnitsInStealth;                                    // 0x0060(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAchCond_StealthUnitChangedState">();
	}
	static class UTedAchCond_StealthUnitChangedState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAchCond_StealthUnitChangedState>();
	}
};
static_assert(alignof(UTedAchCond_StealthUnitChangedState) == 0x000008, "Wrong alignment on UTedAchCond_StealthUnitChangedState");
static_assert(sizeof(UTedAchCond_StealthUnitChangedState) == 0x000070, "Wrong size on UTedAchCond_StealthUnitChangedState");
static_assert(offsetof(UTedAchCond_StealthUnitChangedState, MinUnits) == 0x000058, "Member 'UTedAchCond_StealthUnitChangedState::MinUnits' has a wrong offset!");
static_assert(offsetof(UTedAchCond_StealthUnitChangedState, UnitsInStealth) == 0x000060, "Member 'UTedAchCond_StealthUnitChangedState::UnitsInStealth' has a wrong offset!");

// Class Tempest.TedUnitCommand_HarvestResource
// 0x0008 (0x0578 - 0x0570)
class UTedUnitCommand_HarvestResource : public UTedPawnCommandWithBehavior
{
public:
	bool                                          bAllowRefineryAsTarget;                            // 0x0570(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_571[0x7];                                      // 0x0571(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitCommand_HarvestResource">();
	}
	static class UTedUnitCommand_HarvestResource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUnitCommand_HarvestResource>();
	}
};
static_assert(alignof(UTedUnitCommand_HarvestResource) == 0x000008, "Wrong alignment on UTedUnitCommand_HarvestResource");
static_assert(sizeof(UTedUnitCommand_HarvestResource) == 0x000578, "Wrong size on UTedUnitCommand_HarvestResource");
static_assert(offsetof(UTedUnitCommand_HarvestResource, bAllowRefineryAsTarget) == 0x000570, "Member 'UTedUnitCommand_HarvestResource::bAllowRefineryAsTarget' has a wrong offset!");

// Class Tempest.TedAchCond_StructureCaptured
// 0x0000 (0x0058 - 0x0058)
class UTedAchCond_StructureCaptured final : public UTedAchievementConditionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAchCond_StructureCaptured">();
	}
	static class UTedAchCond_StructureCaptured* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAchCond_StructureCaptured>();
	}
};
static_assert(alignof(UTedAchCond_StructureCaptured) == 0x000008, "Wrong alignment on UTedAchCond_StructureCaptured");
static_assert(sizeof(UTedAchCond_StructureCaptured) == 0x000058, "Wrong size on UTedAchCond_StructureCaptured");

// Class Tempest.TedCommandVisualActor
// 0x00C0 (0x0350 - 0x0290)
class ATedCommandVisualActor : public AActor
{
public:
	uint8                                         Pad_290[0x20];                                     // 0x0290(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedVisibility                         Visibility;                                        // 0x02B0(0x0038)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	float                                         FogOfWarAgentRadiusMultiplier;                     // 0x02E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RevealRadius;                                      // 0x02EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VisionRadius;                                      // 0x02F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bVisibleOnlyToOwnedTeam;                           // 0x02F4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F5[0x3];                                      // 0x02F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExtraTimeKeepAlive;                                // 0x02F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayCommandData                   CachedCommandData;                                 // 0x0300(0x0048)(Net, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           DestroyActorDelayed_Handle;                        // 0x0348(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DestroyActorDelayed(const float DelayOverride);
	void OnRep_Visibility(const struct FTedVisibility& OldValue);

	float GetCommandRange() const;
	class ATedPlayerState* GetOwningPlayerState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandVisualActor">();
	}
	static class ATedCommandVisualActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedCommandVisualActor>();
	}
};
static_assert(alignof(ATedCommandVisualActor) == 0x000008, "Wrong alignment on ATedCommandVisualActor");
static_assert(sizeof(ATedCommandVisualActor) == 0x000350, "Wrong size on ATedCommandVisualActor");
static_assert(offsetof(ATedCommandVisualActor, Visibility) == 0x0002B0, "Member 'ATedCommandVisualActor::Visibility' has a wrong offset!");
static_assert(offsetof(ATedCommandVisualActor, FogOfWarAgentRadiusMultiplier) == 0x0002E8, "Member 'ATedCommandVisualActor::FogOfWarAgentRadiusMultiplier' has a wrong offset!");
static_assert(offsetof(ATedCommandVisualActor, RevealRadius) == 0x0002EC, "Member 'ATedCommandVisualActor::RevealRadius' has a wrong offset!");
static_assert(offsetof(ATedCommandVisualActor, VisionRadius) == 0x0002F0, "Member 'ATedCommandVisualActor::VisionRadius' has a wrong offset!");
static_assert(offsetof(ATedCommandVisualActor, bVisibleOnlyToOwnedTeam) == 0x0002F4, "Member 'ATedCommandVisualActor::bVisibleOnlyToOwnedTeam' has a wrong offset!");
static_assert(offsetof(ATedCommandVisualActor, ExtraTimeKeepAlive) == 0x0002F8, "Member 'ATedCommandVisualActor::ExtraTimeKeepAlive' has a wrong offset!");
static_assert(offsetof(ATedCommandVisualActor, CachedCommandData) == 0x000300, "Member 'ATedCommandVisualActor::CachedCommandData' has a wrong offset!");
static_assert(offsetof(ATedCommandVisualActor, DestroyActorDelayed_Handle) == 0x000348, "Member 'ATedCommandVisualActor::DestroyActorDelayed_Handle' has a wrong offset!");

// Class Tempest.TedAchievementEntry
// 0x0048 (0x0070 - 0x0028)
class UTedAchievementEntry : public UObject
{
public:
	class FName                                   Identifier;                                        // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             AchievementIcon;                                   // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0038(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0048(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTedAchievementConditionBase*           Condition;                                         // 0x0058(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAchievementUnlocked;                              // 0x0060(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedAchievementSubsystem*               OwningSubsystem;                                   // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAchievementEntry">();
	}
	static class UTedAchievementEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAchievementEntry>();
	}
};
static_assert(alignof(UTedAchievementEntry) == 0x000008, "Wrong alignment on UTedAchievementEntry");
static_assert(sizeof(UTedAchievementEntry) == 0x000070, "Wrong size on UTedAchievementEntry");
static_assert(offsetof(UTedAchievementEntry, Identifier) == 0x000028, "Member 'UTedAchievementEntry::Identifier' has a wrong offset!");
static_assert(offsetof(UTedAchievementEntry, AchievementIcon) == 0x000030, "Member 'UTedAchievementEntry::AchievementIcon' has a wrong offset!");
static_assert(offsetof(UTedAchievementEntry, DisplayName) == 0x000038, "Member 'UTedAchievementEntry::DisplayName' has a wrong offset!");
static_assert(offsetof(UTedAchievementEntry, Description) == 0x000048, "Member 'UTedAchievementEntry::Description' has a wrong offset!");
static_assert(offsetof(UTedAchievementEntry, Condition) == 0x000058, "Member 'UTedAchievementEntry::Condition' has a wrong offset!");
static_assert(offsetof(UTedAchievementEntry, bAchievementUnlocked) == 0x000060, "Member 'UTedAchievementEntry::bAchievementUnlocked' has a wrong offset!");
static_assert(offsetof(UTedAchievementEntry, OwningSubsystem) == 0x000068, "Member 'UTedAchievementEntry::OwningSubsystem' has a wrong offset!");

// Class Tempest.TedAchievementEntry_StatBased
// 0x0038 (0x00A8 - 0x0070)
class UTedAchievementEntry_StatBased : public UTedAchievementEntry
{
public:
	class FName                                   StatID;                                            // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bServerSideUnlock;                                 // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetOnLevelEnd;                                  // 0x0079(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x2];                                       // 0x007A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TargetStatValue;                                   // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 ProgressNotification;                              // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         CurrentStatValue;                                  // 0x0090(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 PastNotifications;                                 // 0x0098(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAchievementEntry_StatBased">();
	}
	static class UTedAchievementEntry_StatBased* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAchievementEntry_StatBased>();
	}
};
static_assert(alignof(UTedAchievementEntry_StatBased) == 0x000008, "Wrong alignment on UTedAchievementEntry_StatBased");
static_assert(sizeof(UTedAchievementEntry_StatBased) == 0x0000A8, "Wrong size on UTedAchievementEntry_StatBased");
static_assert(offsetof(UTedAchievementEntry_StatBased, StatID) == 0x000070, "Member 'UTedAchievementEntry_StatBased::StatID' has a wrong offset!");
static_assert(offsetof(UTedAchievementEntry_StatBased, bServerSideUnlock) == 0x000078, "Member 'UTedAchievementEntry_StatBased::bServerSideUnlock' has a wrong offset!");
static_assert(offsetof(UTedAchievementEntry_StatBased, bResetOnLevelEnd) == 0x000079, "Member 'UTedAchievementEntry_StatBased::bResetOnLevelEnd' has a wrong offset!");
static_assert(offsetof(UTedAchievementEntry_StatBased, TargetStatValue) == 0x00007C, "Member 'UTedAchievementEntry_StatBased::TargetStatValue' has a wrong offset!");
static_assert(offsetof(UTedAchievementEntry_StatBased, ProgressNotification) == 0x000080, "Member 'UTedAchievementEntry_StatBased::ProgressNotification' has a wrong offset!");
static_assert(offsetof(UTedAchievementEntry_StatBased, CurrentStatValue) == 0x000090, "Member 'UTedAchievementEntry_StatBased::CurrentStatValue' has a wrong offset!");
static_assert(offsetof(UTedAchievementEntry_StatBased, PastNotifications) == 0x000098, "Member 'UTedAchievementEntry_StatBased::PastNotifications' has a wrong offset!");

// Class Tempest.TedCommandsPanel
// 0x0018 (0x07C8 - 0x07B0)
class UTedCommandsPanel : public UTedContentPanelDynamic
{
public:
	TArray<TSubclassOf<class UTedCommand>>        content;                                           // 0x07B0(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	ETedCommandDisplaySection                     CommandDisplaySection;                             // 0x07C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         DisplaySlots;                                      // 0x07C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bPlayPressedSoundOnShortcut : 1;                   // 0x07C2(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHideEmptyPanel : 1;                               // 0x07C2(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSuppressActionDuringCooldown : 1;                 // 0x07C2(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bRemoveEmptySlots : 1;                             // 0x07C2(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_7C3[0x5];                                      // 0x07C3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static ETedContentSlotState GetAlternatingActiveSlotState();
	static ETedContentSlotState GetAutocastSlotState();
	static ETedContentSlotState GetDurationActiveSlotState();
	static ETedContentSlotState GetMissingPrerequisitesSlotState();

	int32 GetContentIndex(TSubclassOf<class UTedCommand> InContent) const;
	bool GetCooldown(const int32 InSlotIndex, float* OutCooldownAlpha, float* OutDuration) const;
	bool GetShortcut(const int32 InSlotIndex, struct FInputChord* OutShortcut) const;
	TSubclassOf<class UTedCommand> GetSlotContent(const int32 InSlotIndex) const;
	TSubclassOf<class UTedCommand> GetSlotContentByMappingName(const class FName& MappingName) const;
	const class UTedCommand* GetSlotContentCDO(const int32 InSlotIndex) const;
	bool GetSlotContentUIData(const int32 InSlotIndex, class UTexture2D** OutIcon, class FText* OutName, class FText* OutDescription) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandsPanel">();
	}
	static class UTedCommandsPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCommandsPanel>();
	}
};
static_assert(alignof(UTedCommandsPanel) == 0x000008, "Wrong alignment on UTedCommandsPanel");
static_assert(sizeof(UTedCommandsPanel) == 0x0007C8, "Wrong size on UTedCommandsPanel");
static_assert(offsetof(UTedCommandsPanel, content) == 0x0007B0, "Member 'UTedCommandsPanel::content' has a wrong offset!");
static_assert(offsetof(UTedCommandsPanel, CommandDisplaySection) == 0x0007C0, "Member 'UTedCommandsPanel::CommandDisplaySection' has a wrong offset!");
static_assert(offsetof(UTedCommandsPanel, DisplaySlots) == 0x0007C1, "Member 'UTedCommandsPanel::DisplaySlots' has a wrong offset!");

// Class Tempest.TedAchievementEntry_Bitmask
// 0x0000 (0x00A8 - 0x00A8)
class UTedAchievementEntry_Bitmask final : public UTedAchievementEntry_StatBased
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAchievementEntry_Bitmask">();
	}
	static class UTedAchievementEntry_Bitmask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAchievementEntry_Bitmask>();
	}
};
static_assert(alignof(UTedAchievementEntry_Bitmask) == 0x000008, "Wrong alignment on UTedAchievementEntry_Bitmask");
static_assert(sizeof(UTedAchievementEntry_Bitmask) == 0x0000A8, "Wrong size on UTedAchievementEntry_Bitmask");

// Class Tempest.TedUnitCommand_Patrol
// 0x0000 (0x0570 - 0x0570)
class UTedUnitCommand_Patrol : public UTedPawnCommandWithBehavior
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitCommand_Patrol">();
	}
	static class UTedUnitCommand_Patrol* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUnitCommand_Patrol>();
	}
};
static_assert(alignof(UTedUnitCommand_Patrol) == 0x000008, "Wrong alignment on UTedUnitCommand_Patrol");
static_assert(sizeof(UTedUnitCommand_Patrol) == 0x000570, "Wrong size on UTedUnitCommand_Patrol");

// Class Tempest.TedAchievementsDefinition
// 0x0010 (0x0040 - 0x0030)
class UTedAchievementsDefinition final : public UDataAsset
{
public:
	TArray<TSubclassOf<class UTedAchievementEntry>> Achievements;                                    // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAchievementsDefinition">();
	}
	static class UTedAchievementsDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAchievementsDefinition>();
	}
};
static_assert(alignof(UTedAchievementsDefinition) == 0x000008, "Wrong alignment on UTedAchievementsDefinition");
static_assert(sizeof(UTedAchievementsDefinition) == 0x000040, "Wrong size on UTedAchievementsDefinition");
static_assert(offsetof(UTedAchievementsDefinition, Achievements) == 0x000030, "Member 'UTedAchievementsDefinition::Achievements' has a wrong offset!");

// Class Tempest.TedCompletedStructuresSlot
// 0x0020 (0x0450 - 0x0430)
class UTedCompletedStructuresSlot : public UTedContentPanelSlotButton
{
public:
	class UImage*                                 Image_Icon;                                        // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             TextBlock_Amount;                                  // 0x0438(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             TextBlock_Shortcut;                                // 0x0440(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Image_Hover;                                       // 0x0448(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UTedCompletedStructuresPanel* GetParentPanel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCompletedStructuresSlot">();
	}
	static class UTedCompletedStructuresSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCompletedStructuresSlot>();
	}
};
static_assert(alignof(UTedCompletedStructuresSlot) == 0x000008, "Wrong alignment on UTedCompletedStructuresSlot");
static_assert(sizeof(UTedCompletedStructuresSlot) == 0x000450, "Wrong size on UTedCompletedStructuresSlot");
static_assert(offsetof(UTedCompletedStructuresSlot, Image_Icon) == 0x000430, "Member 'UTedCompletedStructuresSlot::Image_Icon' has a wrong offset!");
static_assert(offsetof(UTedCompletedStructuresSlot, TextBlock_Amount) == 0x000438, "Member 'UTedCompletedStructuresSlot::TextBlock_Amount' has a wrong offset!");
static_assert(offsetof(UTedCompletedStructuresSlot, TextBlock_Shortcut) == 0x000440, "Member 'UTedCompletedStructuresSlot::TextBlock_Shortcut' has a wrong offset!");
static_assert(offsetof(UTedCompletedStructuresSlot, Image_Hover) == 0x000448, "Member 'UTedCompletedStructuresSlot::Image_Hover' has a wrong offset!");

// Class Tempest.TedAchievementsPlatform
// 0x0030 (0x0058 - 0x0028)
class UTedAchievementsPlatform : public UObject
{
public:
	class UTedAchievementSubsystem*               ParentSubsystem;                                   // 0x0028(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInitialized;                                      // 0x0030(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x27];                                      // 0x0031(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAchievementsPlatform">();
	}
	static class UTedAchievementsPlatform* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAchievementsPlatform>();
	}
};
static_assert(alignof(UTedAchievementsPlatform) == 0x000008, "Wrong alignment on UTedAchievementsPlatform");
static_assert(sizeof(UTedAchievementsPlatform) == 0x000058, "Wrong size on UTedAchievementsPlatform");
static_assert(offsetof(UTedAchievementsPlatform, ParentSubsystem) == 0x000028, "Member 'UTedAchievementsPlatform::ParentSubsystem' has a wrong offset!");
static_assert(offsetof(UTedAchievementsPlatform, bInitialized) == 0x000030, "Member 'UTedAchievementsPlatform::bInitialized' has a wrong offset!");

// Class Tempest.TedAchievementsPlatform_Steam
// 0x0040 (0x0098 - 0x0058)
class UTedAchievementsPlatform_Steam final : public UTedAchievementsPlatform
{
public:
	uint8                                         Pad_58[0x40];                                      // 0x0058(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAchievementsPlatform_Steam">();
	}
	static class UTedAchievementsPlatform_Steam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAchievementsPlatform_Steam>();
	}
};
static_assert(alignof(UTedAchievementsPlatform_Steam) == 0x000008, "Wrong alignment on UTedAchievementsPlatform_Steam");
static_assert(sizeof(UTedAchievementsPlatform_Steam) == 0x000098, "Wrong size on UTedAchievementsPlatform_Steam");

// Class Tempest.TedMapInfo
// 0x0E78 (0x0EA8 - 0x0030)
class UTedMapInfo final : public UPrimaryDataAsset
{
public:
	class FText                                   DisplayName;                                       // 0x0030(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)
	class FText                                   Location;                                          // 0x0040(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)
	class FText                                   Description;                                       // 0x0050(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             Minimap;                                           // 0x0060(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             CampaignSlotThumbnail;                             // 0x0068(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTedPlayerSlot                         Players[0xA];                                      // 0x0070(0x0100)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTedEditableCustomAttitude>     CustomAttitudes;                                   // 0x0A70(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FRTSCustomPlayerColorPresets           CustomPlayerColorPresets;                          // 0x0A80(0x0120)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTedStartingArmies                     StartingArmies[0x3];                               // 0x0BA0(0x0018)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        RelatedWorldPath;                                  // 0x0BE8(0x0020)(ZeroConstructor, AssetRegistrySearchable, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBox                                   CachedWorldBounds;                                 // 0x0C08(0x0038)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UTedBriefing*                           Briefing;                                          // 0x0C40(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedCommandCompoundMapScreenSetup*      MapScreenSetup;                                    // 0x0C48(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UFileMediaSource*>               VictoryMovies;                                     // 0x0C50(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UFileMediaSource*>               DefeatMovies;                                      // 0x0C60(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USmartDataCollection>    DefinitionCollection;                              // 0x0C70(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USmartDataCollection>    CustomPlayerDefinitionCollections[0xA];            // 0x0C98(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTedJukeboxTrackAsset*>          MapSoundTracks;                                    // 0x0E28(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UTedJukeboxTrackAsset*                  VictoryTrack;                                      // 0x0E38(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedJukeboxTrackAsset*                  LoseTrack;                                         // 0x0E40(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTedEncyclopediaDefinitionAsset*> EncyclopediaEntryToUnlock;                        // 0x0E48(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSet<class UTedObjectiveObj*>                 MapObjectives;                                     // 0x0E58(0x0050)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	static const class UTedMapInfo* GetMapInfoByNameSafe(const class FName& InMapInfoName);
	static const class UTedMapInfo* K2_GetCurrentMapInfo(const class UObject* InWorldContext);

	class UTexture2D* GetCampaignSlotThumbnail();

	int32 GetAmountOfMainObjectives() const;
	int32 GetAmountOfSecondaryObjectives() const;
	int32 GetBotPlayersNum() const;
	const class UTedBriefing* GetBriefing() const;
	const struct FBox GetCachedWorldBounds() const;
	const class FText GetDescription() const;
	const class FText GetDisplayName() const;
	bool GetHumanPlayerSlots(TArray<struct FTedPlayerSlot>* OutSlots) const;
	int32 GetHumanPlayersNum() const;
	const class FText GetLocation() const;
	int32 GetMapRequisitionPoints(ETedGameDifficulty Difficulty) const;
	const class UTedCommandCompoundMapScreenSetup* GetMapScreenSetup() const;
	class UTexture2D* GetMinimap() const;
	int32 GetPlayersNum() const;
	bool IsFinale() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMapInfo">();
	}
	static class UTedMapInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMapInfo>();
	}
};
static_assert(alignof(UTedMapInfo) == 0x000008, "Wrong alignment on UTedMapInfo");
static_assert(sizeof(UTedMapInfo) == 0x000EA8, "Wrong size on UTedMapInfo");
static_assert(offsetof(UTedMapInfo, DisplayName) == 0x000030, "Member 'UTedMapInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(UTedMapInfo, Location) == 0x000040, "Member 'UTedMapInfo::Location' has a wrong offset!");
static_assert(offsetof(UTedMapInfo, Description) == 0x000050, "Member 'UTedMapInfo::Description' has a wrong offset!");
static_assert(offsetof(UTedMapInfo, Minimap) == 0x000060, "Member 'UTedMapInfo::Minimap' has a wrong offset!");
static_assert(offsetof(UTedMapInfo, CampaignSlotThumbnail) == 0x000068, "Member 'UTedMapInfo::CampaignSlotThumbnail' has a wrong offset!");
static_assert(offsetof(UTedMapInfo, Players) == 0x000070, "Member 'UTedMapInfo::Players' has a wrong offset!");
static_assert(offsetof(UTedMapInfo, CustomAttitudes) == 0x000A70, "Member 'UTedMapInfo::CustomAttitudes' has a wrong offset!");
static_assert(offsetof(UTedMapInfo, CustomPlayerColorPresets) == 0x000A80, "Member 'UTedMapInfo::CustomPlayerColorPresets' has a wrong offset!");
static_assert(offsetof(UTedMapInfo, StartingArmies) == 0x000BA0, "Member 'UTedMapInfo::StartingArmies' has a wrong offset!");
static_assert(offsetof(UTedMapInfo, RelatedWorldPath) == 0x000BE8, "Member 'UTedMapInfo::RelatedWorldPath' has a wrong offset!");
static_assert(offsetof(UTedMapInfo, CachedWorldBounds) == 0x000C08, "Member 'UTedMapInfo::CachedWorldBounds' has a wrong offset!");
static_assert(offsetof(UTedMapInfo, Briefing) == 0x000C40, "Member 'UTedMapInfo::Briefing' has a wrong offset!");
static_assert(offsetof(UTedMapInfo, MapScreenSetup) == 0x000C48, "Member 'UTedMapInfo::MapScreenSetup' has a wrong offset!");
static_assert(offsetof(UTedMapInfo, VictoryMovies) == 0x000C50, "Member 'UTedMapInfo::VictoryMovies' has a wrong offset!");
static_assert(offsetof(UTedMapInfo, DefeatMovies) == 0x000C60, "Member 'UTedMapInfo::DefeatMovies' has a wrong offset!");
static_assert(offsetof(UTedMapInfo, DefinitionCollection) == 0x000C70, "Member 'UTedMapInfo::DefinitionCollection' has a wrong offset!");
static_assert(offsetof(UTedMapInfo, CustomPlayerDefinitionCollections) == 0x000C98, "Member 'UTedMapInfo::CustomPlayerDefinitionCollections' has a wrong offset!");
static_assert(offsetof(UTedMapInfo, MapSoundTracks) == 0x000E28, "Member 'UTedMapInfo::MapSoundTracks' has a wrong offset!");
static_assert(offsetof(UTedMapInfo, VictoryTrack) == 0x000E38, "Member 'UTedMapInfo::VictoryTrack' has a wrong offset!");
static_assert(offsetof(UTedMapInfo, LoseTrack) == 0x000E40, "Member 'UTedMapInfo::LoseTrack' has a wrong offset!");
static_assert(offsetof(UTedMapInfo, EncyclopediaEntryToUnlock) == 0x000E48, "Member 'UTedMapInfo::EncyclopediaEntryToUnlock' has a wrong offset!");
static_assert(offsetof(UTedMapInfo, MapObjectives) == 0x000E58, "Member 'UTedMapInfo::MapObjectives' has a wrong offset!");

// Class Tempest.TedAchievementSubsystem
// 0x0080 (0x00B0 - 0x0030)
class UTedAchievementSubsystem final : public UGameInstanceSubsystem
{
public:
	class UTedAchievementsDefinition*             AchievementData;                                   // 0x0030(0x0008)(Edit, ZeroConstructor, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class UTedAchievementEntry>, class UTedAchievementEntry*> Achievements;         // 0x0038(0x0050)(Edit, Transient, EditConst, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UTedAchievementsPlatform*               PlatformInterface;                                 // 0x0088(0x0008)(Edit, ZeroConstructor, Transient, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxEntityConstructedNotifies;                      // 0x0090(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_94[0xC];                                       // 0x0094(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class FString& AchievementClass)> OnAchievementUnlocked;     // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void AddAchievementValue(const TSubclassOf<class UTedAchievementEntry>& AchievementClass, int32 Value);
	void SetAchievementValue(const TSubclassOf<class UTedAchievementEntry>& AchievementClass, int32 Value);
	void UnlockAchievement(const TSubclassOf<class UTedAchievementEntry>& AchievementClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAchievementSubsystem">();
	}
	static class UTedAchievementSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAchievementSubsystem>();
	}
};
static_assert(alignof(UTedAchievementSubsystem) == 0x000008, "Wrong alignment on UTedAchievementSubsystem");
static_assert(sizeof(UTedAchievementSubsystem) == 0x0000B0, "Wrong size on UTedAchievementSubsystem");
static_assert(offsetof(UTedAchievementSubsystem, AchievementData) == 0x000030, "Member 'UTedAchievementSubsystem::AchievementData' has a wrong offset!");
static_assert(offsetof(UTedAchievementSubsystem, Achievements) == 0x000038, "Member 'UTedAchievementSubsystem::Achievements' has a wrong offset!");
static_assert(offsetof(UTedAchievementSubsystem, PlatformInterface) == 0x000088, "Member 'UTedAchievementSubsystem::PlatformInterface' has a wrong offset!");
static_assert(offsetof(UTedAchievementSubsystem, MaxEntityConstructedNotifies) == 0x000090, "Member 'UTedAchievementSubsystem::MaxEntityConstructedNotifies' has a wrong offset!");
static_assert(offsetof(UTedAchievementSubsystem, OnAchievementUnlocked) == 0x0000A0, "Member 'UTedAchievementSubsystem::OnAchievementUnlocked' has a wrong offset!");

// Class Tempest.TedUnitQueueInterface
// 0x0000 (0x0000 - 0x0000)
class ITedUnitQueueInterface final
{
public:
	bool CanEnqueue(const class ATedUnitBase* Unit) const;
	bool IsQueued(const class ATedUnitBase* Unit) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitQueueInterface">();
	}
	static class ITedUnitQueueInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITedUnitQueueInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITedUnitQueueInterface) == 0x000001, "Wrong alignment on ITedUnitQueueInterface");
static_assert(sizeof(ITedUnitQueueInterface) == 0x000001, "Wrong size on ITedUnitQueueInterface");

// Class Tempest.TedActorCacheWorldSubsystem
// 0x0010 (0x0040 - 0x0030)
class UTedActorCacheWorldSubsystem final : public UWorldSubsystem
{
public:
	TArray<class ATedStructurePlacementVolume*>   TedStructurePlacementVolumes;                      // 0x0030(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedActorCacheWorldSubsystem">();
	}
	static class UTedActorCacheWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedActorCacheWorldSubsystem>();
	}
};
static_assert(alignof(UTedActorCacheWorldSubsystem) == 0x000008, "Wrong alignment on UTedActorCacheWorldSubsystem");
static_assert(sizeof(UTedActorCacheWorldSubsystem) == 0x000040, "Wrong size on UTedActorCacheWorldSubsystem");
static_assert(offsetof(UTedActorCacheWorldSubsystem, TedStructurePlacementVolumes) == 0x000030, "Member 'UTedActorCacheWorldSubsystem::TedStructurePlacementVolumes' has a wrong offset!");

// Class Tempest.TedStructureNeighborBase
// 0x0090 (0x1A90 - 0x1A00)
class ATedStructureNeighborBase : public ATedStructureBase
{
public:
	uint8                                         bEnableConnectionRemoval : 1;                      // 0x19F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bConstructionSiteCheck : 1;                        // 0x19F8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_19F9[0x7];                                     // 0x19F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           ConnectableStructures;                             // 0x1A00(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSoftClassPtr<class UClass>>           PlaceableStructures;                               // 0x1A10(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UStaticMesh*                            EndCap;                                            // 0x1A20(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            DeathEndCap;                                       // 0x1A28(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               RotationOffset;                                    // 0x1A30(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bUseProceduralAnimations : 1;                      // 0x1A48(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1A49[0x3];                                     // 0x1A49(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProceduralAnimLength;                              // 0x1A4C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProceduralAnimPlayRate;                            // 0x1A50(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProceduralAnimOverGroundOffset;                    // 0x1A54(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProceduralAnimUnderGroundOffset;                   // 0x1A58(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         ConnectionsState;                                  // 0x1A5C(0x0001)(Edit, Net, ZeroConstructor, EditConst, DuplicateTransient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A5D[0x3];                                     // 0x1A5D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedStructureNeighborhood              Neighbors;                                         // 0x1A60(0x0010)(Edit, Net, EditConst, DuplicateTransient, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<class UStaticMeshComponent*>           EndCapComponents;                                  // 0x1A70(0x0010)(ExportObject, ZeroConstructor, Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           TH_ProceduralAnimHandle;                           // 0x1A80(0x0008)(Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProceduralAnimElapsedTime;                         // 0x1A88(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedNeighborAnim                              PlayingNeighborAnim;                               // 0x1A8C(0x0001)(Net, ZeroConstructor, DuplicateTransient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A8D[0x3];                                     // 0x1A8D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_OnRefreshConnections(const struct FTedStructureConnection& InPreset);
	void K2_OnStartProceduralAnim(const ETedNeighborAnim Anim);
	void OnRep_ConnectionsState();
	void OnRep_Neighbors();
	void OnRep_PlayingNeighborAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedStructureNeighborBase">();
	}
	static class ATedStructureNeighborBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedStructureNeighborBase>();
	}
};
static_assert(alignof(ATedStructureNeighborBase) == 0x000010, "Wrong alignment on ATedStructureNeighborBase");
static_assert(sizeof(ATedStructureNeighborBase) == 0x001A90, "Wrong size on ATedStructureNeighborBase");
static_assert(offsetof(ATedStructureNeighborBase, ConnectableStructures) == 0x001A00, "Member 'ATedStructureNeighborBase::ConnectableStructures' has a wrong offset!");
static_assert(offsetof(ATedStructureNeighborBase, PlaceableStructures) == 0x001A10, "Member 'ATedStructureNeighborBase::PlaceableStructures' has a wrong offset!");
static_assert(offsetof(ATedStructureNeighborBase, EndCap) == 0x001A20, "Member 'ATedStructureNeighborBase::EndCap' has a wrong offset!");
static_assert(offsetof(ATedStructureNeighborBase, DeathEndCap) == 0x001A28, "Member 'ATedStructureNeighborBase::DeathEndCap' has a wrong offset!");
static_assert(offsetof(ATedStructureNeighborBase, RotationOffset) == 0x001A30, "Member 'ATedStructureNeighborBase::RotationOffset' has a wrong offset!");
static_assert(offsetof(ATedStructureNeighborBase, ProceduralAnimLength) == 0x001A4C, "Member 'ATedStructureNeighborBase::ProceduralAnimLength' has a wrong offset!");
static_assert(offsetof(ATedStructureNeighborBase, ProceduralAnimPlayRate) == 0x001A50, "Member 'ATedStructureNeighborBase::ProceduralAnimPlayRate' has a wrong offset!");
static_assert(offsetof(ATedStructureNeighborBase, ProceduralAnimOverGroundOffset) == 0x001A54, "Member 'ATedStructureNeighborBase::ProceduralAnimOverGroundOffset' has a wrong offset!");
static_assert(offsetof(ATedStructureNeighborBase, ProceduralAnimUnderGroundOffset) == 0x001A58, "Member 'ATedStructureNeighborBase::ProceduralAnimUnderGroundOffset' has a wrong offset!");
static_assert(offsetof(ATedStructureNeighborBase, ConnectionsState) == 0x001A5C, "Member 'ATedStructureNeighborBase::ConnectionsState' has a wrong offset!");
static_assert(offsetof(ATedStructureNeighborBase, Neighbors) == 0x001A60, "Member 'ATedStructureNeighborBase::Neighbors' has a wrong offset!");
static_assert(offsetof(ATedStructureNeighborBase, EndCapComponents) == 0x001A70, "Member 'ATedStructureNeighborBase::EndCapComponents' has a wrong offset!");
static_assert(offsetof(ATedStructureNeighborBase, TH_ProceduralAnimHandle) == 0x001A80, "Member 'ATedStructureNeighborBase::TH_ProceduralAnimHandle' has a wrong offset!");
static_assert(offsetof(ATedStructureNeighborBase, ProceduralAnimElapsedTime) == 0x001A88, "Member 'ATedStructureNeighborBase::ProceduralAnimElapsedTime' has a wrong offset!");
static_assert(offsetof(ATedStructureNeighborBase, PlayingNeighborAnim) == 0x001A8C, "Member 'ATedStructureNeighborBase::PlayingNeighborAnim' has a wrong offset!");

// Class Tempest.TedActorTagFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UTedActorTagFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddActorToActorTag(const class UObject* InWorldContext, class AActor* Actor, const struct FGameplayTag& Tag);
	static void ClearActorsUnderActorTag(const class UObject* InWorldContext, const struct FGameplayTag& Tag);
	static class AActor* GetActorByActorTag(const class UObject* InWorldContext, const struct FGameplayTag& Tag, TSubclassOf<class AActor> Class_0);
	static bool GetActorsByActorTag(const class UObject* InWorldContext, const struct FGameplayTag& Tag, TSubclassOf<class AActor> Class_0, TArray<class AActor*>* OutActors);
	static bool GetActorsByActorTags(const class UObject* InWorldContext, const struct FGameplayTagContainer& Tags, TSubclassOf<class AActor> Class_0, TArray<class AActor*>* OutActors);
	static bool GetActorsByActorTagTree(const class UObject* InWorldContext, const struct FGameplayTag& Tag, TSubclassOf<class AActor> Class_0, TArray<class AActor*>* OutActors);
	static void GetActorTag(const class UObject* InWorldContext, class AActor* Actor, struct FGameplayTag* OutTag);
	static void OnAddActorToActorTag(const class UObject* InWorldContext, const ETedActorTagEventAction Action, const struct FGameplayTag& Tag, TDelegate<void(const struct FGameplayTag& InActorTag, class AActor* InActor, class AActor* InSecondActor)> Handler);
	static void OnRemoveActorFromActorTag(const class UObject* InWorldContext, const ETedActorTagEventAction Action, const struct FGameplayTag& Tag, TDelegate<void(const struct FGameplayTag& InActorTag, class AActor* InActor, class AActor* InSecondActor)> Handler);
	static void RemoveActorFromActorTag(const class UObject* InWorldContext, class AActor* Actor);
	static void SetActorUnderActorTag(const class UObject* InWorldContext, const struct FGameplayTag& Tag, class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedActorTagFunctionLibrary">();
	}
	static class UTedActorTagFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedActorTagFunctionLibrary>();
	}
};
static_assert(alignof(UTedActorTagFunctionLibrary) == 0x000008, "Wrong alignment on UTedActorTagFunctionLibrary");
static_assert(sizeof(UTedActorTagFunctionLibrary) == 0x000028, "Wrong size on UTedActorTagFunctionLibrary");

// Class Tempest.TedActorTagSubsystem
// 0x00F0 (0x0120 - 0x0030)
class UTedActorTagSubsystem final : public UWorldSubsystem
{
public:
	TMap<struct FGameplayTag, struct FTedActorTagContainer> ActorTagContainers;                      // 0x0030(0x0050)(Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class AActor*, struct FGameplayTag>      ActorToTagAccelMap;                                // 0x0080(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x50];                                      // 0x00D0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool K2_ActorHasAllMatchingGameplayTags(class AActor* Actor, const struct FGameplayTagContainer& GameplayTags);
	static bool K2_ActorHasAnyMatchingGameplayTags(class AActor* Actor, const struct FGameplayTagContainer& GameplayTags);
	static bool K2_ActorHasMatchingGameplayTag(class AActor* Actor, const struct FGameplayTag& GameplayTag);

	void OnActorEndPlay(class AActor* InActor, EEndPlayReason InEndPlayReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedActorTagSubsystem">();
	}
	static class UTedActorTagSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedActorTagSubsystem>();
	}
};
static_assert(alignof(UTedActorTagSubsystem) == 0x000008, "Wrong alignment on UTedActorTagSubsystem");
static_assert(sizeof(UTedActorTagSubsystem) == 0x000120, "Wrong size on UTedActorTagSubsystem");
static_assert(offsetof(UTedActorTagSubsystem, ActorTagContainers) == 0x000030, "Member 'UTedActorTagSubsystem::ActorTagContainers' has a wrong offset!");
static_assert(offsetof(UTedActorTagSubsystem, ActorToTagAccelMap) == 0x000080, "Member 'UTedActorTagSubsystem::ActorToTagAccelMap' has a wrong offset!");

// Class Tempest.TedLobbyBeaconPlayerState
// 0x0030 (0x0388 - 0x0358)
class ATedLobbyBeaconPlayerState final : public ALobbyBeaconPlayerState
{
public:
	uint8                                         bIsAdmin : 1;                                      // 0x0358(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_359[0x7];                                      // 0x0359(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HydraId;                                           // 0x0360(0x0010)(Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_370[0x18];                                     // 0x0370(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Admin();
	void OnRep_HydraId();

	const struct FUniqueNetIdRepl GetUniqueId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedLobbyBeaconPlayerState">();
	}
	static class ATedLobbyBeaconPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedLobbyBeaconPlayerState>();
	}
};
static_assert(alignof(ATedLobbyBeaconPlayerState) == 0x000008, "Wrong alignment on ATedLobbyBeaconPlayerState");
static_assert(sizeof(ATedLobbyBeaconPlayerState) == 0x000388, "Wrong size on ATedLobbyBeaconPlayerState");
static_assert(offsetof(ATedLobbyBeaconPlayerState, HydraId) == 0x000360, "Member 'ATedLobbyBeaconPlayerState::HydraId' has a wrong offset!");

// Class Tempest.TedCompletedStructuresController
// 0x00B8 (0x04C8 - 0x0410)
class UTedCompletedStructuresController : public UTedPlayerDataWidget
{
public:
	class UTedCompletedStructuresPanel*           Panel;                                             // 0x0410(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedContentPanelBase*                   CollapseButton;                                    // 0x0418(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                CanvasPanel_Counter;                               // 0x0420(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_Counter;                                 // 0x0428(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                CanvasPanel_ExpansionArea;                         // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedCompletedStructuresButton*          Button;                                            // 0x0438(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UTedPlayerCommand_PlaceStructure> PlaceStructureCommand;                       // 0x0440(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UInputAction>            CollapseInputAction;                               // 0x0448(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bShouldPanelCollapseAutomatically : 1;             // 0x0470(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_471[0x3];                                      // 0x0471(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        MinUniqueCompletedStructuresForCollapseButton;     // 0x0474(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        MinUniqueCompletedStructuresForCounter;            // 0x0478(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_47C[0x4];                                      // 0x047C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UInputAction>            PlaceLastCompletedStructureInputAction;            // 0x0480(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A8[0x20];                                     // 0x04A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPanelContentChange(class UTedContentPanelDynamic* InContentPanel);
	void OnPanelTriggerSlotAction(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction);
	void Refresh(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotState InState, bool bInActivated);
	void ToggleExpansionButtonVisibility(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCompletedStructuresController">();
	}
	static class UTedCompletedStructuresController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCompletedStructuresController>();
	}
};
static_assert(alignof(UTedCompletedStructuresController) == 0x000008, "Wrong alignment on UTedCompletedStructuresController");
static_assert(sizeof(UTedCompletedStructuresController) == 0x0004C8, "Wrong size on UTedCompletedStructuresController");
static_assert(offsetof(UTedCompletedStructuresController, Panel) == 0x000410, "Member 'UTedCompletedStructuresController::Panel' has a wrong offset!");
static_assert(offsetof(UTedCompletedStructuresController, CollapseButton) == 0x000418, "Member 'UTedCompletedStructuresController::CollapseButton' has a wrong offset!");
static_assert(offsetof(UTedCompletedStructuresController, CanvasPanel_Counter) == 0x000420, "Member 'UTedCompletedStructuresController::CanvasPanel_Counter' has a wrong offset!");
static_assert(offsetof(UTedCompletedStructuresController, TextBlock_Counter) == 0x000428, "Member 'UTedCompletedStructuresController::TextBlock_Counter' has a wrong offset!");
static_assert(offsetof(UTedCompletedStructuresController, CanvasPanel_ExpansionArea) == 0x000430, "Member 'UTedCompletedStructuresController::CanvasPanel_ExpansionArea' has a wrong offset!");
static_assert(offsetof(UTedCompletedStructuresController, Button) == 0x000438, "Member 'UTedCompletedStructuresController::Button' has a wrong offset!");
static_assert(offsetof(UTedCompletedStructuresController, PlaceStructureCommand) == 0x000440, "Member 'UTedCompletedStructuresController::PlaceStructureCommand' has a wrong offset!");
static_assert(offsetof(UTedCompletedStructuresController, CollapseInputAction) == 0x000448, "Member 'UTedCompletedStructuresController::CollapseInputAction' has a wrong offset!");
static_assert(offsetof(UTedCompletedStructuresController, MinUniqueCompletedStructuresForCollapseButton) == 0x000474, "Member 'UTedCompletedStructuresController::MinUniqueCompletedStructuresForCollapseButton' has a wrong offset!");
static_assert(offsetof(UTedCompletedStructuresController, MinUniqueCompletedStructuresForCounter) == 0x000478, "Member 'UTedCompletedStructuresController::MinUniqueCompletedStructuresForCounter' has a wrong offset!");
static_assert(offsetof(UTedCompletedStructuresController, PlaceLastCompletedStructureInputAction) == 0x000480, "Member 'UTedCompletedStructuresController::PlaceLastCompletedStructureInputAction' has a wrong offset!");

// Class Tempest.TedAIController
// 0x00E8 (0x04A0 - 0x03B8)
class ATedAIController final : public AAIController
{
public:
	class UBehaviorTree*                          BaseBehaviorAsset;                                 // 0x03B8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBehaviorTree*                          IdleBehaviorAsset;                                 // 0x03C0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBehaviorTree*                          CommandBehaviorAsset;                              // 0x03C8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D0[0x50];                                     // 0x03D0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UUtilityAIBrain*                        UtilityAIBrain;                                    // 0x0420(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_428[0x78];                                     // 0x0428(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PauseLogic();
	void ResumeLogic();
	void StopBehaviorTree();

	class AActor* GetCommandTargetActor() const;
	struct FVector GetCommandTargetLocation() const;
	TSubclassOf<class UTedPawnCommandWithBehavior> GetCurrentCommandWithBehavior() const;
	struct FVector GetLeashLocation() const;
	class UUtilityAIBrain* GetUtilityAIBrain() const;
	bool IsCommandTargetLocationSet() const;
	bool IsExecutingCommandWithBehavior(TSubclassOf<class UTedPawnCommandWithBehavior> Command) const;
	bool IsLogicPaused() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAIController">();
	}
	static class ATedAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedAIController>();
	}
};
static_assert(alignof(ATedAIController) == 0x000008, "Wrong alignment on ATedAIController");
static_assert(sizeof(ATedAIController) == 0x0004A0, "Wrong size on ATedAIController");
static_assert(offsetof(ATedAIController, BaseBehaviorAsset) == 0x0003B8, "Member 'ATedAIController::BaseBehaviorAsset' has a wrong offset!");
static_assert(offsetof(ATedAIController, IdleBehaviorAsset) == 0x0003C0, "Member 'ATedAIController::IdleBehaviorAsset' has a wrong offset!");
static_assert(offsetof(ATedAIController, CommandBehaviorAsset) == 0x0003C8, "Member 'ATedAIController::CommandBehaviorAsset' has a wrong offset!");
static_assert(offsetof(ATedAIController, UtilityAIBrain) == 0x000420, "Member 'ATedAIController::UtilityAIBrain' has a wrong offset!");

// Class Tempest.TedStatusPanelTooltip
// 0x0008 (0x04A8 - 0x04A0)
class UTedStatusPanelTooltip : public UTedTooltipWidget
{
public:
	class UTedStatusPanel*                        StatusEffects;                                     // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UTedStatusPanel* GetTargetStatusPanel() const;
	class UTedStatusSlot* GetTargetStatusSlot() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedStatusPanelTooltip">();
	}
	static class UTedStatusPanelTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedStatusPanelTooltip>();
	}
};
static_assert(alignof(UTedStatusPanelTooltip) == 0x000008, "Wrong alignment on UTedStatusPanelTooltip");
static_assert(sizeof(UTedStatusPanelTooltip) == 0x0004A8, "Wrong size on UTedStatusPanelTooltip");
static_assert(offsetof(UTedStatusPanelTooltip, StatusEffects) == 0x0004A0, "Member 'UTedStatusPanelTooltip::StatusEffects' has a wrong offset!");

// Class Tempest.TedPreviewChart
// 0x0008 (0x0038 - 0x0030)
class UTedPreviewChart : public UDataAsset
{
public:
	uint8                                         bStripFromGame : 1;                                // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPreviewChart">();
	}
	static class UTedPreviewChart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPreviewChart>();
	}
};
static_assert(alignof(UTedPreviewChart) == 0x000008, "Wrong alignment on UTedPreviewChart");
static_assert(sizeof(UTedPreviewChart) == 0x000038, "Wrong size on UTedPreviewChart");

// Class Tempest.TedPreviewChart_Generated
// 0x0050 (0x0088 - 0x0038)
class UTedPreviewChart_Generated final : public UTedPreviewChart
{
public:
	int32                                         Entries;                                           // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTedPreviewChartValueGeneration        X;                                                 // 0x003C(0x000C)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTedPreviewChartValueGeneration        Y;                                                 // 0x0048(0x000C)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedChartData                          Data;                                              // 0x0058(0x0030)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPreviewChart_Generated">();
	}
	static class UTedPreviewChart_Generated* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPreviewChart_Generated>();
	}
};
static_assert(alignof(UTedPreviewChart_Generated) == 0x000008, "Wrong alignment on UTedPreviewChart_Generated");
static_assert(sizeof(UTedPreviewChart_Generated) == 0x000088, "Wrong size on UTedPreviewChart_Generated");
static_assert(offsetof(UTedPreviewChart_Generated, Entries) == 0x000038, "Member 'UTedPreviewChart_Generated::Entries' has a wrong offset!");
static_assert(offsetof(UTedPreviewChart_Generated, X) == 0x00003C, "Member 'UTedPreviewChart_Generated::X' has a wrong offset!");
static_assert(offsetof(UTedPreviewChart_Generated, Y) == 0x000048, "Member 'UTedPreviewChart_Generated::Y' has a wrong offset!");
static_assert(offsetof(UTedPreviewChart_Generated, Data) == 0x000058, "Member 'UTedPreviewChart_Generated::Data' has a wrong offset!");

// Class Tempest.TedUnitBase
// 0x0400 (0x1AB0 - 0x16B0)
class ATedUnitBase : public ATedPawn
{
public:
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x16A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedUnitMovementComponent*              UnitMovement;                                      // 0x16B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FollowUnitSpeedAdjustmentDistance;                 // 0x16B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IsMovingSpeedThreshold;                            // 0x16BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16C0[0x1];                                     // 0x16C0(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRequiresValidGroundLocation;                      // 0x16C1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16C2[0x2];                                     // 0x16C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxMovementSpeedOverride;                          // 0x16C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16C8[0x330];                                   // 0x16C8(0x0330)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FollowUnitSpeedAdjustmentDistanceOverride;         // 0x19F8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_19FC[0x4];                                     // 0x19FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ATedUnitBase*                           FollowUnit;                                        // 0x1A00(0x0008)(Net, ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                MaxSpeedOverrideSource;                            // 0x1A08(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A10[0x10];                                    // 0x1A10(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bStealthEnabled : 1;                               // 0x1A20(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1A21[0xF];                                     // 0x1A21(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ATedParachute>              ParachuteClass;                                    // 0x1A30(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ParachuteAttachSocket;                             // 0x1A38(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             ParachuteAttachTransform;                          // 0x1A40(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATedParachute*                          Parachute;                                         // 0x1AA0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATedVetiDomeHelper*                     VetiDome;                                          // 0x1AA8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void EnableOutline(const bool bEnabled);
	void K2_OnRep_IsStealthed();
	void OnRep_IsStealthed();
	void OnVetiDomeDeactivated();
	void ReceiveBeginMovement();
	void ReceiveEndMovement();
	void ReceiveTickMovement(float Speed, float MaxSpeed);
	void SetFollowUnit(class ATedUnitBase* InUnit, const float InFollowUnitSpeedAdjustmentDistanceOverride);

	TSubclassOf<class UNavigationQueryFilter> GetDefaultNavigationFilterClass() const;
	const class UTedUnitDefinitionAsset* GetDefinitionAsset() const;
	class ATedUnitBase* GetFollowUnit() const;
	const class UTedNavFilterSelector* GetNavFilterSelector() const;
	bool IsStealthEnabled() const;
	void UpdateOutline(const class URTSColorSubsystem* InRTSColorSubsystem) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitBase">();
	}
	static class ATedUnitBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedUnitBase>();
	}
};
static_assert(alignof(ATedUnitBase) == 0x000010, "Wrong alignment on ATedUnitBase");
static_assert(sizeof(ATedUnitBase) == 0x001AB0, "Wrong size on ATedUnitBase");
static_assert(offsetof(ATedUnitBase, CapsuleComponent) == 0x0016A8, "Member 'ATedUnitBase::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(ATedUnitBase, UnitMovement) == 0x0016B0, "Member 'ATedUnitBase::UnitMovement' has a wrong offset!");
static_assert(offsetof(ATedUnitBase, FollowUnitSpeedAdjustmentDistance) == 0x0016B8, "Member 'ATedUnitBase::FollowUnitSpeedAdjustmentDistance' has a wrong offset!");
static_assert(offsetof(ATedUnitBase, IsMovingSpeedThreshold) == 0x0016BC, "Member 'ATedUnitBase::IsMovingSpeedThreshold' has a wrong offset!");
static_assert(offsetof(ATedUnitBase, bRequiresValidGroundLocation) == 0x0016C1, "Member 'ATedUnitBase::bRequiresValidGroundLocation' has a wrong offset!");
static_assert(offsetof(ATedUnitBase, MaxMovementSpeedOverride) == 0x0016C4, "Member 'ATedUnitBase::MaxMovementSpeedOverride' has a wrong offset!");
static_assert(offsetof(ATedUnitBase, FollowUnitSpeedAdjustmentDistanceOverride) == 0x0019F8, "Member 'ATedUnitBase::FollowUnitSpeedAdjustmentDistanceOverride' has a wrong offset!");
static_assert(offsetof(ATedUnitBase, FollowUnit) == 0x001A00, "Member 'ATedUnitBase::FollowUnit' has a wrong offset!");
static_assert(offsetof(ATedUnitBase, MaxSpeedOverrideSource) == 0x001A08, "Member 'ATedUnitBase::MaxSpeedOverrideSource' has a wrong offset!");
static_assert(offsetof(ATedUnitBase, ParachuteClass) == 0x001A30, "Member 'ATedUnitBase::ParachuteClass' has a wrong offset!");
static_assert(offsetof(ATedUnitBase, ParachuteAttachSocket) == 0x001A38, "Member 'ATedUnitBase::ParachuteAttachSocket' has a wrong offset!");
static_assert(offsetof(ATedUnitBase, ParachuteAttachTransform) == 0x001A40, "Member 'ATedUnitBase::ParachuteAttachTransform' has a wrong offset!");
static_assert(offsetof(ATedUnitBase, Parachute) == 0x001AA0, "Member 'ATedUnitBase::Parachute' has a wrong offset!");
static_assert(offsetof(ATedUnitBase, VetiDome) == 0x001AA8, "Member 'ATedUnitBase::VetiDome' has a wrong offset!");

// Class Tempest.TedVehicle
// 0x0210 (0x1CC0 - 0x1AB0)
class ATedVehicle : public ATedUnitBase
{
public:
	uint8                                         Pad_1AB0[0x20];                                    // 0x1AB0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInstanceDynamic*>       AllSelectionMIDs;                                  // 0x1AD0(0x0010)(ZeroConstructor, Transient, DuplicateTransient, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   WreckActorClass;                                   // 0x1AE0(0x0028)(Edit, Config, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            WreckMesh;                                         // 0x1B08(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WreckImpulseMultiplier;                            // 0x1B10(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MatParam_Dirt;                                     // 0x1B14(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MatParam_DirtColor;                                // 0x1B1C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DirtColorAlphaRateChange;                          // 0x1B24(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EPhysicalSurface, struct FLinearColor>   PhysicalSurfaceToDirtColor;                        // 0x1B28(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   MatParam_DeathDissolve;                            // 0x1B78(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   IntParam_Surface;                                  // 0x1B80(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bUsesTreadsAnimation : 1;                          // 0x1B88(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1B89[0x7];                                     // 0x1B89(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              TreadsAnimationPlayRateRange;                      // 0x1B90(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MatParam_TreadsSpeed;                              // 0x1BA0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      TracedMovementFX;                                  // 0x1BA8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      AdditionalSelectionFX;                             // 0x1BB0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAdjustRotationToTerrain;                          // 0x1BB8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1BB9[0x7];                                     // 0x1BB9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        IdleAC;                                            // 0x1BC0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        MovementAC;                                        // 0x1BC8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAudioParam                            AudioParam_Speed;                                  // 0x1BD0(0x0030)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FAudioParam                            AudioParam_SpeedPct;                               // 0x1C00(0x0030)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class USoundCue*                              MovementSound_Idle;                                // 0x1C30(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              MovementSound_Loop;                                // 0x1C38(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              MovementSound_Start;                               // 0x1C40(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              MovementSound_Stop;                                // 0x1C48(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseDeprecatedMovementSoundPitchRangeApproach;     // 0x1C50(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C51[0x7];                                     // 0x1C51(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              MovementSoundPitchRange;                           // 0x1C58(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              TEMP_CrashInfantrySound;                           // 0x1C68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              DeathSound;                                        // 0x1C70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              FoliageOverlapExtent;                              // 0x1C78(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            FoliageSpeedPenaltyGE;                             // 0x1C88(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bForceMovementCircleCollider : 1;                  // 0x1C90(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDrivingInReverse : 1;                             // 0x1C90(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1C91[0x27];                                    // 0x1C91(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ATedStructureBase>          CachedStructureClassToDeploy;                      // 0x1CB8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnDeployedStateChanged(const struct FGameplayTag& CallbackTag, int32 NewCount);
	void SetDrivingInReverse(bool bReverse);

	bool IsDrivingInReverse() const;
	void K2_GetSelectionMIDs(TArray<class UMaterialInstanceDynamic*>* OutSelectionMIDs) const;
	void SpawnWreck() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedVehicle">();
	}
	static class ATedVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedVehicle>();
	}
};
static_assert(alignof(ATedVehicle) == 0x000010, "Wrong alignment on ATedVehicle");
static_assert(sizeof(ATedVehicle) == 0x001CC0, "Wrong size on ATedVehicle");
static_assert(offsetof(ATedVehicle, AllSelectionMIDs) == 0x001AD0, "Member 'ATedVehicle::AllSelectionMIDs' has a wrong offset!");
static_assert(offsetof(ATedVehicle, WreckActorClass) == 0x001AE0, "Member 'ATedVehicle::WreckActorClass' has a wrong offset!");
static_assert(offsetof(ATedVehicle, WreckMesh) == 0x001B08, "Member 'ATedVehicle::WreckMesh' has a wrong offset!");
static_assert(offsetof(ATedVehicle, WreckImpulseMultiplier) == 0x001B10, "Member 'ATedVehicle::WreckImpulseMultiplier' has a wrong offset!");
static_assert(offsetof(ATedVehicle, MatParam_Dirt) == 0x001B14, "Member 'ATedVehicle::MatParam_Dirt' has a wrong offset!");
static_assert(offsetof(ATedVehicle, MatParam_DirtColor) == 0x001B1C, "Member 'ATedVehicle::MatParam_DirtColor' has a wrong offset!");
static_assert(offsetof(ATedVehicle, DirtColorAlphaRateChange) == 0x001B24, "Member 'ATedVehicle::DirtColorAlphaRateChange' has a wrong offset!");
static_assert(offsetof(ATedVehicle, PhysicalSurfaceToDirtColor) == 0x001B28, "Member 'ATedVehicle::PhysicalSurfaceToDirtColor' has a wrong offset!");
static_assert(offsetof(ATedVehicle, MatParam_DeathDissolve) == 0x001B78, "Member 'ATedVehicle::MatParam_DeathDissolve' has a wrong offset!");
static_assert(offsetof(ATedVehicle, IntParam_Surface) == 0x001B80, "Member 'ATedVehicle::IntParam_Surface' has a wrong offset!");
static_assert(offsetof(ATedVehicle, TreadsAnimationPlayRateRange) == 0x001B90, "Member 'ATedVehicle::TreadsAnimationPlayRateRange' has a wrong offset!");
static_assert(offsetof(ATedVehicle, MatParam_TreadsSpeed) == 0x001BA0, "Member 'ATedVehicle::MatParam_TreadsSpeed' has a wrong offset!");
static_assert(offsetof(ATedVehicle, TracedMovementFX) == 0x001BA8, "Member 'ATedVehicle::TracedMovementFX' has a wrong offset!");
static_assert(offsetof(ATedVehicle, AdditionalSelectionFX) == 0x001BB0, "Member 'ATedVehicle::AdditionalSelectionFX' has a wrong offset!");
static_assert(offsetof(ATedVehicle, bAdjustRotationToTerrain) == 0x001BB8, "Member 'ATedVehicle::bAdjustRotationToTerrain' has a wrong offset!");
static_assert(offsetof(ATedVehicle, IdleAC) == 0x001BC0, "Member 'ATedVehicle::IdleAC' has a wrong offset!");
static_assert(offsetof(ATedVehicle, MovementAC) == 0x001BC8, "Member 'ATedVehicle::MovementAC' has a wrong offset!");
static_assert(offsetof(ATedVehicle, AudioParam_Speed) == 0x001BD0, "Member 'ATedVehicle::AudioParam_Speed' has a wrong offset!");
static_assert(offsetof(ATedVehicle, AudioParam_SpeedPct) == 0x001C00, "Member 'ATedVehicle::AudioParam_SpeedPct' has a wrong offset!");
static_assert(offsetof(ATedVehicle, MovementSound_Idle) == 0x001C30, "Member 'ATedVehicle::MovementSound_Idle' has a wrong offset!");
static_assert(offsetof(ATedVehicle, MovementSound_Loop) == 0x001C38, "Member 'ATedVehicle::MovementSound_Loop' has a wrong offset!");
static_assert(offsetof(ATedVehicle, MovementSound_Start) == 0x001C40, "Member 'ATedVehicle::MovementSound_Start' has a wrong offset!");
static_assert(offsetof(ATedVehicle, MovementSound_Stop) == 0x001C48, "Member 'ATedVehicle::MovementSound_Stop' has a wrong offset!");
static_assert(offsetof(ATedVehicle, bUseDeprecatedMovementSoundPitchRangeApproach) == 0x001C50, "Member 'ATedVehicle::bUseDeprecatedMovementSoundPitchRangeApproach' has a wrong offset!");
static_assert(offsetof(ATedVehicle, MovementSoundPitchRange) == 0x001C58, "Member 'ATedVehicle::MovementSoundPitchRange' has a wrong offset!");
static_assert(offsetof(ATedVehicle, TEMP_CrashInfantrySound) == 0x001C68, "Member 'ATedVehicle::TEMP_CrashInfantrySound' has a wrong offset!");
static_assert(offsetof(ATedVehicle, DeathSound) == 0x001C70, "Member 'ATedVehicle::DeathSound' has a wrong offset!");
static_assert(offsetof(ATedVehicle, FoliageOverlapExtent) == 0x001C78, "Member 'ATedVehicle::FoliageOverlapExtent' has a wrong offset!");
static_assert(offsetof(ATedVehicle, FoliageSpeedPenaltyGE) == 0x001C88, "Member 'ATedVehicle::FoliageSpeedPenaltyGE' has a wrong offset!");
static_assert(offsetof(ATedVehicle, CachedStructureClassToDeploy) == 0x001CB8, "Member 'ATedVehicle::CachedStructureClassToDeploy' has a wrong offset!");

// Class Tempest.TedCursorWidget
// 0x0028 (0x0428 - 0x0400)
class UTedCursorWidget : public UTedUserWidget
{
public:
	class UPanelWidget*                           InnerPanel;                                        // 0x0400(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTedCursorState*>                CursorStates;                                      // 0x0408(0x0010)(ExportObject, ZeroConstructor, Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UImage*                                 Image_Display;                                     // 0x0418(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_Invalid;                                     // 0x0420(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	ESlateVisibility GetNewSoftwareCursorVisibility() const;
	ESlateVisibility GetOldSoftwareCursorVisibility() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCursorWidget">();
	}
	static class UTedCursorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCursorWidget>();
	}
};
static_assert(alignof(UTedCursorWidget) == 0x000008, "Wrong alignment on UTedCursorWidget");
static_assert(sizeof(UTedCursorWidget) == 0x000428, "Wrong size on UTedCursorWidget");
static_assert(offsetof(UTedCursorWidget, InnerPanel) == 0x000400, "Member 'UTedCursorWidget::InnerPanel' has a wrong offset!");
static_assert(offsetof(UTedCursorWidget, CursorStates) == 0x000408, "Member 'UTedCursorWidget::CursorStates' has a wrong offset!");
static_assert(offsetof(UTedCursorWidget, Image_Display) == 0x000418, "Member 'UTedCursorWidget::Image_Display' has a wrong offset!");
static_assert(offsetof(UTedCursorWidget, Image_Invalid) == 0x000420, "Member 'UTedCursorWidget::Image_Invalid' has a wrong offset!");

// Class Tempest.TedAircraft
// 0x0050 (0x1D10 - 0x1CC0)
class ATedAircraft : public ATedVehicle
{
public:
	ETedAircraftFlightState                       CurrentFlightState;                                // 0x1CC0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CC1[0x7];                                     // 0x1CC1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          HitBox;                                            // 0x1CC8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bRearmsAtAirpad : 1;                               // 0x1CD0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1CD1[0x7];                                     // 0x1CD1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AirpadLocationOffset;                              // 0x1CD8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AirpadYawOffset;                                   // 0x1CF0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CF4[0x4];                                     // 0x1CF4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ATedStructureBase*                      ParentAirpad;                                      // 0x1CF8(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D00[0x8];                                     // 0x1D00(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CachedSelectionBoxZOffset;                         // 0x1D08(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RelativeSelectionBoxZOffset;                       // 0x1D0C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_CurrentFlightState();
	void ReceiveAircraftFlightStateChanged(ETedAircraftFlightState NewFlightState);

	void GetBodyTransform(struct FTransform* OutTransform) const;
	class ATedStructureBase* GetCurrentAirpad() const;
	void GetLandingTransform(struct FTransform* OutTransform) const;
	class ATedStructureBase* GetParentAirpad() const;
	bool IsAirborne() const;
	bool IsLanding() const;
	bool IsTakingOff() const;
	bool IsVTOL() const;
	bool RearmsAtAirpad() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAircraft">();
	}
	static class ATedAircraft* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedAircraft>();
	}
};
static_assert(alignof(ATedAircraft) == 0x000010, "Wrong alignment on ATedAircraft");
static_assert(sizeof(ATedAircraft) == 0x001D10, "Wrong size on ATedAircraft");
static_assert(offsetof(ATedAircraft, CurrentFlightState) == 0x001CC0, "Member 'ATedAircraft::CurrentFlightState' has a wrong offset!");
static_assert(offsetof(ATedAircraft, HitBox) == 0x001CC8, "Member 'ATedAircraft::HitBox' has a wrong offset!");
static_assert(offsetof(ATedAircraft, AirpadLocationOffset) == 0x001CD8, "Member 'ATedAircraft::AirpadLocationOffset' has a wrong offset!");
static_assert(offsetof(ATedAircraft, AirpadYawOffset) == 0x001CF0, "Member 'ATedAircraft::AirpadYawOffset' has a wrong offset!");
static_assert(offsetof(ATedAircraft, ParentAirpad) == 0x001CF8, "Member 'ATedAircraft::ParentAirpad' has a wrong offset!");
static_assert(offsetof(ATedAircraft, CachedSelectionBoxZOffset) == 0x001D08, "Member 'ATedAircraft::CachedSelectionBoxZOffset' has a wrong offset!");
static_assert(offsetof(ATedAircraft, RelativeSelectionBoxZOffset) == 0x001D0C, "Member 'ATedAircraft::RelativeSelectionBoxZOffset' has a wrong offset!");

// Class Tempest.TedStructureAirpad
// 0x0050 (0x1A50 - 0x1A00)
class ATedStructureAirpad : public ATedStructureBase
{
public:
	uint8                                         Pad_19F8[0x10];                                    // 0x19F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            AirpadEffect;                                      // 0x1A08(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           AirpadSocketNames;                                 // 0x1A10(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   HTOLSplineTag;                                     // 0x1A20(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceToLandingTolerance;                        // 0x1A28(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A2C[0x4];                                     // 0x1A2C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTedAircraftSlot>               AircraftSlots;                                     // 0x1A30(0x0010)(Net, ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A40[0x10];                                    // 0x1A40(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedStructureAirpad">();
	}
	static class ATedStructureAirpad* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedStructureAirpad>();
	}
};
static_assert(alignof(ATedStructureAirpad) == 0x000010, "Wrong alignment on ATedStructureAirpad");
static_assert(sizeof(ATedStructureAirpad) == 0x001A50, "Wrong size on ATedStructureAirpad");
static_assert(offsetof(ATedStructureAirpad, AirpadEffect) == 0x001A08, "Member 'ATedStructureAirpad::AirpadEffect' has a wrong offset!");
static_assert(offsetof(ATedStructureAirpad, AirpadSocketNames) == 0x001A10, "Member 'ATedStructureAirpad::AirpadSocketNames' has a wrong offset!");
static_assert(offsetof(ATedStructureAirpad, HTOLSplineTag) == 0x001A20, "Member 'ATedStructureAirpad::HTOLSplineTag' has a wrong offset!");
static_assert(offsetof(ATedStructureAirpad, DistanceToLandingTolerance) == 0x001A28, "Member 'ATedStructureAirpad::DistanceToLandingTolerance' has a wrong offset!");
static_assert(offsetof(ATedStructureAirpad, AircraftSlots) == 0x001A30, "Member 'ATedStructureAirpad::AircraftSlots' has a wrong offset!");

// Class Tempest.TedChatPartyDecorator_Badge
// 0x0000 (0x0028 - 0x0028)
class UTedChatPartyDecorator_Badge final : public URichTextBlockDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedChatPartyDecorator_Badge">();
	}
	static class UTedChatPartyDecorator_Badge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedChatPartyDecorator_Badge>();
	}
};
static_assert(alignof(UTedChatPartyDecorator_Badge) == 0x000008, "Wrong alignment on UTedChatPartyDecorator_Badge");
static_assert(sizeof(UTedChatPartyDecorator_Badge) == 0x000028, "Wrong size on UTedChatPartyDecorator_Badge");

// Class Tempest.TedVehicleMovementComponent
// 0x0008 (0x02A8 - 0x02A0)
class UTedVehicleMovementComponent : public UTedUnitMovementComponent
{
public:
	class ATedVehicle*                            VehicleOwner;                                      // 0x02A0(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedVehicleMovementComponent">();
	}
	static class UTedVehicleMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedVehicleMovementComponent>();
	}
};
static_assert(alignof(UTedVehicleMovementComponent) == 0x000008, "Wrong alignment on UTedVehicleMovementComponent");
static_assert(sizeof(UTedVehicleMovementComponent) == 0x0002A8, "Wrong size on UTedVehicleMovementComponent");
static_assert(offsetof(UTedVehicleMovementComponent, VehicleOwner) == 0x0002A0, "Member 'UTedVehicleMovementComponent::VehicleOwner' has a wrong offset!");

// Class Tempest.TedAircraftMovementComponent
// 0x0258 (0x0500 - 0x02A8)
class UTedAircraftMovementComponent final : public UTedVehicleMovementComponent
{
public:
	uint8                                         Pad_2A8[0x18];                                     // 0x02A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bAirborneOnSpawn : 1;                              // 0x02C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxBankAngle;                                      // 0x02C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxPitchAngle;                                     // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BankInterpSpeed;                                   // 0x02CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PitchInterpSpeed;                                  // 0x02D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HigherGroundLevelTraceDistance;                    // 0x02D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTedAbilityBase>            TakeOffAbility;                                    // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LandingTransformLocOffset;                         // 0x02E0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               LandingTransformRotOffset;                         // 0x02F8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bVTOL : 1;                                         // 0x0310(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_311[0x3];                                      // 0x0311(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SplineAnimDelay;                                   // 0x0314(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRuntimeFloatCurve                     TakeOffCurve;                                      // 0x0318(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FRuntimeFloatCurve                     LandingCurve;                                      // 0x03A0(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_428[0x4];                                      // 0x0428(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bIsAirborne : 1;                                   // 0x042C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsLanding : 1;                                    // 0x042C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsTakingOff : 1;                                  // 0x042C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_42D[0x3];                                      // 0x042D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LandingTransform;                                  // 0x0430(0x0060)(Net, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             BodyTransform;                                     // 0x0490(0x0060)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USplineComponent*                       HTOLSpline;                                        // 0x04F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F8[0x8];                                      // 0x04F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_bIsAirborne();
	void SetBodyTransform(const struct FTransform& InTransform);

	void GetBodyTransform(struct FTransform* OutTransform) const;
	class USplineComponent* GetHTOLSpline() const;
	void GetLandingTransform(struct FTransform* OutTransform) const;
	TSubclassOf<class UTedAbilityBase> GetTakeOffAbility() const;
	bool IsAirborne() const;
	bool IsAirborneOnSpawn() const;
	bool IsLanding() const;
	bool IsTakingOff() const;
	bool IsVTOL() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAircraftMovementComponent">();
	}
	static class UTedAircraftMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAircraftMovementComponent>();
	}
};
static_assert(alignof(UTedAircraftMovementComponent) == 0x000010, "Wrong alignment on UTedAircraftMovementComponent");
static_assert(sizeof(UTedAircraftMovementComponent) == 0x000500, "Wrong size on UTedAircraftMovementComponent");
static_assert(offsetof(UTedAircraftMovementComponent, MaxBankAngle) == 0x0002C4, "Member 'UTedAircraftMovementComponent::MaxBankAngle' has a wrong offset!");
static_assert(offsetof(UTedAircraftMovementComponent, MaxPitchAngle) == 0x0002C8, "Member 'UTedAircraftMovementComponent::MaxPitchAngle' has a wrong offset!");
static_assert(offsetof(UTedAircraftMovementComponent, BankInterpSpeed) == 0x0002CC, "Member 'UTedAircraftMovementComponent::BankInterpSpeed' has a wrong offset!");
static_assert(offsetof(UTedAircraftMovementComponent, PitchInterpSpeed) == 0x0002D0, "Member 'UTedAircraftMovementComponent::PitchInterpSpeed' has a wrong offset!");
static_assert(offsetof(UTedAircraftMovementComponent, HigherGroundLevelTraceDistance) == 0x0002D4, "Member 'UTedAircraftMovementComponent::HigherGroundLevelTraceDistance' has a wrong offset!");
static_assert(offsetof(UTedAircraftMovementComponent, TakeOffAbility) == 0x0002D8, "Member 'UTedAircraftMovementComponent::TakeOffAbility' has a wrong offset!");
static_assert(offsetof(UTedAircraftMovementComponent, LandingTransformLocOffset) == 0x0002E0, "Member 'UTedAircraftMovementComponent::LandingTransformLocOffset' has a wrong offset!");
static_assert(offsetof(UTedAircraftMovementComponent, LandingTransformRotOffset) == 0x0002F8, "Member 'UTedAircraftMovementComponent::LandingTransformRotOffset' has a wrong offset!");
static_assert(offsetof(UTedAircraftMovementComponent, SplineAnimDelay) == 0x000314, "Member 'UTedAircraftMovementComponent::SplineAnimDelay' has a wrong offset!");
static_assert(offsetof(UTedAircraftMovementComponent, TakeOffCurve) == 0x000318, "Member 'UTedAircraftMovementComponent::TakeOffCurve' has a wrong offset!");
static_assert(offsetof(UTedAircraftMovementComponent, LandingCurve) == 0x0003A0, "Member 'UTedAircraftMovementComponent::LandingCurve' has a wrong offset!");
static_assert(offsetof(UTedAircraftMovementComponent, LandingTransform) == 0x000430, "Member 'UTedAircraftMovementComponent::LandingTransform' has a wrong offset!");
static_assert(offsetof(UTedAircraftMovementComponent, BodyTransform) == 0x000490, "Member 'UTedAircraftMovementComponent::BodyTransform' has a wrong offset!");
static_assert(offsetof(UTedAircraftMovementComponent, HTOLSpline) == 0x0004F0, "Member 'UTedAircraftMovementComponent::HTOLSpline' has a wrong offset!");

// Class Tempest.TedAirpadInterface
// 0x0000 (0x0000 - 0x0000)
class ITedAirpadInterface final
{
public:
	bool GetAirpadTransform(const class ATedAircraft* Aircraft, struct FTransform* OutTransform) const;
	uint8 GetFreeAirpadId() const;
	class USplineComponent* GetHTOLSpline() const;
	bool GetLandingApproachLocation(const class ATedAircraft* Aircraft, struct FVector* OutLandingApproach) const;
	bool IsParentToAircraft(const class ATedAircraft* Aircraft) const;
	TArray<class ATedAircraft*> K2_GetRegisteredAircraft() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAirpadInterface">();
	}
	static class ITedAirpadInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITedAirpadInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITedAirpadInterface) == 0x000001, "Wrong alignment on ITedAirpadInterface");
static_assert(sizeof(ITedAirpadInterface) == 0x000001, "Wrong size on ITedAirpadInterface");

// Class Tempest.TedStructureCommand_IssueConstruction
// 0x0030 (0x0570 - 0x0540)
class UTedStructureCommand_IssueConstruction : public UTedPawnCommand
{
public:
	TSubclassOf<class UTedPlayerCommand_ConstructionQueue> QueueConstructionCommand;                 // 0x0540(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   UnitToProduce;                                     // 0x0548(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedStructureCommand_IssueConstruction">();
	}
	static class UTedStructureCommand_IssueConstruction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedStructureCommand_IssueConstruction>();
	}
};
static_assert(alignof(UTedStructureCommand_IssueConstruction) == 0x000008, "Wrong alignment on UTedStructureCommand_IssueConstruction");
static_assert(sizeof(UTedStructureCommand_IssueConstruction) == 0x000570, "Wrong size on UTedStructureCommand_IssueConstruction");
static_assert(offsetof(UTedStructureCommand_IssueConstruction, QueueConstructionCommand) == 0x000540, "Member 'UTedStructureCommand_IssueConstruction::QueueConstructionCommand' has a wrong offset!");
static_assert(offsetof(UTedStructureCommand_IssueConstruction, UnitToProduce) == 0x000548, "Member 'UTedStructureCommand_IssueConstruction::UnitToProduce' has a wrong offset!");

// Class Tempest.TedAISystem
// 0x0000 (0x01A0 - 0x01A0)
class UTedAISystem final : public UAISystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAISystem">();
	}
	static class UTedAISystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAISystem>();
	}
};
static_assert(alignof(UTedAISystem) == 0x000008, "Wrong alignment on UTedAISystem");
static_assert(sizeof(UTedAISystem) == 0x0001A0, "Wrong size on UTedAISystem");

// Class Tempest.TedCursorState
// 0x0020 (0x0420 - 0x0400)
class UTedCursorState : public UTedUserWidget
{
public:
	ETedCursorType                                Type;                                              // 0x0400(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_401[0x7];                                      // 0x0401(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedCursorDisplayData                  CursorData;                                        // 0x0408(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)

public:
	static bool CalculateFlipbookParams(class UTexture2D* InTexture, const int32 InDisplaySize, int32* OutColumns, int32* OutRows);

	bool GetCursorAttitude(ERTSAttitudeType* Out) const;
	class APlayerController* GetPlayerController() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCursorState">();
	}
	static class UTedCursorState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCursorState>();
	}
};
static_assert(alignof(UTedCursorState) == 0x000008, "Wrong alignment on UTedCursorState");
static_assert(sizeof(UTedCursorState) == 0x000420, "Wrong size on UTedCursorState");
static_assert(offsetof(UTedCursorState, Type) == 0x000400, "Member 'UTedCursorState::Type' has a wrong offset!");
static_assert(offsetof(UTedCursorState, CursorData) == 0x000408, "Member 'UTedCursorState::CursorData' has a wrong offset!");

// Class Tempest.TedCursorState_Command
// 0x0008 (0x0428 - 0x0420)
class UTedCursorState_Command : public UTedCursorState
{
public:
	int32                                         DisplaySize;                                       // 0x0420(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_424[0x4];                                      // 0x0424(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UTexture2D* GetCommandCursor(const struct FTedCursorDisplayData& InData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCursorState_Command">();
	}
	static class UTedCursorState_Command* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCursorState_Command>();
	}
};
static_assert(alignof(UTedCursorState_Command) == 0x000008, "Wrong alignment on UTedCursorState_Command");
static_assert(sizeof(UTedCursorState_Command) == 0x000428, "Wrong size on UTedCursorState_Command");
static_assert(offsetof(UTedCursorState_Command, DisplaySize) == 0x000420, "Member 'UTedCursorState_Command::DisplaySize' has a wrong offset!");

// Class Tempest.TedAmmoBarsProxyWidget
// 0x0050 (0x0450 - 0x0400)
class UTedAmmoBarsProxyWidget final : public UTedUserWidget
{
public:
	TArray<struct FTedAmmoBarConfig>              Configs;                                           // 0x0400(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              OffsetOnScreen;                                    // 0x0410(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        DataPackingPrecission;                             // 0x0420(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MinDisplayLengthParam;                             // 0x0424(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MaxDisplayLengthParam;                             // 0x042C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DisplayHeightParam;                                // 0x0434(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DataPackingPrecissionParam;                        // 0x043C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_444[0x4];                                      // 0x0444(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedProceduralMeshWidget*               AmmoBarsWidget;                                    // 0x0448(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAmmoBarsProxyWidget">();
	}
	static class UTedAmmoBarsProxyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAmmoBarsProxyWidget>();
	}
};
static_assert(alignof(UTedAmmoBarsProxyWidget) == 0x000008, "Wrong alignment on UTedAmmoBarsProxyWidget");
static_assert(sizeof(UTedAmmoBarsProxyWidget) == 0x000450, "Wrong size on UTedAmmoBarsProxyWidget");
static_assert(offsetof(UTedAmmoBarsProxyWidget, Configs) == 0x000400, "Member 'UTedAmmoBarsProxyWidget::Configs' has a wrong offset!");
static_assert(offsetof(UTedAmmoBarsProxyWidget, OffsetOnScreen) == 0x000410, "Member 'UTedAmmoBarsProxyWidget::OffsetOnScreen' has a wrong offset!");
static_assert(offsetof(UTedAmmoBarsProxyWidget, DataPackingPrecission) == 0x000420, "Member 'UTedAmmoBarsProxyWidget::DataPackingPrecission' has a wrong offset!");
static_assert(offsetof(UTedAmmoBarsProxyWidget, MinDisplayLengthParam) == 0x000424, "Member 'UTedAmmoBarsProxyWidget::MinDisplayLengthParam' has a wrong offset!");
static_assert(offsetof(UTedAmmoBarsProxyWidget, MaxDisplayLengthParam) == 0x00042C, "Member 'UTedAmmoBarsProxyWidget::MaxDisplayLengthParam' has a wrong offset!");
static_assert(offsetof(UTedAmmoBarsProxyWidget, DisplayHeightParam) == 0x000434, "Member 'UTedAmmoBarsProxyWidget::DisplayHeightParam' has a wrong offset!");
static_assert(offsetof(UTedAmmoBarsProxyWidget, DataPackingPrecissionParam) == 0x00043C, "Member 'UTedAmmoBarsProxyWidget::DataPackingPrecissionParam' has a wrong offset!");
static_assert(offsetof(UTedAmmoBarsProxyWidget, AmmoBarsWidget) == 0x000448, "Member 'UTedAmmoBarsProxyWidget::AmmoBarsWidget' has a wrong offset!");

// Class Tempest.TedAmmoVisualActor
// 0x0018 (0x02A8 - 0x0290)
class ATedAmmoVisualActor final : public AActor
{
public:
	bool                                          bRemainsVisibleWhileRecharging;                    // 0x0290(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_291[0x3];                                      // 0x0291(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayCueTag                        RechargeAmmoVisualActorCue;                        // 0x0294(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueTag                        ConsumeAmmoVisualActorCue;                         // 0x029C(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_OnAmmoConsumed();
	void K2_OnAmmoRecharged();
	void K2_OnAmmoRecharging();
	void K2_OnVisibilityChanged(bool bNewVisible);

	bool IsRecharging() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAmmoVisualActor">();
	}
	static class ATedAmmoVisualActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedAmmoVisualActor>();
	}
};
static_assert(alignof(ATedAmmoVisualActor) == 0x000008, "Wrong alignment on ATedAmmoVisualActor");
static_assert(sizeof(ATedAmmoVisualActor) == 0x0002A8, "Wrong size on ATedAmmoVisualActor");
static_assert(offsetof(ATedAmmoVisualActor, bRemainsVisibleWhileRecharging) == 0x000290, "Member 'ATedAmmoVisualActor::bRemainsVisibleWhileRecharging' has a wrong offset!");
static_assert(offsetof(ATedAmmoVisualActor, RechargeAmmoVisualActorCue) == 0x000294, "Member 'ATedAmmoVisualActor::RechargeAmmoVisualActorCue' has a wrong offset!");
static_assert(offsetof(ATedAmmoVisualActor, ConsumeAmmoVisualActorCue) == 0x00029C, "Member 'ATedAmmoVisualActor::ConsumeAmmoVisualActorCue' has a wrong offset!");

// Class Tempest.TedDebugCameraController
// 0x0000 (0x09E8 - 0x09E8)
class ATedDebugCameraController final : public ADebugCameraController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedDebugCameraController">();
	}
	static class ATedDebugCameraController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedDebugCameraController>();
	}
};
static_assert(alignof(ATedDebugCameraController) == 0x000008, "Wrong alignment on ATedDebugCameraController");
static_assert(sizeof(ATedDebugCameraController) == 0x0009E8, "Wrong size on ATedDebugCameraController");

// Class Tempest.TedAnimInstance
// 0x0020 (0x0390 - 0x0370)
#pragma pack(push, 0x1)
class alignas(0x10) UTedAnimInstance : public UAnimInstance
{
public:
	class ATedPawn*                               MyPawn;                                            // 0x0368(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RandStartPos;                                      // 0x0370(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_374[0x4];                                      // 0x0374(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              AimOffsetPct;                                      // 0x0378(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAnimInstance">();
	}
	static class UTedAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UTedAnimInstance) == 0x000010, "Wrong alignment on UTedAnimInstance");
static_assert(sizeof(UTedAnimInstance) == 0x000390, "Wrong size on UTedAnimInstance");
static_assert(offsetof(UTedAnimInstance, MyPawn) == 0x000368, "Member 'UTedAnimInstance::MyPawn' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance, RandStartPos) == 0x000370, "Member 'UTedAnimInstance::RandStartPos' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance, AimOffsetPct) == 0x000378, "Member 'UTedAnimInstance::AimOffsetPct' has a wrong offset!");

// Class Tempest.TedStructureFactoryTypesSlot
// 0x0008 (0x0438 - 0x0430)
class UTedStructureFactoryTypesSlot final : public UTedContentPanelSlotButton
{
public:
	struct FGameplayTag                           content;                                           // 0x0430(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool GetContent(struct FGameplayTag* OutContent) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedStructureFactoryTypesSlot">();
	}
	static class UTedStructureFactoryTypesSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedStructureFactoryTypesSlot>();
	}
};
static_assert(alignof(UTedStructureFactoryTypesSlot) == 0x000008, "Wrong alignment on UTedStructureFactoryTypesSlot");
static_assert(sizeof(UTedStructureFactoryTypesSlot) == 0x000438, "Wrong size on UTedStructureFactoryTypesSlot");
static_assert(offsetof(UTedStructureFactoryTypesSlot, content) == 0x000430, "Member 'UTedStructureFactoryTypesSlot::content' has a wrong offset!");

// Class Tempest.TedAnimInstance_UnitBase
// 0x0020 (0x03B0 - 0x0390)
#pragma pack(push, 0x1)
class alignas(0x10) UTedAnimInstance_UnitBase : public UTedAnimInstance
{
public:
	class ATedUnitBase*                           MyUnit;                                            // 0x0388(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSpeed;                                          // 0x0390(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Speed;                                             // 0x0394(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IsMovingSpeedThreshold;                            // 0x0398(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsMoving : 1;                                     // 0x039C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsFalling : 1;                                    // 0x039C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_39D[0x3];                                      // 0x039D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurningAngle;                                      // 0x03A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A4[0x4];                                      // 0x03A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAnimInstance_UnitBase">();
	}
	static class UTedAnimInstance_UnitBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAnimInstance_UnitBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(UTedAnimInstance_UnitBase) == 0x000010, "Wrong alignment on UTedAnimInstance_UnitBase");
static_assert(sizeof(UTedAnimInstance_UnitBase) == 0x0003B0, "Wrong size on UTedAnimInstance_UnitBase");
static_assert(offsetof(UTedAnimInstance_UnitBase, MyUnit) == 0x000388, "Member 'UTedAnimInstance_UnitBase::MyUnit' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_UnitBase, MaxSpeed) == 0x000390, "Member 'UTedAnimInstance_UnitBase::MaxSpeed' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_UnitBase, Speed) == 0x000394, "Member 'UTedAnimInstance_UnitBase::Speed' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_UnitBase, IsMovingSpeedThreshold) == 0x000398, "Member 'UTedAnimInstance_UnitBase::IsMovingSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_UnitBase, TurningAngle) == 0x0003A0, "Member 'UTedAnimInstance_UnitBase::TurningAngle' has a wrong offset!");

// Class Tempest.TedCustomUpgradeLogic
// 0x0008 (0x0030 - 0x0028)
class UTedCustomUpgradeLogic : public UObject
{
public:
	uint8                                         bCanBeAppliedToPawns : 1;                          // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsAppliedOnPawnDeath : 1;                         // 0x0028(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAppliedOnlyToSourcePawns : 1;                     // 0x0028(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bReapplyOnGameLoad : 1;                            // 0x0028(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bReplicates : 1;                                   // 0x0028(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_ApplyUpgrade(const struct FTedActiveUpgrade& InActiveUpgrade) const;
	bool K2_IsApplicableToPawn(const class ATedPawn* InPawn) const;
	void K2_RemoveUpgrade(const struct FTedActiveUpgrade& InActiveUpgrade) const;
	bool K2_TryApplyToPawn(class ATedPawn* InPawn) const;
	bool K2_TryRemoveFromPawn(class ATedPawn* InPawn) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCustomUpgradeLogic">();
	}
	static class UTedCustomUpgradeLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCustomUpgradeLogic>();
	}
};
static_assert(alignof(UTedCustomUpgradeLogic) == 0x000008, "Wrong alignment on UTedCustomUpgradeLogic");
static_assert(sizeof(UTedCustomUpgradeLogic) == 0x000030, "Wrong size on UTedCustomUpgradeLogic");

// Class Tempest.TedAnimInstance_Aircraft
// 0x0070 (0x0420 - 0x03B0)
class UTedAnimInstance_Aircraft : public UTedAnimInstance_UnitBase
{
public:
	float                                         RotorInterpSpeed;                                  // 0x03A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3AC[0x4];                                      // 0x03AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BodyTransform;                                     // 0x03B0(0x0060)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotorSpeed;                                        // 0x0410(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsAirborne : 1;                                   // 0x0414(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsLanding : 1;                                    // 0x0414(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsTakingOff : 1;                                  // 0x0414(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_415[0x3];                                      // 0x0415(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedAircraftMovementComponent*          MovementComponent;                                 // 0x0418(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAnimInstance_Aircraft">();
	}
	static class UTedAnimInstance_Aircraft* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAnimInstance_Aircraft>();
	}
};
static_assert(alignof(UTedAnimInstance_Aircraft) == 0x000010, "Wrong alignment on UTedAnimInstance_Aircraft");
static_assert(sizeof(UTedAnimInstance_Aircraft) == 0x000420, "Wrong size on UTedAnimInstance_Aircraft");
static_assert(offsetof(UTedAnimInstance_Aircraft, RotorInterpSpeed) == 0x0003A8, "Member 'UTedAnimInstance_Aircraft::RotorInterpSpeed' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_Aircraft, BodyTransform) == 0x0003B0, "Member 'UTedAnimInstance_Aircraft::BodyTransform' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_Aircraft, RotorSpeed) == 0x000410, "Member 'UTedAnimInstance_Aircraft::RotorSpeed' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_Aircraft, MovementComponent) == 0x000418, "Member 'UTedAnimInstance_Aircraft::MovementComponent' has a wrong offset!");

// Class Tempest.TedAnimInstance_Infantry
// 0x01D0 (0x0580 - 0x03B0)
class UTedAnimInstance_Infantry : public UTedAnimInstance_UnitBase
{
public:
	class ATedInfantry*                           MyInfantry;                                        // 0x03A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTedInfantryAnimSet                    DefaultAnimSet;                                    // 0x03B0(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class UTedWeapon>, struct FTedInfantryAnimSet> WeaponAnimSets;                  // 0x0428(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              IdleBreakFrequency;                                // 0x0478(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              IdleBreakPlayRate;                                 // 0x0488(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IdleBreakBlendTime;                                // 0x0498(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49C[0x4];                                      // 0x049C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ShootingIdleBreakFrequency;                        // 0x04A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              ShootingIdleBreakPlayRate;                         // 0x04B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShootingIdleBreakBlendTime;                        // 0x04C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentIdleBreakPlayRate;                          // 0x04C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          CurrentIdleBreak;                                  // 0x04C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          CurrentShootingIdleBreak;                          // 0x04D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          NextShootingIdleBreak;                             // 0x04D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bCanPlayIdleBreak : 1;                             // 0x04E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsPlayingIdleBreak : 1;                           // 0x04E0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_4E1[0x7];                                      // 0x04E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedInfantryAnimSet                    CurrentAnimSet;                                    // 0x04E8(0x0078)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         bIsCrawling : 1;                                   // 0x0560(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsAiming : 1;                                     // 0x0560(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsBlendingShootingIdleBreak : 1;                  // 0x0560(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_561[0x1F];                                     // 0x0561(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAnimInstance_Infantry">();
	}
	static class UTedAnimInstance_Infantry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAnimInstance_Infantry>();
	}
};
static_assert(alignof(UTedAnimInstance_Infantry) == 0x000010, "Wrong alignment on UTedAnimInstance_Infantry");
static_assert(sizeof(UTedAnimInstance_Infantry) == 0x000580, "Wrong size on UTedAnimInstance_Infantry");
static_assert(offsetof(UTedAnimInstance_Infantry, MyInfantry) == 0x0003A8, "Member 'UTedAnimInstance_Infantry::MyInfantry' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_Infantry, DefaultAnimSet) == 0x0003B0, "Member 'UTedAnimInstance_Infantry::DefaultAnimSet' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_Infantry, WeaponAnimSets) == 0x000428, "Member 'UTedAnimInstance_Infantry::WeaponAnimSets' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_Infantry, IdleBreakFrequency) == 0x000478, "Member 'UTedAnimInstance_Infantry::IdleBreakFrequency' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_Infantry, IdleBreakPlayRate) == 0x000488, "Member 'UTedAnimInstance_Infantry::IdleBreakPlayRate' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_Infantry, IdleBreakBlendTime) == 0x000498, "Member 'UTedAnimInstance_Infantry::IdleBreakBlendTime' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_Infantry, ShootingIdleBreakFrequency) == 0x0004A0, "Member 'UTedAnimInstance_Infantry::ShootingIdleBreakFrequency' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_Infantry, ShootingIdleBreakPlayRate) == 0x0004B0, "Member 'UTedAnimInstance_Infantry::ShootingIdleBreakPlayRate' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_Infantry, ShootingIdleBreakBlendTime) == 0x0004C0, "Member 'UTedAnimInstance_Infantry::ShootingIdleBreakBlendTime' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_Infantry, CurrentIdleBreakPlayRate) == 0x0004C4, "Member 'UTedAnimInstance_Infantry::CurrentIdleBreakPlayRate' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_Infantry, CurrentIdleBreak) == 0x0004C8, "Member 'UTedAnimInstance_Infantry::CurrentIdleBreak' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_Infantry, CurrentShootingIdleBreak) == 0x0004D0, "Member 'UTedAnimInstance_Infantry::CurrentShootingIdleBreak' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_Infantry, NextShootingIdleBreak) == 0x0004D8, "Member 'UTedAnimInstance_Infantry::NextShootingIdleBreak' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_Infantry, CurrentAnimSet) == 0x0004E8, "Member 'UTedAnimInstance_Infantry::CurrentAnimSet' has a wrong offset!");

// Class Tempest.TedCursorSettings
// 0x00A8 (0x00E0 - 0x0038)
class UTedCursorSettings final : public UDeveloperSettings
{
public:
	TSoftObjectPtr<class UTedCursorConfig>        DefaultCursor;                                     // 0x0038(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UTedCursorConfig>> DefaultCursorVariant;                             // 0x0060(0x0010)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTedCursorConfig>        SelectionCursor;                                   // 0x0070(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETedCursorType                                UI;                                                // 0x0098(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bForceUIInMenuScreens : 1;                         // 0x0099(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowCmdOnMinimap : 1;                             // 0x0099(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHideInFreeLook : 1;                               // 0x0099(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHideWhenHidingHUD : 1;                            // 0x0099(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	ETedCursorType                                SelectionBox;                                      // 0x009A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETedCursorType                                FullscreenMovie;                                   // 0x009B(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETedCursorType                                Cinematic;                                         // 0x009C(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCinematicCursorIfAnySequencePlaying : 1;          // 0x009D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	struct FTedCursorSelector                     PendingCommand;                                    // 0x009E(0x0005)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FTedCursorSelector                     Default;                                           // 0x00A3(0x0005)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   UseAnimatedTextureParam;                           // 0x00A8(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TextureParam;                                      // 0x00B0(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UseAttitudeParam;                                  // 0x00B8(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttitudeParam;                                     // 0x00C0(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RowsParam;                                         // 0x00C8(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ColumnsParam;                                      // 0x00D0(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AnimDurationParam;                                 // 0x00D8(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCursorSettings">();
	}
	static class UTedCursorSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCursorSettings>();
	}
};
static_assert(alignof(UTedCursorSettings) == 0x000008, "Wrong alignment on UTedCursorSettings");
static_assert(sizeof(UTedCursorSettings) == 0x0000E0, "Wrong size on UTedCursorSettings");
static_assert(offsetof(UTedCursorSettings, DefaultCursor) == 0x000038, "Member 'UTedCursorSettings::DefaultCursor' has a wrong offset!");
static_assert(offsetof(UTedCursorSettings, DefaultCursorVariant) == 0x000060, "Member 'UTedCursorSettings::DefaultCursorVariant' has a wrong offset!");
static_assert(offsetof(UTedCursorSettings, SelectionCursor) == 0x000070, "Member 'UTedCursorSettings::SelectionCursor' has a wrong offset!");
static_assert(offsetof(UTedCursorSettings, UI) == 0x000098, "Member 'UTedCursorSettings::UI' has a wrong offset!");
static_assert(offsetof(UTedCursorSettings, SelectionBox) == 0x00009A, "Member 'UTedCursorSettings::SelectionBox' has a wrong offset!");
static_assert(offsetof(UTedCursorSettings, FullscreenMovie) == 0x00009B, "Member 'UTedCursorSettings::FullscreenMovie' has a wrong offset!");
static_assert(offsetof(UTedCursorSettings, Cinematic) == 0x00009C, "Member 'UTedCursorSettings::Cinematic' has a wrong offset!");
static_assert(offsetof(UTedCursorSettings, PendingCommand) == 0x00009E, "Member 'UTedCursorSettings::PendingCommand' has a wrong offset!");
static_assert(offsetof(UTedCursorSettings, Default) == 0x0000A3, "Member 'UTedCursorSettings::Default' has a wrong offset!");
static_assert(offsetof(UTedCursorSettings, UseAnimatedTextureParam) == 0x0000A8, "Member 'UTedCursorSettings::UseAnimatedTextureParam' has a wrong offset!");
static_assert(offsetof(UTedCursorSettings, TextureParam) == 0x0000B0, "Member 'UTedCursorSettings::TextureParam' has a wrong offset!");
static_assert(offsetof(UTedCursorSettings, UseAttitudeParam) == 0x0000B8, "Member 'UTedCursorSettings::UseAttitudeParam' has a wrong offset!");
static_assert(offsetof(UTedCursorSettings, AttitudeParam) == 0x0000C0, "Member 'UTedCursorSettings::AttitudeParam' has a wrong offset!");
static_assert(offsetof(UTedCursorSettings, RowsParam) == 0x0000C8, "Member 'UTedCursorSettings::RowsParam' has a wrong offset!");
static_assert(offsetof(UTedCursorSettings, ColumnsParam) == 0x0000D0, "Member 'UTedCursorSettings::ColumnsParam' has a wrong offset!");
static_assert(offsetof(UTedCursorSettings, AnimDurationParam) == 0x0000D8, "Member 'UTedCursorSettings::AnimDurationParam' has a wrong offset!");

// Class Tempest.TedAnimInstance_Structure
// 0x00A0 (0x0430 - 0x0390)
class UTedAnimInstance_Structure : public UTedAnimInstance
{
public:
	class ATedStructureBase*                      MyStructure;                                       // 0x0388(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bLowPower : 1;                                     // 0x0390(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPowered : 1;                                      // 0x0390(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSupportsConstruction : 1;                         // 0x0390(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSupportsFinishingConstruction : 1;                // 0x0390(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bFinishingConstructionAnimStopsOtherMontages : 1;  // 0x0390(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bConstructing : 1;                                 // 0x0390(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bConstructionPaused : 1;                           // 0x0390(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDeconstructing : 1;                               // 0x0390(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPlayingFinishingConstructionAnim : 1;             // 0x0391(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_392[0x2];                                      // 0x0392(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConstructionPlayRateDefault;                       // 0x0394(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ConstructionPlayRatePaused;                        // 0x0398(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ConstructionPlayRateLowPower;                      // 0x039C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ConstructionPlayRateChangeSpeed;                   // 0x03A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ConstructionPlayRate;                              // 0x03A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bConstructionPlayRateOverride;                     // 0x03A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A9[0x3];                                      // 0x03A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConstructionPlayRateOverride;                      // 0x03AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ConstructionPlayRateTarget;                        // 0x03B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FinishingConstructionThreshold;                    // 0x03B4(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           FinishingConstructionAnim;                         // 0x03B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<struct FTedConstructionElementType>      FinishingConstructions;                            // 0x03C0(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	uint8                                         bHasUpgrade1 : 1;                                  // 0x0410(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHasUpgrade2 : 1;                                  // 0x0410(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	ETedStructureAlignment                        Alignment;                                         // 0x0411(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_412[0x6];                                      // 0x0412(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               AlignmentRotation;                                 // 0x0418(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void PlayFinishingConstruction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAnimInstance_Structure">();
	}
	static class UTedAnimInstance_Structure* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAnimInstance_Structure>();
	}
};
static_assert(alignof(UTedAnimInstance_Structure) == 0x000010, "Wrong alignment on UTedAnimInstance_Structure");
static_assert(sizeof(UTedAnimInstance_Structure) == 0x000430, "Wrong size on UTedAnimInstance_Structure");
static_assert(offsetof(UTedAnimInstance_Structure, MyStructure) == 0x000388, "Member 'UTedAnimInstance_Structure::MyStructure' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_Structure, ConstructionPlayRateDefault) == 0x000394, "Member 'UTedAnimInstance_Structure::ConstructionPlayRateDefault' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_Structure, ConstructionPlayRatePaused) == 0x000398, "Member 'UTedAnimInstance_Structure::ConstructionPlayRatePaused' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_Structure, ConstructionPlayRateLowPower) == 0x00039C, "Member 'UTedAnimInstance_Structure::ConstructionPlayRateLowPower' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_Structure, ConstructionPlayRateChangeSpeed) == 0x0003A0, "Member 'UTedAnimInstance_Structure::ConstructionPlayRateChangeSpeed' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_Structure, ConstructionPlayRate) == 0x0003A4, "Member 'UTedAnimInstance_Structure::ConstructionPlayRate' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_Structure, bConstructionPlayRateOverride) == 0x0003A8, "Member 'UTedAnimInstance_Structure::bConstructionPlayRateOverride' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_Structure, ConstructionPlayRateOverride) == 0x0003AC, "Member 'UTedAnimInstance_Structure::ConstructionPlayRateOverride' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_Structure, ConstructionPlayRateTarget) == 0x0003B0, "Member 'UTedAnimInstance_Structure::ConstructionPlayRateTarget' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_Structure, FinishingConstructionThreshold) == 0x0003B4, "Member 'UTedAnimInstance_Structure::FinishingConstructionThreshold' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_Structure, FinishingConstructionAnim) == 0x0003B8, "Member 'UTedAnimInstance_Structure::FinishingConstructionAnim' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_Structure, FinishingConstructions) == 0x0003C0, "Member 'UTedAnimInstance_Structure::FinishingConstructions' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_Structure, Alignment) == 0x000411, "Member 'UTedAnimInstance_Structure::Alignment' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_Structure, AlignmentRotation) == 0x000418, "Member 'UTedAnimInstance_Structure::AlignmentRotation' has a wrong offset!");

// Class Tempest.TedSavedGameSlotData
// 0x00A0 (0x02A8 - 0x0208)
class UTedSavedGameSlotData final : public USavedGameSlotData
{
public:
	TMap<ETedPlayerID, struct FGuid>              PlayerStateGuids;                                  // 0x0208(0x0050)(SaveGame, Protected, NativeAccessSpecifierProtected)
	TMap<ETedPlayerID, struct FGuid>              BotPlayerControllerGuids;                          // 0x0258(0x0050)(SaveGame, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSavedGameSlotData">();
	}
	static class UTedSavedGameSlotData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSavedGameSlotData>();
	}
};
static_assert(alignof(UTedSavedGameSlotData) == 0x000008, "Wrong alignment on UTedSavedGameSlotData");
static_assert(sizeof(UTedSavedGameSlotData) == 0x0002A8, "Wrong size on UTedSavedGameSlotData");
static_assert(offsetof(UTedSavedGameSlotData, PlayerStateGuids) == 0x000208, "Member 'UTedSavedGameSlotData::PlayerStateGuids' has a wrong offset!");
static_assert(offsetof(UTedSavedGameSlotData, BotPlayerControllerGuids) == 0x000258, "Member 'UTedSavedGameSlotData::BotPlayerControllerGuids' has a wrong offset!");

// Class Tempest.TedAnimInstance_Vehicle
// 0x0020 (0x03D0 - 0x03B0)
class UTedAnimInstance_Vehicle : public UTedAnimInstance_UnitBase
{
public:
	class ATedVehicle*                            MyVehicle;                                         // 0x03A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MoveAnimAlphaRange;                                // 0x03B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveAnimAlphaInterpSpeed;                          // 0x03C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveAnimAlpha;                                     // 0x03C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C8[0x8];                                      // 0x03C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAnimInstance_Vehicle">();
	}
	static class UTedAnimInstance_Vehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAnimInstance_Vehicle>();
	}
};
static_assert(alignof(UTedAnimInstance_Vehicle) == 0x000010, "Wrong alignment on UTedAnimInstance_Vehicle");
static_assert(sizeof(UTedAnimInstance_Vehicle) == 0x0003D0, "Wrong size on UTedAnimInstance_Vehicle");
static_assert(offsetof(UTedAnimInstance_Vehicle, MyVehicle) == 0x0003A8, "Member 'UTedAnimInstance_Vehicle::MyVehicle' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_Vehicle, MoveAnimAlphaRange) == 0x0003B0, "Member 'UTedAnimInstance_Vehicle::MoveAnimAlphaRange' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_Vehicle, MoveAnimAlphaInterpSpeed) == 0x0003C0, "Member 'UTedAnimInstance_Vehicle::MoveAnimAlphaInterpSpeed' has a wrong offset!");
static_assert(offsetof(UTedAnimInstance_Vehicle, MoveAnimAlpha) == 0x0003C4, "Member 'UTedAnimInstance_Vehicle::MoveAnimAlpha' has a wrong offset!");

// Class Tempest.TedDamageType
// 0x0058 (0x0098 - 0x0040)
class UTedDamageType : public UDamageType
{
public:
	uint8                                         bIgnoresResistances : 1;                           // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPenetratesContainers : 1;                         // 0x0040(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDealsFatalDamageToContainers : 1;                 // 0x0040(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAttribute                     RelevantResistAttribute;                           // 0x0048(0x0038)(Edit, BlueprintReadOnly, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayCueTag                        GameplayCueTag;                                    // 0x0080(0x0008)(Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FText                                   DisplayName;                                       // 0x0088(0x0010)(Edit, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	const struct FGameplayCueTag GetGameplayCueTag() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedDamageType">();
	}
	static class UTedDamageType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedDamageType>();
	}
};
static_assert(alignof(UTedDamageType) == 0x000008, "Wrong alignment on UTedDamageType");
static_assert(sizeof(UTedDamageType) == 0x000098, "Wrong size on UTedDamageType");
static_assert(offsetof(UTedDamageType, RelevantResistAttribute) == 0x000048, "Member 'UTedDamageType::RelevantResistAttribute' has a wrong offset!");
static_assert(offsetof(UTedDamageType, GameplayCueTag) == 0x000080, "Member 'UTedDamageType::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(UTedDamageType, DisplayName) == 0x000088, "Member 'UTedDamageType::DisplayName' has a wrong offset!");

// Class Tempest.TedDamageType_ForceKill
// 0x0000 (0x0098 - 0x0098)
class UTedDamageType_ForceKill final : public UTedDamageType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedDamageType_ForceKill">();
	}
	static class UTedDamageType_ForceKill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedDamageType_ForceKill>();
	}
};
static_assert(alignof(UTedDamageType_ForceKill) == 0x000008, "Wrong alignment on UTedDamageType_ForceKill");
static_assert(sizeof(UTedDamageType_ForceKill) == 0x000098, "Wrong size on UTedDamageType_ForceKill");

// Class Tempest.TedAnimNotifyState_PlaySound
// 0x0028 (0x0058 - 0x0030)
class UTedAnimNotifyState_PlaySound final : public UAnimNotifyState
{
public:
	class USoundBase*                             Sound;                                             // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachName;                                        // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideSoundSettings;                            // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VolumeMultiplier;                                  // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFadeOut;                                          // 0x004C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeTime;                                          // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAnimNotifyState_PlaySound">();
	}
	static class UTedAnimNotifyState_PlaySound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAnimNotifyState_PlaySound>();
	}
};
static_assert(alignof(UTedAnimNotifyState_PlaySound) == 0x000008, "Wrong alignment on UTedAnimNotifyState_PlaySound");
static_assert(sizeof(UTedAnimNotifyState_PlaySound) == 0x000058, "Wrong size on UTedAnimNotifyState_PlaySound");
static_assert(offsetof(UTedAnimNotifyState_PlaySound, Sound) == 0x000030, "Member 'UTedAnimNotifyState_PlaySound::Sound' has a wrong offset!");
static_assert(offsetof(UTedAnimNotifyState_PlaySound, AttachName) == 0x000038, "Member 'UTedAnimNotifyState_PlaySound::AttachName' has a wrong offset!");
static_assert(offsetof(UTedAnimNotifyState_PlaySound, bOverrideSoundSettings) == 0x000040, "Member 'UTedAnimNotifyState_PlaySound::bOverrideSoundSettings' has a wrong offset!");
static_assert(offsetof(UTedAnimNotifyState_PlaySound, VolumeMultiplier) == 0x000044, "Member 'UTedAnimNotifyState_PlaySound::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(UTedAnimNotifyState_PlaySound, PitchMultiplier) == 0x000048, "Member 'UTedAnimNotifyState_PlaySound::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(UTedAnimNotifyState_PlaySound, bFadeOut) == 0x00004C, "Member 'UTedAnimNotifyState_PlaySound::bFadeOut' has a wrong offset!");
static_assert(offsetof(UTedAnimNotifyState_PlaySound, FadeTime) == 0x000050, "Member 'UTedAnimNotifyState_PlaySound::FadeTime' has a wrong offset!");

// Class Tempest.TedAnimNotifyState_TimedFXSystem_MuzzleFlash
// 0x0000 (0x0080 - 0x0080)
class UTedAnimNotifyState_TimedFXSystem_MuzzleFlash final : public UAnimNotifyState_TimedFXSystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAnimNotifyState_TimedFXSystem_MuzzleFlash">();
	}
	static class UTedAnimNotifyState_TimedFXSystem_MuzzleFlash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAnimNotifyState_TimedFXSystem_MuzzleFlash>();
	}
};
static_assert(alignof(UTedAnimNotifyState_TimedFXSystem_MuzzleFlash) == 0x000008, "Wrong alignment on UTedAnimNotifyState_TimedFXSystem_MuzzleFlash");
static_assert(sizeof(UTedAnimNotifyState_TimedFXSystem_MuzzleFlash) == 0x000080, "Wrong size on UTedAnimNotifyState_TimedFXSystem_MuzzleFlash");

// Class Tempest.TedDifficultyLibrary
// 0x0000 (0x0028 - 0x0028)
class UTedDifficultyLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void DelayWithDifficulty(const class UObject* WorldContextObject, float Duration, class FName MultiplierPreset, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& LatentSaveGameData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedDifficultyLibrary">();
	}
	static class UTedDifficultyLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedDifficultyLibrary>();
	}
};
static_assert(alignof(UTedDifficultyLibrary) == 0x000008, "Wrong alignment on UTedDifficultyLibrary");
static_assert(sizeof(UTedDifficultyLibrary) == 0x000028, "Wrong size on UTedDifficultyLibrary");

// Class Tempest.TedAnimNotify_ConstructionDrill
// 0x0010 (0x0048 - 0x0038)
class UTedAnimNotify_ConstructionDrill final : public UAnimNotify
{
public:
	class USkeletalMesh*                          DrillMesh;                                         // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           DrillAnimation;                                    // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAnimNotify_ConstructionDrill">();
	}
	static class UTedAnimNotify_ConstructionDrill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAnimNotify_ConstructionDrill>();
	}
};
static_assert(alignof(UTedAnimNotify_ConstructionDrill) == 0x000008, "Wrong alignment on UTedAnimNotify_ConstructionDrill");
static_assert(sizeof(UTedAnimNotify_ConstructionDrill) == 0x000048, "Wrong size on UTedAnimNotify_ConstructionDrill");
static_assert(offsetof(UTedAnimNotify_ConstructionDrill, DrillMesh) == 0x000038, "Member 'UTedAnimNotify_ConstructionDrill::DrillMesh' has a wrong offset!");
static_assert(offsetof(UTedAnimNotify_ConstructionDrill, DrillAnimation) == 0x000040, "Member 'UTedAnimNotify_ConstructionDrill::DrillAnimation' has a wrong offset!");

// Class Tempest.TedSaveLoadMenuScreen
// 0x0020 (0x0420 - 0x0400)
class UTedSaveLoadMenuScreen : public UTedUserWidget
{
public:
	TMulticastInlineDelegate<void(bool bSuccess)> OnSaveSlotDeletedDelegate;                         // 0x0400(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bSelectFirstSaveOnRefresh;                         // 0x0410(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_411[0x7];                                      // 0x0411(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedSaveLoadContentPanel*               SaveLoadPanel;                                     // 0x0418(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void GoBack();
	void OnMenuVisibilityChanged(ESlateVisibility NewVisibility);
	void OnPopupDeleteSlotButtonClicked();
	bool WillHandleGoBackEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSaveLoadMenuScreen">();
	}
	static class UTedSaveLoadMenuScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSaveLoadMenuScreen>();
	}
};
static_assert(alignof(UTedSaveLoadMenuScreen) == 0x000008, "Wrong alignment on UTedSaveLoadMenuScreen");
static_assert(sizeof(UTedSaveLoadMenuScreen) == 0x000420, "Wrong size on UTedSaveLoadMenuScreen");
static_assert(offsetof(UTedSaveLoadMenuScreen, OnSaveSlotDeletedDelegate) == 0x000400, "Member 'UTedSaveLoadMenuScreen::OnSaveSlotDeletedDelegate' has a wrong offset!");
static_assert(offsetof(UTedSaveLoadMenuScreen, bSelectFirstSaveOnRefresh) == 0x000410, "Member 'UTedSaveLoadMenuScreen::bSelectFirstSaveOnRefresh' has a wrong offset!");
static_assert(offsetof(UTedSaveLoadMenuScreen, SaveLoadPanel) == 0x000418, "Member 'UTedSaveLoadMenuScreen::SaveLoadPanel' has a wrong offset!");

// Class Tempest.TedAnimNotify_ConstructionSite
// 0x0008 (0x0040 - 0x0038)
class UTedAnimNotify_ConstructionSite final : public UAnimNotify
{
public:
	ETedConstructionSiteAnimNotify                Type;                                              // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAnimNotify_ConstructionSite">();
	}
	static class UTedAnimNotify_ConstructionSite* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAnimNotify_ConstructionSite>();
	}
};
static_assert(alignof(UTedAnimNotify_ConstructionSite) == 0x000008, "Wrong alignment on UTedAnimNotify_ConstructionSite");
static_assert(sizeof(UTedAnimNotify_ConstructionSite) == 0x000040, "Wrong size on UTedAnimNotify_ConstructionSite");
static_assert(offsetof(UTedAnimNotify_ConstructionSite, Type) == 0x000038, "Member 'UTedAnimNotify_ConstructionSite::Type' has a wrong offset!");

// Class Tempest.TedDefinitionPanel
// 0x0018 (0x07C8 - 0x07B0)
class UTedDefinitionPanel : public UTedContentPanelDynamic
{
public:
	TArray<struct FTedDefinitionRef>              content;                                           // 0x07B0(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	class ATedPlayerState*                        DefinitionContext;                                 // 0x07C0(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void K2_SetContent(const TArray<class UTedDefinitionAsset*>& InContent);
	void K2_SetContentAndContext(const TArray<class UTedDefinitionAsset*>& InContent, class ATedPlayerState* InContext);
	void SetDefinitionContext(class ATedPlayerState* InContext);

	const class UTedDefinitionAsset* GetContentDefinition(const int32 InSlotIndex) const;
	class FText GetContentDescription(const int32 InSlotIndex) const;
	const class FText GetContentDisplayName(const int32 InSlotIndex) const;
	class UTexture2D* GetContentIcon(const int32 InSlotIndex) const;
	class ATedPlayerState* GetDefinitionContext() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedDefinitionPanel">();
	}
	static class UTedDefinitionPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedDefinitionPanel>();
	}
};
static_assert(alignof(UTedDefinitionPanel) == 0x000008, "Wrong alignment on UTedDefinitionPanel");
static_assert(sizeof(UTedDefinitionPanel) == 0x0007C8, "Wrong size on UTedDefinitionPanel");
static_assert(offsetof(UTedDefinitionPanel, content) == 0x0007B0, "Member 'UTedDefinitionPanel::content' has a wrong offset!");
static_assert(offsetof(UTedDefinitionPanel, DefinitionContext) == 0x0007C0, "Member 'UTedDefinitionPanel::DefinitionContext' has a wrong offset!");

// Class Tempest.TedAnimNotify_PlayFXSystem_MuzzleFlash
// 0x0000 (0x00D0 - 0x00D0)
class UTedAnimNotify_PlayFXSystem_MuzzleFlash final : public UAnimNotify_PlayFXSystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAnimNotify_PlayFXSystem_MuzzleFlash">();
	}
	static class UTedAnimNotify_PlayFXSystem_MuzzleFlash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAnimNotify_PlayFXSystem_MuzzleFlash>();
	}
};
static_assert(alignof(UTedAnimNotify_PlayFXSystem_MuzzleFlash) == 0x000010, "Wrong alignment on UTedAnimNotify_PlayFXSystem_MuzzleFlash");
static_assert(sizeof(UTedAnimNotify_PlayFXSystem_MuzzleFlash) == 0x0000D0, "Wrong size on UTedAnimNotify_PlayFXSystem_MuzzleFlash");

// Class Tempest.TedAnimNotify_PlaySound
// 0x0008 (0x0060 - 0x0058)
class UTedAnimNotify_PlaySound final : public UAnimNotify_PlaySound
{
public:
	uint8                                         bPlayOnDedicatedServer : 1;                        // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAnimNotify_PlaySound">();
	}
	static class UTedAnimNotify_PlaySound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAnimNotify_PlaySound>();
	}
};
static_assert(alignof(UTedAnimNotify_PlaySound) == 0x000008, "Wrong alignment on UTedAnimNotify_PlaySound");
static_assert(sizeof(UTedAnimNotify_PlaySound) == 0x000060, "Wrong size on UTedAnimNotify_PlaySound");

// Class Tempest.TedDamageType_Cinematic
// 0x0000 (0x0098 - 0x0098)
class UTedDamageType_Cinematic final : public UTedDamageType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedDamageType_Cinematic">();
	}
	static class UTedDamageType_Cinematic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedDamageType_Cinematic>();
	}
};
static_assert(alignof(UTedDamageType_Cinematic) == 0x000008, "Wrong alignment on UTedDamageType_Cinematic");
static_assert(sizeof(UTedDamageType_Cinematic) == 0x000098, "Wrong size on UTedDamageType_Cinematic");

// Class Tempest.TedAnnouncement
// 0x0098 (0x00C0 - 0x0028)
class UTedAnnouncement : public UObject
{
public:
	struct FAnnouncementData                      AnnouncementData;                                  // 0x0028(0x0060)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTedAnnouncementMarker>         Markers;                                           // 0x0088(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTedHotspotConfig>       HotspotConfigAsset;                                // 0x0098(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnAnnouncementPlay(const class ATedPlayerController* OwningPC, const class UObject* OptionalObject) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAnnouncement">();
	}
	static class UTedAnnouncement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAnnouncement>();
	}
};
static_assert(alignof(UTedAnnouncement) == 0x000008, "Wrong alignment on UTedAnnouncement");
static_assert(sizeof(UTedAnnouncement) == 0x0000C0, "Wrong size on UTedAnnouncement");
static_assert(offsetof(UTedAnnouncement, AnnouncementData) == 0x000028, "Member 'UTedAnnouncement::AnnouncementData' has a wrong offset!");
static_assert(offsetof(UTedAnnouncement, Markers) == 0x000088, "Member 'UTedAnnouncement::Markers' has a wrong offset!");
static_assert(offsetof(UTedAnnouncement, HotspotConfigAsset) == 0x000098, "Member 'UTedAnnouncement::HotspotConfigAsset' has a wrong offset!");

// Class Tempest.TedScoreScreenHeadersPanel
// 0x0018 (0x07C8 - 0x07B0)
class UTedScoreScreenHeadersPanel : public UTedContentPanelDynamic
{
public:
	TArray<struct FTedTableHeaderContent>         content;                                           // 0x07B0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bSortingEnabled : 1;                               // 0x07C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_7C1[0x7];                                      // 0x07C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetContent(const int32 InSlotIndex, struct FTedTableHeaderContent* OutContent) const;
	bool GetContentByState(const ETedContentSlotState InState, const int32 InIndex, struct FTedTableHeaderContent* OutContent) const;
	bool IsSorting() const;
	bool IsSortingEnabled() const;
	bool IsSortingInAscendingOrder() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedScoreScreenHeadersPanel">();
	}
	static class UTedScoreScreenHeadersPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedScoreScreenHeadersPanel>();
	}
};
static_assert(alignof(UTedScoreScreenHeadersPanel) == 0x000008, "Wrong alignment on UTedScoreScreenHeadersPanel");
static_assert(sizeof(UTedScoreScreenHeadersPanel) == 0x0007C8, "Wrong size on UTedScoreScreenHeadersPanel");
static_assert(offsetof(UTedScoreScreenHeadersPanel, content) == 0x0007B0, "Member 'UTedScoreScreenHeadersPanel::content' has a wrong offset!");

// Class Tempest.TedAnnouncer
// 0x00F8 (0x0120 - 0x0028)
class UTedAnnouncer final : public UObject
{
public:
	class UAudioComponent*                        AudioComponent;                                    // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAnnouncement                          CurrentAnnouncement;                               // 0x0030(0x0020)(SaveGame, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAnnouncement>                  AnnouncementQueue;                                 // 0x0050(0x0010)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	TMap<class UTedAnnouncement*, float>          AnnouncementsLastPlayedTimes;                      // 0x0060(0x0050)(SaveGame, Protected, NativeAccessSpecifierProtected)
	ETedFaction                                   OwningFaction;                                     // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B1[0xF];                                       // 0x00B1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAnnouncement>                  SilentAnnouncements;                               // 0x00C0(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPrivate)
	TMap<struct FAnnouncementHandle, struct FTimerHandle> AutoDeleteSilentAnnouncementTimerHandles;  // 0x00D0(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	void OnAnnouncementFinished();
	void StartNextAnnouncement(bool bUseSpacing, const bool bSilent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAnnouncer">();
	}
	static class UTedAnnouncer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAnnouncer>();
	}
};
static_assert(alignof(UTedAnnouncer) == 0x000008, "Wrong alignment on UTedAnnouncer");
static_assert(sizeof(UTedAnnouncer) == 0x000120, "Wrong size on UTedAnnouncer");
static_assert(offsetof(UTedAnnouncer, AudioComponent) == 0x000028, "Member 'UTedAnnouncer::AudioComponent' has a wrong offset!");
static_assert(offsetof(UTedAnnouncer, CurrentAnnouncement) == 0x000030, "Member 'UTedAnnouncer::CurrentAnnouncement' has a wrong offset!");
static_assert(offsetof(UTedAnnouncer, AnnouncementQueue) == 0x000050, "Member 'UTedAnnouncer::AnnouncementQueue' has a wrong offset!");
static_assert(offsetof(UTedAnnouncer, AnnouncementsLastPlayedTimes) == 0x000060, "Member 'UTedAnnouncer::AnnouncementsLastPlayedTimes' has a wrong offset!");
static_assert(offsetof(UTedAnnouncer, OwningFaction) == 0x0000B0, "Member 'UTedAnnouncer::OwningFaction' has a wrong offset!");
static_assert(offsetof(UTedAnnouncer, SilentAnnouncements) == 0x0000C0, "Member 'UTedAnnouncer::SilentAnnouncements' has a wrong offset!");
static_assert(offsetof(UTedAnnouncer, AutoDeleteSilentAnnouncementTimerHandles) == 0x0000D0, "Member 'UTedAnnouncer::AutoDeleteSilentAnnouncementTimerHandles' has a wrong offset!");

// Class Tempest.TedDestructible
// 0x0040 (0x16F0 - 0x16B0)
class ATedDestructible : public ATedPawn
{
public:
	TArray<struct FOffsetCoords>                  OccupiedCoords;                                    // 0x16A8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         DeathEventsDelay;                                  // 0x16B8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16BC[0x4];                                     // 0x16BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x16C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZOffset;                                           // 0x16C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseDamageCauserForDeathDamage;                    // 0x16CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16CD[0x3];                                     // 0x16CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            LastKiller;                                        // 0x16D0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 LastDamageCauser;                                  // 0x16D8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16E0[0x10];                                    // 0x16E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedDestructible">();
	}
	static class ATedDestructible* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedDestructible>();
	}
};
static_assert(alignof(ATedDestructible) == 0x000010, "Wrong alignment on ATedDestructible");
static_assert(sizeof(ATedDestructible) == 0x0016F0, "Wrong size on ATedDestructible");
static_assert(offsetof(ATedDestructible, OccupiedCoords) == 0x0016A8, "Member 'ATedDestructible::OccupiedCoords' has a wrong offset!");
static_assert(offsetof(ATedDestructible, DeathEventsDelay) == 0x0016B8, "Member 'ATedDestructible::DeathEventsDelay' has a wrong offset!");
static_assert(offsetof(ATedDestructible, CapsuleComponent) == 0x0016C0, "Member 'ATedDestructible::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(ATedDestructible, ZOffset) == 0x0016C8, "Member 'ATedDestructible::ZOffset' has a wrong offset!");
static_assert(offsetof(ATedDestructible, bUseDamageCauserForDeathDamage) == 0x0016CC, "Member 'ATedDestructible::bUseDamageCauserForDeathDamage' has a wrong offset!");
static_assert(offsetof(ATedDestructible, LastKiller) == 0x0016D0, "Member 'ATedDestructible::LastKiller' has a wrong offset!");
static_assert(offsetof(ATedDestructible, LastDamageCauser) == 0x0016D8, "Member 'ATedDestructible::LastDamageCauser' has a wrong offset!");

// Class Tempest.TedCommandPreviewActor
// 0x0000 (0x0368 - 0x0368)
class ATedCommandPreviewActor : public AGameplayCommandPreviewActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandPreviewActor">();
	}
	static class ATedCommandPreviewActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedCommandPreviewActor>();
	}
};
static_assert(alignof(ATedCommandPreviewActor) == 0x000008, "Wrong alignment on ATedCommandPreviewActor");
static_assert(sizeof(ATedCommandPreviewActor) == 0x000368, "Wrong size on ATedCommandPreviewActor");

// Class Tempest.TedPawnCommandPreviewActor
// 0x00F0 (0x0458 - 0x0368)
class ATedPawnCommandPreviewActor : public ATedCommandPreviewActor
{
public:
	TMap<class UFXSystemComponent*, class AActor*> BeamIndicatorTargets;                             // 0x0368(0x0050)(Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bShowOnlyForPrimarySelected;                       // 0x03B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B9[0x3];                                      // 0x03B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FXNormalParamName;                                 // 0x03BC(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FXSizeParamName;                                   // 0x03C4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3CC[0x4];                                      // 0x03CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFXSystemAsset*                         BeamIdicatorTemplate;                              // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           BeamColor;                                         // 0x03D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BeamColorParameterName;                            // 0x03E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BeamIdicatorSourceParamaterName;                   // 0x03F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BeamIdicatorTargetParamaterName;                   // 0x03F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayCommandID                     CachedCommandID;                                   // 0x0400(0x0002)(Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_402[0x56];                                     // 0x0402(0x0056)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommandPreviewActor">();
	}
	static class ATedPawnCommandPreviewActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedPawnCommandPreviewActor>();
	}
};
static_assert(alignof(ATedPawnCommandPreviewActor) == 0x000008, "Wrong alignment on ATedPawnCommandPreviewActor");
static_assert(sizeof(ATedPawnCommandPreviewActor) == 0x000458, "Wrong size on ATedPawnCommandPreviewActor");
static_assert(offsetof(ATedPawnCommandPreviewActor, BeamIndicatorTargets) == 0x000368, "Member 'ATedPawnCommandPreviewActor::BeamIndicatorTargets' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreviewActor, bShowOnlyForPrimarySelected) == 0x0003B8, "Member 'ATedPawnCommandPreviewActor::bShowOnlyForPrimarySelected' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreviewActor, FXNormalParamName) == 0x0003BC, "Member 'ATedPawnCommandPreviewActor::FXNormalParamName' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreviewActor, FXSizeParamName) == 0x0003C4, "Member 'ATedPawnCommandPreviewActor::FXSizeParamName' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreviewActor, BeamIdicatorTemplate) == 0x0003D0, "Member 'ATedPawnCommandPreviewActor::BeamIdicatorTemplate' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreviewActor, BeamColor) == 0x0003D8, "Member 'ATedPawnCommandPreviewActor::BeamColor' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreviewActor, BeamColorParameterName) == 0x0003E8, "Member 'ATedPawnCommandPreviewActor::BeamColorParameterName' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreviewActor, BeamIdicatorSourceParamaterName) == 0x0003F0, "Member 'ATedPawnCommandPreviewActor::BeamIdicatorSourceParamaterName' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreviewActor, BeamIdicatorTargetParamaterName) == 0x0003F8, "Member 'ATedPawnCommandPreviewActor::BeamIdicatorTargetParamaterName' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreviewActor, CachedCommandID) == 0x000400, "Member 'ATedPawnCommandPreviewActor::CachedCommandID' has a wrong offset!");

// Class Tempest.TedDoctrineTreeDefinition
// 0x0038 (0x0068 - 0x0030)
class UTedDoctrineTreeDefinition final : public UDataAsset
{
public:
	class UTexture2D*                             Icon;                                              // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   Title;                                             // 0x0038(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)
	class FText                                   Description;                                       // 0x0048(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<class UTedDoctrineDefinition*>         Doctrines;                                         // 0x0058(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedDoctrineTreeDefinition">();
	}
	static class UTedDoctrineTreeDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedDoctrineTreeDefinition>();
	}
};
static_assert(alignof(UTedDoctrineTreeDefinition) == 0x000008, "Wrong alignment on UTedDoctrineTreeDefinition");
static_assert(sizeof(UTedDoctrineTreeDefinition) == 0x000068, "Wrong size on UTedDoctrineTreeDefinition");
static_assert(offsetof(UTedDoctrineTreeDefinition, Icon) == 0x000030, "Member 'UTedDoctrineTreeDefinition::Icon' has a wrong offset!");
static_assert(offsetof(UTedDoctrineTreeDefinition, Title) == 0x000038, "Member 'UTedDoctrineTreeDefinition::Title' has a wrong offset!");
static_assert(offsetof(UTedDoctrineTreeDefinition, Description) == 0x000048, "Member 'UTedDoctrineTreeDefinition::Description' has a wrong offset!");
static_assert(offsetof(UTedDoctrineTreeDefinition, Doctrines) == 0x000058, "Member 'UTedDoctrineTreeDefinition::Doctrines' has a wrong offset!");

// Class Tempest.TedAoECommandPreview
// 0x0088 (0x04E0 - 0x0458)
class ATedAoECommandPreview : public ATedPawnCommandPreviewActor
{
public:
	bool                                          bDisplayAffectedPawns;                             // 0x0458(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedCommandRangeType                          RangeType;                                         // 0x0459(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_45A[0x2];                                      // 0x045A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Range;                                             // 0x045C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAttachToCommandActor;                             // 0x0460(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_461[0x3];                                      // 0x0461(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DecalRadiusScale;                                  // 0x0464(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DecalMaterial;                                     // 0x0468(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DecalColorParameterName;                           // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           DecalColor;                                        // 0x0478(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class ATedPawn*>                         CachedHoveredPawns;                                // 0x0488(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	class UDecalComponent*                        DecalComponent;                                    // 0x04D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAoECommandPreview">();
	}
	static class ATedAoECommandPreview* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedAoECommandPreview>();
	}
};
static_assert(alignof(ATedAoECommandPreview) == 0x000008, "Wrong alignment on ATedAoECommandPreview");
static_assert(sizeof(ATedAoECommandPreview) == 0x0004E0, "Wrong size on ATedAoECommandPreview");
static_assert(offsetof(ATedAoECommandPreview, bDisplayAffectedPawns) == 0x000458, "Member 'ATedAoECommandPreview::bDisplayAffectedPawns' has a wrong offset!");
static_assert(offsetof(ATedAoECommandPreview, RangeType) == 0x000459, "Member 'ATedAoECommandPreview::RangeType' has a wrong offset!");
static_assert(offsetof(ATedAoECommandPreview, Range) == 0x00045C, "Member 'ATedAoECommandPreview::Range' has a wrong offset!");
static_assert(offsetof(ATedAoECommandPreview, bAttachToCommandActor) == 0x000460, "Member 'ATedAoECommandPreview::bAttachToCommandActor' has a wrong offset!");
static_assert(offsetof(ATedAoECommandPreview, DecalRadiusScale) == 0x000464, "Member 'ATedAoECommandPreview::DecalRadiusScale' has a wrong offset!");
static_assert(offsetof(ATedAoECommandPreview, DecalMaterial) == 0x000468, "Member 'ATedAoECommandPreview::DecalMaterial' has a wrong offset!");
static_assert(offsetof(ATedAoECommandPreview, DecalColorParameterName) == 0x000470, "Member 'ATedAoECommandPreview::DecalColorParameterName' has a wrong offset!");
static_assert(offsetof(ATedAoECommandPreview, DecalColor) == 0x000478, "Member 'ATedAoECommandPreview::DecalColor' has a wrong offset!");
static_assert(offsetof(ATedAoECommandPreview, CachedHoveredPawns) == 0x000488, "Member 'ATedAoECommandPreview::CachedHoveredPawns' has a wrong offset!");
static_assert(offsetof(ATedAoECommandPreview, DecalComponent) == 0x0004D8, "Member 'ATedAoECommandPreview::DecalComponent' has a wrong offset!");

// Class Tempest.TedScoreScreenSlotInterface
// 0x0000 (0x0000 - 0x0000)
class ITedScoreScreenSlotInterface final
{
public:
	void SetAvatar(class UTexture2D* InTexture);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedScoreScreenSlotInterface">();
	}
	static class ITedScoreScreenSlotInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITedScoreScreenSlotInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITedScoreScreenSlotInterface) == 0x000001, "Wrong alignment on ITedScoreScreenSlotInterface");
static_assert(sizeof(ITedScoreScreenSlotInterface) == 0x000001, "Wrong size on ITedScoreScreenSlotInterface");

// Class Tempest.TedDoctrinePanel
// 0x0030 (0x07E0 - 0x07B0)
class UTedDoctrinePanel : public UTedContentPanelDynamic
{
public:
	class UWidget*                                ExternalTooltipAttachParent;                       // 0x07B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTedDoctrineDefinition*>         content;                                           // 0x07B8(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_TreeLabel;                                    // 0x07C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_DoctrinePoints;                               // 0x07D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedDoctrineTreeDefinition*             ContentTree;                                       // 0x07D8(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static ETedContentSlotState GetDoctrineSlotState_Disabled();
	static ETedContentSlotState GetDoctrineSlotState_Purchased();

	void K2_SetContent(const TArray<class UTedDoctrineDefinition*>& InContent);
	void RefreshDoctrinePoints();
	void RefreshTreeLabel();
	void SetContentFromTree(const class UTedDoctrineTreeDefinition* InTree);

	const class FText GetContentTreeDescription() const;
	class UTexture2D* GetContentTreeIcon() const;
	const class FText GetContentTreeTitle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedDoctrinePanel">();
	}
	static class UTedDoctrinePanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedDoctrinePanel>();
	}
};
static_assert(alignof(UTedDoctrinePanel) == 0x000008, "Wrong alignment on UTedDoctrinePanel");
static_assert(sizeof(UTedDoctrinePanel) == 0x0007E0, "Wrong size on UTedDoctrinePanel");
static_assert(offsetof(UTedDoctrinePanel, ExternalTooltipAttachParent) == 0x0007B0, "Member 'UTedDoctrinePanel::ExternalTooltipAttachParent' has a wrong offset!");
static_assert(offsetof(UTedDoctrinePanel, content) == 0x0007B8, "Member 'UTedDoctrinePanel::content' has a wrong offset!");
static_assert(offsetof(UTedDoctrinePanel, Text_TreeLabel) == 0x0007C8, "Member 'UTedDoctrinePanel::Text_TreeLabel' has a wrong offset!");
static_assert(offsetof(UTedDoctrinePanel, Text_DoctrinePoints) == 0x0007D0, "Member 'UTedDoctrinePanel::Text_DoctrinePoints' has a wrong offset!");
static_assert(offsetof(UTedDoctrinePanel, ContentTree) == 0x0007D8, "Member 'UTedDoctrinePanel::ContentTree' has a wrong offset!");

// Class Tempest.TedDoctrinePanel_HUD
// 0x0038 (0x0818 - 0x07E0)
class UTedDoctrinePanel_HUD : public UTedDoctrinePanel
{
public:
	TSubclassOf<class UTedPlayerCommand_DoctrineResearchQueue> EnqueueResearchCmd;                   // 0x07E0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTedPlayerCommand_DoctrineResearchQueue> DequeueResearchCmd;                   // 0x07E8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTedPlayerCommand_PauseDoctrineResearch> PauseResearchCmd;                     // 0x07F0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTedPlayerCommand_PauseDoctrineResearch> UnPauseResearchCmd;                   // 0x07F8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTedPlayerCommand_SellDoctrine> SellDoctrineCmd;                               // 0x0800(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedPlayerData*                         TargetPlayerData;                                  // 0x0808(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bResearchable;                                     // 0x0810(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_811[0x7];                                      // 0x0811(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTargetPlayerData(class UTedPlayerData* InPlayerData, bool bInRefreshContent);

	class UTedDoctrineSlot* GetLastUnlockedSlot() const;
	class UTedPlayerData* GetTargetPlayerData() const;
	bool IsLastUnlockedSlot(const int32 InSlotIndex) const;
	bool IsResearched(const int32 InSlotIndex) const;
	bool IsResearchInProgress(const int32 InSlotIndex) const;
	bool IsResearchPaused(const int32 InSlotIndex) const;
	bool IsResearchRelevant() const;
	bool IsSlotUnlocked(const int32 InSlotIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedDoctrinePanel_HUD">();
	}
	static class UTedDoctrinePanel_HUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedDoctrinePanel_HUD>();
	}
};
static_assert(alignof(UTedDoctrinePanel_HUD) == 0x000008, "Wrong alignment on UTedDoctrinePanel_HUD");
static_assert(sizeof(UTedDoctrinePanel_HUD) == 0x000818, "Wrong size on UTedDoctrinePanel_HUD");
static_assert(offsetof(UTedDoctrinePanel_HUD, EnqueueResearchCmd) == 0x0007E0, "Member 'UTedDoctrinePanel_HUD::EnqueueResearchCmd' has a wrong offset!");
static_assert(offsetof(UTedDoctrinePanel_HUD, DequeueResearchCmd) == 0x0007E8, "Member 'UTedDoctrinePanel_HUD::DequeueResearchCmd' has a wrong offset!");
static_assert(offsetof(UTedDoctrinePanel_HUD, PauseResearchCmd) == 0x0007F0, "Member 'UTedDoctrinePanel_HUD::PauseResearchCmd' has a wrong offset!");
static_assert(offsetof(UTedDoctrinePanel_HUD, UnPauseResearchCmd) == 0x0007F8, "Member 'UTedDoctrinePanel_HUD::UnPauseResearchCmd' has a wrong offset!");
static_assert(offsetof(UTedDoctrinePanel_HUD, SellDoctrineCmd) == 0x000800, "Member 'UTedDoctrinePanel_HUD::SellDoctrineCmd' has a wrong offset!");
static_assert(offsetof(UTedDoctrinePanel_HUD, TargetPlayerData) == 0x000808, "Member 'UTedDoctrinePanel_HUD::TargetPlayerData' has a wrong offset!");
static_assert(offsetof(UTedDoctrinePanel_HUD, bResearchable) == 0x000810, "Member 'UTedDoctrinePanel_HUD::bResearchable' has a wrong offset!");

// Class Tempest.TedAoEConfigAsset
// 0x00C0 (0x0170 - 0x00B0)
class UTedAoEConfigAsset final : public UTedDefinitionAsset
{
public:
	TSubclassOf<class UGameplayEffect>            EffectClass;                                       // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectRadius;                                      // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectExpireDelay;                                 // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccrueStackTime;                                   // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReceiverPeriod;                                    // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  SourceRequiredTags;                                // 0x00C8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  SourceIgnoredTags;                                 // 0x00E8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bAllowOverflow;                                    // 0x0108(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGracefullyDecreaseEffectStack;                    // 0x0109(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10A[0x2];                                      // 0x010A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAISenseAffiliationFilter              AttitudeFilter;                                    // 0x010C(0x0004)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FTedAoEConfig                          Data;                                              // 0x0110(0x0060)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAoEConfigAsset">();
	}
	static class UTedAoEConfigAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAoEConfigAsset>();
	}
};
static_assert(alignof(UTedAoEConfigAsset) == 0x000008, "Wrong alignment on UTedAoEConfigAsset");
static_assert(sizeof(UTedAoEConfigAsset) == 0x000170, "Wrong size on UTedAoEConfigAsset");
static_assert(offsetof(UTedAoEConfigAsset, EffectClass) == 0x0000B0, "Member 'UTedAoEConfigAsset::EffectClass' has a wrong offset!");
static_assert(offsetof(UTedAoEConfigAsset, EffectRadius) == 0x0000B8, "Member 'UTedAoEConfigAsset::EffectRadius' has a wrong offset!");
static_assert(offsetof(UTedAoEConfigAsset, EffectExpireDelay) == 0x0000BC, "Member 'UTedAoEConfigAsset::EffectExpireDelay' has a wrong offset!");
static_assert(offsetof(UTedAoEConfigAsset, AccrueStackTime) == 0x0000C0, "Member 'UTedAoEConfigAsset::AccrueStackTime' has a wrong offset!");
static_assert(offsetof(UTedAoEConfigAsset, ReceiverPeriod) == 0x0000C4, "Member 'UTedAoEConfigAsset::ReceiverPeriod' has a wrong offset!");
static_assert(offsetof(UTedAoEConfigAsset, SourceRequiredTags) == 0x0000C8, "Member 'UTedAoEConfigAsset::SourceRequiredTags' has a wrong offset!");
static_assert(offsetof(UTedAoEConfigAsset, SourceIgnoredTags) == 0x0000E8, "Member 'UTedAoEConfigAsset::SourceIgnoredTags' has a wrong offset!");
static_assert(offsetof(UTedAoEConfigAsset, bAllowOverflow) == 0x000108, "Member 'UTedAoEConfigAsset::bAllowOverflow' has a wrong offset!");
static_assert(offsetof(UTedAoEConfigAsset, bGracefullyDecreaseEffectStack) == 0x000109, "Member 'UTedAoEConfigAsset::bGracefullyDecreaseEffectStack' has a wrong offset!");
static_assert(offsetof(UTedAoEConfigAsset, AttitudeFilter) == 0x00010C, "Member 'UTedAoEConfigAsset::AttitudeFilter' has a wrong offset!");
static_assert(offsetof(UTedAoEConfigAsset, Data) == 0x000110, "Member 'UTedAoEConfigAsset::Data' has a wrong offset!");

// Class Tempest.TedArmyDefinition
// 0x0038 (0x0060 - 0x0028)
class UTedArmyDefinition final : public UObject
{
public:
	TSoftClassPtr<class UClass>                   ConstructionYard;                                  // 0x0028(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftClassPtr<class UClass>>           Units;                                             // 0x0050(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedArmyDefinition">();
	}
	static class UTedArmyDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedArmyDefinition>();
	}
};
static_assert(alignof(UTedArmyDefinition) == 0x000008, "Wrong alignment on UTedArmyDefinition");
static_assert(sizeof(UTedArmyDefinition) == 0x000060, "Wrong size on UTedArmyDefinition");
static_assert(offsetof(UTedArmyDefinition, ConstructionYard) == 0x000028, "Member 'UTedArmyDefinition::ConstructionYard' has a wrong offset!");
static_assert(offsetof(UTedArmyDefinition, Units) == 0x000050, "Member 'UTedArmyDefinition::Units' has a wrong offset!");

// Class Tempest.TedDefinitionSlot
// 0x0018 (0x0448 - 0x0430)
class UTedDefinitionSlot : public UTedContentPanelSlotButton
{
public:
	class UImage*                                 Image_Icon_Texture;                                // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_DisplayName;                                  // 0x0438(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Description;                                  // 0x0440(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	const class UTedDefinitionAsset* GetContentDefinition() const;
	class FText GetContentDescription() const;
	const class FText GetContentDisplayName() const;
	class UTexture2D* GetContentIcon() const;
	class ATedPlayerState* GetDefinitionContext() const;
	class UTedDefinitionPanel* GetParentPanel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedDefinitionSlot">();
	}
	static class UTedDefinitionSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedDefinitionSlot>();
	}
};
static_assert(alignof(UTedDefinitionSlot) == 0x000008, "Wrong alignment on UTedDefinitionSlot");
static_assert(sizeof(UTedDefinitionSlot) == 0x000448, "Wrong size on UTedDefinitionSlot");
static_assert(offsetof(UTedDefinitionSlot, Image_Icon_Texture) == 0x000430, "Member 'UTedDefinitionSlot::Image_Icon_Texture' has a wrong offset!");
static_assert(offsetof(UTedDefinitionSlot, Text_DisplayName) == 0x000438, "Member 'UTedDefinitionSlot::Text_DisplayName' has a wrong offset!");
static_assert(offsetof(UTedDefinitionSlot, Text_Description) == 0x000440, "Member 'UTedDefinitionSlot::Text_Description' has a wrong offset!");

// Class Tempest.TedAssetManager
// 0x0010 (0x04E0 - 0x04D0)
class UTedAssetManager final : public UAssetManager
{
public:
	TArray<struct FPrimaryAssetTypeToLoadOnStartInfo> PrimaryAssetsToLoadOnStart;                    // 0x04D0(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAssetManager">();
	}
	static class UTedAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAssetManager>();
	}
};
static_assert(alignof(UTedAssetManager) == 0x000008, "Wrong alignment on UTedAssetManager");
static_assert(sizeof(UTedAssetManager) == 0x0004E0, "Wrong size on UTedAssetManager");
static_assert(offsetof(UTedAssetManager, PrimaryAssetsToLoadOnStart) == 0x0004D0, "Member 'UTedAssetManager::PrimaryAssetsToLoadOnStart' has a wrong offset!");

// Class Tempest.TedOnlineSessionsSlot
// 0x0040 (0x0470 - 0x0430)
class UTedOnlineSessionsSlot final : public UTedContentPanelSlotButton
{
public:
	class UImage*                                 Image_Map;                                         // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_LobbyName;                                    // 0x0438(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Host;                                         // 0x0440(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_PasswordProtected;                           // 0x0448(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Ping;                                         // 0x0450(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Players;                                      // 0x0458(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Spectators;                                   // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                Root_Spectators;                                   // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool AreSpectatorsEnabledOnUI() const;
	uint8 GetCurrentPlayers() const;
	uint8 GetCurrentSpectators() const;
	class FText GetHostName() const;
	class FText GetLobbyName() const;
	const class UTedMapInfo* GetMapInfo() const;
	class UTexture2D* GetMapMinimap() const;
	class FText GetMapName() const;
	uint8 GetMaxPlayers() const;
	uint8 GetMaxSpectators() const;
	class UTedOnlineSessionsPanel* GetParentPanel() const;
	int32 GetPing() const;
	bool IsPasswordProtected() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedOnlineSessionsSlot">();
	}
	static class UTedOnlineSessionsSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedOnlineSessionsSlot>();
	}
};
static_assert(alignof(UTedOnlineSessionsSlot) == 0x000008, "Wrong alignment on UTedOnlineSessionsSlot");
static_assert(sizeof(UTedOnlineSessionsSlot) == 0x000470, "Wrong size on UTedOnlineSessionsSlot");
static_assert(offsetof(UTedOnlineSessionsSlot, Image_Map) == 0x000430, "Member 'UTedOnlineSessionsSlot::Image_Map' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionsSlot, Text_LobbyName) == 0x000438, "Member 'UTedOnlineSessionsSlot::Text_LobbyName' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionsSlot, Text_Host) == 0x000440, "Member 'UTedOnlineSessionsSlot::Text_Host' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionsSlot, Image_PasswordProtected) == 0x000448, "Member 'UTedOnlineSessionsSlot::Image_PasswordProtected' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionsSlot, Text_Ping) == 0x000450, "Member 'UTedOnlineSessionsSlot::Text_Ping' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionsSlot, Text_Players) == 0x000458, "Member 'UTedOnlineSessionsSlot::Text_Players' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionsSlot, Text_Spectators) == 0x000460, "Member 'UTedOnlineSessionsSlot::Text_Spectators' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionsSlot, Root_Spectators) == 0x000468, "Member 'UTedOnlineSessionsSlot::Root_Spectators' has a wrong offset!");

// Class Tempest.TedAttributePanel
// 0x0018 (0x07C8 - 0x07B0)
class UTedAttributePanel : public UTedContentPanelDynamic
{
public:
	TArray<struct FTedAttributPanelContent>       content;                                           // 0x07B0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class ATedPawn*                               ContextPawn;                                       // 0x07C0(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetContent(const TArray<struct FTedAttributPanelContent>& InContent, class ATedPawn* InContextPawn);
	void SetContextPawn(class ATedPawn* InContextPawn, const bool bInRefreshUI);

	bool GetAttributeColor(const int32 InSlotIndex, struct FLinearColor* OutColor) const;
	const class FText GetAttributeDisplayName(const int32 InSlotIndex) const;
	float GetAttributeValue(const int32 InSlotIndex, const bool bInBaseOnly) const;
	class ATedPawn* GetContextPawn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAttributePanel">();
	}
	static class UTedAttributePanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAttributePanel>();
	}
};
static_assert(alignof(UTedAttributePanel) == 0x000008, "Wrong alignment on UTedAttributePanel");
static_assert(sizeof(UTedAttributePanel) == 0x0007C8, "Wrong size on UTedAttributePanel");
static_assert(offsetof(UTedAttributePanel, content) == 0x0007B0, "Member 'UTedAttributePanel::content' has a wrong offset!");
static_assert(offsetof(UTedAttributePanel, ContextPawn) == 0x0007C0, "Member 'UTedAttributePanel::ContextPawn' has a wrong offset!");

// Class Tempest.TedAttributeSet
// 0x03A0 (0x03D0 - 0x0030)
class UTedAttributeSet final : public UTedAttributeSetBase
{
public:
	struct FTedGameplayAttributeData              Health;                                            // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FTedGameplayAttributeData              HealthMax;                                         // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AmmoRechargeTimeMultiplier;                        // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AmmoCapacityMultiplier;                            // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 GunResistance;                                     // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 FireResistance;                                    // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 CannonResistance;                                  // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 RocketResistance;                                  // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SniperResistance;                                  // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ExplosiveResistance;                               // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AddResistance;                                     // 0x00D0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DebuffDurationMod;                                 // 0x00E0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DebuffBuildupSpeedMod;                             // 0x00F0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HealEfficiencyMod;                                 // 0x0100(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 RepairEfficiencyMod;                               // 0x0110(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ReceivedDamage;                                    // 0x0120(0x0010)(NativeAccessSpecifierPublic)
	struct FTedGameplayAttributeData              FoWRevealRadius;                                   // 0x0130(0x0010)(NativeAccessSpecifierPublic)
	struct FTedGameplayAttributeData              FoWVisionRadius;                                   // 0x0140(0x0010)(NativeAccessSpecifierPublic)
	struct FTedGameplayAttributeData              FoWRadiusAttributesMultiplier;                     // 0x0150(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Damage;                                            // 0x0160(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AttackSpeed;                                       // 0x0170(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AttackSpeedMod;                                    // 0x0180(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	struct FTedGameplayAttributeData              AttackRange;                                       // 0x0190(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	struct FTedGameplayAttributeData              AttackGraceRange;                                  // 0x01A0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	struct FTedGameplayAttributeData              MovementSpeedMod;                                  // 0x01B0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MovementSpeed;                                     // 0x01C0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FTedGameplayAttributeData              ProductionTimeMultiplier;                          // 0x01D0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Power;                                             // 0x01E0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FTedGameplayAttributeData              EnlightenedSacrificed;                             // 0x01F0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FTedGameplayAttributeData              AwakeningTechLevel;                                // 0x0200(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FTedReplicatedAttributeModsContainer   ReplicatedModsContainer;                           // 0x0210(0x0170)(Net, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSet<struct FGameplayAttribute>               AttributesWithReplicatedMods;                      // 0x0380(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	void OnRep_AttackSpeedMod(const struct FTedGameplayAttributeData& OldValue);
	void OnRep_AwakeningTechLevel(const struct FTedGameplayAttributeData& OldValue);
	void OnRep_EnlightenedSacrificed(const struct FTedGameplayAttributeData& OldValue);
	void OnRep_FoWRadiusAttributesMultiplier(const struct FTedGameplayAttributeData& OldValue);
	void OnRep_Health(const struct FTedGameplayAttributeData& OldValue);
	void OnRep_HealthMax(const struct FTedGameplayAttributeData& OldValue);
	void OnRep_MovementSpeedMod(const struct FTedGameplayAttributeData& OldValue);
	void OnRep_ProductionTimeMultiplier(const struct FTedGameplayAttributeData& OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAttributeSet">();
	}
	static class UTedAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAttributeSet>();
	}
};
static_assert(alignof(UTedAttributeSet) == 0x000008, "Wrong alignment on UTedAttributeSet");
static_assert(sizeof(UTedAttributeSet) == 0x0003D0, "Wrong size on UTedAttributeSet");
static_assert(offsetof(UTedAttributeSet, Health) == 0x000030, "Member 'UTedAttributeSet::Health' has a wrong offset!");
static_assert(offsetof(UTedAttributeSet, HealthMax) == 0x000040, "Member 'UTedAttributeSet::HealthMax' has a wrong offset!");
static_assert(offsetof(UTedAttributeSet, AmmoRechargeTimeMultiplier) == 0x000050, "Member 'UTedAttributeSet::AmmoRechargeTimeMultiplier' has a wrong offset!");
static_assert(offsetof(UTedAttributeSet, AmmoCapacityMultiplier) == 0x000060, "Member 'UTedAttributeSet::AmmoCapacityMultiplier' has a wrong offset!");
static_assert(offsetof(UTedAttributeSet, GunResistance) == 0x000070, "Member 'UTedAttributeSet::GunResistance' has a wrong offset!");
static_assert(offsetof(UTedAttributeSet, FireResistance) == 0x000080, "Member 'UTedAttributeSet::FireResistance' has a wrong offset!");
static_assert(offsetof(UTedAttributeSet, CannonResistance) == 0x000090, "Member 'UTedAttributeSet::CannonResistance' has a wrong offset!");
static_assert(offsetof(UTedAttributeSet, RocketResistance) == 0x0000A0, "Member 'UTedAttributeSet::RocketResistance' has a wrong offset!");
static_assert(offsetof(UTedAttributeSet, SniperResistance) == 0x0000B0, "Member 'UTedAttributeSet::SniperResistance' has a wrong offset!");
static_assert(offsetof(UTedAttributeSet, ExplosiveResistance) == 0x0000C0, "Member 'UTedAttributeSet::ExplosiveResistance' has a wrong offset!");
static_assert(offsetof(UTedAttributeSet, AddResistance) == 0x0000D0, "Member 'UTedAttributeSet::AddResistance' has a wrong offset!");
static_assert(offsetof(UTedAttributeSet, DebuffDurationMod) == 0x0000E0, "Member 'UTedAttributeSet::DebuffDurationMod' has a wrong offset!");
static_assert(offsetof(UTedAttributeSet, DebuffBuildupSpeedMod) == 0x0000F0, "Member 'UTedAttributeSet::DebuffBuildupSpeedMod' has a wrong offset!");
static_assert(offsetof(UTedAttributeSet, HealEfficiencyMod) == 0x000100, "Member 'UTedAttributeSet::HealEfficiencyMod' has a wrong offset!");
static_assert(offsetof(UTedAttributeSet, RepairEfficiencyMod) == 0x000110, "Member 'UTedAttributeSet::RepairEfficiencyMod' has a wrong offset!");
static_assert(offsetof(UTedAttributeSet, ReceivedDamage) == 0x000120, "Member 'UTedAttributeSet::ReceivedDamage' has a wrong offset!");
static_assert(offsetof(UTedAttributeSet, FoWRevealRadius) == 0x000130, "Member 'UTedAttributeSet::FoWRevealRadius' has a wrong offset!");
static_assert(offsetof(UTedAttributeSet, FoWVisionRadius) == 0x000140, "Member 'UTedAttributeSet::FoWVisionRadius' has a wrong offset!");
static_assert(offsetof(UTedAttributeSet, FoWRadiusAttributesMultiplier) == 0x000150, "Member 'UTedAttributeSet::FoWRadiusAttributesMultiplier' has a wrong offset!");
static_assert(offsetof(UTedAttributeSet, Damage) == 0x000160, "Member 'UTedAttributeSet::Damage' has a wrong offset!");
static_assert(offsetof(UTedAttributeSet, AttackSpeed) == 0x000170, "Member 'UTedAttributeSet::AttackSpeed' has a wrong offset!");
static_assert(offsetof(UTedAttributeSet, AttackSpeedMod) == 0x000180, "Member 'UTedAttributeSet::AttackSpeedMod' has a wrong offset!");
static_assert(offsetof(UTedAttributeSet, AttackRange) == 0x000190, "Member 'UTedAttributeSet::AttackRange' has a wrong offset!");
static_assert(offsetof(UTedAttributeSet, AttackGraceRange) == 0x0001A0, "Member 'UTedAttributeSet::AttackGraceRange' has a wrong offset!");
static_assert(offsetof(UTedAttributeSet, MovementSpeedMod) == 0x0001B0, "Member 'UTedAttributeSet::MovementSpeedMod' has a wrong offset!");
static_assert(offsetof(UTedAttributeSet, MovementSpeed) == 0x0001C0, "Member 'UTedAttributeSet::MovementSpeed' has a wrong offset!");
static_assert(offsetof(UTedAttributeSet, ProductionTimeMultiplier) == 0x0001D0, "Member 'UTedAttributeSet::ProductionTimeMultiplier' has a wrong offset!");
static_assert(offsetof(UTedAttributeSet, Power) == 0x0001E0, "Member 'UTedAttributeSet::Power' has a wrong offset!");
static_assert(offsetof(UTedAttributeSet, EnlightenedSacrificed) == 0x0001F0, "Member 'UTedAttributeSet::EnlightenedSacrificed' has a wrong offset!");
static_assert(offsetof(UTedAttributeSet, AwakeningTechLevel) == 0x000200, "Member 'UTedAttributeSet::AwakeningTechLevel' has a wrong offset!");
static_assert(offsetof(UTedAttributeSet, ReplicatedModsContainer) == 0x000210, "Member 'UTedAttributeSet::ReplicatedModsContainer' has a wrong offset!");
static_assert(offsetof(UTedAttributeSet, AttributesWithReplicatedMods) == 0x000380, "Member 'UTedAttributeSet::AttributesWithReplicatedMods' has a wrong offset!");

// Class Tempest.TedPassiveAbilityPanel
// 0x0010 (0x07C0 - 0x07B0)
class UTedPassiveAbilityPanel : public UTedContentPanelDynamic
{
public:
	TArray<class UTedPassiveAbilityDefinitionAsset*> content;                                        // 0x07B0(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)

public:
	void K2_SetContent(const TArray<class UTedPassiveAbilityDefinitionAsset*>& InContent);

	const class UTedPassiveAbilityDefinitionAsset* GetContent(const int32 InSlotIndex) const;
	bool GetContentDescription(const int32 InSlotIndex, class FText* OutText) const;
	bool GetContentDisplayName(const int32 InSlotIndex, class FText* OutText) const;
	class UTexture2D* GetContentIcon(const int32 InSlotIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPassiveAbilityPanel">();
	}
	static class UTedPassiveAbilityPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPassiveAbilityPanel>();
	}
};
static_assert(alignof(UTedPassiveAbilityPanel) == 0x000008, "Wrong alignment on UTedPassiveAbilityPanel");
static_assert(sizeof(UTedPassiveAbilityPanel) == 0x0007C0, "Wrong size on UTedPassiveAbilityPanel");
static_assert(offsetof(UTedPassiveAbilityPanel, content) == 0x0007B0, "Member 'UTedPassiveAbilityPanel::content' has a wrong offset!");

// Class Tempest.TedAttributeSlot
// 0x0070 (0x0480 - 0x0410)
class UTedAttributeSlot : public UTedContentPanelSlotBase
{
public:
	class UTextBlock*                             Text_Label;                                        // 0x0410(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Value;                                        // 0x0418(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Modifier;                                     // 0x0420(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_Status_Icon;                                 // 0x0428(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_430[0x4];                                      // 0x0430(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateColor                            BaseColor;                                         // 0x0434(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            BuffColor;                                         // 0x0448(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            DebuffColor;                                       // 0x045C(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             BuffIcon;                                          // 0x0470(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             DebuffIcon;                                        // 0x0478(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	float GetAttributeValue();

	const class FText GetAttributeDisplayName() const;
	class ATedPawn* GetContextPawn() const;
	class UTedAttributePanel* GetParentPanel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedAttributeSlot">();
	}
	static class UTedAttributeSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedAttributeSlot>();
	}
};
static_assert(alignof(UTedAttributeSlot) == 0x000008, "Wrong alignment on UTedAttributeSlot");
static_assert(sizeof(UTedAttributeSlot) == 0x000480, "Wrong size on UTedAttributeSlot");
static_assert(offsetof(UTedAttributeSlot, Text_Label) == 0x000410, "Member 'UTedAttributeSlot::Text_Label' has a wrong offset!");
static_assert(offsetof(UTedAttributeSlot, Text_Value) == 0x000418, "Member 'UTedAttributeSlot::Text_Value' has a wrong offset!");
static_assert(offsetof(UTedAttributeSlot, Text_Modifier) == 0x000420, "Member 'UTedAttributeSlot::Text_Modifier' has a wrong offset!");
static_assert(offsetof(UTedAttributeSlot, Image_Status_Icon) == 0x000428, "Member 'UTedAttributeSlot::Image_Status_Icon' has a wrong offset!");
static_assert(offsetof(UTedAttributeSlot, BaseColor) == 0x000434, "Member 'UTedAttributeSlot::BaseColor' has a wrong offset!");
static_assert(offsetof(UTedAttributeSlot, BuffColor) == 0x000448, "Member 'UTedAttributeSlot::BuffColor' has a wrong offset!");
static_assert(offsetof(UTedAttributeSlot, DebuffColor) == 0x00045C, "Member 'UTedAttributeSlot::DebuffColor' has a wrong offset!");
static_assert(offsetof(UTedAttributeSlot, BuffIcon) == 0x000470, "Member 'UTedAttributeSlot::BuffIcon' has a wrong offset!");
static_assert(offsetof(UTedAttributeSlot, DebuffIcon) == 0x000478, "Member 'UTedAttributeSlot::DebuffIcon' has a wrong offset!");

// Class Tempest.TedBlackboardHelpers
// 0x0000 (0x0028 - 0x0028)
class UTedBlackboardHelpers final : public UBlueprintFunctionLibrary
{
public:
	static float GetBlackboardAttackGraceRange(class UBTNode* NodeOwner);
	static float GetBlackboardAttackRange(class UBTNode* NodeOwner);
	static float GetBlackboardChaseRange(class UBTNode* NodeOwner);
	static TSubclassOf<class UGameplayAbility> GetBlackboardCommandAbilityClass(class UBTNode* NodeOwner);
	static TSubclassOf<class UTedCommand> GetBlackboardCommandClass(class UBTNode* NodeOwner);
	static struct FVector GetBlackboardLeashLocation(class UBTNode* NodeOwner);
	static struct FVector GetBlackboardPatrolLocation(class UBTNode* NodeOwner);
	static class AActor* GetBlackboardTargetActor(class UBTNode* NodeOwner);
	static struct FVector GetBlackboardTargetLocation(class UBTNode* NodeOwner);
	static void GetBlackBoardValueAsGameplayTag(class UBTNode* NodeOwner, const struct FBlackboardKeySelector& Key, struct FGameplayTag* OutTag);
	static void SetBlackBoardValueAsGameplayTag(class UBTNode* NodeOwner, const struct FBlackboardKeySelector& Key, const struct FGameplayTag& Tag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedBlackboardHelpers">();
	}
	static class UTedBlackboardHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedBlackboardHelpers>();
	}
};
static_assert(alignof(UTedBlackboardHelpers) == 0x000008, "Wrong alignment on UTedBlackboardHelpers");
static_assert(sizeof(UTedBlackboardHelpers) == 0x000028, "Wrong size on UTedBlackboardHelpers");

// Class Tempest.TedPawnAmmoVisualComponent
// 0x0060 (0x0110 - 0x00B0)
class UTedPawnAmmoVisualComponent final : public UActorComponent
{
public:
	TSoftClassPtr<class UClass>                   AmmoVisualActorClass;                              // 0x00B0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTedWeapon>                 WeaponClassToVisualiseAmmo;                        // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayCueTag                        ShowAmmoVisualActorCue;                            // 0x00E0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class ATedPawn*                               PawnOwner;                                         // 0x00E8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTedWeapon*                             CachedWeapon;                                      // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ATedAmmoVisualActor*>            AmmoVisualActors;                                  // 0x00F8(0x0010)(ZeroConstructor, Transient, DuplicateTransient, NativeAccessSpecifierPrivate)
	int32                                         LastAmmo;                                          // 0x0108(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnAmmoVisualComponent">();
	}
	static class UTedPawnAmmoVisualComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnAmmoVisualComponent>();
	}
};
static_assert(alignof(UTedPawnAmmoVisualComponent) == 0x000008, "Wrong alignment on UTedPawnAmmoVisualComponent");
static_assert(sizeof(UTedPawnAmmoVisualComponent) == 0x000110, "Wrong size on UTedPawnAmmoVisualComponent");
static_assert(offsetof(UTedPawnAmmoVisualComponent, AmmoVisualActorClass) == 0x0000B0, "Member 'UTedPawnAmmoVisualComponent::AmmoVisualActorClass' has a wrong offset!");
static_assert(offsetof(UTedPawnAmmoVisualComponent, WeaponClassToVisualiseAmmo) == 0x0000D8, "Member 'UTedPawnAmmoVisualComponent::WeaponClassToVisualiseAmmo' has a wrong offset!");
static_assert(offsetof(UTedPawnAmmoVisualComponent, ShowAmmoVisualActorCue) == 0x0000E0, "Member 'UTedPawnAmmoVisualComponent::ShowAmmoVisualActorCue' has a wrong offset!");
static_assert(offsetof(UTedPawnAmmoVisualComponent, PawnOwner) == 0x0000E8, "Member 'UTedPawnAmmoVisualComponent::PawnOwner' has a wrong offset!");
static_assert(offsetof(UTedPawnAmmoVisualComponent, CachedWeapon) == 0x0000F0, "Member 'UTedPawnAmmoVisualComponent::CachedWeapon' has a wrong offset!");
static_assert(offsetof(UTedPawnAmmoVisualComponent, AmmoVisualActors) == 0x0000F8, "Member 'UTedPawnAmmoVisualComponent::AmmoVisualActors' has a wrong offset!");
static_assert(offsetof(UTedPawnAmmoVisualComponent, LastAmmo) == 0x000108, "Member 'UTedPawnAmmoVisualComponent::LastAmmo' has a wrong offset!");

// Class Tempest.TedBriefing
// 0x0050 (0x0080 - 0x0030)
class UTedBriefing final : public UPrimaryDataAsset
{
public:
	TSoftObjectPtr<class UWorld>                  BriefingLevel;                                     // 0x0030(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTedDialogueLine>               DialogueLines;                                     // 0x0058(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bFinale : 1;                                       // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UWorld>>          ForceLoadLevels;                                   // 0x0070(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	const TArray<struct FTedDialogueLine> GetDialogueLines() const;
	bool HasDialogueLines() const;
	bool IsFinale() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedBriefing">();
	}
	static class UTedBriefing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedBriefing>();
	}
};
static_assert(alignof(UTedBriefing) == 0x000008, "Wrong alignment on UTedBriefing");
static_assert(sizeof(UTedBriefing) == 0x000080, "Wrong size on UTedBriefing");
static_assert(offsetof(UTedBriefing, BriefingLevel) == 0x000030, "Member 'UTedBriefing::BriefingLevel' has a wrong offset!");
static_assert(offsetof(UTedBriefing, DialogueLines) == 0x000058, "Member 'UTedBriefing::DialogueLines' has a wrong offset!");
static_assert(offsetof(UTedBriefing, ForceLoadLevels) == 0x000070, "Member 'UTedBriefing::ForceLoadLevels' has a wrong offset!");

// Class Tempest.TedPawnCommandPreview_LayMines
// 0x00A8 (0x0500 - 0x0458)
class ATedPawnCommandPreview_LayMines : public ATedPawnCommandPreviewActor
{
public:
	class UTedGridVisualizationComponent*         GridVisualisation;                                 // 0x0458(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInstancedStaticMeshComponent*          InstantStaticMeshComponent;                        // 0x0460(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              CachedDeployLoc;                                   // 0x0468(0x0010)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASquareNavGrid*                         CachedNavGrid;                                     // 0x0478(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedMinefieldProxy*                     CachedMineFieldProxy;                              // 0x0480(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   CachedMeshComp;                                    // 0x0488(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     PreviewMaterial;                                   // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       MIDs;                                              // 0x0498(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	class FName                                   MeshPreviewMaterialValidParam;                     // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class FName>                             TextureParamsToCopy;                               // 0x04B0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommandPreview_LayMines">();
	}
	static class ATedPawnCommandPreview_LayMines* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedPawnCommandPreview_LayMines>();
	}
};
static_assert(alignof(ATedPawnCommandPreview_LayMines) == 0x000008, "Wrong alignment on ATedPawnCommandPreview_LayMines");
static_assert(sizeof(ATedPawnCommandPreview_LayMines) == 0x000500, "Wrong size on ATedPawnCommandPreview_LayMines");
static_assert(offsetof(ATedPawnCommandPreview_LayMines, GridVisualisation) == 0x000458, "Member 'ATedPawnCommandPreview_LayMines::GridVisualisation' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_LayMines, InstantStaticMeshComponent) == 0x000460, "Member 'ATedPawnCommandPreview_LayMines::InstantStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_LayMines, CachedDeployLoc) == 0x000468, "Member 'ATedPawnCommandPreview_LayMines::CachedDeployLoc' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_LayMines, CachedNavGrid) == 0x000478, "Member 'ATedPawnCommandPreview_LayMines::CachedNavGrid' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_LayMines, CachedMineFieldProxy) == 0x000480, "Member 'ATedPawnCommandPreview_LayMines::CachedMineFieldProxy' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_LayMines, CachedMeshComp) == 0x000488, "Member 'ATedPawnCommandPreview_LayMines::CachedMeshComp' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_LayMines, PreviewMaterial) == 0x000490, "Member 'ATedPawnCommandPreview_LayMines::PreviewMaterial' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_LayMines, MIDs) == 0x000498, "Member 'ATedPawnCommandPreview_LayMines::MIDs' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_LayMines, MeshPreviewMaterialValidParam) == 0x0004A8, "Member 'ATedPawnCommandPreview_LayMines::MeshPreviewMaterialValidParam' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_LayMines, TextureParamsToCopy) == 0x0004B0, "Member 'ATedPawnCommandPreview_LayMines::TextureParamsToCopy' has a wrong offset!");

// Class Tempest.TedBuildingGridController
// 0x0070 (0x0480 - 0x0410)
class UTedBuildingGridController : public UTedPlayerDataWidget
{
public:
	uint8                                         bSyncToSelectedStructure : 1;                      // 0x0410(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSyncToSelectedStructureTab : 1;                   // 0x0410(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCycleFactoriesOnShortcut : 1;                     // 0x0410(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_411[0x3];                                      // 0x0411(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CycleFactoriesOnShortcutWindow;                    // 0x0414(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastCycleFactoryTime;                              // 0x0418(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41C[0x4];                                      // 0x041C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedBuildingGridFactoryTypesPanel*      FactoryTabs;                                       // 0x0420(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedStructuresPanel*                    Factories;                                         // 0x0428(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedBuildingGridPanel*                  BuildingGrid;                                      // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedContentPanelBase*                   ModeTabs;                                          // 0x0438(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedDoctrinePanel_HUD*                  DoctrinePanelA;                                    // 0x0440(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedDoctrinePanel_HUD*                  DoctrinePanelB;                                    // 0x0448(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedDoctrinePanel_HUD*                  DoctrinePanelC;                                    // 0x0450(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bEnableDoctrines : 1;                              // 0x0458(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_459[0x7];                                      // 0x0459(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTedDoctrinePanel_HUD*>          DoctrinePanels;                                    // 0x0460(0x0010)(ExportObject, ZeroConstructor, Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTedBuildingGridCachedDataForTab> CachedDataPerFactoryTab;                         // 0x0470(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)

public:
	void Factories_OnActivateSlotState(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotState InState, bool bInActivated);
	void Factories_OnPageSwitched();
	void FactoryTabs_OnActivateSlotState(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotState InState, bool bInActivated);
	void K2_OnVisibilityChange(const ESlateVisibility InFrom, const ESlateVisibility InTo);
	void ModeTabs_OnActivateSlotState(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotState InState, bool bInActivated);

	bool IsWithinBuildTab() const;
	bool IsWithinDoctrineTab() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedBuildingGridController">();
	}
	static class UTedBuildingGridController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedBuildingGridController>();
	}
};
static_assert(alignof(UTedBuildingGridController) == 0x000008, "Wrong alignment on UTedBuildingGridController");
static_assert(sizeof(UTedBuildingGridController) == 0x000480, "Wrong size on UTedBuildingGridController");
static_assert(offsetof(UTedBuildingGridController, CycleFactoriesOnShortcutWindow) == 0x000414, "Member 'UTedBuildingGridController::CycleFactoriesOnShortcutWindow' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridController, LastCycleFactoryTime) == 0x000418, "Member 'UTedBuildingGridController::LastCycleFactoryTime' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridController, FactoryTabs) == 0x000420, "Member 'UTedBuildingGridController::FactoryTabs' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridController, Factories) == 0x000428, "Member 'UTedBuildingGridController::Factories' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridController, BuildingGrid) == 0x000430, "Member 'UTedBuildingGridController::BuildingGrid' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridController, ModeTabs) == 0x000438, "Member 'UTedBuildingGridController::ModeTabs' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridController, DoctrinePanelA) == 0x000440, "Member 'UTedBuildingGridController::DoctrinePanelA' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridController, DoctrinePanelB) == 0x000448, "Member 'UTedBuildingGridController::DoctrinePanelB' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridController, DoctrinePanelC) == 0x000450, "Member 'UTedBuildingGridController::DoctrinePanelC' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridController, DoctrinePanels) == 0x000460, "Member 'UTedBuildingGridController::DoctrinePanels' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridController, CachedDataPerFactoryTab) == 0x000470, "Member 'UTedBuildingGridController::CachedDataPerFactoryTab' has a wrong offset!");

// Class Tempest.TedBuildingGridPanel
// 0x0098 (0x0848 - 0x07B0)
class UTedBuildingGridPanel : public UTedContentPanelDynamic
{
public:
	uint8                                         ColumnsCount;                                      // 0x07B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         RowsCount;                                         // 0x07B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7B2[0x6];                                      // 0x07B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UInputAction>            BaseShortcutInputAction;                           // 0x07B8(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTedPlayerCommand_ConstructionQueue> EnqueueCmdSingle;                         // 0x07E0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTedPlayerCommand_ConstructionQueue> EnqueueCmdMultiple;                       // 0x07E8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTedPlayerCommand_ConstructionQueue> DequeueCmdSingle;                         // 0x07F0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTedPlayerCommand_ConstructionQueue> DequeueCmdMultiple;                       // 0x07F8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTedPlayerCommand_PauseConstruction> PauseConstructionCmd;                     // 0x0800(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTedPlayerCommand_PauseConstruction> UnPauseConstructionCmd;                   // 0x0808(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTedPlayerCommand_PlaceStructure> PlaceStructureCmd;                           // 0x0810(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTedPlayerCommand_PlaceConstructionSite> PlaceConstructionSiteCmd;             // 0x0818(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           SelectedFactoryTab;                                // 0x0820(0x0008)(Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATedStructureBase*                      SelectedFactory;                                   // 0x0828(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTedConstructionElementType>    CachedContent;                                     // 0x0830(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	class UTedPlayerData*                         TargetPlayerData;                                  // 0x0840(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static ETedContentSlotState GetMissingPrerequisitesSlotState();

	void K2_SelectFactoryTab(const struct FGameplayTag& InTab, bool bInRefreshContent);
	void RefreshDisabledState();
	void SelectFactory(class ATedStructureBase* InFactory, bool bInRefreshContent);
	void SetTargetPlayerData(class UTedPlayerData* InPlayerData, bool bInRefreshContent);

	class ATedStructureBase* GetSelectedFactory() const;
	bool GetSelectedFactoryTab(struct FGameplayTag* OutTab) const;
	bool GetShortcut(const int32 InSlotIndex, struct FInputActionKeyMapping* OutShortcut) const;
	class UTedPlayerData* GetTargetPlayerData() const;
	bool IsConstructionCompleted(const int32 InSlotIndex) const;
	bool IsConstructionInProgress(const int32 InSlotIndex) const;
	bool IsConstructionPaused(const int32 InSlotIndex) const;
	bool K2_GetContent_Structure(int32 InSlotIndex, TSubclassOf<class ATedStructureBase>* OutContent) const;
	bool K2_GetContent_Unit(int32 InSlotIndex, TSubclassOf<class ATedUnitBase>* OutContent) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedBuildingGridPanel">();
	}
	static class UTedBuildingGridPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedBuildingGridPanel>();
	}
};
static_assert(alignof(UTedBuildingGridPanel) == 0x000008, "Wrong alignment on UTedBuildingGridPanel");
static_assert(sizeof(UTedBuildingGridPanel) == 0x000848, "Wrong size on UTedBuildingGridPanel");
static_assert(offsetof(UTedBuildingGridPanel, ColumnsCount) == 0x0007B0, "Member 'UTedBuildingGridPanel::ColumnsCount' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridPanel, RowsCount) == 0x0007B1, "Member 'UTedBuildingGridPanel::RowsCount' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridPanel, BaseShortcutInputAction) == 0x0007B8, "Member 'UTedBuildingGridPanel::BaseShortcutInputAction' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridPanel, EnqueueCmdSingle) == 0x0007E0, "Member 'UTedBuildingGridPanel::EnqueueCmdSingle' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridPanel, EnqueueCmdMultiple) == 0x0007E8, "Member 'UTedBuildingGridPanel::EnqueueCmdMultiple' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridPanel, DequeueCmdSingle) == 0x0007F0, "Member 'UTedBuildingGridPanel::DequeueCmdSingle' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridPanel, DequeueCmdMultiple) == 0x0007F8, "Member 'UTedBuildingGridPanel::DequeueCmdMultiple' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridPanel, PauseConstructionCmd) == 0x000800, "Member 'UTedBuildingGridPanel::PauseConstructionCmd' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridPanel, UnPauseConstructionCmd) == 0x000808, "Member 'UTedBuildingGridPanel::UnPauseConstructionCmd' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridPanel, PlaceStructureCmd) == 0x000810, "Member 'UTedBuildingGridPanel::PlaceStructureCmd' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridPanel, PlaceConstructionSiteCmd) == 0x000818, "Member 'UTedBuildingGridPanel::PlaceConstructionSiteCmd' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridPanel, SelectedFactoryTab) == 0x000820, "Member 'UTedBuildingGridPanel::SelectedFactoryTab' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridPanel, SelectedFactory) == 0x000828, "Member 'UTedBuildingGridPanel::SelectedFactory' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridPanel, CachedContent) == 0x000830, "Member 'UTedBuildingGridPanel::CachedContent' has a wrong offset!");
static_assert(offsetof(UTedBuildingGridPanel, TargetPlayerData) == 0x000840, "Member 'UTedBuildingGridPanel::TargetPlayerData' has a wrong offset!");

// Class Tempest.TedObjectiveConditionBase
// 0x00C0 (0x00E8 - 0x0028)
class UTedObjectiveConditionBase : public UObject
{
public:
	class FText                                   DisplayText;                                       // 0x0028(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)
	class UTedObjectiveProgress*                  DisplayProgress;                                   // 0x0038(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EObjectiveResultWithNone                      MetResult;                                         // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EObjectiveResultWithNone                      NotMetResult;                                      // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           RuntimeID;                                         // 0x0044(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bExpectRuntimeData : 1;                            // 0x004C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDisplayOnUI : 1;                                  // 0x004C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIgnoreProgressAnnouncement : 1;                   // 0x004C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIgnoreStateAnnouncement : 1;                      // 0x004C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIgnoreUpdateAnimation : 1;                        // 0x004C(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedMarkerConfig*                       MarkerOverride;                                    // 0x0050(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bShowMarker : 1;                                   // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bActive : 1;                                       // 0x0058(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	EObjectiveConditionState                      State;                                             // 0x0059(0x0001)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AActor*>                           MarkedActors;                                      // 0x0060(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	class UTedObjectiveObj*                       OwningObjective;                                   // 0x00B0(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyProgressChange();
	void RemoveMarker(const class AActor* InActor);
	struct FTedMarkerHandle TryAddMarker(const class AActor* InActor);

	bool CanBeDisplayedOnUI() const;
	bool ExpectsRuntimeData() const;
	EObjectiveResultWithNone GetCurrentDesiredResult() const;
	EObjectiveResultWithNone GetDesiredResult(const EObjectiveConditionState InState) const;
	EObjectiveConditionState GetState() const;
	bool HasAnyDesiredResult() const;
	bool HasDesiredResult(EObjectiveResult InResult) const;
	bool IsActive() const;
	bool IsRestoringFromSave() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveConditionBase">();
	}
	static class UTedObjectiveConditionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveConditionBase>();
	}
};
static_assert(alignof(UTedObjectiveConditionBase) == 0x000008, "Wrong alignment on UTedObjectiveConditionBase");
static_assert(sizeof(UTedObjectiveConditionBase) == 0x0000E8, "Wrong size on UTedObjectiveConditionBase");
static_assert(offsetof(UTedObjectiveConditionBase, DisplayText) == 0x000028, "Member 'UTedObjectiveConditionBase::DisplayText' has a wrong offset!");
static_assert(offsetof(UTedObjectiveConditionBase, DisplayProgress) == 0x000038, "Member 'UTedObjectiveConditionBase::DisplayProgress' has a wrong offset!");
static_assert(offsetof(UTedObjectiveConditionBase, MetResult) == 0x000040, "Member 'UTedObjectiveConditionBase::MetResult' has a wrong offset!");
static_assert(offsetof(UTedObjectiveConditionBase, NotMetResult) == 0x000041, "Member 'UTedObjectiveConditionBase::NotMetResult' has a wrong offset!");
static_assert(offsetof(UTedObjectiveConditionBase, RuntimeID) == 0x000044, "Member 'UTedObjectiveConditionBase::RuntimeID' has a wrong offset!");
static_assert(offsetof(UTedObjectiveConditionBase, MarkerOverride) == 0x000050, "Member 'UTedObjectiveConditionBase::MarkerOverride' has a wrong offset!");
static_assert(offsetof(UTedObjectiveConditionBase, State) == 0x000059, "Member 'UTedObjectiveConditionBase::State' has a wrong offset!");
static_assert(offsetof(UTedObjectiveConditionBase, MarkedActors) == 0x000060, "Member 'UTedObjectiveConditionBase::MarkedActors' has a wrong offset!");
static_assert(offsetof(UTedObjectiveConditionBase, OwningObjective) == 0x0000B0, "Member 'UTedObjectiveConditionBase::OwningObjective' has a wrong offset!");

// Class Tempest.TedObjectiveCondition_HaveResourceBase
// 0x0010 (0x00F8 - 0x00E8)
class UTedObjectiveCondition_HaveResourceBase : public UTedObjectiveConditionBase
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EComparison                                   ComparisonMethod;                                  // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        ExpectedAmount;                                    // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPlayerResourcesChangeEvent_Handler(class UTedPlayerData* InPlayerData, const struct FTedPlayerDataResources& InPrevious, const struct FTedPlayerDataResources& InCurrent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveCondition_HaveResourceBase">();
	}
	static class UTedObjectiveCondition_HaveResourceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveCondition_HaveResourceBase>();
	}
};
static_assert(alignof(UTedObjectiveCondition_HaveResourceBase) == 0x000008, "Wrong alignment on UTedObjectiveCondition_HaveResourceBase");
static_assert(sizeof(UTedObjectiveCondition_HaveResourceBase) == 0x0000F8, "Wrong size on UTedObjectiveCondition_HaveResourceBase");
static_assert(offsetof(UTedObjectiveCondition_HaveResourceBase, ComparisonMethod) == 0x0000F0, "Member 'UTedObjectiveCondition_HaveResourceBase::ComparisonMethod' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_HaveResourceBase, ExpectedAmount) == 0x0000F4, "Member 'UTedObjectiveCondition_HaveResourceBase::ExpectedAmount' has a wrong offset!");

// Class Tempest.TedObjectiveCondition_HaveResource_PowerConsumption
// 0x0000 (0x00F8 - 0x00F8)
class UTedObjectiveCondition_HaveResource_PowerConsumption final : public UTedObjectiveCondition_HaveResourceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveCondition_HaveResource_PowerConsumption">();
	}
	static class UTedObjectiveCondition_HaveResource_PowerConsumption* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveCondition_HaveResource_PowerConsumption>();
	}
};
static_assert(alignof(UTedObjectiveCondition_HaveResource_PowerConsumption) == 0x000008, "Wrong alignment on UTedObjectiveCondition_HaveResource_PowerConsumption");
static_assert(sizeof(UTedObjectiveCondition_HaveResource_PowerConsumption) == 0x0000F8, "Wrong size on UTedObjectiveCondition_HaveResource_PowerConsumption");

// Class Tempest.TedBuildingGridSlotBase
// 0x0008 (0x0438 - 0x0430)
class UTedBuildingGridSlotBase : public UTedContentPanelSlotButton
{
public:
	class UTextBlock*                             TextBlock_Shortcut;                                // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRefresh_Common(const class UTedEntityDefinitionAsset* InDefinition);
	void OnRefresh_Empty();
	void OnRefresh_Progress(uint8 InQueuedCount, bool bInPaused, bool bInCompleted, bool bInRunning, float InProgress);
	void OnRefresh_Structure(const class UTedStructureDefinitionAsset* InDefinition);
	void OnRefresh_Unit(const class UTedUnitDefinitionAsset* InDefinition);
	void RefreshProgress();

	class UTedBuildingGridPanel* GetBuildingGridPanel() const;
	class ATedStructureBase* GetFactory() const;
	bool HasContent() const;
	bool IsStructure() const;
	bool IsUnit() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedBuildingGridSlotBase">();
	}
	static class UTedBuildingGridSlotBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedBuildingGridSlotBase>();
	}
};
static_assert(alignof(UTedBuildingGridSlotBase) == 0x000008, "Wrong alignment on UTedBuildingGridSlotBase");
static_assert(sizeof(UTedBuildingGridSlotBase) == 0x000438, "Wrong size on UTedBuildingGridSlotBase");
static_assert(offsetof(UTedBuildingGridSlotBase, TextBlock_Shortcut) == 0x000430, "Member 'UTedBuildingGridSlotBase::TextBlock_Shortcut' has a wrong offset!");

// Class Tempest.TedObjectiveCondition_KillActors
// 0x00C0 (0x01A8 - 0x00E8)
class UTedObjectiveCondition_KillActors final : public UTedObjectiveConditionBase
{
public:
	TArray<TSoftObjectPtr<class ATedPawn>>        Actors;                                            // 0x00E8(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         ExpectedAmount;                                    // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ATedPawn*, struct FTedMarkerHandle> MarkerHandleAccelMap;                             // 0x0100(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TSet<TSoftObjectPtr<class ATedPawn>>          DeadActors;                                        // 0x0150(0x0050)(Transient, DuplicateTransient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UTedMarkerConfig*                       MarkerConfig;                                      // 0x01A0(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void PassRuntimeData(const TArray<class ATedPawn*>& InActors, const uint8 InExpectedAmount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveCondition_KillActors">();
	}
	static class UTedObjectiveCondition_KillActors* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveCondition_KillActors>();
	}
};
static_assert(alignof(UTedObjectiveCondition_KillActors) == 0x000008, "Wrong alignment on UTedObjectiveCondition_KillActors");
static_assert(sizeof(UTedObjectiveCondition_KillActors) == 0x0001A8, "Wrong size on UTedObjectiveCondition_KillActors");
static_assert(offsetof(UTedObjectiveCondition_KillActors, Actors) == 0x0000E8, "Member 'UTedObjectiveCondition_KillActors::Actors' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_KillActors, ExpectedAmount) == 0x0000F8, "Member 'UTedObjectiveCondition_KillActors::ExpectedAmount' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_KillActors, MarkerHandleAccelMap) == 0x000100, "Member 'UTedObjectiveCondition_KillActors::MarkerHandleAccelMap' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_KillActors, DeadActors) == 0x000150, "Member 'UTedObjectiveCondition_KillActors::DeadActors' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_KillActors, MarkerConfig) == 0x0001A0, "Member 'UTedObjectiveCondition_KillActors::MarkerConfig' has a wrong offset!");

// Class Tempest.TedCamModifer_CC
// 0x0040 (0x0088 - 0x0048)
class UTedCamModifer_CC final : public UCameraModifier
{
public:
	float                                         SwayStrength;                                      // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               SwayRotator;                                       // 0x0050(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x20];                                      // 0x0068(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCamModifer_CC">();
	}
	static class UTedCamModifer_CC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCamModifer_CC>();
	}
};
static_assert(alignof(UTedCamModifer_CC) == 0x000008, "Wrong alignment on UTedCamModifer_CC");
static_assert(sizeof(UTedCamModifer_CC) == 0x000088, "Wrong size on UTedCamModifer_CC");
static_assert(offsetof(UTedCamModifer_CC, SwayStrength) == 0x000048, "Member 'UTedCamModifer_CC::SwayStrength' has a wrong offset!");
static_assert(offsetof(UTedCamModifer_CC, SwayRotator) == 0x000050, "Member 'UTedCamModifer_CC::SwayRotator' has a wrong offset!");

// Class Tempest.TedChartWidgetBase
// 0x05E0 (0x09E0 - 0x0400)
class UTedChartWidgetBase : public UTedUserWidget
{
public:
	TMulticastInlineDelegate<void()>              OnRevealingFinished;                               // 0x0400(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_410[0x20];                                     // 0x0410(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimationDuration;                                 // 0x0430(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_434[0x4];                                      // 0x0434(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedChartMarkerMinimal                 HorizontalAxis;                                    // 0x0438(0x00B8)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FTedChartMarkerMinimal                 HorizontalRuler;                                   // 0x04F0(0x00B8)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FTedChartValueRoundingRules            HorizontalRounding;                                // 0x05A8(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FTedChartMarkerMinimal                 VerticalAxis;                                      // 0x05B8(0x00B8)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FTedChartMarkerMinimal                 VerticalRuler;                                     // 0x0670(0x00B8)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FTedChartValueRoundingRules            VerticalRounding;                                  // 0x0728(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FTedSlateText                          CursorText;                                        // 0x0738(0x00A0)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_7D8[0x8];                                      // 0x07D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            CursorBrush;                                       // 0x07E0(0x00D0)(Edit, Protected, NativeAccessSpecifierProtected)
	int32                                         RulerCountHorizontal;                              // 0x08B0(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RulerCountVertical;                                // 0x08B4(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              ValuesRange;                                       // 0x08B8(0x0010)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ElapsedProgress;                                   // 0x08C8(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8CC[0x4];                                      // 0x08CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedSlateText                          TextPainter;                                       // 0x08D0(0x00A0)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	struct FTedChartDisplayData                   DisplayData;                                       // 0x0970(0x0038)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_9A8[0x30];                                     // 0x09A8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bPaintRulers : 1;                                  // 0x09D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPaintMarkers : 1;                                 // 0x09D8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPaintContent : 1;                                 // 0x09D8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPaintAxes : 1;                                    // 0x09D8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_9D9[0x7];                                      // 0x09D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Reset();
	void RestartAnimation();
	void SetDisplayData(const struct FTedChartDisplayData& InData, const bool bInRestartAnim);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedChartWidgetBase">();
	}
	static class UTedChartWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedChartWidgetBase>();
	}
};
static_assert(alignof(UTedChartWidgetBase) == 0x000010, "Wrong alignment on UTedChartWidgetBase");
static_assert(sizeof(UTedChartWidgetBase) == 0x0009E0, "Wrong size on UTedChartWidgetBase");
static_assert(offsetof(UTedChartWidgetBase, OnRevealingFinished) == 0x000400, "Member 'UTedChartWidgetBase::OnRevealingFinished' has a wrong offset!");
static_assert(offsetof(UTedChartWidgetBase, AnimationDuration) == 0x000430, "Member 'UTedChartWidgetBase::AnimationDuration' has a wrong offset!");
static_assert(offsetof(UTedChartWidgetBase, HorizontalAxis) == 0x000438, "Member 'UTedChartWidgetBase::HorizontalAxis' has a wrong offset!");
static_assert(offsetof(UTedChartWidgetBase, HorizontalRuler) == 0x0004F0, "Member 'UTedChartWidgetBase::HorizontalRuler' has a wrong offset!");
static_assert(offsetof(UTedChartWidgetBase, HorizontalRounding) == 0x0005A8, "Member 'UTedChartWidgetBase::HorizontalRounding' has a wrong offset!");
static_assert(offsetof(UTedChartWidgetBase, VerticalAxis) == 0x0005B8, "Member 'UTedChartWidgetBase::VerticalAxis' has a wrong offset!");
static_assert(offsetof(UTedChartWidgetBase, VerticalRuler) == 0x000670, "Member 'UTedChartWidgetBase::VerticalRuler' has a wrong offset!");
static_assert(offsetof(UTedChartWidgetBase, VerticalRounding) == 0x000728, "Member 'UTedChartWidgetBase::VerticalRounding' has a wrong offset!");
static_assert(offsetof(UTedChartWidgetBase, CursorText) == 0x000738, "Member 'UTedChartWidgetBase::CursorText' has a wrong offset!");
static_assert(offsetof(UTedChartWidgetBase, CursorBrush) == 0x0007E0, "Member 'UTedChartWidgetBase::CursorBrush' has a wrong offset!");
static_assert(offsetof(UTedChartWidgetBase, RulerCountHorizontal) == 0x0008B0, "Member 'UTedChartWidgetBase::RulerCountHorizontal' has a wrong offset!");
static_assert(offsetof(UTedChartWidgetBase, RulerCountVertical) == 0x0008B4, "Member 'UTedChartWidgetBase::RulerCountVertical' has a wrong offset!");
static_assert(offsetof(UTedChartWidgetBase, ValuesRange) == 0x0008B8, "Member 'UTedChartWidgetBase::ValuesRange' has a wrong offset!");
static_assert(offsetof(UTedChartWidgetBase, ElapsedProgress) == 0x0008C8, "Member 'UTedChartWidgetBase::ElapsedProgress' has a wrong offset!");
static_assert(offsetof(UTedChartWidgetBase, TextPainter) == 0x0008D0, "Member 'UTedChartWidgetBase::TextPainter' has a wrong offset!");
static_assert(offsetof(UTedChartWidgetBase, DisplayData) == 0x000970, "Member 'UTedChartWidgetBase::DisplayData' has a wrong offset!");

// Class Tempest.TedObjectiveCondition_ActorTag
// 0x0078 (0x0160 - 0x00E8)
class UTedObjectiveCondition_ActorTag : public UTedObjectiveConditionBase
{
public:
	struct FGameplayTagContainer                  ActorTags;                                         // 0x00E8(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	TSet<class AActor*>                           CachedActors;                                      // 0x0108(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	class UTedMarkerConfig*                       MarkerConfig;                                      // 0x0158(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveCondition_ActorTag">();
	}
	static class UTedObjectiveCondition_ActorTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveCondition_ActorTag>();
	}
};
static_assert(alignof(UTedObjectiveCondition_ActorTag) == 0x000008, "Wrong alignment on UTedObjectiveCondition_ActorTag");
static_assert(sizeof(UTedObjectiveCondition_ActorTag) == 0x000160, "Wrong size on UTedObjectiveCondition_ActorTag");
static_assert(offsetof(UTedObjectiveCondition_ActorTag, ActorTags) == 0x0000E8, "Member 'UTedObjectiveCondition_ActorTag::ActorTags' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_ActorTag, CachedActors) == 0x000108, "Member 'UTedObjectiveCondition_ActorTag::CachedActors' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_ActorTag, MarkerConfig) == 0x000158, "Member 'UTedObjectiveCondition_ActorTag::MarkerConfig' has a wrong offset!");

// Class Tempest.TedObjectiveCondition_LosePawn
// 0x0020 (0x0180 - 0x0160)
class UTedObjectiveCondition_LosePawn final : public UTedObjectiveCondition_ActorTag
{
public:
	uint8                                         Pad_160[0x8];                                      // 0x0160(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         ExpectedAmount;                                    // 0x0168(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EComparison                                   Comparison;                                        // 0x0169(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bHandleExistance : 1;                              // 0x016A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHandleDeath : 1;                                  // 0x016A(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHandleOwnershipChange : 1;                        // 0x016A(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	ETedPlayerID                                  OwningPlayer;                                      // 0x016B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentAmount;                                     // 0x016C(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ATedPawn*>                       AlreadyLost;                                       // 0x0170(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)

public:
	void OnPawnEndPlay(class AActor* InActor, EEndPlayReason InEndPlayReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveCondition_LosePawn">();
	}
	static class UTedObjectiveCondition_LosePawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveCondition_LosePawn>();
	}
};
static_assert(alignof(UTedObjectiveCondition_LosePawn) == 0x000008, "Wrong alignment on UTedObjectiveCondition_LosePawn");
static_assert(sizeof(UTedObjectiveCondition_LosePawn) == 0x000180, "Wrong size on UTedObjectiveCondition_LosePawn");
static_assert(offsetof(UTedObjectiveCondition_LosePawn, ExpectedAmount) == 0x000168, "Member 'UTedObjectiveCondition_LosePawn::ExpectedAmount' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_LosePawn, Comparison) == 0x000169, "Member 'UTedObjectiveCondition_LosePawn::Comparison' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_LosePawn, OwningPlayer) == 0x00016B, "Member 'UTedObjectiveCondition_LosePawn::OwningPlayer' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_LosePawn, CurrentAmount) == 0x00016C, "Member 'UTedObjectiveCondition_LosePawn::CurrentAmount' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_LosePawn, AlreadyLost) == 0x000170, "Member 'UTedObjectiveCondition_LosePawn::AlreadyLost' has a wrong offset!");

// Class Tempest.TedPreviewChart_Static
// 0x0030 (0x0068 - 0x0038)
class UTedPreviewChart_Static final : public UTedPreviewChart
{
public:
	struct FTedChartData                          Data;                                              // 0x0038(0x0030)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPreviewChart_Static">();
	}
	static class UTedPreviewChart_Static* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPreviewChart_Static>();
	}
};
static_assert(alignof(UTedPreviewChart_Static) == 0x000008, "Wrong alignment on UTedPreviewChart_Static");
static_assert(sizeof(UTedPreviewChart_Static) == 0x000068, "Wrong size on UTedPreviewChart_Static");
static_assert(offsetof(UTedPreviewChart_Static, Data) == 0x000038, "Member 'UTedPreviewChart_Static::Data' has a wrong offset!");

// Class Tempest.TedPreviewChartMarker
// 0x00C8 (0x00F8 - 0x0030)
class UTedPreviewChartMarker final : public UDataAsset
{
public:
	uint8                                         bStripFromGame : 1;                                // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedChartMarker                        Data;                                              // 0x0038(0x00C0)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPreviewChartMarker">();
	}
	static class UTedPreviewChartMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPreviewChartMarker>();
	}
};
static_assert(alignof(UTedPreviewChartMarker) == 0x000008, "Wrong alignment on UTedPreviewChartMarker");
static_assert(sizeof(UTedPreviewChartMarker) == 0x0000F8, "Wrong size on UTedPreviewChartMarker");
static_assert(offsetof(UTedPreviewChartMarker, Data) == 0x000038, "Member 'UTedPreviewChartMarker::Data' has a wrong offset!");

// Class Tempest.TedObjectiveCondition_StructureTeam
// 0x00B8 (0x01A0 - 0x00E8)
class UTedObjectiveCondition_StructureTeam final : public UTedObjectiveConditionBase
{
public:
	uint8                                         ExpectedAmount;                                    // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class ATedStructureBase>> Structures;                                      // 0x00F0(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	ETedPlayerID                                  PlayerID;                                          // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bInverseCondition : 1;                             // 0x0101(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHandleDestroyedStructures : 1;                    // 0x0101(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_102[0x6];                                      // 0x0102(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedBaseLatentActionWrapper_KillPawns  HandleDestroyedStructures;                         // 0x0108(0x0040)(Edit, Protected, NativeAccessSpecifierProtected)
	TSet<TSoftObjectPtr<class ATedStructureBase>> MatchingStructures;                                // 0x0148(0x0050)(Transient, DuplicateTransient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UTedMarkerConfig*                       MarkerConfig;                                      // 0x0198(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void PassRuntimeData(const TArray<class ATedStructureBase*>& InStructures, const ETedPlayerID InPlayerID, const uint8 InExpectedAmount, const bool bInInverseCondition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveCondition_StructureTeam">();
	}
	static class UTedObjectiveCondition_StructureTeam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveCondition_StructureTeam>();
	}
};
static_assert(alignof(UTedObjectiveCondition_StructureTeam) == 0x000008, "Wrong alignment on UTedObjectiveCondition_StructureTeam");
static_assert(sizeof(UTedObjectiveCondition_StructureTeam) == 0x0001A0, "Wrong size on UTedObjectiveCondition_StructureTeam");
static_assert(offsetof(UTedObjectiveCondition_StructureTeam, ExpectedAmount) == 0x0000E8, "Member 'UTedObjectiveCondition_StructureTeam::ExpectedAmount' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_StructureTeam, Structures) == 0x0000F0, "Member 'UTedObjectiveCondition_StructureTeam::Structures' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_StructureTeam, PlayerID) == 0x000100, "Member 'UTedObjectiveCondition_StructureTeam::PlayerID' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_StructureTeam, HandleDestroyedStructures) == 0x000108, "Member 'UTedObjectiveCondition_StructureTeam::HandleDestroyedStructures' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_StructureTeam, MatchingStructures) == 0x000148, "Member 'UTedObjectiveCondition_StructureTeam::MatchingStructures' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_StructureTeam, MarkerConfig) == 0x000198, "Member 'UTedObjectiveCondition_StructureTeam::MarkerConfig' has a wrong offset!");

// Class Tempest.TedChatPartyContextPanel
// 0x0028 (0x07D8 - 0x07B0)
class UTedChatPartyContextPanel final : public UTedContentPanelDynamic
{
public:
	uint8                                         Pad_7B0[0x28];                                     // 0x07B0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static ETedContentSlotState GetStateForUnreadMessageInContext();

	void CloseContext(const int32 SlotIndex);
	class FText GetContextTitle(const int32 SlotIndex);
	bool IsSlotLobbyContext(const int32 SlotIndex);
	bool IsSlotTeamContext(const int32 SlotIndex);
	bool IsSlotWhisperContext(const int32 SlotIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedChatPartyContextPanel">();
	}
	static class UTedChatPartyContextPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedChatPartyContextPanel>();
	}
};
static_assert(alignof(UTedChatPartyContextPanel) == 0x000008, "Wrong alignment on UTedChatPartyContextPanel");
static_assert(sizeof(UTedChatPartyContextPanel) == 0x0007D8, "Wrong size on UTedChatPartyContextPanel");

// Class Tempest.TedChatPartyPlayerBadge
// 0x0000 (0x0400 - 0x0400)
class UTedChatPartyPlayerBadge : public UTedUserWidget
{
public:
	void K2_DescribeDestination(const EChatMessageDestination& Destination);
	void K2_DescribePreorder(const bool bPreorder);
	void K2_DescribeSameTeam(const bool bIsSameTeam);
	void K2_DescribeSender(const EChatMessageSender& Sender);
	void K2_DescribeSenderName(const class FString& Name_0);
	void K2_DescribeTimestamp(const struct FDateTime& Timestamp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedChatPartyPlayerBadge">();
	}
	static class UTedChatPartyPlayerBadge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedChatPartyPlayerBadge>();
	}
};
static_assert(alignof(UTedChatPartyPlayerBadge) == 0x000008, "Wrong alignment on UTedChatPartyPlayerBadge");
static_assert(sizeof(UTedChatPartyPlayerBadge) == 0x000400, "Wrong size on UTedChatPartyPlayerBadge");

// Class Tempest.TedMovieSequencePlayerActor
// 0x0090 (0x0320 - 0x0290)
class ATedMovieSequencePlayerActor final : public AInfo
{
public:
	class UTedMoviePlayerConfig*                  MovieConfig;                                       // 0x0290(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTedMoviePlayParams                    MoviePlayParams;                                   // 0x0298(0x0018)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTedMovieSequenceStage>         Stages;                                            // 0x02B0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  SequenceTags;                                      // 0x02C0(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	int32                                         PlayingStage;                                      // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bPlaying : 1;                                      // 0x02E4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Interp, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2E5[0x3];                                      // 0x02E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedMoviePlayerController*              MoviePlayerController;                             // 0x02E8(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x30];                                     // 0x02F0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ATedMovieSequencePlayerActor* K2_GetMovieSequencePlayer(const class UObject* InContextObject, const struct FGameplayTag& SequenceTag);

	bool PlayFirstStage();
	bool PlayLastStage();
	bool PlayNextStage();
	bool PlayStage(const int32 InStageIndex);
	void SetPlaying(const bool bInValue);
	void SetPlayingStage(const int32 InValue);

	int32 GetLastStage() const;
	const class UTedMoviePlayerConfig* GetMovieConfig() const;
	int32 GetPlayingStage() const;
	const struct FGameplayTagContainer GetSequenceTags() const;
	int32 GetStagesNum() const;
	bool IsPlaying() const;
	bool IsPlayingLastStage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMovieSequencePlayerActor">();
	}
	static class ATedMovieSequencePlayerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedMovieSequencePlayerActor>();
	}
};
static_assert(alignof(ATedMovieSequencePlayerActor) == 0x000008, "Wrong alignment on ATedMovieSequencePlayerActor");
static_assert(sizeof(ATedMovieSequencePlayerActor) == 0x000320, "Wrong size on ATedMovieSequencePlayerActor");
static_assert(offsetof(ATedMovieSequencePlayerActor, MovieConfig) == 0x000290, "Member 'ATedMovieSequencePlayerActor::MovieConfig' has a wrong offset!");
static_assert(offsetof(ATedMovieSequencePlayerActor, MoviePlayParams) == 0x000298, "Member 'ATedMovieSequencePlayerActor::MoviePlayParams' has a wrong offset!");
static_assert(offsetof(ATedMovieSequencePlayerActor, Stages) == 0x0002B0, "Member 'ATedMovieSequencePlayerActor::Stages' has a wrong offset!");
static_assert(offsetof(ATedMovieSequencePlayerActor, SequenceTags) == 0x0002C0, "Member 'ATedMovieSequencePlayerActor::SequenceTags' has a wrong offset!");
static_assert(offsetof(ATedMovieSequencePlayerActor, PlayingStage) == 0x0002E0, "Member 'ATedMovieSequencePlayerActor::PlayingStage' has a wrong offset!");
static_assert(offsetof(ATedMovieSequencePlayerActor, MoviePlayerController) == 0x0002E8, "Member 'ATedMovieSequencePlayerActor::MoviePlayerController' has a wrong offset!");

// Class Tempest.TedChatPartyPlayersPanel
// 0x0108 (0x08B8 - 0x07B0)
class UTedChatPartyPlayersPanel final : public UTedContentPanelDynamic
{
public:
	uint8                                         Pad_7B0[0x18];                                     // 0x07B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ATedLobbyBeaconState*                   CachedLobbyState;                                  // 0x07C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTedPartyManager*                       PartyMgr;                                          // 0x07D0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTedOnlineFriendsManager*               FriendsMgr;                                        // 0x07D8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTedOnlineSessionsAPI*                  OnlineAPI;                                         // 0x07E0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UTedUserWidget>             PlayerActionPanelClass;                            // 0x07E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FSlateBrush>         SectionBrushes;                                    // 0x07F0(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          bShowFriends;                                      // 0x0840(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_841[0x77];                                     // 0x0841(0x0077)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayerActionPanelSlotAction(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction);
	void OnRegisterPlayerSectionSlot(class UTedContentPanelSlotBase* ContentSlot, const struct FTedChatPartyPlayerSection& PlayerSectionHeader);
	void OnRegisterPlayerSlot(class UTedContentPanelSlotBase* ContentSlot, const struct FTedChatPartyPlayer_BP& Player);

	class FText GetDisplayNameForSection(const class FName& SectionID) const;
	struct FTedChatPartyPlayer_BP GetPlayerContent(const int32 InSlotIndex, bool* bSuccess) const;
	struct FTedChatPartyPlayerSection GetSectionContent(const int32 InSlotIndex, bool* bSuccess) const;
	bool IsSlotIndexPlayer(const int32 SlotIndex) const;
	bool IsSlotIndexSection(const int32 SlotIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedChatPartyPlayersPanel">();
	}
	static class UTedChatPartyPlayersPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedChatPartyPlayersPanel>();
	}
};
static_assert(alignof(UTedChatPartyPlayersPanel) == 0x000008, "Wrong alignment on UTedChatPartyPlayersPanel");
static_assert(sizeof(UTedChatPartyPlayersPanel) == 0x0008B8, "Wrong size on UTedChatPartyPlayersPanel");
static_assert(offsetof(UTedChatPartyPlayersPanel, CachedLobbyState) == 0x0007C8, "Member 'UTedChatPartyPlayersPanel::CachedLobbyState' has a wrong offset!");
static_assert(offsetof(UTedChatPartyPlayersPanel, PartyMgr) == 0x0007D0, "Member 'UTedChatPartyPlayersPanel::PartyMgr' has a wrong offset!");
static_assert(offsetof(UTedChatPartyPlayersPanel, FriendsMgr) == 0x0007D8, "Member 'UTedChatPartyPlayersPanel::FriendsMgr' has a wrong offset!");
static_assert(offsetof(UTedChatPartyPlayersPanel, OnlineAPI) == 0x0007E0, "Member 'UTedChatPartyPlayersPanel::OnlineAPI' has a wrong offset!");
static_assert(offsetof(UTedChatPartyPlayersPanel, PlayerActionPanelClass) == 0x0007E8, "Member 'UTedChatPartyPlayersPanel::PlayerActionPanelClass' has a wrong offset!");
static_assert(offsetof(UTedChatPartyPlayersPanel, SectionBrushes) == 0x0007F0, "Member 'UTedChatPartyPlayersPanel::SectionBrushes' has a wrong offset!");
static_assert(offsetof(UTedChatPartyPlayersPanel, bShowFriends) == 0x000840, "Member 'UTedChatPartyPlayersPanel::bShowFriends' has a wrong offset!");

// Class Tempest.TedNavArea_FoliageObstacle
// 0x0000 (0x0048 - 0x0048)
class UTedNavArea_FoliageObstacle final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedNavArea_FoliageObstacle">();
	}
	static class UTedNavArea_FoliageObstacle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedNavArea_FoliageObstacle>();
	}
};
static_assert(alignof(UTedNavArea_FoliageObstacle) == 0x000008, "Wrong alignment on UTedNavArea_FoliageObstacle");
static_assert(sizeof(UTedNavArea_FoliageObstacle) == 0x000048, "Wrong size on UTedNavArea_FoliageObstacle");

// Class Tempest.TedChatPartyWidget_MainMenu
// 0x0098 (0x0540 - 0x04A8)
class UTedChatPartyWidget_MainMenu final : public UTedChatPartyWidget
{
public:
	uint8                                         Pad_4A8[0x8];                                      // 0x04A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bExpanded)> OnExpanded;                                       // 0x04B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UTedChatPartyPlayersPanel*              ExpandedPlayersPanel;                              // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTedChatPartyPlayersPanel*              CollapsedPlayersPanel;                             // 0x04C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTedChatPartyContextPanel*              ChatContextPanel;                                  // 0x04D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D8[0x18];                                     // 0x04D8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FTedChatPartyContext, class FString> CachedChats;                                    // 0x04F0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	class UTedChatPartyContextPanel* GetChatContextPanel();
	class UTedChatPartyPlayersPanel* GetCollapsedPartyPlayersPanel();
	void OnChatContextContentChange(class UTedContentPanelDynamic* InContentPanel);
	void OnChatContextSlotActivatedState(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotState InState, bool bInActivated);
	void OnContextsEmpty(bool bEmpty);
	void OnMainMenuTabSelected(class UWidget* InWidget, const class FName& InTabName);
	void OnPlayersChanged(class UTedContentPanelDynamic* InContentPanel);
	void SetExpanded(const bool bExpanded);
	void TriggerExpanded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedChatPartyWidget_MainMenu">();
	}
	static class UTedChatPartyWidget_MainMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedChatPartyWidget_MainMenu>();
	}
};
static_assert(alignof(UTedChatPartyWidget_MainMenu) == 0x000008, "Wrong alignment on UTedChatPartyWidget_MainMenu");
static_assert(sizeof(UTedChatPartyWidget_MainMenu) == 0x000540, "Wrong size on UTedChatPartyWidget_MainMenu");
static_assert(offsetof(UTedChatPartyWidget_MainMenu, OnExpanded) == 0x0004B0, "Member 'UTedChatPartyWidget_MainMenu::OnExpanded' has a wrong offset!");
static_assert(offsetof(UTedChatPartyWidget_MainMenu, ExpandedPlayersPanel) == 0x0004C0, "Member 'UTedChatPartyWidget_MainMenu::ExpandedPlayersPanel' has a wrong offset!");
static_assert(offsetof(UTedChatPartyWidget_MainMenu, CollapsedPlayersPanel) == 0x0004C8, "Member 'UTedChatPartyWidget_MainMenu::CollapsedPlayersPanel' has a wrong offset!");
static_assert(offsetof(UTedChatPartyWidget_MainMenu, ChatContextPanel) == 0x0004D0, "Member 'UTedChatPartyWidget_MainMenu::ChatContextPanel' has a wrong offset!");
static_assert(offsetof(UTedChatPartyWidget_MainMenu, CachedChats) == 0x0004F0, "Member 'UTedChatPartyWidget_MainMenu::CachedChats' has a wrong offset!");

// Class Tempest.TedChatWindow
// 0x0038 (0x0438 - 0x0400)
class UTedChatWindow final : public UTedUserWidget
{
public:
	class UTedScrollBox*                          ChatScroll;                                        // 0x0400(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URichTextBlock*                         RichChatText;                                      // 0x0408(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTedEditableTextBox*                    ChatBox;                                           // 0x0410(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USizeBox*                               ScrollMaxHeightBox;                                // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHideScrollBar;                                    // 0x0420(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSetFocusToViewportOnTextCommitted;                // 0x0421(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_422[0x16];                                     // 0x0422(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChatBoxTextCommitted(const class FText& TextCommitted, ETextCommit CommitType);

	class FText GetAllTextInChatBox() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedChatWindow">();
	}
	static class UTedChatWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedChatWindow>();
	}
};
static_assert(alignof(UTedChatWindow) == 0x000008, "Wrong alignment on UTedChatWindow");
static_assert(sizeof(UTedChatWindow) == 0x000438, "Wrong size on UTedChatWindow");
static_assert(offsetof(UTedChatWindow, ChatScroll) == 0x000400, "Member 'UTedChatWindow::ChatScroll' has a wrong offset!");
static_assert(offsetof(UTedChatWindow, RichChatText) == 0x000408, "Member 'UTedChatWindow::RichChatText' has a wrong offset!");
static_assert(offsetof(UTedChatWindow, ChatBox) == 0x000410, "Member 'UTedChatWindow::ChatBox' has a wrong offset!");
static_assert(offsetof(UTedChatWindow, ScrollMaxHeightBox) == 0x000418, "Member 'UTedChatWindow::ScrollMaxHeightBox' has a wrong offset!");
static_assert(offsetof(UTedChatWindow, bHideScrollBar) == 0x000420, "Member 'UTedChatWindow::bHideScrollBar' has a wrong offset!");
static_assert(offsetof(UTedChatWindow, bSetFocusToViewportOnTextCommitted) == 0x000421, "Member 'UTedChatWindow::bSetFocusToViewportOnTextCommitted' has a wrong offset!");

// Class Tempest.TedNavArea_NoStructures
// 0x0000 (0x0048 - 0x0048)
class UTedNavArea_NoStructures final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedNavArea_NoStructures">();
	}
	static class UTedNavArea_NoStructures* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedNavArea_NoStructures>();
	}
};
static_assert(alignof(UTedNavArea_NoStructures) == 0x000008, "Wrong alignment on UTedNavArea_NoStructures");
static_assert(sizeof(UTedNavArea_NoStructures) == 0x000048, "Wrong size on UTedNavArea_NoStructures");

// Class Tempest.TedCinematicBarsWidget
// 0x0000 (0x0400 - 0x0400)
class UTedCinematicBarsWidget : public UTedUserWidget
{
public:
	void HideBars();
	void ShowBars();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCinematicBarsWidget">();
	}
	static class UTedCinematicBarsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCinematicBarsWidget>();
	}
};
static_assert(alignof(UTedCinematicBarsWidget) == 0x000008, "Wrong alignment on UTedCinematicBarsWidget");
static_assert(sizeof(UTedCinematicBarsWidget) == 0x000400, "Wrong size on UTedCinematicBarsWidget");

// Class Tempest.TedCommandComponent
// 0x0000 (0x0400 - 0x0400)
class UTedCommandComponent final : public UGameplayCommandComponentV2
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandComponent">();
	}
	static class UTedCommandComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCommandComponent>();
	}
};
static_assert(alignof(UTedCommandComponent) == 0x000008, "Wrong alignment on UTedCommandComponent");
static_assert(sizeof(UTedCommandComponent) == 0x000400, "Wrong size on UTedCommandComponent");

// Class Tempest.TedNavArea_VetiDome
// 0x0000 (0x0048 - 0x0048)
class UTedNavArea_VetiDome final : public UNavArea_Obstacle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedNavArea_VetiDome">();
	}
	static class UTedNavArea_VetiDome* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedNavArea_VetiDome>();
	}
};
static_assert(alignof(UTedNavArea_VetiDome) == 0x000008, "Wrong alignment on UTedNavArea_VetiDome");
static_assert(sizeof(UTedNavArea_VetiDome) == 0x000048, "Wrong size on UTedNavArea_VetiDome");

// Class Tempest.TedCommandCompoundArmoryScreen
// 0x00B8 (0x0540 - 0x0488)
class UTedCommandCompoundArmoryScreen final : public UTedMenuScreenPage
{
public:
	struct FAssetManagerSearchRules               EquipmentAssetSearchRules;                         // 0x0488(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UTedEquipmentPanel*                     EquipmentPanel_Armory;                             // 0x04D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedPopup*                              Popup_LoadingArmory;                               // 0x04E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E8[0x10];                                     // 0x04E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTedEquipment*>                  AvailableEquipment;                                // 0x04F8(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	class UTedEquipment*                          ArmoryContextEquipment;                            // 0x0508(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ResetButtonSlotID;                                 // 0x0510(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CloseButtonSlotID;                                 // 0x0518(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_520[0x10];                                     // 0x0520(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedEquipmentPanel*                     EquipmentPanel_Loadout;                            // 0x0530(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedPopup*                              Popup_Default;                                     // 0x0538(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void K2_OnRefreshResetButtonUI();
	void OnArmoryContentChange(class UTedContentPanelDynamic* InContentPanel);
	void OnArmoryRequestBuy(class UTedEquipmentSlot* InEquipmentSlot);
	void OnArmoryRequestEquip(class UTedEquipmentSlot* InEquipmentSlot);
	void OnArmoryRequestUnequip(class UTedEquipmentSlot* InEquipmentSlot);
	void OnCancelPurchase(const int32 InButtonIndex);
	void OnCancelResetArmory(const int32 InButtonIndex);
	void OnConfirmPurchase(const int32 InButtonIndex);
	void OnConfirmResetArmory(const int32 InButtonIndex);
	void OnPopupButton_Ok(const int32 InButtonIndex);
	void OnRequestResetArmory();
	void OnTriggerButtonPanelSlotAction(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction);
	void OnTriggerLoadoutSlotAction(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction);
	void RefreshArmoryContent(const bool bInImmediately);
	void RefreshResetButtonUI();
	bool RequestBuyEquipment(class UTedEquipmentSlot* InEquipmentSlot);
	bool RequestEquipEquipment(const class UTedEquipment* InEquipment);
	bool RequestUnequipEquipment(const class UTedEquipment* InEquipment);
	void SyncArmoryWithGameProgress();
	void SyncLoadoutWithGameProgress();

	bool CanBuyOrEquipSomething() const;
	ETedFaction GetCurrentFaction() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandCompoundArmoryScreen">();
	}
	static class UTedCommandCompoundArmoryScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCommandCompoundArmoryScreen>();
	}
};
static_assert(alignof(UTedCommandCompoundArmoryScreen) == 0x000008, "Wrong alignment on UTedCommandCompoundArmoryScreen");
static_assert(sizeof(UTedCommandCompoundArmoryScreen) == 0x000540, "Wrong size on UTedCommandCompoundArmoryScreen");
static_assert(offsetof(UTedCommandCompoundArmoryScreen, EquipmentAssetSearchRules) == 0x000488, "Member 'UTedCommandCompoundArmoryScreen::EquipmentAssetSearchRules' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundArmoryScreen, EquipmentPanel_Armory) == 0x0004D8, "Member 'UTedCommandCompoundArmoryScreen::EquipmentPanel_Armory' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundArmoryScreen, Popup_LoadingArmory) == 0x0004E0, "Member 'UTedCommandCompoundArmoryScreen::Popup_LoadingArmory' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundArmoryScreen, AvailableEquipment) == 0x0004F8, "Member 'UTedCommandCompoundArmoryScreen::AvailableEquipment' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundArmoryScreen, ArmoryContextEquipment) == 0x000508, "Member 'UTedCommandCompoundArmoryScreen::ArmoryContextEquipment' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundArmoryScreen, ResetButtonSlotID) == 0x000510, "Member 'UTedCommandCompoundArmoryScreen::ResetButtonSlotID' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundArmoryScreen, CloseButtonSlotID) == 0x000518, "Member 'UTedCommandCompoundArmoryScreen::CloseButtonSlotID' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundArmoryScreen, EquipmentPanel_Loadout) == 0x000530, "Member 'UTedCommandCompoundArmoryScreen::EquipmentPanel_Loadout' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundArmoryScreen, Popup_Default) == 0x000538, "Member 'UTedCommandCompoundArmoryScreen::Popup_Default' has a wrong offset!");

// Class Tempest.TedCommandCompoundDoctrineScreen
// 0x0060 (0x04E8 - 0x0488)
class UTedCommandCompoundDoctrineScreen final : public UTedMenuScreenPage
{
public:
	class UTedDoctrinePanel*                      DoctrinePanelA;                                    // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedDoctrinePanel*                      DoctrinePanelB;                                    // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedDoctrinePanel*                      DoctrinePanelC;                                    // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_DoctrinePoints;                               // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTedDoctrinePanel*>              DoctrinePanels;                                    // 0x04A8(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UTedDoctrineDefinition*                 ContextDoctrine;                                   // 0x04B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ButtonID_Reset;                                    // 0x04C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ButtonID_Close;                                    // 0x04C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D0[0x10];                                     // 0x04D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedPopup*                              Popup_Default;                                     // 0x04E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandlePopupButtonClick_Ok(const int32 InButtonIndex);
	void OnCancelDoctrinePurchase(const int32 InButtonIndex);
	void OnCancelResetDoctrines(const int32 InButtonIndex);
	void OnConfirmDoctrinePurchase(const int32 InButtonIndex);
	void OnConfirmResetDoctrines(const int32 InButtonIndex);
	void OnTriggerDoctrineSlotAction(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction);
	void RefreshDoctrinePoints();
	void RefreshDoctrineSlotsStates();
	void SyncDoctrinesWithGameProgress();

	bool CanBuyAnyNewDoctrine() const;
	int32 GetRemainingDoctrinePoints() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandCompoundDoctrineScreen">();
	}
	static class UTedCommandCompoundDoctrineScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCommandCompoundDoctrineScreen>();
	}
};
static_assert(alignof(UTedCommandCompoundDoctrineScreen) == 0x000008, "Wrong alignment on UTedCommandCompoundDoctrineScreen");
static_assert(sizeof(UTedCommandCompoundDoctrineScreen) == 0x0004E8, "Wrong size on UTedCommandCompoundDoctrineScreen");
static_assert(offsetof(UTedCommandCompoundDoctrineScreen, DoctrinePanelA) == 0x000488, "Member 'UTedCommandCompoundDoctrineScreen::DoctrinePanelA' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundDoctrineScreen, DoctrinePanelB) == 0x000490, "Member 'UTedCommandCompoundDoctrineScreen::DoctrinePanelB' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundDoctrineScreen, DoctrinePanelC) == 0x000498, "Member 'UTedCommandCompoundDoctrineScreen::DoctrinePanelC' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundDoctrineScreen, Text_DoctrinePoints) == 0x0004A0, "Member 'UTedCommandCompoundDoctrineScreen::Text_DoctrinePoints' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundDoctrineScreen, DoctrinePanels) == 0x0004A8, "Member 'UTedCommandCompoundDoctrineScreen::DoctrinePanels' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundDoctrineScreen, ContextDoctrine) == 0x0004B8, "Member 'UTedCommandCompoundDoctrineScreen::ContextDoctrine' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundDoctrineScreen, ButtonID_Reset) == 0x0004C0, "Member 'UTedCommandCompoundDoctrineScreen::ButtonID_Reset' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundDoctrineScreen, ButtonID_Close) == 0x0004C8, "Member 'UTedCommandCompoundDoctrineScreen::ButtonID_Close' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundDoctrineScreen, Popup_Default) == 0x0004E0, "Member 'UTedCommandCompoundDoctrineScreen::Popup_Default' has a wrong offset!");

// Class Tempest.TedOnlineHydraAPI
// 0x03E0 (0x0410 - 0x0030)
class UTedOnlineHydraAPI final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x3B0];                                     // 0x0030(0x03B0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FNetDriverDefinition>           IpNetDriverDefinitions;                            // 0x03E0(0x0010)(ZeroConstructor, Transient, Config, NativeAccessSpecifierPrivate)
	TArray<struct FNetDriverDefinition>           P2PNetDriverDefinitions;                           // 0x03F0(0x0010)(ZeroConstructor, Transient, Config, NativeAccessSpecifierPrivate)
	uint8                                         Pad_400[0x10];                                     // 0x0400(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DebugOnSessionControlGetDataCenters(const TArray<struct FSessionControlDataCenter>& DataCenters, EProsdkErrorCodeSessionControl ResultCode);
	void OnClientConnectingTicket(const struct FClientData& ClientData);
	void OnClientRatingsUpdate(int32 LocalUserNum, EProsdkErrorCodeRatings ErrorCode);
	void OnFinishSession(EProsdkErrorCodeSessionControl ErrorCode);
	void OnHydraClientServiceStateChanged(int32 LocalUserNum, EProsServiceState State, EProsdkErrorCodeAuthorization ErrorCode, const class FString& ErrorMessage);
	void OnHydraGetUsersPresenceDataComplete(EProsdkErrorCodePresence ResultCode, const struct FPresenceUsersPresence& Data);
	void OnHydraPresenceServiceStateChanged(int32 AuthorizationIndex, EProsServiceState State, EProsdkErrorCodePresence ResultCode, const class FString& Message);
	void OnHydraServerServiceStateChanged(EProsServiceState State, EProsdkErrorCodeSessionControl ResultCode, const class FString& Message);
	void OnLeaderboardsFilteredGetWhenRatingUpdate(int32 LocalUserNum, EProsdkErrorCodeLeaderboards ResultCode, const TArray<struct FLeaderboardBoard>& Leaderboards);
	void OnMatchmakeSessionUpdated(int32 AuthorizationIndex, const struct FMatchmakeSessionStatus& Status, const struct FMatchmakeSessionStatusUpdateReasons& Reason);
	void OnMatchmakeStartComplete(int32 LocalUserNum, EProsdkErrorCodePresence ResultCode);
	void OnMatchmakeStopComplete(int32 LocalUserNum, EProsdkErrorCodePresence ResultCode);
	void OnSessionClientAcceptResult(const class FString& GameSessionId, const struct FSessionControlAcceptClientResult& Result, EProsdkErrorCodeSessionControl Error);
	void OnSessionControlGetDataCenters(const TArray<struct FSessionControlDataCenter>& DataCenters, EProsdkErrorCodeSessionControl ResultCode);
	void OnStandaloneBrowseRequestComplete(int32 LocalUserNum, const struct FStandaloneBrowseResult& BrowseResult, EProsdkErrorCodeSessionControl ResultCode);
	void OnStandaloneCodeRequestComplete(int32 LocalUserNum, const class FString& SignInCode, EProsdkErrorCodeSessionControl ResultCode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedOnlineHydraAPI">();
	}
	static class UTedOnlineHydraAPI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedOnlineHydraAPI>();
	}
};
static_assert(alignof(UTedOnlineHydraAPI) == 0x000008, "Wrong alignment on UTedOnlineHydraAPI");
static_assert(sizeof(UTedOnlineHydraAPI) == 0x000410, "Wrong size on UTedOnlineHydraAPI");
static_assert(offsetof(UTedOnlineHydraAPI, IpNetDriverDefinitions) == 0x0003E0, "Member 'UTedOnlineHydraAPI::IpNetDriverDefinitions' has a wrong offset!");
static_assert(offsetof(UTedOnlineHydraAPI, P2PNetDriverDefinitions) == 0x0003F0, "Member 'UTedOnlineHydraAPI::P2PNetDriverDefinitions' has a wrong offset!");

// Class Tempest.TedCommandCompoundMapScreen
// 0x00E8 (0x0540 - 0x0458)
class UTedCommandCompoundMapScreen final : public UTedMenuScreenWidget
{
public:
	ETedCommandCompoundMapScreenStage             CurrentStage;                                      // 0x0458(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_459[0x7];                                      // 0x0459(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETedCommandCompoundMapScreenStage, struct FTedCommandCompoundMapScreenStageSetup> StageSetups; // 0x0460(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TSet<class UTedCommandCompoundMapScreenComponent*> Components;                                   // 0x04B0(0x0050)(ExportObject, Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UTedCommandCompoundMapScreenComponent_Missions* Component_Details;                         // 0x0500(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedCommandCompoundMapScreenComponent_Movie* Component_Movie;                              // 0x0508(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedCommandCompoundMapScreenComponent_Buttons* Component_Buttons;                          // 0x0510(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                Widget_ExitConfirmation;                           // 0x0518(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpacer*                                Spacer_ContentSize;                                // 0x0520(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             MapScreenMusicTrack;                               // 0x0528(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MapScreenMusicTrackFadeOut;                        // 0x0530(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAudioFaderCurve                              MapScreenMusicTrackFadeOutCurve;                   // 0x0534(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_535[0x3];                                      // 0x0535(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        MapScreenMusicTrackAC;                             // 0x0538(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static ETedCommandCompoundMapScreenStage K2_BranchStage(const ETedCommandCompoundMapScreenStage InValue);

	bool ChangeStage(const bool bInForward);
	void HideExitConfirmation();
	void K2_OnChangeStage(const ETedCommandCompoundMapScreenStage InPrevStage, const ETedCommandCompoundMapScreenStage InCurrent);
	void K2_OnFinished();
	void OnButtons_Continue(class UTedCommandCompoundMapScreenComponent* InComponent);
	void OnButtons_MainMenu(class UTedCommandCompoundMapScreenComponent* InComponent);
	void OnComponentTrigger(class UTedCommandCompoundMapScreenComponent* InComponent);
	void OnExitConfirmation_Cancel();
	void OnExitConfirmation_Exit();
	void PlayMusic();
	bool SetStage(const ETedCommandCompoundMapScreenStage InStage);
	void ShowExitConfirmation();
	void StartMission();
	void StopMusic();

	const class UTedMapInfo* GetCurrentMission() const;
	ETedCommandCompoundMapScreenStage GetCurrentStage() const;
	ETedCommandCompoundMapScreenStage K2_BranchCurrentStage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandCompoundMapScreen">();
	}
	static class UTedCommandCompoundMapScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCommandCompoundMapScreen>();
	}
};
static_assert(alignof(UTedCommandCompoundMapScreen) == 0x000008, "Wrong alignment on UTedCommandCompoundMapScreen");
static_assert(sizeof(UTedCommandCompoundMapScreen) == 0x000540, "Wrong size on UTedCommandCompoundMapScreen");
static_assert(offsetof(UTedCommandCompoundMapScreen, CurrentStage) == 0x000458, "Member 'UTedCommandCompoundMapScreen::CurrentStage' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundMapScreen, StageSetups) == 0x000460, "Member 'UTedCommandCompoundMapScreen::StageSetups' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundMapScreen, Components) == 0x0004B0, "Member 'UTedCommandCompoundMapScreen::Components' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundMapScreen, Component_Details) == 0x000500, "Member 'UTedCommandCompoundMapScreen::Component_Details' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundMapScreen, Component_Movie) == 0x000508, "Member 'UTedCommandCompoundMapScreen::Component_Movie' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundMapScreen, Component_Buttons) == 0x000510, "Member 'UTedCommandCompoundMapScreen::Component_Buttons' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundMapScreen, Widget_ExitConfirmation) == 0x000518, "Member 'UTedCommandCompoundMapScreen::Widget_ExitConfirmation' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundMapScreen, Spacer_ContentSize) == 0x000520, "Member 'UTedCommandCompoundMapScreen::Spacer_ContentSize' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundMapScreen, MapScreenMusicTrack) == 0x000528, "Member 'UTedCommandCompoundMapScreen::MapScreenMusicTrack' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundMapScreen, MapScreenMusicTrackFadeOut) == 0x000530, "Member 'UTedCommandCompoundMapScreen::MapScreenMusicTrackFadeOut' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundMapScreen, MapScreenMusicTrackFadeOutCurve) == 0x000534, "Member 'UTedCommandCompoundMapScreen::MapScreenMusicTrackFadeOutCurve' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundMapScreen, MapScreenMusicTrackAC) == 0x000538, "Member 'UTedCommandCompoundMapScreen::MapScreenMusicTrackAC' has a wrong offset!");

// Class Tempest.TedCommandCompoundMapScreenComponent_Buttons
// 0x0020 (0x0438 - 0x0418)
class UTedCommandCompoundMapScreenComponent_Buttons final : public UTedCommandCompoundMapScreenComponent
{
public:
	TMulticastInlineDelegate<void(class UTedCommandCompoundMapScreenComponent* InComponent)> OnMainMenu; // 0x0418(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTedCommandCompoundMapScreenComponent* InComponent)> OnContinue; // 0x0428(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void CallOnContinue();
	void CallOnMainMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandCompoundMapScreenComponent_Buttons">();
	}
	static class UTedCommandCompoundMapScreenComponent_Buttons* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCommandCompoundMapScreenComponent_Buttons>();
	}
};
static_assert(alignof(UTedCommandCompoundMapScreenComponent_Buttons) == 0x000008, "Wrong alignment on UTedCommandCompoundMapScreenComponent_Buttons");
static_assert(sizeof(UTedCommandCompoundMapScreenComponent_Buttons) == 0x000438, "Wrong size on UTedCommandCompoundMapScreenComponent_Buttons");
static_assert(offsetof(UTedCommandCompoundMapScreenComponent_Buttons, OnMainMenu) == 0x000418, "Member 'UTedCommandCompoundMapScreenComponent_Buttons::OnMainMenu' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundMapScreenComponent_Buttons, OnContinue) == 0x000428, "Member 'UTedCommandCompoundMapScreenComponent_Buttons::OnContinue' has a wrong offset!");

// Class Tempest.TedOnlinePlayerProfileWidgetContext
// 0x0140 (0x0168 - 0x0028)
class UTedOnlinePlayerProfileWidgetContext final : public UObject
{
public:
	class FString                                 HydraId;                                           // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTedStatistics                         Profile;                                           // 0x0038(0x0090)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FTedUserInfo                           UserInfo;                                          // 0x00C8(0x0040)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FTedUserRating>                 UserRatings;                                       // 0x0108(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTedOnlinePlayerProfileWidgetContextParams Params_0;                                      // 0x0118(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x10];                                     // 0x0128(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedPopup*                              LoadingPopup;                                      // 0x0138(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTedOnlinePlayerProfileWidget*          CachedWidget;                                      // 0x0140(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x20];                                     // 0x0148(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTedOnlinePlayerProfileWidgetContext* Get();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedOnlinePlayerProfileWidgetContext">();
	}
	static class UTedOnlinePlayerProfileWidgetContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedOnlinePlayerProfileWidgetContext>();
	}
};
static_assert(alignof(UTedOnlinePlayerProfileWidgetContext) == 0x000008, "Wrong alignment on UTedOnlinePlayerProfileWidgetContext");
static_assert(sizeof(UTedOnlinePlayerProfileWidgetContext) == 0x000168, "Wrong size on UTedOnlinePlayerProfileWidgetContext");
static_assert(offsetof(UTedOnlinePlayerProfileWidgetContext, HydraId) == 0x000028, "Member 'UTedOnlinePlayerProfileWidgetContext::HydraId' has a wrong offset!");
static_assert(offsetof(UTedOnlinePlayerProfileWidgetContext, Profile) == 0x000038, "Member 'UTedOnlinePlayerProfileWidgetContext::Profile' has a wrong offset!");
static_assert(offsetof(UTedOnlinePlayerProfileWidgetContext, UserInfo) == 0x0000C8, "Member 'UTedOnlinePlayerProfileWidgetContext::UserInfo' has a wrong offset!");
static_assert(offsetof(UTedOnlinePlayerProfileWidgetContext, UserRatings) == 0x000108, "Member 'UTedOnlinePlayerProfileWidgetContext::UserRatings' has a wrong offset!");
static_assert(offsetof(UTedOnlinePlayerProfileWidgetContext, Params_0) == 0x000118, "Member 'UTedOnlinePlayerProfileWidgetContext::Params_0' has a wrong offset!");
static_assert(offsetof(UTedOnlinePlayerProfileWidgetContext, LoadingPopup) == 0x000138, "Member 'UTedOnlinePlayerProfileWidgetContext::LoadingPopup' has a wrong offset!");
static_assert(offsetof(UTedOnlinePlayerProfileWidgetContext, CachedWidget) == 0x000140, "Member 'UTedOnlinePlayerProfileWidgetContext::CachedWidget' has a wrong offset!");

// Class Tempest.TedCommandCompoundMapScreenComponent_Movie
// 0x0008 (0x0420 - 0x0418)
class UTedCommandCompoundMapScreenComponent_Movie final : public UTedCommandCompoundMapScreenComponent
{
public:
	class UTedMoviePlayerWidgetV2*                MoviePlayer;                                       // 0x0418(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnMoviePlayerFinished(class UTedMoviePlayerWidgetV2* InWidget, const class UFileMediaSource* InMovie);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandCompoundMapScreenComponent_Movie">();
	}
	static class UTedCommandCompoundMapScreenComponent_Movie* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCommandCompoundMapScreenComponent_Movie>();
	}
};
static_assert(alignof(UTedCommandCompoundMapScreenComponent_Movie) == 0x000008, "Wrong alignment on UTedCommandCompoundMapScreenComponent_Movie");
static_assert(sizeof(UTedCommandCompoundMapScreenComponent_Movie) == 0x000420, "Wrong size on UTedCommandCompoundMapScreenComponent_Movie");
static_assert(offsetof(UTedCommandCompoundMapScreenComponent_Movie, MoviePlayer) == 0x000418, "Member 'UTedCommandCompoundMapScreenComponent_Movie::MoviePlayer' has a wrong offset!");

// Class Tempest.ReconnectNetGame
// 0x00B0 (0x00D8 - 0x0028)
class UReconnectNetGame final : public UObject
{
public:
	uint8                                         Pad_28[0x78];                                      // 0x0028(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UNetDriver>              NetDriverPtr;                                      // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x30];                                      // 0x00A8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReconnectNetGame">();
	}
	static class UReconnectNetGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReconnectNetGame>();
	}
};
static_assert(alignof(UReconnectNetGame) == 0x000008, "Wrong alignment on UReconnectNetGame");
static_assert(sizeof(UReconnectNetGame) == 0x0000D8, "Wrong size on UReconnectNetGame");
static_assert(offsetof(UReconnectNetGame, NetDriverPtr) == 0x0000A0, "Member 'UReconnectNetGame::NetDriverPtr' has a wrong offset!");

// Class Tempest.TedCommandCompoundMoviePlayerContextObject
// 0x0018 (0x0040 - 0x0028)
class UTedCommandCompoundMoviePlayerContextObject final : public UObject
{
public:
	class UFileMediaSource*                       Movie;                                             // 0x0028(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLoop : 1;                                         // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFileMediaSource*                       IntroAnimOverride;                                 // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UTedCommandCompoundMoviePlayerContextObject* New(const class UFileMediaSource* InMovie, const bool bInLoop, const class UFileMediaSource* InIntroAnimOverride);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandCompoundMoviePlayerContextObject">();
	}
	static class UTedCommandCompoundMoviePlayerContextObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCommandCompoundMoviePlayerContextObject>();
	}
};
static_assert(alignof(UTedCommandCompoundMoviePlayerContextObject) == 0x000008, "Wrong alignment on UTedCommandCompoundMoviePlayerContextObject");
static_assert(sizeof(UTedCommandCompoundMoviePlayerContextObject) == 0x000040, "Wrong size on UTedCommandCompoundMoviePlayerContextObject");
static_assert(offsetof(UTedCommandCompoundMoviePlayerContextObject, Movie) == 0x000028, "Member 'UTedCommandCompoundMoviePlayerContextObject::Movie' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundMoviePlayerContextObject, IntroAnimOverride) == 0x000038, "Member 'UTedCommandCompoundMoviePlayerContextObject::IntroAnimOverride' has a wrong offset!");

// Class Tempest.TedCommandCompoundMoviePlayer
// 0x00C0 (0x0530 - 0x0470)
class UTedCommandCompoundMoviePlayer final : public UTedMoviePlayerWidgetV2
{
public:
	struct FGameplayTag                           PlayEvent;                                         // 0x0470(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           StopEvent;                                         // 0x0478(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedCommandCompoundMoviePlayerContextObject* PlayEventContext;                             // 0x0480(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTedThemeMovie                         DefaultFrameIntroAnimThemed;                       // 0x0488(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FTedThemeMovie                         DefaultFrameOutroAnimThemed;                       // 0x04D8(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	class UTedMoviePlayerWidgetV2*                AnimMoviePlayer;                                   // 0x0528(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnContentVisibilityChange(const bool bInShow);
	void OnFrameIntroFinished(class UTedMoviePlayerWidgetV2* InWidget, const class UFileMediaSource* InSource);
	void OnFrameOutroFinished(class UTedMoviePlayerWidgetV2* InWidget, const class UFileMediaSource* InSource);
	void OnMainMovieFinished(class UTedMoviePlayerWidgetV2* InWidget, const class UFileMediaSource* InSource);

	bool ShouldMovieLoop() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandCompoundMoviePlayer">();
	}
	static class UTedCommandCompoundMoviePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCommandCompoundMoviePlayer>();
	}
};
static_assert(alignof(UTedCommandCompoundMoviePlayer) == 0x000008, "Wrong alignment on UTedCommandCompoundMoviePlayer");
static_assert(sizeof(UTedCommandCompoundMoviePlayer) == 0x000530, "Wrong size on UTedCommandCompoundMoviePlayer");
static_assert(offsetof(UTedCommandCompoundMoviePlayer, PlayEvent) == 0x000470, "Member 'UTedCommandCompoundMoviePlayer::PlayEvent' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundMoviePlayer, StopEvent) == 0x000478, "Member 'UTedCommandCompoundMoviePlayer::StopEvent' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundMoviePlayer, PlayEventContext) == 0x000480, "Member 'UTedCommandCompoundMoviePlayer::PlayEventContext' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundMoviePlayer, DefaultFrameIntroAnimThemed) == 0x000488, "Member 'UTedCommandCompoundMoviePlayer::DefaultFrameIntroAnimThemed' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundMoviePlayer, DefaultFrameOutroAnimThemed) == 0x0004D8, "Member 'UTedCommandCompoundMoviePlayer::DefaultFrameOutroAnimThemed' has a wrong offset!");
static_assert(offsetof(UTedCommandCompoundMoviePlayer, AnimMoviePlayer) == 0x000528, "Member 'UTedCommandCompoundMoviePlayer::AnimMoviePlayer' has a wrong offset!");

// Class Tempest.TedOnlineSessionsAPI
// 0x02D0 (0x0300 - 0x0030)
class UTedOnlineSessionsAPI final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ATedLobbyBeaconHost*                    HostLobbyBeacon;                                   // 0x0038(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x50];                                      // 0x0040(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class ATedLobbyBeaconClient*                  ClientLobbyBeacon;                                 // 0x0090(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x48];                                      // 0x0098(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedDedicatedServerMonitor*             DedicatedMonitor;                                  // 0x00E0(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x10];                                      // 0x00E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedIpcManager*                         IpcManager;                                        // 0x00F8(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x200];                                    // 0x0100(0x0200)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedOnlineSessionsAPI">();
	}
	static class UTedOnlineSessionsAPI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedOnlineSessionsAPI>();
	}
};
static_assert(alignof(UTedOnlineSessionsAPI) == 0x000008, "Wrong alignment on UTedOnlineSessionsAPI");
static_assert(sizeof(UTedOnlineSessionsAPI) == 0x000300, "Wrong size on UTedOnlineSessionsAPI");
static_assert(offsetof(UTedOnlineSessionsAPI, HostLobbyBeacon) == 0x000038, "Member 'UTedOnlineSessionsAPI::HostLobbyBeacon' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionsAPI, ClientLobbyBeacon) == 0x000090, "Member 'UTedOnlineSessionsAPI::ClientLobbyBeacon' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionsAPI, DedicatedMonitor) == 0x0000E0, "Member 'UTedOnlineSessionsAPI::DedicatedMonitor' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionsAPI, IpcManager) == 0x0000F8, "Member 'UTedOnlineSessionsAPI::IpcManager' has a wrong offset!");

// Class Tempest.TedCommandCompoundPreview
// 0x0008 (0x0370 - 0x0368)
class ATedCommandCompoundPreview final : public AGameplayCommandPreviewActor
{
public:
	class AGameplayCommandPreviewActor*           CommandPreviewProxy;                               // 0x0368(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandCompoundPreview">();
	}
	static class ATedCommandCompoundPreview* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedCommandCompoundPreview>();
	}
};
static_assert(alignof(ATedCommandCompoundPreview) == 0x000008, "Wrong alignment on ATedCommandCompoundPreview");
static_assert(sizeof(ATedCommandCompoundPreview) == 0x000370, "Wrong size on ATedCommandCompoundPreview");
static_assert(offsetof(ATedCommandCompoundPreview, CommandPreviewProxy) == 0x000368, "Member 'ATedCommandCompoundPreview::CommandPreviewProxy' has a wrong offset!");

// Class Tempest.TedPlayerCommandsPanel
// 0x0000 (0x07C8 - 0x07C8)
class UTedPlayerCommandsPanel : public UTedCommandsPanel
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerCommandsPanel">();
	}
	static class UTedPlayerCommandsPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerCommandsPanel>();
	}
};
static_assert(alignof(UTedPlayerCommandsPanel) == 0x000008, "Wrong alignment on UTedPlayerCommandsPanel");
static_assert(sizeof(UTedPlayerCommandsPanel) == 0x0007C8, "Wrong size on UTedPlayerCommandsPanel");

// Class Tempest.TedCommandCustomMultiplayerRequirement_PlayerOwnsTech
// 0x0008 (0x0030 - 0x0028)
class UTedCommandCustomMultiplayerRequirement_PlayerOwnsTech final : public UTedCommandCustomMultiplayerRequirement
{
public:
	struct FGameplayTag                           TechTag;                                           // 0x0028(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandCustomMultiplayerRequirement_PlayerOwnsTech">();
	}
	static class UTedCommandCustomMultiplayerRequirement_PlayerOwnsTech* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCommandCustomMultiplayerRequirement_PlayerOwnsTech>();
	}
};
static_assert(alignof(UTedCommandCustomMultiplayerRequirement_PlayerOwnsTech) == 0x000008, "Wrong alignment on UTedCommandCustomMultiplayerRequirement_PlayerOwnsTech");
static_assert(sizeof(UTedCommandCustomMultiplayerRequirement_PlayerOwnsTech) == 0x000030, "Wrong size on UTedCommandCustomMultiplayerRequirement_PlayerOwnsTech");
static_assert(offsetof(UTedCommandCustomMultiplayerRequirement_PlayerOwnsTech, TechTag) == 0x000028, "Member 'UTedCommandCustomMultiplayerRequirement_PlayerOwnsTech::TechTag' has a wrong offset!");

// Class Tempest.TedCommandCustomMultiplayerRequirement_PlayerOwnsPrerequisites
// 0x0110 (0x0138 - 0x0028)
class UTedCommandCustomMultiplayerRequirement_PlayerOwnsPrerequisites final : public UTedCommandCustomMultiplayerRequirement
{
public:
	struct FTedPrerequisiteContainer              Prerequisites;                                     // 0x0028(0x0110)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandCustomMultiplayerRequirement_PlayerOwnsPrerequisites">();
	}
	static class UTedCommandCustomMultiplayerRequirement_PlayerOwnsPrerequisites* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCommandCustomMultiplayerRequirement_PlayerOwnsPrerequisites>();
	}
};
static_assert(alignof(UTedCommandCustomMultiplayerRequirement_PlayerOwnsPrerequisites) == 0x000008, "Wrong alignment on UTedCommandCustomMultiplayerRequirement_PlayerOwnsPrerequisites");
static_assert(sizeof(UTedCommandCustomMultiplayerRequirement_PlayerOwnsPrerequisites) == 0x000138, "Wrong size on UTedCommandCustomMultiplayerRequirement_PlayerOwnsPrerequisites");
static_assert(offsetof(UTedCommandCustomMultiplayerRequirement_PlayerOwnsPrerequisites, Prerequisites) == 0x000028, "Member 'UTedCommandCustomMultiplayerRequirement_PlayerOwnsPrerequisites::Prerequisites' has a wrong offset!");

// Class Tempest.TedPlayerCommand_AirMission_Base
// 0x0088 (0x05F8 - 0x0570)
class UTedPlayerCommand_AirMission_Base : public UTedPlayerCommand
{
public:
	TSubclassOf<class UTedUnitCommand_AirMission> CommandClassPushedToAircraft;                      // 0x0570(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   AircraftClass;                                     // 0x0578(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   CommandVisualActorClass;                           // 0x05A0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFGameplayCommandValue                 AircraftNum;                                       // 0x05C8(0x0028)(Edit, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         FormationDistance;                                 // 0x05F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F4[0x4];                                      // 0x05F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerCommand_AirMission_Base">();
	}
	static class UTedPlayerCommand_AirMission_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerCommand_AirMission_Base>();
	}
};
static_assert(alignof(UTedPlayerCommand_AirMission_Base) == 0x000008, "Wrong alignment on UTedPlayerCommand_AirMission_Base");
static_assert(sizeof(UTedPlayerCommand_AirMission_Base) == 0x0005F8, "Wrong size on UTedPlayerCommand_AirMission_Base");
static_assert(offsetof(UTedPlayerCommand_AirMission_Base, CommandClassPushedToAircraft) == 0x000570, "Member 'UTedPlayerCommand_AirMission_Base::CommandClassPushedToAircraft' has a wrong offset!");
static_assert(offsetof(UTedPlayerCommand_AirMission_Base, AircraftClass) == 0x000578, "Member 'UTedPlayerCommand_AirMission_Base::AircraftClass' has a wrong offset!");
static_assert(offsetof(UTedPlayerCommand_AirMission_Base, CommandVisualActorClass) == 0x0005A0, "Member 'UTedPlayerCommand_AirMission_Base::CommandVisualActorClass' has a wrong offset!");
static_assert(offsetof(UTedPlayerCommand_AirMission_Base, AircraftNum) == 0x0005C8, "Member 'UTedPlayerCommand_AirMission_Base::AircraftNum' has a wrong offset!");
static_assert(offsetof(UTedPlayerCommand_AirMission_Base, FormationDistance) == 0x0005F0, "Member 'UTedPlayerCommand_AirMission_Base::FormationDistance' has a wrong offset!");

// Class Tempest.TedPlayerCommand_AirDrop
// 0x0008 (0x0600 - 0x05F8)
class UTedPlayerCommand_AirDrop : public UTedPlayerCommand_AirMission_Base
{
public:
	int32                                         ValidationPointsNum;                               // 0x05F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValidationCircleRadius;                            // 0x05FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static struct FGameplayCommandData CreateAirDropCommandData(TSubclassOf<class UTedPlayerCommand_AirDrop> CommandClass, const struct FGameplayCommandDataPayload_AirDrop& Payload);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerCommand_AirDrop">();
	}
	static class UTedPlayerCommand_AirDrop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerCommand_AirDrop>();
	}
};
static_assert(alignof(UTedPlayerCommand_AirDrop) == 0x000008, "Wrong alignment on UTedPlayerCommand_AirDrop");
static_assert(sizeof(UTedPlayerCommand_AirDrop) == 0x000600, "Wrong size on UTedPlayerCommand_AirDrop");
static_assert(offsetof(UTedPlayerCommand_AirDrop, ValidationPointsNum) == 0x0005F8, "Member 'UTedPlayerCommand_AirDrop::ValidationPointsNum' has a wrong offset!");
static_assert(offsetof(UTedPlayerCommand_AirDrop, ValidationCircleRadius) == 0x0005FC, "Member 'UTedPlayerCommand_AirDrop::ValidationCircleRadius' has a wrong offset!");

// Class Tempest.TedPlayerCommand_AirDropVolume
// 0x0000 (0x0600 - 0x0600)
class UTedPlayerCommand_AirDropVolume : public UTedPlayerCommand_AirDrop
{
public:
	static struct FGameplayCommandData CreateAirDropVolumeCommandData(TSubclassOf<class UTedPlayerCommand_AirDrop> CommandClass, const struct FGameplayCommandDataPayload_AirDrop& Payload);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerCommand_AirDropVolume">();
	}
	static class UTedPlayerCommand_AirDropVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerCommand_AirDropVolume>();
	}
};
static_assert(alignof(UTedPlayerCommand_AirDropVolume) == 0x000008, "Wrong alignment on UTedPlayerCommand_AirDropVolume");
static_assert(sizeof(UTedPlayerCommand_AirDropVolume) == 0x000600, "Wrong size on UTedPlayerCommand_AirDropVolume");

// Class Tempest.TedCommandPreview_PlaceStructure
// 0x00C8 (0x0430 - 0x0368)
class ATedCommandPreview_PlaceStructure : public AGameplayCommandPreviewActor
{
public:
	class UTedStructurePlacementPreviewComponent* PlacementPreviewComponent;                         // 0x0368(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        OffsetComponent;                                   // 0x0370(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 SkeletalMesh;                                      // 0x0378(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   StaticMesh;                                        // 0x0380(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedGridVisualizationComponent*         InfluenceArea;                                     // 0x0388(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedGridOutlineComponent*               InfluenceAreaBorder;                               // 0x0390(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           InfluenceAreaBorderColor;                          // 0x0398(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InfluenceAreaBorderThickness;                      // 0x03A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bCachedCanIssue : 1;                               // 0x03AC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3AD[0x3];                                      // 0x03AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayCommandErrorTags              CachedPendingErrorTags;                            // 0x03B0(0x0060)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	class ATedPlayerState*                        CachedPS;                                          // 0x0410(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_418[0x10];                                     // 0x0418(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedRangeDecalComponent*                RangeDecal;                                        // 0x0428(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void UpdateRangeDecalData(const TSubclassOf<class ATedStructureBase> StructureClass);

	class USkeletalMeshComponent* GetSkeletalMesh() const;
	class UStaticMeshComponent* GetStaticMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandPreview_PlaceStructure">();
	}
	static class ATedCommandPreview_PlaceStructure* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedCommandPreview_PlaceStructure>();
	}
};
static_assert(alignof(ATedCommandPreview_PlaceStructure) == 0x000008, "Wrong alignment on ATedCommandPreview_PlaceStructure");
static_assert(sizeof(ATedCommandPreview_PlaceStructure) == 0x000430, "Wrong size on ATedCommandPreview_PlaceStructure");
static_assert(offsetof(ATedCommandPreview_PlaceStructure, PlacementPreviewComponent) == 0x000368, "Member 'ATedCommandPreview_PlaceStructure::PlacementPreviewComponent' has a wrong offset!");
static_assert(offsetof(ATedCommandPreview_PlaceStructure, OffsetComponent) == 0x000370, "Member 'ATedCommandPreview_PlaceStructure::OffsetComponent' has a wrong offset!");
static_assert(offsetof(ATedCommandPreview_PlaceStructure, SkeletalMesh) == 0x000378, "Member 'ATedCommandPreview_PlaceStructure::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(ATedCommandPreview_PlaceStructure, StaticMesh) == 0x000380, "Member 'ATedCommandPreview_PlaceStructure::StaticMesh' has a wrong offset!");
static_assert(offsetof(ATedCommandPreview_PlaceStructure, InfluenceArea) == 0x000388, "Member 'ATedCommandPreview_PlaceStructure::InfluenceArea' has a wrong offset!");
static_assert(offsetof(ATedCommandPreview_PlaceStructure, InfluenceAreaBorder) == 0x000390, "Member 'ATedCommandPreview_PlaceStructure::InfluenceAreaBorder' has a wrong offset!");
static_assert(offsetof(ATedCommandPreview_PlaceStructure, InfluenceAreaBorderColor) == 0x000398, "Member 'ATedCommandPreview_PlaceStructure::InfluenceAreaBorderColor' has a wrong offset!");
static_assert(offsetof(ATedCommandPreview_PlaceStructure, InfluenceAreaBorderThickness) == 0x0003A8, "Member 'ATedCommandPreview_PlaceStructure::InfluenceAreaBorderThickness' has a wrong offset!");
static_assert(offsetof(ATedCommandPreview_PlaceStructure, CachedPendingErrorTags) == 0x0003B0, "Member 'ATedCommandPreview_PlaceStructure::CachedPendingErrorTags' has a wrong offset!");
static_assert(offsetof(ATedCommandPreview_PlaceStructure, CachedPS) == 0x000410, "Member 'ATedCommandPreview_PlaceStructure::CachedPS' has a wrong offset!");
static_assert(offsetof(ATedCommandPreview_PlaceStructure, RangeDecal) == 0x000428, "Member 'ATedCommandPreview_PlaceStructure::RangeDecal' has a wrong offset!");

// Class Tempest.TedCommandPreview_TeleportStructure
// 0x0018 (0x0448 - 0x0430)
class ATedCommandPreview_TeleportStructure : public ATedCommandPreview_PlaceStructure
{
public:
	class ASquareNavGrid*                         CachedNavGrid;                                     // 0x0430(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 CachedCommandActor;                                // 0x0438(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsInstancedPreview;                               // 0x0440(0x0001)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_441[0x7];                                      // 0x0441(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandPreview_TeleportStructure">();
	}
	static class ATedCommandPreview_TeleportStructure* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedCommandPreview_TeleportStructure>();
	}
};
static_assert(alignof(ATedCommandPreview_TeleportStructure) == 0x000008, "Wrong alignment on ATedCommandPreview_TeleportStructure");
static_assert(sizeof(ATedCommandPreview_TeleportStructure) == 0x000448, "Wrong size on ATedCommandPreview_TeleportStructure");
static_assert(offsetof(ATedCommandPreview_TeleportStructure, CachedNavGrid) == 0x000430, "Member 'ATedCommandPreview_TeleportStructure::CachedNavGrid' has a wrong offset!");
static_assert(offsetof(ATedCommandPreview_TeleportStructure, CachedCommandActor) == 0x000438, "Member 'ATedCommandPreview_TeleportStructure::CachedCommandActor' has a wrong offset!");
static_assert(offsetof(ATedCommandPreview_TeleportStructure, bIsInstancedPreview) == 0x000440, "Member 'ATedCommandPreview_TeleportStructure::bIsInstancedPreview' has a wrong offset!");

// Class Tempest.TedPlayerCommand_Compound
// 0x0058 (0x05C8 - 0x0570)
class UTedPlayerCommand_Compound : public UTedPlayerCommand
{
public:
	TSet<TSubclassOf<class UTedPlayerCommand>>    Commands;                                          // 0x0570(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bTryExecuteAll;                                    // 0x05C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C1[0x7];                                      // 0x05C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerCommand_Compound">();
	}
	static class UTedPlayerCommand_Compound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerCommand_Compound>();
	}
};
static_assert(alignof(UTedPlayerCommand_Compound) == 0x000008, "Wrong alignment on UTedPlayerCommand_Compound");
static_assert(sizeof(UTedPlayerCommand_Compound) == 0x0005C8, "Wrong size on UTedPlayerCommand_Compound");
static_assert(offsetof(UTedPlayerCommand_Compound, Commands) == 0x000570, "Member 'UTedPlayerCommand_Compound::Commands' has a wrong offset!");
static_assert(offsetof(UTedPlayerCommand_Compound, bTryExecuteAll) == 0x0005C0, "Member 'UTedPlayerCommand_Compound::bTryExecuteAll' has a wrong offset!");

// Class Tempest.TedCommandsTooltip
// 0x0008 (0x04A8 - 0x04A0)
class UTedCommandsTooltip : public UTedTooltipWidget
{
public:
	class UTedCommandsTooltipDisplay*             DisplayWidget;                                     // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Hide();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandsTooltip">();
	}
	static class UTedCommandsTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCommandsTooltip>();
	}
};
static_assert(alignof(UTedCommandsTooltip) == 0x000008, "Wrong alignment on UTedCommandsTooltip");
static_assert(sizeof(UTedCommandsTooltip) == 0x0004A8, "Wrong size on UTedCommandsTooltip");
static_assert(offsetof(UTedCommandsTooltip, DisplayWidget) == 0x0004A0, "Member 'UTedCommandsTooltip::DisplayWidget' has a wrong offset!");

// Class Tempest.TedCommandValueCalculation_Aggregator
// 0x0018 (0x0040 - 0x0028)
class UTedCommandValueCalculation_Aggregator : public UGameplayCommandValueCalculation
{
public:
	EAggregationMethod                            AggregationMethod;                                 // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGameplayCommandValueCalculation*> Calculations;                                    // 0x0030(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandValueCalculation_Aggregator">();
	}
	static class UTedCommandValueCalculation_Aggregator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCommandValueCalculation_Aggregator>();
	}
};
static_assert(alignof(UTedCommandValueCalculation_Aggregator) == 0x000008, "Wrong alignment on UTedCommandValueCalculation_Aggregator");
static_assert(sizeof(UTedCommandValueCalculation_Aggregator) == 0x000040, "Wrong size on UTedCommandValueCalculation_Aggregator");
static_assert(offsetof(UTedCommandValueCalculation_Aggregator, AggregationMethod) == 0x000028, "Member 'UTedCommandValueCalculation_Aggregator::AggregationMethod' has a wrong offset!");
static_assert(offsetof(UTedCommandValueCalculation_Aggregator, Calculations) == 0x000030, "Member 'UTedCommandValueCalculation_Aggregator::Calculations' has a wrong offset!");

// Class Tempest.TedPlayerCommand_DoctrineBase
// 0x0000 (0x0570 - 0x0570)
class UTedPlayerCommand_DoctrineBase : public UTedPlayerCommand
{
public:
	static struct FGameplayCommandData CreateCommandData_ResearchedDoctrine(TSubclassOf<class UTedCommand> InCommand, const class UTedDoctrineDefinition* InResearchedDoctrine);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerCommand_DoctrineBase">();
	}
	static class UTedPlayerCommand_DoctrineBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerCommand_DoctrineBase>();
	}
};
static_assert(alignof(UTedPlayerCommand_DoctrineBase) == 0x000008, "Wrong alignment on UTedPlayerCommand_DoctrineBase");
static_assert(sizeof(UTedPlayerCommand_DoctrineBase) == 0x000570, "Wrong size on UTedPlayerCommand_DoctrineBase");

// Class Tempest.TedPlayerCommand_DoctrineResearchQueue
// 0x0008 (0x0578 - 0x0570)
class UTedPlayerCommand_DoctrineResearchQueue : public UTedPlayerCommand_DoctrineBase
{
public:
	bool                                          bShouldQueue;                                      // 0x0570(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_571[0x7];                                      // 0x0571(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerCommand_DoctrineResearchQueue">();
	}
	static class UTedPlayerCommand_DoctrineResearchQueue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerCommand_DoctrineResearchQueue>();
	}
};
static_assert(alignof(UTedPlayerCommand_DoctrineResearchQueue) == 0x000008, "Wrong alignment on UTedPlayerCommand_DoctrineResearchQueue");
static_assert(sizeof(UTedPlayerCommand_DoctrineResearchQueue) == 0x000578, "Wrong size on UTedPlayerCommand_DoctrineResearchQueue");
static_assert(offsetof(UTedPlayerCommand_DoctrineResearchQueue, bShouldQueue) == 0x000570, "Member 'UTedPlayerCommand_DoctrineResearchQueue::bShouldQueue' has a wrong offset!");

// Class Tempest.TedCommandValueCalculation_PlayerTagBased
// 0x0018 (0x0040 - 0x0028)
class UTedCommandValueCalculation_PlayerTagBased : public UGameplayCommandValueCalculation
{
public:
	float                                         BaseValue;                                         // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedValueModsWithTagRequirements       ValueMods;                                         // 0x0030(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCommandValueCalculation_PlayerTagBased">();
	}
	static class UTedCommandValueCalculation_PlayerTagBased* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCommandValueCalculation_PlayerTagBased>();
	}
};
static_assert(alignof(UTedCommandValueCalculation_PlayerTagBased) == 0x000008, "Wrong alignment on UTedCommandValueCalculation_PlayerTagBased");
static_assert(sizeof(UTedCommandValueCalculation_PlayerTagBased) == 0x000040, "Wrong size on UTedCommandValueCalculation_PlayerTagBased");
static_assert(offsetof(UTedCommandValueCalculation_PlayerTagBased, BaseValue) == 0x000028, "Member 'UTedCommandValueCalculation_PlayerTagBased::BaseValue' has a wrong offset!");
static_assert(offsetof(UTedCommandValueCalculation_PlayerTagBased, ValueMods) == 0x000030, "Member 'UTedCommandValueCalculation_PlayerTagBased::ValueMods' has a wrong offset!");

// Class Tempest.TedCompletedStructuresButton
// 0x0048 (0x0448 - 0x0400)
class UTedCompletedStructuresButton : public UTedUserWidget
{
public:
	uint8                                         Pad_400[0x10];                                     // 0x0400(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 Image_Structure_Icon;                              // 0x0410(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Image_Completed_Effect;                            // 0x0418(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             TextBlock_Amount;                                  // 0x0420(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             TextBlock_Completed;                               // 0x0428(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             TextBlock_Shortcut;                                // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             DefaultIcon;                                       // 0x0438(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_440[0x8];                                      // 0x0440(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCompletedStructuresButton">();
	}
	static class UTedCompletedStructuresButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCompletedStructuresButton>();
	}
};
static_assert(alignof(UTedCompletedStructuresButton) == 0x000008, "Wrong alignment on UTedCompletedStructuresButton");
static_assert(sizeof(UTedCompletedStructuresButton) == 0x000448, "Wrong size on UTedCompletedStructuresButton");
static_assert(offsetof(UTedCompletedStructuresButton, Image_Structure_Icon) == 0x000410, "Member 'UTedCompletedStructuresButton::Image_Structure_Icon' has a wrong offset!");
static_assert(offsetof(UTedCompletedStructuresButton, Image_Completed_Effect) == 0x000418, "Member 'UTedCompletedStructuresButton::Image_Completed_Effect' has a wrong offset!");
static_assert(offsetof(UTedCompletedStructuresButton, TextBlock_Amount) == 0x000420, "Member 'UTedCompletedStructuresButton::TextBlock_Amount' has a wrong offset!");
static_assert(offsetof(UTedCompletedStructuresButton, TextBlock_Completed) == 0x000428, "Member 'UTedCompletedStructuresButton::TextBlock_Completed' has a wrong offset!");
static_assert(offsetof(UTedCompletedStructuresButton, TextBlock_Shortcut) == 0x000430, "Member 'UTedCompletedStructuresButton::TextBlock_Shortcut' has a wrong offset!");
static_assert(offsetof(UTedCompletedStructuresButton, DefaultIcon) == 0x000438, "Member 'UTedCompletedStructuresButton::DefaultIcon' has a wrong offset!");

// Class Tempest.TedCompletedStructuresPanel
// 0x0028 (0x07D8 - 0x07B0)
class UTedCompletedStructuresPanel : public UTedContentPanelDynamic
{
public:
	TArray<struct FTedCompletedStructure>         content;                                           // 0x07B0(0x0010)(ZeroConstructor, Transient, DuplicateTransient, NativeAccessSpecifierPrivate)
	uint8                                         ColumnsAmount;                                     // 0x07C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C1[0x3];                                      // 0x07C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMargin                                SlotPadding;                                       // 0x07C4(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7D4[0x4];                                      // 0x07D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCompletedStructuresPanel">();
	}
	static class UTedCompletedStructuresPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCompletedStructuresPanel>();
	}
};
static_assert(alignof(UTedCompletedStructuresPanel) == 0x000008, "Wrong alignment on UTedCompletedStructuresPanel");
static_assert(sizeof(UTedCompletedStructuresPanel) == 0x0007D8, "Wrong size on UTedCompletedStructuresPanel");
static_assert(offsetof(UTedCompletedStructuresPanel, content) == 0x0007B0, "Member 'UTedCompletedStructuresPanel::content' has a wrong offset!");
static_assert(offsetof(UTedCompletedStructuresPanel, ColumnsAmount) == 0x0007C0, "Member 'UTedCompletedStructuresPanel::ColumnsAmount' has a wrong offset!");
static_assert(offsetof(UTedCompletedStructuresPanel, SlotPadding) == 0x0007C4, "Member 'UTedCompletedStructuresPanel::SlotPadding' has a wrong offset!");

// Class Tempest.TedPawnCommand_AttackGround
// 0x0000 (0x0580 - 0x0580)
class UTedPawnCommand_AttackGround : public UTedPawnCommand_Attack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommand_AttackGround">();
	}
	static class UTedPawnCommand_AttackGround* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnCommand_AttackGround>();
	}
};
static_assert(alignof(UTedPawnCommand_AttackGround) == 0x000008, "Wrong alignment on UTedPawnCommand_AttackGround");
static_assert(sizeof(UTedPawnCommand_AttackGround) == 0x000580, "Wrong size on UTedPawnCommand_AttackGround");

// Class Tempest.TedConformation_Garrison
// 0x0010 (0x1B10 - 0x1B00)
class ATedConformation_Garrison final : public ATedConformationBase
{
public:
	class UTedPawnContainerComponent*             PawnContainerComponent;                            // 0x1B00(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B08[0x8];                                     // 0x1B08(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedConformation_Garrison">();
	}
	static class ATedConformation_Garrison* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedConformation_Garrison>();
	}
};
static_assert(alignof(ATedConformation_Garrison) == 0x000010, "Wrong alignment on ATedConformation_Garrison");
static_assert(sizeof(ATedConformation_Garrison) == 0x001B10, "Wrong size on ATedConformation_Garrison");
static_assert(offsetof(ATedConformation_Garrison, PawnContainerComponent) == 0x001B00, "Member 'ATedConformation_Garrison::PawnContainerComponent' has a wrong offset!");

// Class Tempest.TedConstructionSite
// 0x0200 (0x1C90 - 0x1A90)
class ATedConstructionSite : public ATedStructureNeighborBase
{
public:
	uint8                                         Pad_1A90[0x18];                                    // 0x1A90(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        StartingHealth;                                    // 0x1AA8(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AAA[0x6];                                     // 0x1AAA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          HitBox;                                            // 0x1AB0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTedConstructionElementType            ConstructingElement;                               // 0x1AB8(0x0028)(Net, Transient, DuplicateTransient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATedStructureBase*                      ConstructingFactory;                               // 0x1AE0(0x0008)(Net, ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ATedConstructionSite*>           LinkedConstructionSites;                           // 0x1AE8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         ConstructionSiteTotalBuildTime;                    // 0x1AF8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPaused;                                           // 0x1AFC(0x0001)(Net, ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AFD[0xB];                                     // 0x1AFD(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 ConstructionDrone;                                 // 0x1B08(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           DronePickupAnim;                                   // 0x1B10(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           DroneDropAnim;                                     // 0x1B18(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayCueTag                        DroneExplosionCue;                                 // 0x1B20(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSet<class FName>                             DroneExplosionSockets;                             // 0x1B28(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   FactoryDroneSocket;                                // 0x1B78(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastConstructionProgress;                          // 0x1B80(0x0004)(Net, ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B84[0x4];                                     // 0x1B84(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           TH_HandlingUpdatingConstructionProgress;           // 0x1B88(0x0008)(Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTedConstructionSiteConfig>     FootprintConfigs;                                  // 0x1B90(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         ActiveFootprintConfig;                             // 0x1BA0(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1BA4[0x14];                                    // 0x1BA4(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETedConstructionSiteAnim, struct FTedConstructionSiteAnimNotifyTimeMap> AnimNotifyTimes;    // 0x1BB8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ETedConstructionSiteAnimNotify, struct FTimerHandle> ProceduralAnimNotifies;                // 0x1C08(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	ETedConstructionSiteAnim                      PlayingProceduralAnim;                             // 0x1C58(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedConstructionSiteAnim                      CurrentAnim;                                       // 0x1C59(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C5A[0x6];                                     // 0x1C5A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UDecalComponent*                        DecalComponent;                                    // 0x1C60(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecalFadeInTime;                                   // 0x1C68(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecalFadeOutTime;                                  // 0x1C6C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedStructurePlacementPreviewComponent* PreviewComponent;                                  // 0x1C70(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 PreviewSkeletalMesh;                               // 0x1C78(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   PreviewStaticMesh;                                 // 0x1C80(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterial*                              PreviewMaterial;                                   // 0x1C88(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ConditionallyPauseDroneDropOff();
	void OnRep_PlayingProceduralAnim();
	void OnRep_SetPaused();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedConstructionSite">();
	}
	static class ATedConstructionSite* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedConstructionSite>();
	}
};
static_assert(alignof(ATedConstructionSite) == 0x000010, "Wrong alignment on ATedConstructionSite");
static_assert(sizeof(ATedConstructionSite) == 0x001C90, "Wrong size on ATedConstructionSite");
static_assert(offsetof(ATedConstructionSite, StartingHealth) == 0x001AA8, "Member 'ATedConstructionSite::StartingHealth' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite, HitBox) == 0x001AB0, "Member 'ATedConstructionSite::HitBox' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite, ConstructingElement) == 0x001AB8, "Member 'ATedConstructionSite::ConstructingElement' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite, ConstructingFactory) == 0x001AE0, "Member 'ATedConstructionSite::ConstructingFactory' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite, LinkedConstructionSites) == 0x001AE8, "Member 'ATedConstructionSite::LinkedConstructionSites' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite, ConstructionSiteTotalBuildTime) == 0x001AF8, "Member 'ATedConstructionSite::ConstructionSiteTotalBuildTime' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite, bPaused) == 0x001AFC, "Member 'ATedConstructionSite::bPaused' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite, ConstructionDrone) == 0x001B08, "Member 'ATedConstructionSite::ConstructionDrone' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite, DronePickupAnim) == 0x001B10, "Member 'ATedConstructionSite::DronePickupAnim' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite, DroneDropAnim) == 0x001B18, "Member 'ATedConstructionSite::DroneDropAnim' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite, DroneExplosionCue) == 0x001B20, "Member 'ATedConstructionSite::DroneExplosionCue' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite, DroneExplosionSockets) == 0x001B28, "Member 'ATedConstructionSite::DroneExplosionSockets' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite, FactoryDroneSocket) == 0x001B78, "Member 'ATedConstructionSite::FactoryDroneSocket' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite, LastConstructionProgress) == 0x001B80, "Member 'ATedConstructionSite::LastConstructionProgress' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite, TH_HandlingUpdatingConstructionProgress) == 0x001B88, "Member 'ATedConstructionSite::TH_HandlingUpdatingConstructionProgress' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite, FootprintConfigs) == 0x001B90, "Member 'ATedConstructionSite::FootprintConfigs' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite, ActiveFootprintConfig) == 0x001BA0, "Member 'ATedConstructionSite::ActiveFootprintConfig' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite, AnimNotifyTimes) == 0x001BB8, "Member 'ATedConstructionSite::AnimNotifyTimes' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite, ProceduralAnimNotifies) == 0x001C08, "Member 'ATedConstructionSite::ProceduralAnimNotifies' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite, PlayingProceduralAnim) == 0x001C58, "Member 'ATedConstructionSite::PlayingProceduralAnim' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite, CurrentAnim) == 0x001C59, "Member 'ATedConstructionSite::CurrentAnim' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite, DecalComponent) == 0x001C60, "Member 'ATedConstructionSite::DecalComponent' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite, DecalFadeInTime) == 0x001C68, "Member 'ATedConstructionSite::DecalFadeInTime' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite, DecalFadeOutTime) == 0x001C6C, "Member 'ATedConstructionSite::DecalFadeOutTime' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite, PreviewComponent) == 0x001C70, "Member 'ATedConstructionSite::PreviewComponent' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite, PreviewSkeletalMesh) == 0x001C78, "Member 'ATedConstructionSite::PreviewSkeletalMesh' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite, PreviewStaticMesh) == 0x001C80, "Member 'ATedConstructionSite::PreviewStaticMesh' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite, PreviewMaterial) == 0x001C88, "Member 'ATedConstructionSite::PreviewMaterial' has a wrong offset!");

// Class Tempest.TedLocalPlayer
// 0x0000 (0x02B0 - 0x02B0)
class UTedLocalPlayer final : public ULocalPlayer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedLocalPlayer">();
	}
	static class UTedLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedLocalPlayer>();
	}
};
static_assert(alignof(UTedLocalPlayer) == 0x000008, "Wrong alignment on UTedLocalPlayer");
static_assert(sizeof(UTedLocalPlayer) == 0x0002B0, "Wrong size on UTedLocalPlayer");

// Class Tempest.TedConstructionSite_Gate
// 0x0010 (0x1CA0 - 0x1C90)
class ATedConstructionSite_Gate final : public ATedConstructionSite
{
public:
	uint8                                         bRotated : 1;                                      // 0x1C90(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (SaveGame, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1C91[0xF];                                     // 0x1C91(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedConstructionSite_Gate">();
	}
	static class ATedConstructionSite_Gate* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedConstructionSite_Gate>();
	}
};
static_assert(alignof(ATedConstructionSite_Gate) == 0x000010, "Wrong alignment on ATedConstructionSite_Gate");
static_assert(sizeof(ATedConstructionSite_Gate) == 0x001CA0, "Wrong size on ATedConstructionSite_Gate");

// Class Tempest.TedPawnCommand_Deconstruct
// 0x0000 (0x0540 - 0x0540)
class UTedPawnCommand_Deconstruct final : public UTedPawnCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommand_Deconstruct">();
	}
	static class UTedPawnCommand_Deconstruct* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnCommand_Deconstruct>();
	}
};
static_assert(alignof(UTedPawnCommand_Deconstruct) == 0x000008, "Wrong alignment on UTedPawnCommand_Deconstruct");
static_assert(sizeof(UTedPawnCommand_Deconstruct) == 0x000540, "Wrong size on UTedPawnCommand_Deconstruct");

// Class Tempest.TedConstructionSite_Wall
// 0x0050 (0x1CE0 - 0x1C90)
class ATedConstructionSite_Wall final : public ATedConstructionSite
{
public:
	class UBoxComponent*                          SecondaryNavModifier;                              // 0x1C90(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NavModifierWidth;                                  // 0x1C98(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NavModifierHeight;                                 // 0x1C9C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          PrimaryHitBox;                                     // 0x1CA0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          SecondaryHitBox;                                   // 0x1CA8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitBoxWidth;                                       // 0x1CB0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitBoxHeight;                                      // 0x1CB4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTedStructureWallMeshSetup_Temp        MeshSetup;                                         // 0x1CB8(0x0028)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedConstructionSite_Wall">();
	}
	static class ATedConstructionSite_Wall* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedConstructionSite_Wall>();
	}
};
static_assert(alignof(ATedConstructionSite_Wall) == 0x000010, "Wrong alignment on ATedConstructionSite_Wall");
static_assert(sizeof(ATedConstructionSite_Wall) == 0x001CE0, "Wrong size on ATedConstructionSite_Wall");
static_assert(offsetof(ATedConstructionSite_Wall, SecondaryNavModifier) == 0x001C90, "Member 'ATedConstructionSite_Wall::SecondaryNavModifier' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite_Wall, NavModifierWidth) == 0x001C98, "Member 'ATedConstructionSite_Wall::NavModifierWidth' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite_Wall, NavModifierHeight) == 0x001C9C, "Member 'ATedConstructionSite_Wall::NavModifierHeight' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite_Wall, PrimaryHitBox) == 0x001CA0, "Member 'ATedConstructionSite_Wall::PrimaryHitBox' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite_Wall, SecondaryHitBox) == 0x001CA8, "Member 'ATedConstructionSite_Wall::SecondaryHitBox' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite_Wall, HitBoxWidth) == 0x001CB0, "Member 'ATedConstructionSite_Wall::HitBoxWidth' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite_Wall, HitBoxHeight) == 0x001CB4, "Member 'ATedConstructionSite_Wall::HitBoxHeight' has a wrong offset!");
static_assert(offsetof(ATedConstructionSite_Wall, MeshSetup) == 0x001CB8, "Member 'ATedConstructionSite_Wall::MeshSetup' has a wrong offset!");

// Class Tempest.TedUI_InstancedContent
// 0x0108 (0x0130 - 0x0028)
class UTedUI_InstancedContent final : public UObject
{
public:
	class FName                                   ID;                                                // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0040(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            Icon;                                              // 0x0050(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      MaterialOverride;                                  // 0x0120(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTedUI_InstancedContent* New(const class FName InID, const class FText& InText, const class FText& InDescription, const struct FSlateBrush& InIcon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUI_InstancedContent">();
	}
	static class UTedUI_InstancedContent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUI_InstancedContent>();
	}
};
static_assert(alignof(UTedUI_InstancedContent) == 0x000010, "Wrong alignment on UTedUI_InstancedContent");
static_assert(sizeof(UTedUI_InstancedContent) == 0x000130, "Wrong size on UTedUI_InstancedContent");
static_assert(offsetof(UTedUI_InstancedContent, ID) == 0x000028, "Member 'UTedUI_InstancedContent::ID' has a wrong offset!");
static_assert(offsetof(UTedUI_InstancedContent, Text) == 0x000030, "Member 'UTedUI_InstancedContent::Text' has a wrong offset!");
static_assert(offsetof(UTedUI_InstancedContent, Description) == 0x000040, "Member 'UTedUI_InstancedContent::Description' has a wrong offset!");
static_assert(offsetof(UTedUI_InstancedContent, Icon) == 0x000050, "Member 'UTedUI_InstancedContent::Icon' has a wrong offset!");
static_assert(offsetof(UTedUI_InstancedContent, MaterialOverride) == 0x000120, "Member 'UTedUI_InstancedContent::MaterialOverride' has a wrong offset!");

// Class Tempest.TedContentPanelInstanced
// 0x0010 (0x07C0 - 0x07B0)
class UTedContentPanelInstanced : public UTedContentPanelDynamic
{
public:
	TArray<class UTedUI_InstancedContent*>        content;                                           // 0x07B0(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void ActivateStateByContent(const class UTedUI_InstancedContent* InContent, const ETedContentSlotState InState, const bool bInActivate);
	void ActivateStateByContentID(const class FName InContentID, const ETedContentSlotState InState, const bool bInActivate);
	void AddToContent(class UTedUI_InstancedContent* NewContent, const bool bUnique);
	TArray<class UTedUI_InstancedContent*> GetAllContentMutable();
	void RemoveContentById(const class FName& InID);
	void ReplaceContentDescription(const class FName InContentID, const class FText& InNewDescription);
	void ReplaceContentIcon(const class FName InContentID, const struct FSlateBrush& InNewIcon);
	void ReplaceContentText(const class FName InContentID, const class FText& InNewText);
	void SetContent(const TArray<class UTedUI_InstancedContent*>& InContent);

	const TArray<class UTedUI_InstancedContent*> GetAllContent() const;
	const class UTedUI_InstancedContent* GetContent(const int32 InSlotIndex) const;
	class UTedUI_InstancedContent* GetContentById(const class FName InID) const;
	const class UTedUI_InstancedContent* GetContentByState(const ETedContentSlotState InState, int32 InIndex) const;
	class FName GetContentID(const int32 InSlotIndex) const;
	class FName GetContentIDByState(const ETedContentSlotState InState, int32 InIndex) const;
	int32 GetSlotIndexByContent(const class UTedUI_InstancedContent* InContent) const;
	int32 GetSlotIndexByContentID(const class FName InContentID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedContentPanelInstanced">();
	}
	static class UTedContentPanelInstanced* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedContentPanelInstanced>();
	}
};
static_assert(alignof(UTedContentPanelInstanced) == 0x000008, "Wrong alignment on UTedContentPanelInstanced");
static_assert(sizeof(UTedContentPanelInstanced) == 0x0007C0, "Wrong size on UTedContentPanelInstanced");
static_assert(offsetof(UTedContentPanelInstanced, content) == 0x0007B0, "Member 'UTedContentPanelInstanced::content' has a wrong offset!");

// Class Tempest.TedPawnCommand_LayMines
// 0x0010 (0x05D0 - 0x05C0)
class UTedPawnCommand_LayMines : public UTedPawnCommandWithBehavior_Ability
{
public:
	TSubclassOf<class ATedStructureBase>          FakeMinefieldToTestAgainst;                        // 0x05C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxDeployNodeSearchDepth;                          // 0x05C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5CC[0x4];                                      // 0x05CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommand_LayMines">();
	}
	static class UTedPawnCommand_LayMines* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnCommand_LayMines>();
	}
};
static_assert(alignof(UTedPawnCommand_LayMines) == 0x000008, "Wrong alignment on UTedPawnCommand_LayMines");
static_assert(sizeof(UTedPawnCommand_LayMines) == 0x0005D0, "Wrong size on UTedPawnCommand_LayMines");
static_assert(offsetof(UTedPawnCommand_LayMines, FakeMinefieldToTestAgainst) == 0x0005C0, "Member 'UTedPawnCommand_LayMines::FakeMinefieldToTestAgainst' has a wrong offset!");
static_assert(offsetof(UTedPawnCommand_LayMines, MaxDeployNodeSearchDepth) == 0x0005C8, "Member 'UTedPawnCommand_LayMines::MaxDeployNodeSearchDepth' has a wrong offset!");

// Class Tempest.TedContentSlotStateAssetSelectorAsset
// 0x0018 (0x0048 - 0x0030)
class UTedContentSlotStateAssetSelectorAsset final : public UDataAsset
{
public:
	struct FTedContentSlotStateAssetSelector      Data;                                              // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedContentSlotStateAssetSelectorAsset">();
	}
	static class UTedContentSlotStateAssetSelectorAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedContentSlotStateAssetSelectorAsset>();
	}
};
static_assert(alignof(UTedContentSlotStateAssetSelectorAsset) == 0x000008, "Wrong alignment on UTedContentSlotStateAssetSelectorAsset");
static_assert(sizeof(UTedContentSlotStateAssetSelectorAsset) == 0x000048, "Wrong size on UTedContentSlotStateAssetSelectorAsset");
static_assert(offsetof(UTedContentSlotStateAssetSelectorAsset, Data) == 0x000030, "Member 'UTedContentSlotStateAssetSelectorAsset::Data' has a wrong offset!");

// Class Tempest.TedCredits
// 0x0048 (0x04A0 - 0x0458)
class UTedCredits final : public UTedMenuScreenWidget
{
public:
	TMulticastInlineDelegate<void()>              OnCreditsClose;                                    // 0x0458(0x0010)(ZeroConstructor, InstancedReference, BlueprintCallable, NativeAccessSpecifierPublic)
	TArray<class UFileMediaSource*>               MoviesToPlay;                                      // 0x0468(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FTedMoviePlayParams                    PlayParams;                                        // 0x0478(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	class UTedMoviePlayerWidgetV2*                MoviePlayer;                                       // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           SkippableMovieGameplayTag;                         // 0x0498(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnAllMoviesFinishedOrSkipped();
	void OnMovieFinished(class UTedMoviePlayerWidgetV2* InWidget, const class UFileMediaSource* InSource);
	void PlayMoviesSequentially();
	void Show();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCredits">();
	}
	static class UTedCredits* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCredits>();
	}
};
static_assert(alignof(UTedCredits) == 0x000008, "Wrong alignment on UTedCredits");
static_assert(sizeof(UTedCredits) == 0x0004A0, "Wrong size on UTedCredits");
static_assert(offsetof(UTedCredits, OnCreditsClose) == 0x000458, "Member 'UTedCredits::OnCreditsClose' has a wrong offset!");
static_assert(offsetof(UTedCredits, MoviesToPlay) == 0x000468, "Member 'UTedCredits::MoviesToPlay' has a wrong offset!");
static_assert(offsetof(UTedCredits, PlayParams) == 0x000478, "Member 'UTedCredits::PlayParams' has a wrong offset!");
static_assert(offsetof(UTedCredits, MoviePlayer) == 0x000490, "Member 'UTedCredits::MoviePlayer' has a wrong offset!");
static_assert(offsetof(UTedCredits, SkippableMovieGameplayTag) == 0x000498, "Member 'UTedCredits::SkippableMovieGameplayTag' has a wrong offset!");

// Class Tempest.TedCursorConfig
// 0x0158 (0x0188 - 0x0030)
class UTedCursorConfig final : public UDataAsset
{
public:
	uint8                                         bSupportAttitude : 1;                              // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              CommonHotSpot;                                     // 0x0038(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTedThemedHardwareCursor               DefaultThemedHardwareCursor;                       // 0x0048(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FTedThemedHardwareCursor               FriendlyThemedHardwareCursor;                      // 0x0078(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FTedThemedHardwareCursor               NeutralThemedHardwareCursor;                       // 0x00A8(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FTedThemedHardwareCursor               HostileThemedHardwareCursor;                       // 0x00D8(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FVector2D                              HardwareCursorHotSpot;                             // 0x0108(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SoftwareCursorHotSpot;                             // 0x0118(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Material;                                          // 0x0128(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UseAnimatedTextureParam;                           // 0x0130(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TextureParam;                                      // 0x0138(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UseAttitudeParam;                                  // 0x0140(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttitudeParam;                                     // 0x0148(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RowsParam;                                         // 0x0150(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ColumnsParam;                                      // 0x0158(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AnimDurationParam;                                 // 0x0160(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             SoftwareCursor;                                    // 0x0168(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             SoftwareCursorFlipbook;                            // 0x0170(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              SoftwareCursorFlipbookSize;                        // 0x0178(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoftwareCursorAnimDuration;                        // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_HardwareCursorHotSpot : 1;               // 0x0184(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_SoftwareCursorHotSpot : 1;               // 0x0184(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_185[0x3];                                      // 0x0185(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCursorConfig">();
	}
	static class UTedCursorConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCursorConfig>();
	}
};
static_assert(alignof(UTedCursorConfig) == 0x000008, "Wrong alignment on UTedCursorConfig");
static_assert(sizeof(UTedCursorConfig) == 0x000188, "Wrong size on UTedCursorConfig");
static_assert(offsetof(UTedCursorConfig, CommonHotSpot) == 0x000038, "Member 'UTedCursorConfig::CommonHotSpot' has a wrong offset!");
static_assert(offsetof(UTedCursorConfig, DefaultThemedHardwareCursor) == 0x000048, "Member 'UTedCursorConfig::DefaultThemedHardwareCursor' has a wrong offset!");
static_assert(offsetof(UTedCursorConfig, FriendlyThemedHardwareCursor) == 0x000078, "Member 'UTedCursorConfig::FriendlyThemedHardwareCursor' has a wrong offset!");
static_assert(offsetof(UTedCursorConfig, NeutralThemedHardwareCursor) == 0x0000A8, "Member 'UTedCursorConfig::NeutralThemedHardwareCursor' has a wrong offset!");
static_assert(offsetof(UTedCursorConfig, HostileThemedHardwareCursor) == 0x0000D8, "Member 'UTedCursorConfig::HostileThemedHardwareCursor' has a wrong offset!");
static_assert(offsetof(UTedCursorConfig, HardwareCursorHotSpot) == 0x000108, "Member 'UTedCursorConfig::HardwareCursorHotSpot' has a wrong offset!");
static_assert(offsetof(UTedCursorConfig, SoftwareCursorHotSpot) == 0x000118, "Member 'UTedCursorConfig::SoftwareCursorHotSpot' has a wrong offset!");
static_assert(offsetof(UTedCursorConfig, Material) == 0x000128, "Member 'UTedCursorConfig::Material' has a wrong offset!");
static_assert(offsetof(UTedCursorConfig, UseAnimatedTextureParam) == 0x000130, "Member 'UTedCursorConfig::UseAnimatedTextureParam' has a wrong offset!");
static_assert(offsetof(UTedCursorConfig, TextureParam) == 0x000138, "Member 'UTedCursorConfig::TextureParam' has a wrong offset!");
static_assert(offsetof(UTedCursorConfig, UseAttitudeParam) == 0x000140, "Member 'UTedCursorConfig::UseAttitudeParam' has a wrong offset!");
static_assert(offsetof(UTedCursorConfig, AttitudeParam) == 0x000148, "Member 'UTedCursorConfig::AttitudeParam' has a wrong offset!");
static_assert(offsetof(UTedCursorConfig, RowsParam) == 0x000150, "Member 'UTedCursorConfig::RowsParam' has a wrong offset!");
static_assert(offsetof(UTedCursorConfig, ColumnsParam) == 0x000158, "Member 'UTedCursorConfig::ColumnsParam' has a wrong offset!");
static_assert(offsetof(UTedCursorConfig, AnimDurationParam) == 0x000160, "Member 'UTedCursorConfig::AnimDurationParam' has a wrong offset!");
static_assert(offsetof(UTedCursorConfig, SoftwareCursor) == 0x000168, "Member 'UTedCursorConfig::SoftwareCursor' has a wrong offset!");
static_assert(offsetof(UTedCursorConfig, SoftwareCursorFlipbook) == 0x000170, "Member 'UTedCursorConfig::SoftwareCursorFlipbook' has a wrong offset!");
static_assert(offsetof(UTedCursorConfig, SoftwareCursorFlipbookSize) == 0x000178, "Member 'UTedCursorConfig::SoftwareCursorFlipbookSize' has a wrong offset!");
static_assert(offsetof(UTedCursorConfig, SoftwareCursorAnimDuration) == 0x000180, "Member 'UTedCursorConfig::SoftwareCursorAnimDuration' has a wrong offset!");

// Class Tempest.TedObjectiveCondition_Volume_ActorCounter
// 0x0250 (0x0338 - 0x00E8)
class UTedObjectiveCondition_Volume_ActorCounter final : public UTedObjectiveConditionBase
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ETedObjectiveConditionVolumeActorCounterTracking Track;                                          // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class AVolume>                 Volume;                                            // 0x00F8(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTedPawnFilter                         Filter;                                            // 0x0120(0x01C0)(Edit, Protected, NativeAccessSpecifierProtected)
	EComparison                                   ComparisonMethod;                                  // 0x02E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E1[0x3];                                      // 0x02E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        ExpectedAmount;                                    // 0x02E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class AActor>                  MarkerActorOverride;                               // 0x02E8(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AVolume*                                VolumeActor;                                       // 0x0310(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        CurrentAmount;                                     // 0x0318(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31C[0x4];                                      // 0x031C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         CountedActors;                                     // 0x0320(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	class UTedMarkerConfig*                       MarkerConfig;                                      // 0x0330(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnVolumeBeginOverlap_Handler(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnVolumeEndOverlap_Handler(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveCondition_Volume_ActorCounter">();
	}
	static class UTedObjectiveCondition_Volume_ActorCounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveCondition_Volume_ActorCounter>();
	}
};
static_assert(alignof(UTedObjectiveCondition_Volume_ActorCounter) == 0x000008, "Wrong alignment on UTedObjectiveCondition_Volume_ActorCounter");
static_assert(sizeof(UTedObjectiveCondition_Volume_ActorCounter) == 0x000338, "Wrong size on UTedObjectiveCondition_Volume_ActorCounter");
static_assert(offsetof(UTedObjectiveCondition_Volume_ActorCounter, Track) == 0x0000F0, "Member 'UTedObjectiveCondition_Volume_ActorCounter::Track' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_Volume_ActorCounter, Volume) == 0x0000F8, "Member 'UTedObjectiveCondition_Volume_ActorCounter::Volume' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_Volume_ActorCounter, Filter) == 0x000120, "Member 'UTedObjectiveCondition_Volume_ActorCounter::Filter' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_Volume_ActorCounter, ComparisonMethod) == 0x0002E0, "Member 'UTedObjectiveCondition_Volume_ActorCounter::ComparisonMethod' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_Volume_ActorCounter, ExpectedAmount) == 0x0002E4, "Member 'UTedObjectiveCondition_Volume_ActorCounter::ExpectedAmount' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_Volume_ActorCounter, MarkerActorOverride) == 0x0002E8, "Member 'UTedObjectiveCondition_Volume_ActorCounter::MarkerActorOverride' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_Volume_ActorCounter, VolumeActor) == 0x000310, "Member 'UTedObjectiveCondition_Volume_ActorCounter::VolumeActor' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_Volume_ActorCounter, CurrentAmount) == 0x000318, "Member 'UTedObjectiveCondition_Volume_ActorCounter::CurrentAmount' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_Volume_ActorCounter, CountedActors) == 0x000320, "Member 'UTedObjectiveCondition_Volume_ActorCounter::CountedActors' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_Volume_ActorCounter, MarkerConfig) == 0x000330, "Member 'UTedObjectiveCondition_Volume_ActorCounter::MarkerConfig' has a wrong offset!");

// Class Tempest.TedCursorSubsystem
// 0x0058 (0x0098 - 0x0040)
class UTedCursorSubsystem final : public UTickableWorldSubsystem
{
public:
	class UTedCursorSettings*                     Settings;                                          // 0x0040(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameViewportClient*                    GameViewport;                                      // 0x0048(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTedCursorDisplayData                  CurrentCursor;                                     // 0x0050(0x0018)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_68[0x30];                                      // 0x0068(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCursorSubsystem">();
	}
	static class UTedCursorSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCursorSubsystem>();
	}
};
static_assert(alignof(UTedCursorSubsystem) == 0x000008, "Wrong alignment on UTedCursorSubsystem");
static_assert(sizeof(UTedCursorSubsystem) == 0x000098, "Wrong size on UTedCursorSubsystem");
static_assert(offsetof(UTedCursorSubsystem, Settings) == 0x000040, "Member 'UTedCursorSubsystem::Settings' has a wrong offset!");
static_assert(offsetof(UTedCursorSubsystem, GameViewport) == 0x000048, "Member 'UTedCursorSubsystem::GameViewport' has a wrong offset!");
static_assert(offsetof(UTedCursorSubsystem, CurrentCursor) == 0x000050, "Member 'UTedCursorSubsystem::CurrentCursor' has a wrong offset!");

// Class Tempest.TedObjectiveProgress
// 0x0000 (0x0028 - 0x0028)
class UTedObjectiveProgress : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveProgress">();
	}
	static class UTedObjectiveProgress* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveProgress>();
	}
};
static_assert(alignof(UTedObjectiveProgress) == 0x000008, "Wrong alignment on UTedObjectiveProgress");
static_assert(sizeof(UTedObjectiveProgress) == 0x000028, "Wrong size on UTedObjectiveProgress");

// Class Tempest.TedCustomUpgradeCondition
// 0x0000 (0x0028 - 0x0028)
class UTedCustomUpgradeCondition final : public UObject
{
public:
	bool K2_IsMet(const struct FTedActiveUpgrade& InActiveUpgrade) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedCustomUpgradeCondition">();
	}
	static class UTedCustomUpgradeCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedCustomUpgradeCondition>();
	}
};
static_assert(alignof(UTedCustomUpgradeCondition) == 0x000008, "Wrong alignment on UTedCustomUpgradeCondition");
static_assert(sizeof(UTedCustomUpgradeCondition) == 0x000028, "Wrong size on UTedCustomUpgradeCondition");

// Class Tempest.TedObjectiveProgressWidget
// 0x0000 (0x0400 - 0x0400)
class UTedObjectiveProgressWidget : public UTedUserWidget
{
public:
	void K2_OnDisplayProgress(const class UTedObjectiveProgress* InProgress);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveProgressWidget">();
	}
	static class UTedObjectiveProgressWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveProgressWidget>();
	}
};
static_assert(alignof(UTedObjectiveProgressWidget) == 0x000008, "Wrong alignment on UTedObjectiveProgressWidget");
static_assert(sizeof(UTedObjectiveProgressWidget) == 0x000400, "Wrong size on UTedObjectiveProgressWidget");

// Class Tempest.TedObjectiveProgressWidget_IntegerCounter
// 0x0028 (0x0428 - 0x0400)
class UTedObjectiveProgressWidget_IntegerCounter : public UTedObjectiveProgressWidget
{
public:
	class UProgressBar*                           ProgressBar;                                       // 0x0400(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_CurrentValue;                            // 0x0408(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_ExpectedValue;                           // 0x0410(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                Text_CurrentValue;                                 // 0x0418(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                Text_ExpectedValue;                                // 0x0420(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveProgressWidget_IntegerCounter">();
	}
	static class UTedObjectiveProgressWidget_IntegerCounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveProgressWidget_IntegerCounter>();
	}
};
static_assert(alignof(UTedObjectiveProgressWidget_IntegerCounter) == 0x000008, "Wrong alignment on UTedObjectiveProgressWidget_IntegerCounter");
static_assert(sizeof(UTedObjectiveProgressWidget_IntegerCounter) == 0x000428, "Wrong size on UTedObjectiveProgressWidget_IntegerCounter");
static_assert(offsetof(UTedObjectiveProgressWidget_IntegerCounter, ProgressBar) == 0x000400, "Member 'UTedObjectiveProgressWidget_IntegerCounter::ProgressBar' has a wrong offset!");
static_assert(offsetof(UTedObjectiveProgressWidget_IntegerCounter, TextBlock_CurrentValue) == 0x000408, "Member 'UTedObjectiveProgressWidget_IntegerCounter::TextBlock_CurrentValue' has a wrong offset!");
static_assert(offsetof(UTedObjectiveProgressWidget_IntegerCounter, TextBlock_ExpectedValue) == 0x000410, "Member 'UTedObjectiveProgressWidget_IntegerCounter::TextBlock_ExpectedValue' has a wrong offset!");
static_assert(offsetof(UTedObjectiveProgressWidget_IntegerCounter, Text_CurrentValue) == 0x000418, "Member 'UTedObjectiveProgressWidget_IntegerCounter::Text_CurrentValue' has a wrong offset!");
static_assert(offsetof(UTedObjectiveProgressWidget_IntegerCounter, Text_ExpectedValue) == 0x000420, "Member 'UTedObjectiveProgressWidget_IntegerCounter::Text_ExpectedValue' has a wrong offset!");

// Class Tempest.TedDamageType_Crushing
// 0x0000 (0x0098 - 0x0098)
class UTedDamageType_Crushing final : public UTedDamageType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedDamageType_Crushing">();
	}
	static class UTedDamageType_Crushing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedDamageType_Crushing>();
	}
};
static_assert(alignof(UTedDamageType_Crushing) == 0x000008, "Wrong alignment on UTedDamageType_Crushing");
static_assert(sizeof(UTedDamageType_Crushing) == 0x000098, "Wrong size on UTedDamageType_Crushing");

// Class Tempest.TedDamageType_DisconnectKill
// 0x0000 (0x0098 - 0x0098)
class UTedDamageType_DisconnectKill final : public UTedDamageType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedDamageType_DisconnectKill">();
	}
	static class UTedDamageType_DisconnectKill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedDamageType_DisconnectKill>();
	}
};
static_assert(alignof(UTedDamageType_DisconnectKill) == 0x000008, "Wrong alignment on UTedDamageType_DisconnectKill");
static_assert(sizeof(UTedDamageType_DisconnectKill) == 0x000098, "Wrong size on UTedDamageType_DisconnectKill");

// Class Tempest.TedObjectiveSettings
// 0x0028 (0x0060 - 0x0038)
class UTedObjectiveSettings final : public UDeveloperSettings
{
public:
	uint8                                         bEnableAnnouncements : 1;                          // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTedObjectiveAnnouncement>      Announcements;                                     // 0x0040(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<ETedObjectiveAnnouncementType>         DisabledAnnouncements;                             // 0x0050(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	bool AreAnnouncementsEnabled() const;
	TSubclassOf<class UTedAnnouncement> GetAnnouncement(const ETedObjectiveAnnouncementType InType, const bool bInPrimary) const;
	bool IsAnnouncementEnabled(const ETedObjectiveAnnouncementType InType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveSettings">();
	}
	static class UTedObjectiveSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveSettings>();
	}
};
static_assert(alignof(UTedObjectiveSettings) == 0x000008, "Wrong alignment on UTedObjectiveSettings");
static_assert(sizeof(UTedObjectiveSettings) == 0x000060, "Wrong size on UTedObjectiveSettings");
static_assert(offsetof(UTedObjectiveSettings, Announcements) == 0x000040, "Member 'UTedObjectiveSettings::Announcements' has a wrong offset!");
static_assert(offsetof(UTedObjectiveSettings, DisabledAnnouncements) == 0x000050, "Member 'UTedObjectiveSettings::DisabledAnnouncements' has a wrong offset!");

// Class Tempest.TedDedicatedServerMonitor
// 0x03F0 (0x0418 - 0x0028)
class UTedDedicatedServerMonitor final : public UObject
{
public:
	uint8                                         Pad_28[0x3F0];                                     // 0x0028(0x03F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnParentProcessDied();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedDedicatedServerMonitor">();
	}
	static class UTedDedicatedServerMonitor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedDedicatedServerMonitor>();
	}
};
static_assert(alignof(UTedDedicatedServerMonitor) == 0x000008, "Wrong alignment on UTedDedicatedServerMonitor");
static_assert(sizeof(UTedDedicatedServerMonitor) == 0x000418, "Wrong size on UTedDedicatedServerMonitor");

// Class Tempest.TedDefinitionPanel_Weapon
// 0x0008 (0x07D0 - 0x07C8)
class UTedDefinitionPanel_Weapon : public UTedDefinitionPanel
{
public:
	class ATedPawn*                               ContextPawn;                                       // 0x07C8(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetContextPawn(class ATedPawn* InContext);

	class ATedPawn* GetContextPawn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedDefinitionPanel_Weapon">();
	}
	static class UTedDefinitionPanel_Weapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedDefinitionPanel_Weapon>();
	}
};
static_assert(alignof(UTedDefinitionPanel_Weapon) == 0x000008, "Wrong alignment on UTedDefinitionPanel_Weapon");
static_assert(sizeof(UTedDefinitionPanel_Weapon) == 0x0007D0, "Wrong size on UTedDefinitionPanel_Weapon");
static_assert(offsetof(UTedDefinitionPanel_Weapon, ContextPawn) == 0x0007C8, "Member 'UTedDefinitionPanel_Weapon::ContextPawn' has a wrong offset!");

// Class Tempest.TedPawnSound
// 0x0018 (0x0040 - 0x0028)
class UTedPawnSound : public UObject
{
public:
	struct FPawnSoundData                         PawnSoundData;                                     // 0x0028(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnSound">();
	}
	static class UTedPawnSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnSound>();
	}
};
static_assert(alignof(UTedPawnSound) == 0x000008, "Wrong alignment on UTedPawnSound");
static_assert(sizeof(UTedPawnSound) == 0x000040, "Wrong size on UTedPawnSound");
static_assert(offsetof(UTedPawnSound, PawnSoundData) == 0x000028, "Member 'UTedPawnSound::PawnSoundData' has a wrong offset!");

// Class Tempest.TedDefinitionSlot_Weapon
// 0x0020 (0x0468 - 0x0448)
class UTedDefinitionSlot_Weapon : public UTedDefinitionSlot
{
public:
	class UTedPassiveAbilityPanel*                PassiveAbilities;                                  // 0x0448(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                PassiveAbilities_Separator;                        // 0x0450(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATedPawn*                               CachedContextPawn;                                 // 0x0458(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_460[0x8];                                      // 0x0460(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnContextPawnAmmoChange(class ATedPawn* Pawn, TSubclassOf<class UTedWeapon> WeaponClass, int32 AmmoCount);

	int32 GetAmmoCount() const;
	float GetAttackRange(const bool bInBaseOnly) const;
	float GetAttackRangeModifier(const float InBaseValue) const;
	float GetAttackSpeed(const bool bInBaseOnly) const;
	float GetAttackSpeedModifier() const;
	class ATedPawn* GetContextPawn() const;
	float GetDamage(const bool bInBaseOnly) const;
	const class FText GetDamageType() const;
	float GetDamageWithModifiers(const float InBaseValue) const;
	bool GetRechargesAutomatically() const;
	float GetRechargeTime(const bool bInBaseOnly) const;
	const struct FGameplayTagContainer GetTargetDomains() const;
	class FText GetTargetDomainsText() const;
	bool GetUsesAmmo() const;
	const class UTedWeapon* GetWeapon() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedDefinitionSlot_Weapon">();
	}
	static class UTedDefinitionSlot_Weapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedDefinitionSlot_Weapon>();
	}
};
static_assert(alignof(UTedDefinitionSlot_Weapon) == 0x000008, "Wrong alignment on UTedDefinitionSlot_Weapon");
static_assert(sizeof(UTedDefinitionSlot_Weapon) == 0x000468, "Wrong size on UTedDefinitionSlot_Weapon");
static_assert(offsetof(UTedDefinitionSlot_Weapon, PassiveAbilities) == 0x000448, "Member 'UTedDefinitionSlot_Weapon::PassiveAbilities' has a wrong offset!");
static_assert(offsetof(UTedDefinitionSlot_Weapon, PassiveAbilities_Separator) == 0x000450, "Member 'UTedDefinitionSlot_Weapon::PassiveAbilities_Separator' has a wrong offset!");
static_assert(offsetof(UTedDefinitionSlot_Weapon, CachedContextPawn) == 0x000458, "Member 'UTedDefinitionSlot_Weapon::CachedContextPawn' has a wrong offset!");

// Class Tempest.TedDifficultySettings
// 0x0098 (0x00D0 - 0x0038)
class UTedDifficultySettings final : public UDeveloperSettings
{
public:
	TArray<struct FTedDifficultyContainer>        TedDifficultySettings;                             // 0x0038(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              DefaultAttackWavePreset;                           // 0x0048(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultAttackWavePresetName;                       // 0x0070(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              DefaultDelayPreset;                                // 0x0078(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              DefaultUnitsSpawnPreset;                           // 0x00A0(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultUnitsSpawnPresetName;                       // 0x00C8(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static TArray<class FName> GetDefaultAttackWaveNames();
	static TArray<class FName> GetDefaultUnitsSpawnNames();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedDifficultySettings">();
	}
	static class UTedDifficultySettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedDifficultySettings>();
	}
};
static_assert(alignof(UTedDifficultySettings) == 0x000008, "Wrong alignment on UTedDifficultySettings");
static_assert(sizeof(UTedDifficultySettings) == 0x0000D0, "Wrong size on UTedDifficultySettings");
static_assert(offsetof(UTedDifficultySettings, TedDifficultySettings) == 0x000038, "Member 'UTedDifficultySettings::TedDifficultySettings' has a wrong offset!");
static_assert(offsetof(UTedDifficultySettings, DefaultAttackWavePreset) == 0x000048, "Member 'UTedDifficultySettings::DefaultAttackWavePreset' has a wrong offset!");
static_assert(offsetof(UTedDifficultySettings, DefaultAttackWavePresetName) == 0x000070, "Member 'UTedDifficultySettings::DefaultAttackWavePresetName' has a wrong offset!");
static_assert(offsetof(UTedDifficultySettings, DefaultDelayPreset) == 0x000078, "Member 'UTedDifficultySettings::DefaultDelayPreset' has a wrong offset!");
static_assert(offsetof(UTedDifficultySettings, DefaultUnitsSpawnPreset) == 0x0000A0, "Member 'UTedDifficultySettings::DefaultUnitsSpawnPreset' has a wrong offset!");
static_assert(offsetof(UTedDifficultySettings, DefaultUnitsSpawnPresetName) == 0x0000C8, "Member 'UTedDifficultySettings::DefaultUnitsSpawnPresetName' has a wrong offset!");

// Class Tempest.TedPawnUpgradesPanel
// 0x0018 (0x07E0 - 0x07C8)
class UTedPawnUpgradesPanel : public UTedCommandsPanel
{
public:
	TSubclassOf<class UTedPawnCommand_CancelUpgradeResearch> CancelUpgradeResearchCmd;               // 0x07C8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTedPawnCommand_PauseUpgradeResearch> PauseUpgradeResearchCmd;                 // 0x07D0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTedPawnCommand_PauseUpgradeResearch> UnpauseUpgradeResearchCmd;               // 0x07D8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool GetUpgradeProgress(const int32 InSlotIndex, float* OutProgressAlpha, float* OutDuration, bool* bOutIsRunning) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnUpgradesPanel">();
	}
	static class UTedPawnUpgradesPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnUpgradesPanel>();
	}
};
static_assert(alignof(UTedPawnUpgradesPanel) == 0x000008, "Wrong alignment on UTedPawnUpgradesPanel");
static_assert(sizeof(UTedPawnUpgradesPanel) == 0x0007E0, "Wrong size on UTedPawnUpgradesPanel");
static_assert(offsetof(UTedPawnUpgradesPanel, CancelUpgradeResearchCmd) == 0x0007C8, "Member 'UTedPawnUpgradesPanel::CancelUpgradeResearchCmd' has a wrong offset!");
static_assert(offsetof(UTedPawnUpgradesPanel, PauseUpgradeResearchCmd) == 0x0007D0, "Member 'UTedPawnUpgradesPanel::PauseUpgradeResearchCmd' has a wrong offset!");
static_assert(offsetof(UTedPawnUpgradesPanel, UnpauseUpgradeResearchCmd) == 0x0007D8, "Member 'UTedPawnUpgradesPanel::UnpauseUpgradeResearchCmd' has a wrong offset!");

// Class Tempest.TedDoctrineSlot
// 0x0018 (0x0448 - 0x0430)
class UTedDoctrineSlot : public UTedContentPanelSlotButton
{
public:
	class FName                                   IconMaterialParam;                                 // 0x0430(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_Icon;                                        // 0x0438(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                Widget_ConnectorToNext;                            // 0x0440(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class FText GetDescription() const;
	class UTedDoctrinePanel* GetDoctrinePanel() const;
	class UTexture2D* GetIcon() const;
	class UTedDoctrineSlot* GetNextSlot() const;
	int32 GetOnSellRefundedCredits() const;
	class UTedDoctrineSlot* GetPreviousSlot() const;
	int32 GetResearchCostCredits() const;
	float GetResearchTime() const;
	const class FText GetTitle() const;
	bool IsLast() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedDoctrineSlot">();
	}
	static class UTedDoctrineSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedDoctrineSlot>();
	}
};
static_assert(alignof(UTedDoctrineSlot) == 0x000008, "Wrong alignment on UTedDoctrineSlot");
static_assert(sizeof(UTedDoctrineSlot) == 0x000448, "Wrong size on UTedDoctrineSlot");
static_assert(offsetof(UTedDoctrineSlot, IconMaterialParam) == 0x000430, "Member 'UTedDoctrineSlot::IconMaterialParam' has a wrong offset!");
static_assert(offsetof(UTedDoctrineSlot, Image_Icon) == 0x000438, "Member 'UTedDoctrineSlot::Image_Icon' has a wrong offset!");
static_assert(offsetof(UTedDoctrineSlot, Widget_ConnectorToNext) == 0x000440, "Member 'UTedDoctrineSlot::Widget_ConnectorToNext' has a wrong offset!");

// Class Tempest.TedPerfStatWidget
// 0x0038 (0x0438 - 0x0400)
class UTedPerfStatWidget : public UTedUserWidget
{
public:
	ETedDisplayablePerformanceStat                StatType;                                          // 0x0400(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_401[0x7];                                      // 0x0401(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   StatDisplayName;                                   // 0x0408(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)
	class FText                                   StatUnitText;                                      // 0x0418(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         StatScaleFactor;                                   // 0x0428(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StatFractionalDigits;                              // 0x042C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedPerformanceStatSubsystem*           PerfStatSubsystem;                                 // 0x0430(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class FText GetStatDisplayName() const;
	ETedDisplayablePerformanceStat GetStatType() const;
	double GetStatValue() const;
	class FText GetStatValueText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPerfStatWidget">();
	}
	static class UTedPerfStatWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPerfStatWidget>();
	}
};
static_assert(alignof(UTedPerfStatWidget) == 0x000008, "Wrong alignment on UTedPerfStatWidget");
static_assert(sizeof(UTedPerfStatWidget) == 0x000438, "Wrong size on UTedPerfStatWidget");
static_assert(offsetof(UTedPerfStatWidget, StatType) == 0x000400, "Member 'UTedPerfStatWidget::StatType' has a wrong offset!");
static_assert(offsetof(UTedPerfStatWidget, StatDisplayName) == 0x000408, "Member 'UTedPerfStatWidget::StatDisplayName' has a wrong offset!");
static_assert(offsetof(UTedPerfStatWidget, StatUnitText) == 0x000418, "Member 'UTedPerfStatWidget::StatUnitText' has a wrong offset!");
static_assert(offsetof(UTedPerfStatWidget, StatScaleFactor) == 0x000428, "Member 'UTedPerfStatWidget::StatScaleFactor' has a wrong offset!");
static_assert(offsetof(UTedPerfStatWidget, StatFractionalDigits) == 0x00042C, "Member 'UTedPerfStatWidget::StatFractionalDigits' has a wrong offset!");
static_assert(offsetof(UTedPerfStatWidget, PerfStatSubsystem) == 0x000430, "Member 'UTedPerfStatWidget::PerfStatSubsystem' has a wrong offset!");

// Class Tempest.TedDoctrineSlot_HUD
// 0x0000 (0x0448 - 0x0448)
class UTedDoctrineSlot_HUD : public UTedDoctrineSlot
{
public:
	void OnRefresh_Progress(bool bInPaused, bool bInRunning, bool bInIsQueued, float InProgress);
	void RefreshProgress();

	class UTedDoctrinePanel_HUD* GetDoctrinePanel_HUD() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedDoctrineSlot_HUD">();
	}
	static class UTedDoctrineSlot_HUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedDoctrineSlot_HUD>();
	}
};
static_assert(alignof(UTedDoctrineSlot_HUD) == 0x000008, "Wrong alignment on UTedDoctrineSlot_HUD");
static_assert(sizeof(UTedDoctrineSlot_HUD) == 0x000448, "Wrong size on UTedDoctrineSlot_HUD");

// Class Tempest.TedDoctrineDefinition
// 0x0010 (0x00E8 - 0x00D8)
class UTedDoctrineDefinition final : public UTedUpgrade
{
public:
	int32                                         CostDoctrine;                                      // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ResearchCostCredits;                               // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ResearchTime;                                      // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SellCostPct;                                       // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedDoctrineDefinition">();
	}
	static class UTedDoctrineDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedDoctrineDefinition>();
	}
};
static_assert(alignof(UTedDoctrineDefinition) == 0x000008, "Wrong alignment on UTedDoctrineDefinition");
static_assert(sizeof(UTedDoctrineDefinition) == 0x0000E8, "Wrong size on UTedDoctrineDefinition");
static_assert(offsetof(UTedDoctrineDefinition, CostDoctrine) == 0x0000D8, "Member 'UTedDoctrineDefinition::CostDoctrine' has a wrong offset!");
static_assert(offsetof(UTedDoctrineDefinition, ResearchCostCredits) == 0x0000DC, "Member 'UTedDoctrineDefinition::ResearchCostCredits' has a wrong offset!");
static_assert(offsetof(UTedDoctrineDefinition, ResearchTime) == 0x0000E0, "Member 'UTedDoctrineDefinition::ResearchTime' has a wrong offset!");
static_assert(offsetof(UTedDoctrineDefinition, SellCostPct) == 0x0000E4, "Member 'UTedDoctrineDefinition::SellCostPct' has a wrong offset!");

// Class Tempest.TedPingSubsystem
// 0x0060 (0x0090 - 0x0030)
class UTedPingSubsystem final : public UWorldSubsystem
{
public:
	TMap<ETedTeamID, struct FTedPingActors>       RegisteredPingActors;                              // 0x0030(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTedPingTimestamp>              PingTimestamp;                                     // 0x0080(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPingSubsystem">();
	}
	static class UTedPingSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPingSubsystem>();
	}
};
static_assert(alignof(UTedPingSubsystem) == 0x000008, "Wrong alignment on UTedPingSubsystem");
static_assert(sizeof(UTedPingSubsystem) == 0x000090, "Wrong size on UTedPingSubsystem");
static_assert(offsetof(UTedPingSubsystem, RegisteredPingActors) == 0x000030, "Member 'UTedPingSubsystem::RegisteredPingActors' has a wrong offset!");
static_assert(offsetof(UTedPingSubsystem, PingTimestamp) == 0x000080, "Member 'UTedPingSubsystem::PingTimestamp' has a wrong offset!");

// Class Tempest.TedDrone
// 0x0020 (0x1D30 - 0x1D10)
class ATedDrone : public ATedAircraft
{
public:
	class FName                                   DroneOwnerBBKeyName;                               // 0x1D10(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDeployed;                                         // 0x1D18(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D19[0x7];                                     // 0x1D19(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ATedPawn*                               DroneOwner;                                        // 0x1D20(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D28[0x8];                                     // 0x1D28(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_DroneOwner();

	class ATedPawn* GetDroneOwner() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedDrone">();
	}
	static class ATedDrone* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedDrone>();
	}
};
static_assert(alignof(ATedDrone) == 0x000010, "Wrong alignment on ATedDrone");
static_assert(sizeof(ATedDrone) == 0x001D30, "Wrong size on ATedDrone");
static_assert(offsetof(ATedDrone, DroneOwnerBBKeyName) == 0x001D10, "Member 'ATedDrone::DroneOwnerBBKeyName' has a wrong offset!");
static_assert(offsetof(ATedDrone, bDeployed) == 0x001D18, "Member 'ATedDrone::bDeployed' has a wrong offset!");
static_assert(offsetof(ATedDrone, DroneOwner) == 0x001D20, "Member 'ATedDrone::DroneOwner' has a wrong offset!");

// Class Tempest.AirDropBlueprintNode
// 0x0000 (0x0028 - 0x0028)
class UAirDropBlueprintNode final : public UBlueprintFunctionLibrary
{
public:
	static void RequestAirDrop(class UObject* InWorldContext, EAirDropInputs In, EAirDropOutputs* Out, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo, const TArray<class ATargetPoint*>& PlaneRoute, const TArray<class ATedUnitSpawner*>& Spawners, TArray<class ATedUnitBase*>* DroppedUnits);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AirDropBlueprintNode">();
	}
	static class UAirDropBlueprintNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAirDropBlueprintNode>();
	}
};
static_assert(alignof(UAirDropBlueprintNode) == 0x000008, "Wrong alignment on UAirDropBlueprintNode");
static_assert(sizeof(UAirDropBlueprintNode) == 0x000028, "Wrong size on UAirDropBlueprintNode");

// Class Tempest.TedInputMappingPanel
// 0x0018 (0x07C8 - 0x07B0)
class UTedInputMappingPanel : public UTedContentPanelDynamic
{
public:
	uint8                                         MinSlots;                                          // 0x07B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7B1[0x7];                                      // 0x07B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTedInputMappingContent>        content;                                           // 0x07B8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	class FText GetContentDisplayText(const int32 InSlotIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedInputMappingPanel">();
	}
	static class UTedInputMappingPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedInputMappingPanel>();
	}
};
static_assert(alignof(UTedInputMappingPanel) == 0x000008, "Wrong alignment on UTedInputMappingPanel");
static_assert(sizeof(UTedInputMappingPanel) == 0x0007C8, "Wrong size on UTedInputMappingPanel");
static_assert(offsetof(UTedInputMappingPanel, MinSlots) == 0x0007B0, "Member 'UTedInputMappingPanel::MinSlots' has a wrong offset!");
static_assert(offsetof(UTedInputMappingPanel, content) == 0x0007B8, "Member 'UTedInputMappingPanel::content' has a wrong offset!");

// Class Tempest.TedDroneCommand_Attack
// 0x0000 (0x0580 - 0x0580)
class UTedDroneCommand_Attack : public UTedPawnCommand_Attack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedDroneCommand_Attack">();
	}
	static class UTedDroneCommand_Attack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedDroneCommand_Attack>();
	}
};
static_assert(alignof(UTedDroneCommand_Attack) == 0x000008, "Wrong alignment on UTedDroneCommand_Attack");
static_assert(sizeof(UTedDroneCommand_Attack) == 0x000580, "Wrong size on UTedDroneCommand_Attack");

// Class Tempest.TedUnitCommand_Move
// 0x0008 (0x0578 - 0x0570)
class UTedUnitCommand_Move : public UTedPawnCommandWithBehavior
{
public:
	bool                                          bCheckForValidGroundLocation;                      // 0x0570(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_571[0x7];                                      // 0x0571(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitCommand_Move">();
	}
	static class UTedUnitCommand_Move* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUnitCommand_Move>();
	}
};
static_assert(alignof(UTedUnitCommand_Move) == 0x000008, "Wrong alignment on UTedUnitCommand_Move");
static_assert(sizeof(UTedUnitCommand_Move) == 0x000578, "Wrong size on UTedUnitCommand_Move");
static_assert(offsetof(UTedUnitCommand_Move, bCheckForValidGroundLocation) == 0x000570, "Member 'UTedUnitCommand_Move::bCheckForValidGroundLocation' has a wrong offset!");

// Class Tempest.SpawnInVolumeBlueprintNode
// 0x0000 (0x0028 - 0x0028)
class USpawnInVolumeBlueprintNode final : public UBlueprintFunctionLibrary
{
public:
	static void RequestSpawnInVolume(class UObject* InWorldContext, ESpawnInVolumeInputs In, ESpawnInVolumeOutputs* Out, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo, class ATedUnitSpawner_Volume* Spawner, TArray<class ATedUnitBase*>* SpawnedUnits);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnInVolumeBlueprintNode">();
	}
	static class USpawnInVolumeBlueprintNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnInVolumeBlueprintNode>();
	}
};
static_assert(alignof(USpawnInVolumeBlueprintNode) == 0x000008, "Wrong alignment on USpawnInVolumeBlueprintNode");
static_assert(sizeof(USpawnInVolumeBlueprintNode) == 0x000028, "Wrong size on USpawnInVolumeBlueprintNode");

// Class Tempest.TedDroneCommand_Move
// 0x0000 (0x0578 - 0x0578)
class UTedDroneCommand_Move : public UTedUnitCommand_Move
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedDroneCommand_Move">();
	}
	static class UTedDroneCommand_Move* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedDroneCommand_Move>();
	}
};
static_assert(alignof(UTedDroneCommand_Move) == 0x000008, "Wrong alignment on UTedDroneCommand_Move");
static_assert(sizeof(UTedDroneCommand_Move) == 0x000578, "Wrong size on UTedDroneCommand_Move");

// Class Tempest.TedDropDownOld
// 0x0000 (0x1DD0 - 0x1DD0)
class UTedDropDownOld final : public UComboBoxString
{
public:
	void SetOptions(const TArray<class FText>& InOptions);

	int32 GetSelectedOptionIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedDropDownOld">();
	}
	static class UTedDropDownOld* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedDropDownOld>();
	}
};
static_assert(alignof(UTedDropDownOld) == 0x000010, "Wrong alignment on UTedDropDownOld");
static_assert(sizeof(UTedDropDownOld) == 0x001DD0, "Wrong size on UTedDropDownOld");

// Class Tempest.TedLeaderboardHeadersPanel
// 0x0010 (0x07C0 - 0x07B0)
class UTedLeaderboardHeadersPanel final : public UTedContentPanelDynamic
{
public:
	TArray<struct FTedLeaderboardHeaderContent>   content;                                           // 0x07B0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	TArray<class FName> GetAvailableHeaderIDs() const;
	bool GetContent(const int32 InSlotIndex, struct FTedLeaderboardHeaderContent* OutContent) const;
	bool GetContentByState(const ETedContentSlotState InState, const int32 InIndex, struct FTedLeaderboardHeaderContent* OutContent) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedLeaderboardHeadersPanel">();
	}
	static class UTedLeaderboardHeadersPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedLeaderboardHeadersPanel>();
	}
};
static_assert(alignof(UTedLeaderboardHeadersPanel) == 0x000008, "Wrong alignment on UTedLeaderboardHeadersPanel");
static_assert(sizeof(UTedLeaderboardHeadersPanel) == 0x0007C0, "Wrong size on UTedLeaderboardHeadersPanel");
static_assert(offsetof(UTedLeaderboardHeadersPanel, content) == 0x0007B0, "Member 'UTedLeaderboardHeadersPanel::content' has a wrong offset!");

// Class Tempest.TedDynamicEventForwarder
// 0x0050 (0x0080 - 0x0030)
class UTedDynamicEventForwarder final : public UWorldSubsystem
{
public:
	TMap<class AActor*, struct FNativeActorEvents> Events;                                           // 0x0030(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	void OnActorBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnActorEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnActorTakeAnyDamage(class AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser);
	void OnEndPlay(class AActor* InActor, EEndPlayReason InEndPlayReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedDynamicEventForwarder">();
	}
	static class UTedDynamicEventForwarder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedDynamicEventForwarder>();
	}
};
static_assert(alignof(UTedDynamicEventForwarder) == 0x000008, "Wrong alignment on UTedDynamicEventForwarder");
static_assert(sizeof(UTedDynamicEventForwarder) == 0x000080, "Wrong size on UTedDynamicEventForwarder");
static_assert(offsetof(UTedDynamicEventForwarder, Events) == 0x000030, "Member 'UTedDynamicEventForwarder::Events' has a wrong offset!");

// Class Tempest.EcsTypeDesc_AoEProvider
// 0x0000 (0x0028 - 0x0028)
class UEcsTypeDesc_AoEProvider final : public UEcsTypeDesc
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EcsTypeDesc_AoEProvider">();
	}
	static class UEcsTypeDesc_AoEProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEcsTypeDesc_AoEProvider>();
	}
};
static_assert(alignof(UEcsTypeDesc_AoEProvider) == 0x000008, "Wrong alignment on UEcsTypeDesc_AoEProvider");
static_assert(sizeof(UEcsTypeDesc_AoEProvider) == 0x000028, "Wrong size on UEcsTypeDesc_AoEProvider");

// Class Tempest.TedLevelScriptActor
// 0x00B8 (0x0350 - 0x0298)
class ATedLevelScriptActor : public ALevelScriptActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bTriggerOnPawnSpawnedDelegate;                     // 0x02A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1[0xAF];                                     // 0x02A1(0x00AF)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_DisablePawnSpawnTracking();
	void K2_EnablePawnSpawnTracking();
	void K2_OnPawnSpawned(class ATedPawn* NewPawn);
	void OnActorSpawned(class AActor* NewActor);
	void SetSaveActorComponentActive(class UActorComponent* Component, bool bActive, bool bReset);
	void SetSaveActorHiddenInGame(class AActor* Actor, bool bInHidden);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedLevelScriptActor">();
	}
	static class ATedLevelScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedLevelScriptActor>();
	}
};
static_assert(alignof(ATedLevelScriptActor) == 0x000008, "Wrong alignment on ATedLevelScriptActor");
static_assert(sizeof(ATedLevelScriptActor) == 0x000350, "Wrong size on ATedLevelScriptActor");
static_assert(offsetof(ATedLevelScriptActor, bTriggerOnPawnSpawnedDelegate) == 0x0002A0, "Member 'ATedLevelScriptActor::bTriggerOnPawnSpawnedDelegate' has a wrong offset!");

// Class Tempest.TedEcsModule_AoE
// 0x0000 (0x0030 - 0x0030)
class UTedEcsModule_AoE final : public UTedEcsModule
{
public:
	static void K2_ReapplyAoEEffect(class ATedPawn* AoEProviderPawn, const TSubclassOf<class UGameplayEffect> EffectToReapply);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedEcsModule_AoE">();
	}
	static class UTedEcsModule_AoE* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedEcsModule_AoE>();
	}
};
static_assert(alignof(UTedEcsModule_AoE) == 0x000008, "Wrong alignment on UTedEcsModule_AoE");
static_assert(sizeof(UTedEcsModule_AoE) == 0x000030, "Wrong size on UTedEcsModule_AoE");

// Class Tempest.TedEcsModule_Attitude
// 0x0000 (0x0030 - 0x0030)
class UTedEcsModule_Attitude final : public UNubEcsModule_Attitude
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedEcsModule_Attitude">();
	}
	static class UTedEcsModule_Attitude* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedEcsModule_Attitude>();
	}
};
static_assert(alignof(UTedEcsModule_Attitude) == 0x000008, "Wrong alignment on UTedEcsModule_Attitude");
static_assert(sizeof(UTedEcsModule_Attitude) == 0x000030, "Wrong size on UTedEcsModule_Attitude");

// Class Tempest.TedInfluenceMap_OwnerInterestSpace
// 0x0008 (0x0030 - 0x0028)
class UTedInfluenceMap_OwnerInterestSpace final : public UInfluenceMap
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedInfluenceMap_OwnerInterestSpace">();
	}
	static class UTedInfluenceMap_OwnerInterestSpace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedInfluenceMap_OwnerInterestSpace>();
	}
};
static_assert(alignof(UTedInfluenceMap_OwnerInterestSpace) == 0x000008, "Wrong alignment on UTedInfluenceMap_OwnerInterestSpace");
static_assert(sizeof(UTedInfluenceMap_OwnerInterestSpace) == 0x000030, "Wrong size on UTedInfluenceMap_OwnerInterestSpace");

// Class Tempest.TedEcsModule_Collision
// 0x0000 (0x0030 - 0x0030)
class UTedEcsModule_Collision final : public UNubEcsModule_Collision
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedEcsModule_Collision">();
	}
	static class UTedEcsModule_Collision* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedEcsModule_Collision>();
	}
};
static_assert(alignof(UTedEcsModule_Collision) == 0x000008, "Wrong alignment on UTedEcsModule_Collision");
static_assert(sizeof(UTedEcsModule_Collision) == 0x000030, "Wrong size on UTedEcsModule_Collision");

// Class Tempest.EcsTypeDesc_Mine
// 0x0000 (0x0028 - 0x0028)
class UEcsTypeDesc_Mine final : public UEcsTypeDesc
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EcsTypeDesc_Mine">();
	}
	static class UEcsTypeDesc_Mine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEcsTypeDesc_Mine>();
	}
};
static_assert(alignof(UEcsTypeDesc_Mine) == 0x000008, "Wrong alignment on UEcsTypeDesc_Mine");
static_assert(sizeof(UEcsTypeDesc_Mine) == 0x000028, "Wrong size on UEcsTypeDesc_Mine");

// Class Tempest.TedNavFilter_UnitBase
// 0x0000 (0x0048 - 0x0048)
class UTedNavFilter_UnitBase : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedNavFilter_UnitBase">();
	}
	static class UTedNavFilter_UnitBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedNavFilter_UnitBase>();
	}
};
static_assert(alignof(UTedNavFilter_UnitBase) == 0x000008, "Wrong alignment on UTedNavFilter_UnitBase");
static_assert(sizeof(UTedNavFilter_UnitBase) == 0x000048, "Wrong size on UTedNavFilter_UnitBase");

// Class Tempest.EcsTypeDesc_MineTrigger
// 0x0000 (0x0028 - 0x0028)
class UEcsTypeDesc_MineTrigger final : public UEcsTypeDesc
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EcsTypeDesc_MineTrigger">();
	}
	static class UEcsTypeDesc_MineTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEcsTypeDesc_MineTrigger>();
	}
};
static_assert(alignof(UEcsTypeDesc_MineTrigger) == 0x000008, "Wrong alignment on UEcsTypeDesc_MineTrigger");
static_assert(sizeof(UEcsTypeDesc_MineTrigger) == 0x000028, "Wrong size on UEcsTypeDesc_MineTrigger");

// Class Tempest.TedEcsModule_Mines
// 0x0000 (0x0030 - 0x0030)
class UTedEcsModule_Mines final : public UTedEcsModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedEcsModule_Mines">();
	}
	static class UTedEcsModule_Mines* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedEcsModule_Mines>();
	}
};
static_assert(alignof(UTedEcsModule_Mines) == 0x000008, "Wrong alignment on UTedEcsModule_Mines");
static_assert(sizeof(UTedEcsModule_Mines) == 0x000030, "Wrong size on UTedEcsModule_Mines");

// Class Tempest.TedEcsModule_Movement
// 0x0000 (0x0030 - 0x0030)
class UTedEcsModule_Movement final : public UNubEcsModule_Movement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedEcsModule_Movement">();
	}
	static class UTedEcsModule_Movement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedEcsModule_Movement>();
	}
};
static_assert(alignof(UTedEcsModule_Movement) == 0x000008, "Wrong alignment on UTedEcsModule_Movement");
static_assert(sizeof(UTedEcsModule_Movement) == 0x000030, "Wrong size on UTedEcsModule_Movement");

// Class Tempest.TedNavFilter_TempestField
// 0x0000 (0x0048 - 0x0048)
class UTedNavFilter_TempestField final : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedNavFilter_TempestField">();
	}
	static class UTedNavFilter_TempestField* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedNavFilter_TempestField>();
	}
};
static_assert(alignof(UTedNavFilter_TempestField) == 0x000008, "Wrong alignment on UTedNavFilter_TempestField");
static_assert(sizeof(UTedNavFilter_TempestField) == 0x000048, "Wrong size on UTedNavFilter_TempestField");

// Class Tempest.TedEcsModule_Pawn
// 0x0000 (0x0030 - 0x0030)
class UTedEcsModule_Pawn final : public UTedEcsModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedEcsModule_Pawn">();
	}
	static class UTedEcsModule_Pawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedEcsModule_Pawn>();
	}
};
static_assert(alignof(UTedEcsModule_Pawn) == 0x000008, "Wrong alignment on UTedEcsModule_Pawn");
static_assert(sizeof(UTedEcsModule_Pawn) == 0x000030, "Wrong size on UTedEcsModule_Pawn");

// Class Tempest.EcsTypeDesc_PickupCollector
// 0x0000 (0x0028 - 0x0028)
class UEcsTypeDesc_PickupCollector final : public UEcsTypeDesc
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EcsTypeDesc_PickupCollector">();
	}
	static class UEcsTypeDesc_PickupCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEcsTypeDesc_PickupCollector>();
	}
};
static_assert(alignof(UEcsTypeDesc_PickupCollector) == 0x000008, "Wrong alignment on UEcsTypeDesc_PickupCollector");
static_assert(sizeof(UEcsTypeDesc_PickupCollector) == 0x000028, "Wrong size on UEcsTypeDesc_PickupCollector");

// Class Tempest.TedEcsModule_Pickups
// 0x0000 (0x0030 - 0x0030)
class UTedEcsModule_Pickups final : public UTedEcsModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedEcsModule_Pickups">();
	}
	static class UTedEcsModule_Pickups* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedEcsModule_Pickups>();
	}
};
static_assert(alignof(UTedEcsModule_Pickups) == 0x000008, "Wrong alignment on UTedEcsModule_Pickups");
static_assert(sizeof(UTedEcsModule_Pickups) == 0x000030, "Wrong size on UTedEcsModule_Pickups");

// Class Tempest.TedNavigationSystem
// 0x0000 (0x15C8 - 0x15C8)
class UTedNavigationSystem final : public UNavGridSystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedNavigationSystem">();
	}
	static class UTedNavigationSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedNavigationSystem>();
	}
};
static_assert(alignof(UTedNavigationSystem) == 0x000008, "Wrong alignment on UTedNavigationSystem");
static_assert(sizeof(UTedNavigationSystem) == 0x0015C8, "Wrong size on UTedNavigationSystem");

// Class Tempest.TedEcsModule_SpatialQuery
// 0x0000 (0x0030 - 0x0030)
class UTedEcsModule_SpatialQuery final : public UNubEcsModule_SpatialQuery
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedEcsModule_SpatialQuery">();
	}
	static class UTedEcsModule_SpatialQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedEcsModule_SpatialQuery>();
	}
};
static_assert(alignof(UTedEcsModule_SpatialQuery) == 0x000008, "Wrong alignment on UTedEcsModule_SpatialQuery");
static_assert(sizeof(UTedEcsModule_SpatialQuery) == 0x000030, "Wrong size on UTedEcsModule_SpatialQuery");

// Class Tempest.EcsTypeDesc_StealthEntity
// 0x0000 (0x0028 - 0x0028)
class UEcsTypeDesc_StealthEntity final : public UEcsTypeDesc
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EcsTypeDesc_StealthEntity">();
	}
	static class UEcsTypeDesc_StealthEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEcsTypeDesc_StealthEntity>();
	}
};
static_assert(alignof(UEcsTypeDesc_StealthEntity) == 0x000008, "Wrong alignment on UEcsTypeDesc_StealthEntity");
static_assert(sizeof(UEcsTypeDesc_StealthEntity) == 0x000028, "Wrong size on UEcsTypeDesc_StealthEntity");

// Class Tempest.TedNewReplicationGraph
// 0x0150 (0x06C0 - 0x0570)
class UTedNewReplicationGraph final : public UReplicationGraph
{
public:
	bool                                          bFogOfWarBasedClientSidePreload;                   // 0x0570(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_571[0x7];                                      // 0x0571(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UObject>>            AlwaysRelevantClasses;                             // 0x0578(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UReplicationGraphNode_GridSpatialization2D* GridNode;                                      // 0x0588(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReplicationGraphNode_ActorList*        AlwaysRelevantNode;                                // 0x0590(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTedNewReplicationGraphNode_PlayerStateFrequencyLimiter* PlayerStateNode;                  // 0x0598(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A0[0x50];                                     // 0x05A0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFOW_ConnectionNodePair>        FOW_ForConnectionNodes;                            // 0x05F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         FOW_ActorsNetConnection;                           // 0x0600(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_610[0xA0];                                     // 0x0610(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsWithoutNetConnection;                        // 0x06B0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedNewReplicationGraph">();
	}
	static class UTedNewReplicationGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedNewReplicationGraph>();
	}
};
static_assert(alignof(UTedNewReplicationGraph) == 0x000010, "Wrong alignment on UTedNewReplicationGraph");
static_assert(sizeof(UTedNewReplicationGraph) == 0x0006C0, "Wrong size on UTedNewReplicationGraph");
static_assert(offsetof(UTedNewReplicationGraph, bFogOfWarBasedClientSidePreload) == 0x000570, "Member 'UTedNewReplicationGraph::bFogOfWarBasedClientSidePreload' has a wrong offset!");
static_assert(offsetof(UTedNewReplicationGraph, AlwaysRelevantClasses) == 0x000578, "Member 'UTedNewReplicationGraph::AlwaysRelevantClasses' has a wrong offset!");
static_assert(offsetof(UTedNewReplicationGraph, GridNode) == 0x000588, "Member 'UTedNewReplicationGraph::GridNode' has a wrong offset!");
static_assert(offsetof(UTedNewReplicationGraph, AlwaysRelevantNode) == 0x000590, "Member 'UTedNewReplicationGraph::AlwaysRelevantNode' has a wrong offset!");
static_assert(offsetof(UTedNewReplicationGraph, PlayerStateNode) == 0x000598, "Member 'UTedNewReplicationGraph::PlayerStateNode' has a wrong offset!");
static_assert(offsetof(UTedNewReplicationGraph, FOW_ForConnectionNodes) == 0x0005F0, "Member 'UTedNewReplicationGraph::FOW_ForConnectionNodes' has a wrong offset!");
static_assert(offsetof(UTedNewReplicationGraph, FOW_ActorsNetConnection) == 0x000600, "Member 'UTedNewReplicationGraph::FOW_ActorsNetConnection' has a wrong offset!");
static_assert(offsetof(UTedNewReplicationGraph, ActorsWithoutNetConnection) == 0x0006B0, "Member 'UTedNewReplicationGraph::ActorsWithoutNetConnection' has a wrong offset!");

// Class Tempest.EcsTypeDesc_Trigger
// 0x0000 (0x0028 - 0x0028)
class UEcsTypeDesc_Trigger final : public UEcsTypeDesc
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EcsTypeDesc_Trigger">();
	}
	static class UEcsTypeDesc_Trigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEcsTypeDesc_Trigger>();
	}
};
static_assert(alignof(UEcsTypeDesc_Trigger) == 0x000008, "Wrong alignment on UEcsTypeDesc_Trigger");
static_assert(sizeof(UEcsTypeDesc_Trigger) == 0x000028, "Wrong size on UEcsTypeDesc_Trigger");

// Class Tempest.EcsTypeDesc_TriggeringEntity
// 0x0000 (0x0028 - 0x0028)
class UEcsTypeDesc_TriggeringEntity final : public UEcsTypeDesc
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EcsTypeDesc_TriggeringEntity">();
	}
	static class UEcsTypeDesc_TriggeringEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEcsTypeDesc_TriggeringEntity>();
	}
};
static_assert(alignof(UEcsTypeDesc_TriggeringEntity) == 0x000008, "Wrong alignment on UEcsTypeDesc_TriggeringEntity");
static_assert(sizeof(UEcsTypeDesc_TriggeringEntity) == 0x000028, "Wrong size on UEcsTypeDesc_TriggeringEntity");

// Class Tempest.TedMarkerConfig
// 0x0100 (0x0130 - 0x0030)
class UTedMarkerConfig : public UDataAsset
{
public:
	float                                         Duration;                                          // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bUseWorldMarker : 1;                               // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_35[0xB];                                       // 0x0035(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            WorldMarkerBursh;                                  // 0x0040(0x00D0)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  ContextTags;                                       // 0x0110(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	const struct FGameplayTagContainer GetContextTags() const;
	float GetDuration() const;
	const struct FSlateBrush GetWorldMarkerBursh() const;
	bool UseWorldMarker() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMarkerConfig">();
	}
	static class UTedMarkerConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMarkerConfig>();
	}
};
static_assert(alignof(UTedMarkerConfig) == 0x000010, "Wrong alignment on UTedMarkerConfig");
static_assert(sizeof(UTedMarkerConfig) == 0x000130, "Wrong size on UTedMarkerConfig");
static_assert(offsetof(UTedMarkerConfig, Duration) == 0x000030, "Member 'UTedMarkerConfig::Duration' has a wrong offset!");
static_assert(offsetof(UTedMarkerConfig, WorldMarkerBursh) == 0x000040, "Member 'UTedMarkerConfig::WorldMarkerBursh' has a wrong offset!");
static_assert(offsetof(UTedMarkerConfig, ContextTags) == 0x000110, "Member 'UTedMarkerConfig::ContextTags' has a wrong offset!");

// Class Tempest.TedEditableTextBox
// 0x0040 (0x10D0 - 0x1090)
class UTedEditableTextBox final : public UEditableTextBox
{
public:
	TMulticastInlineDelegate<void()>              OnUserMovedFocus;                                  // 0x1088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bApplyRegex;                                       // 0x1098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1099[0x7];                                     // 0x1099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RegexToApply;                                      // 0x10A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplySuffix;                                      // 0x10B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESuffixType                                   SuffixType;                                        // 0x10B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterLimitType                           CharacterLimitType;                                // 0x10B2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10B3[0x15];                                    // 0x10B3(0x0015)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         CharacterLimit;                                    // 0x10C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10C9[0x7];                                     // 0x10C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyCharacterLimit(const class FText& InText);
	class FText RemoveSuffixAndRestoreValue(const class FText& InValue);

	class FText AddSuffixAndTrim(const class FText& InValue) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedEditableTextBox">();
	}
	static class UTedEditableTextBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedEditableTextBox>();
	}
};
static_assert(alignof(UTedEditableTextBox) == 0x000010, "Wrong alignment on UTedEditableTextBox");
static_assert(sizeof(UTedEditableTextBox) == 0x0010D0, "Wrong size on UTedEditableTextBox");
static_assert(offsetof(UTedEditableTextBox, OnUserMovedFocus) == 0x001088, "Member 'UTedEditableTextBox::OnUserMovedFocus' has a wrong offset!");
static_assert(offsetof(UTedEditableTextBox, bApplyRegex) == 0x001098, "Member 'UTedEditableTextBox::bApplyRegex' has a wrong offset!");
static_assert(offsetof(UTedEditableTextBox, RegexToApply) == 0x0010A0, "Member 'UTedEditableTextBox::RegexToApply' has a wrong offset!");
static_assert(offsetof(UTedEditableTextBox, bApplySuffix) == 0x0010B0, "Member 'UTedEditableTextBox::bApplySuffix' has a wrong offset!");
static_assert(offsetof(UTedEditableTextBox, SuffixType) == 0x0010B1, "Member 'UTedEditableTextBox::SuffixType' has a wrong offset!");
static_assert(offsetof(UTedEditableTextBox, CharacterLimitType) == 0x0010B2, "Member 'UTedEditableTextBox::CharacterLimitType' has a wrong offset!");
static_assert(offsetof(UTedEditableTextBox, CharacterLimit) == 0x0010C8, "Member 'UTedEditableTextBox::CharacterLimit' has a wrong offset!");

// Class Tempest.TedPawnCommand_StartUpgradeResearch
// 0x0168 (0x06A8 - 0x0540)
class UTedPawnCommand_StartUpgradeResearch : public UTedPawnCommand
{
public:
	ETedPawnUpgradeType                           UpgradeType;                                       // 0x0540(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_541[0x7];                                      // 0x0541(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  RequiredTech;                                      // 0x0548(0x0020)(Deprecated, Protected, NativeAccessSpecifierProtected)
	struct FTedPrerequisiteContainer              RequiredPrerequisites;                             // 0x0568(0x0110)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           UpgradeTechTag;                                    // 0x0678(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTedUpgrade>             ResearchedUpgrade;                                 // 0x0680(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommand_StartUpgradeResearch">();
	}
	static class UTedPawnCommand_StartUpgradeResearch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnCommand_StartUpgradeResearch>();
	}
};
static_assert(alignof(UTedPawnCommand_StartUpgradeResearch) == 0x000008, "Wrong alignment on UTedPawnCommand_StartUpgradeResearch");
static_assert(sizeof(UTedPawnCommand_StartUpgradeResearch) == 0x0006A8, "Wrong size on UTedPawnCommand_StartUpgradeResearch");
static_assert(offsetof(UTedPawnCommand_StartUpgradeResearch, UpgradeType) == 0x000540, "Member 'UTedPawnCommand_StartUpgradeResearch::UpgradeType' has a wrong offset!");
static_assert(offsetof(UTedPawnCommand_StartUpgradeResearch, RequiredTech) == 0x000548, "Member 'UTedPawnCommand_StartUpgradeResearch::RequiredTech' has a wrong offset!");
static_assert(offsetof(UTedPawnCommand_StartUpgradeResearch, RequiredPrerequisites) == 0x000568, "Member 'UTedPawnCommand_StartUpgradeResearch::RequiredPrerequisites' has a wrong offset!");
static_assert(offsetof(UTedPawnCommand_StartUpgradeResearch, UpgradeTechTag) == 0x000678, "Member 'UTedPawnCommand_StartUpgradeResearch::UpgradeTechTag' has a wrong offset!");
static_assert(offsetof(UTedPawnCommand_StartUpgradeResearch, ResearchedUpgrade) == 0x000680, "Member 'UTedPawnCommand_StartUpgradeResearch::ResearchedUpgrade' has a wrong offset!");

// Class Tempest.TedEffectAppliedToAttackerConfigAsset
// 0x0170 (0x01A0 - 0x0030)
class UTedEffectAppliedToAttackerConfigAsset final : public UDataAsset
{
public:
	struct FTedEffectAppliedToAttackerConfig      Data;                                              // 0x0030(0x0170)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedEffectAppliedToAttackerConfigAsset">();
	}
	static class UTedEffectAppliedToAttackerConfigAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedEffectAppliedToAttackerConfigAsset>();
	}
};
static_assert(alignof(UTedEffectAppliedToAttackerConfigAsset) == 0x000008, "Wrong alignment on UTedEffectAppliedToAttackerConfigAsset");
static_assert(sizeof(UTedEffectAppliedToAttackerConfigAsset) == 0x0001A0, "Wrong size on UTedEffectAppliedToAttackerConfigAsset");
static_assert(offsetof(UTedEffectAppliedToAttackerConfigAsset, Data) == 0x000030, "Member 'UTedEffectAppliedToAttackerConfigAsset::Data' has a wrong offset!");

// Class Tempest.TedEffectsProxyWidget
// 0x0018 (0x0418 - 0x0400)
class UTedEffectsProxyWidget : public UTedUserWidget
{
public:
	class UMaterialInterface*                     IconMaterial;                                      // 0x0400(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FPawnEffectData>                DrawData;                                          // 0x0408(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void HandleEffectApplied(const class ATedPawn* TargetPawn, const class UTedStatusDefinition* AppliedEffect);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedEffectsProxyWidget">();
	}
	static class UTedEffectsProxyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedEffectsProxyWidget>();
	}
};
static_assert(alignof(UTedEffectsProxyWidget) == 0x000008, "Wrong alignment on UTedEffectsProxyWidget");
static_assert(sizeof(UTedEffectsProxyWidget) == 0x000418, "Wrong size on UTedEffectsProxyWidget");
static_assert(offsetof(UTedEffectsProxyWidget, IconMaterial) == 0x000400, "Member 'UTedEffectsProxyWidget::IconMaterial' has a wrong offset!");
static_assert(offsetof(UTedEffectsProxyWidget, DrawData) == 0x000408, "Member 'UTedEffectsProxyWidget::DrawData' has a wrong offset!");

// Class Tempest.TedMarkerShapeActor
// 0x0020 (0x02B0 - 0x0290)
class ATedMarkerShapeActor : public AActor
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           InitActorTag;                                      // 0x0298(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedMarkerConfig*                       InitMarker;                                        // 0x02A0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMarkerShapeActor">();
	}
	static class ATedMarkerShapeActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedMarkerShapeActor>();
	}
};
static_assert(alignof(ATedMarkerShapeActor) == 0x000008, "Wrong alignment on ATedMarkerShapeActor");
static_assert(sizeof(ATedMarkerShapeActor) == 0x0002B0, "Wrong size on ATedMarkerShapeActor");
static_assert(offsetof(ATedMarkerShapeActor, InitActorTag) == 0x000298, "Member 'ATedMarkerShapeActor::InitActorTag' has a wrong offset!");
static_assert(offsetof(ATedMarkerShapeActor, InitMarker) == 0x0002A0, "Member 'ATedMarkerShapeActor::InitMarker' has a wrong offset!");

// Class Tempest.TedMarkerShapeActor_Circle
// 0x02C0 (0x0570 - 0x02B0)
class ATedMarkerShapeActor_Circle final : public ATedMarkerShapeActor
{
public:
	uint32                                        RadiusInWorld;                                     // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B4[0xC];                                      // 0x02B4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            DefaultAreaBrush;                                  // 0x02C0(0x00D0)(Edit, Protected, NativeAccessSpecifierProtected)
	class FName                                   AreaMaterialRadiusParam;                           // 0x0390(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AreaMaterialPosXParam;                             // 0x0398(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AreaMaterialPosYParam;                             // 0x03A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AreaMaterialPrimaryParam;                          // 0x03A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateBrush                            MinimapMarkerBrush;                                // 0x03B0(0x00D0)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            ObjectiveMinimapMarkerBrush;                       // 0x0480(0x00D0)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	class UDecalComponent*                        Decal;                                             // 0x0550(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DecalMaterial;                                     // 0x0558(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DecalMaterialSizeParam;                            // 0x0560(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DecalMaterialPrimaryParam;                         // 0x0568(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMarkerShapeActor_Circle">();
	}
	static class ATedMarkerShapeActor_Circle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedMarkerShapeActor_Circle>();
	}
};
static_assert(alignof(ATedMarkerShapeActor_Circle) == 0x000010, "Wrong alignment on ATedMarkerShapeActor_Circle");
static_assert(sizeof(ATedMarkerShapeActor_Circle) == 0x000570, "Wrong size on ATedMarkerShapeActor_Circle");
static_assert(offsetof(ATedMarkerShapeActor_Circle, RadiusInWorld) == 0x0002B0, "Member 'ATedMarkerShapeActor_Circle::RadiusInWorld' has a wrong offset!");
static_assert(offsetof(ATedMarkerShapeActor_Circle, DefaultAreaBrush) == 0x0002C0, "Member 'ATedMarkerShapeActor_Circle::DefaultAreaBrush' has a wrong offset!");
static_assert(offsetof(ATedMarkerShapeActor_Circle, AreaMaterialRadiusParam) == 0x000390, "Member 'ATedMarkerShapeActor_Circle::AreaMaterialRadiusParam' has a wrong offset!");
static_assert(offsetof(ATedMarkerShapeActor_Circle, AreaMaterialPosXParam) == 0x000398, "Member 'ATedMarkerShapeActor_Circle::AreaMaterialPosXParam' has a wrong offset!");
static_assert(offsetof(ATedMarkerShapeActor_Circle, AreaMaterialPosYParam) == 0x0003A0, "Member 'ATedMarkerShapeActor_Circle::AreaMaterialPosYParam' has a wrong offset!");
static_assert(offsetof(ATedMarkerShapeActor_Circle, AreaMaterialPrimaryParam) == 0x0003A8, "Member 'ATedMarkerShapeActor_Circle::AreaMaterialPrimaryParam' has a wrong offset!");
static_assert(offsetof(ATedMarkerShapeActor_Circle, MinimapMarkerBrush) == 0x0003B0, "Member 'ATedMarkerShapeActor_Circle::MinimapMarkerBrush' has a wrong offset!");
static_assert(offsetof(ATedMarkerShapeActor_Circle, ObjectiveMinimapMarkerBrush) == 0x000480, "Member 'ATedMarkerShapeActor_Circle::ObjectiveMinimapMarkerBrush' has a wrong offset!");
static_assert(offsetof(ATedMarkerShapeActor_Circle, Decal) == 0x000550, "Member 'ATedMarkerShapeActor_Circle::Decal' has a wrong offset!");
static_assert(offsetof(ATedMarkerShapeActor_Circle, DecalMaterial) == 0x000558, "Member 'ATedMarkerShapeActor_Circle::DecalMaterial' has a wrong offset!");
static_assert(offsetof(ATedMarkerShapeActor_Circle, DecalMaterialSizeParam) == 0x000560, "Member 'ATedMarkerShapeActor_Circle::DecalMaterialSizeParam' has a wrong offset!");
static_assert(offsetof(ATedMarkerShapeActor_Circle, DecalMaterialPrimaryParam) == 0x000568, "Member 'ATedMarkerShapeActor_Circle::DecalMaterialPrimaryParam' has a wrong offset!");

// Class Tempest.TedEncyclopediaAbilities
// 0x0010 (0x0420 - 0x0410)
class UTedEncyclopediaAbilities final : public UTedContentPanelSlotBase
{
public:
	class UTextBlock*                             AbilityHeading;                                    // 0x0410(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 DisplayImage;                                      // 0x0418(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedEncyclopediaAbilities">();
	}
	static class UTedEncyclopediaAbilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedEncyclopediaAbilities>();
	}
};
static_assert(alignof(UTedEncyclopediaAbilities) == 0x000008, "Wrong alignment on UTedEncyclopediaAbilities");
static_assert(sizeof(UTedEncyclopediaAbilities) == 0x000420, "Wrong size on UTedEncyclopediaAbilities");
static_assert(offsetof(UTedEncyclopediaAbilities, AbilityHeading) == 0x000410, "Member 'UTedEncyclopediaAbilities::AbilityHeading' has a wrong offset!");
static_assert(offsetof(UTedEncyclopediaAbilities, DisplayImage) == 0x000418, "Member 'UTedEncyclopediaAbilities::DisplayImage' has a wrong offset!");

// Class Tempest.TedPawnCommand_AbilityBase
// 0x0050 (0x0590 - 0x0540)
class UTedPawnCommand_AbilityBase : public UTedPawnCommand
{
public:
	uint8                                         bUseCommandDataPayload : 1;                        // 0x0540(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseAbilityTags : 1;                               // 0x0540(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_541[0x7];                                      // 0x0541(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   AbilityClassToActivate;                            // 0x0548(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  AbilityTags;                                       // 0x0570(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommand_AbilityBase">();
	}
	static class UTedPawnCommand_AbilityBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnCommand_AbilityBase>();
	}
};
static_assert(alignof(UTedPawnCommand_AbilityBase) == 0x000008, "Wrong alignment on UTedPawnCommand_AbilityBase");
static_assert(sizeof(UTedPawnCommand_AbilityBase) == 0x000590, "Wrong size on UTedPawnCommand_AbilityBase");
static_assert(offsetof(UTedPawnCommand_AbilityBase, AbilityClassToActivate) == 0x000548, "Member 'UTedPawnCommand_AbilityBase::AbilityClassToActivate' has a wrong offset!");
static_assert(offsetof(UTedPawnCommand_AbilityBase, AbilityTags) == 0x000570, "Member 'UTedPawnCommand_AbilityBase::AbilityTags' has a wrong offset!");

// Class Tempest.TedPawnCommand_SelfContextAbility
// 0x0000 (0x0590 - 0x0590)
class UTedPawnCommand_SelfContextAbility : public UTedPawnCommand_AbilityBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommand_SelfContextAbility">();
	}
	static class UTedPawnCommand_SelfContextAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnCommand_SelfContextAbility>();
	}
};
static_assert(alignof(UTedPawnCommand_SelfContextAbility) == 0x000008, "Wrong alignment on UTedPawnCommand_SelfContextAbility");
static_assert(sizeof(UTedPawnCommand_SelfContextAbility) == 0x000590, "Wrong size on UTedPawnCommand_SelfContextAbility");

// Class Tempest.TedEncyclopediaAbilitiesPanel
// 0x0010 (0x07C0 - 0x07B0)
class UTedEncyclopediaAbilitiesPanel final : public UTedContentPanelDynamic
{
public:
	TArray<TSubclassOf<class UTedCommand>>        content;                                           // 0x07B0(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void SetContent(TArray<TSubclassOf<class UTedCommand>>* AbilityData);

	TSubclassOf<class UTedCommand> GetContent(int32 Index_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedEncyclopediaAbilitiesPanel">();
	}
	static class UTedEncyclopediaAbilitiesPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedEncyclopediaAbilitiesPanel>();
	}
};
static_assert(alignof(UTedEncyclopediaAbilitiesPanel) == 0x000008, "Wrong alignment on UTedEncyclopediaAbilitiesPanel");
static_assert(sizeof(UTedEncyclopediaAbilitiesPanel) == 0x0007C0, "Wrong size on UTedEncyclopediaAbilitiesPanel");
static_assert(offsetof(UTedEncyclopediaAbilitiesPanel, content) == 0x0007B0, "Member 'UTedEncyclopediaAbilitiesPanel::content' has a wrong offset!");

// Class Tempest.TedEncyclopediaDefinitionAsset
// 0x0060 (0x0090 - 0x0030)
class UTedEncyclopediaDefinitionAsset final : public UPrimaryDataAsset
{
public:
	ETedFaction                                   Faction;                                           // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           FactoryTab;                                        // 0x0034(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             DisplayTexture;                                    // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Heading;                                           // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   SubHeading;                                        // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Paragraph;                                         // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UTedCommand>>        abilities;                                         // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	class UTedMapInfo*                            MapToUnlockAfter;                                  // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedEncyclopediaDefinitionAsset">();
	}
	static class UTedEncyclopediaDefinitionAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedEncyclopediaDefinitionAsset>();
	}
};
static_assert(alignof(UTedEncyclopediaDefinitionAsset) == 0x000008, "Wrong alignment on UTedEncyclopediaDefinitionAsset");
static_assert(sizeof(UTedEncyclopediaDefinitionAsset) == 0x000090, "Wrong size on UTedEncyclopediaDefinitionAsset");
static_assert(offsetof(UTedEncyclopediaDefinitionAsset, Faction) == 0x000030, "Member 'UTedEncyclopediaDefinitionAsset::Faction' has a wrong offset!");
static_assert(offsetof(UTedEncyclopediaDefinitionAsset, FactoryTab) == 0x000034, "Member 'UTedEncyclopediaDefinitionAsset::FactoryTab' has a wrong offset!");
static_assert(offsetof(UTedEncyclopediaDefinitionAsset, DisplayTexture) == 0x000040, "Member 'UTedEncyclopediaDefinitionAsset::DisplayTexture' has a wrong offset!");
static_assert(offsetof(UTedEncyclopediaDefinitionAsset, Heading) == 0x000048, "Member 'UTedEncyclopediaDefinitionAsset::Heading' has a wrong offset!");
static_assert(offsetof(UTedEncyclopediaDefinitionAsset, SubHeading) == 0x000058, "Member 'UTedEncyclopediaDefinitionAsset::SubHeading' has a wrong offset!");
static_assert(offsetof(UTedEncyclopediaDefinitionAsset, Paragraph) == 0x000068, "Member 'UTedEncyclopediaDefinitionAsset::Paragraph' has a wrong offset!");
static_assert(offsetof(UTedEncyclopediaDefinitionAsset, abilities) == 0x000078, "Member 'UTedEncyclopediaDefinitionAsset::abilities' has a wrong offset!");
static_assert(offsetof(UTedEncyclopediaDefinitionAsset, MapToUnlockAfter) == 0x000088, "Member 'UTedEncyclopediaDefinitionAsset::MapToUnlockAfter' has a wrong offset!");

// Class Tempest.TedEncyclopediaEntryPanel
// 0x0018 (0x07C8 - 0x07B0)
class UTedEncyclopediaEntryPanel final : public UTedContentPanelDynamic
{
public:
	class UTedEncyclepediaFactionSlot*            ParentFactionSlot;                                 // 0x07B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTedEncyclopediaDefinitionAsset*> content;                                          // 0x07B8(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)

public:
	void SetContent(const TArray<class UTedEncyclopediaDefinitionAsset*>& NewContent);

	class UTedEncyclopediaDefinitionAsset* GetContent(int32 Index_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedEncyclopediaEntryPanel">();
	}
	static class UTedEncyclopediaEntryPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedEncyclopediaEntryPanel>();
	}
};
static_assert(alignof(UTedEncyclopediaEntryPanel) == 0x000008, "Wrong alignment on UTedEncyclopediaEntryPanel");
static_assert(sizeof(UTedEncyclopediaEntryPanel) == 0x0007C8, "Wrong size on UTedEncyclopediaEntryPanel");
static_assert(offsetof(UTedEncyclopediaEntryPanel, ParentFactionSlot) == 0x0007B0, "Member 'UTedEncyclopediaEntryPanel::ParentFactionSlot' has a wrong offset!");
static_assert(offsetof(UTedEncyclopediaEntryPanel, content) == 0x0007B8, "Member 'UTedEncyclopediaEntryPanel::content' has a wrong offset!");

// Class Tempest.TedMatchHistoryPanel
// 0x0018 (0x07C8 - 0x07B0)
class UTedMatchHistoryPanel final : public UTedContentPanelDynamic
{
public:
	uint8                                         Pad_7B0[0x10];                                     // 0x07B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedOnlinePlayerProfileWidgetContext*   ProfileContext;                                    // 0x07C0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Sort(const struct FGameplayTag& SortType, const bool bAscending);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMatchHistoryPanel">();
	}
	static class UTedMatchHistoryPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMatchHistoryPanel>();
	}
};
static_assert(alignof(UTedMatchHistoryPanel) == 0x000008, "Wrong alignment on UTedMatchHistoryPanel");
static_assert(sizeof(UTedMatchHistoryPanel) == 0x0007C8, "Wrong size on UTedMatchHistoryPanel");
static_assert(offsetof(UTedMatchHistoryPanel, ProfileContext) == 0x0007C0, "Member 'UTedMatchHistoryPanel::ProfileContext' has a wrong offset!");

// Class Tempest.TedEncyclopediaEntrySlot
// 0x0040 (0x0470 - 0x0430)
class UTedEncyclopediaEntrySlot final : public UTedContentPanelSlotButton
{
public:
	class UTextBlock*                             Maintext;                                          // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 UnseenMark;                                        // 0x0438(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 SlotBG;                                            // 0x0440(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DefaultBG;                                         // 0x0448(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     SelectedBG;                                        // 0x0450(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     ClassifiedDefaultBG;                               // 0x0458(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     ClassifiedActiveBG;                                // 0x0460(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEncyclopediaAssetStatus                      CurrentStatus;                                     // 0x0468(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_469[0x7];                                      // 0x0469(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedEncyclopediaEntrySlot">();
	}
	static class UTedEncyclopediaEntrySlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedEncyclopediaEntrySlot>();
	}
};
static_assert(alignof(UTedEncyclopediaEntrySlot) == 0x000008, "Wrong alignment on UTedEncyclopediaEntrySlot");
static_assert(sizeof(UTedEncyclopediaEntrySlot) == 0x000470, "Wrong size on UTedEncyclopediaEntrySlot");
static_assert(offsetof(UTedEncyclopediaEntrySlot, Maintext) == 0x000430, "Member 'UTedEncyclopediaEntrySlot::Maintext' has a wrong offset!");
static_assert(offsetof(UTedEncyclopediaEntrySlot, UnseenMark) == 0x000438, "Member 'UTedEncyclopediaEntrySlot::UnseenMark' has a wrong offset!");
static_assert(offsetof(UTedEncyclopediaEntrySlot, SlotBG) == 0x000440, "Member 'UTedEncyclopediaEntrySlot::SlotBG' has a wrong offset!");
static_assert(offsetof(UTedEncyclopediaEntrySlot, DefaultBG) == 0x000448, "Member 'UTedEncyclopediaEntrySlot::DefaultBG' has a wrong offset!");
static_assert(offsetof(UTedEncyclopediaEntrySlot, SelectedBG) == 0x000450, "Member 'UTedEncyclopediaEntrySlot::SelectedBG' has a wrong offset!");
static_assert(offsetof(UTedEncyclopediaEntrySlot, ClassifiedDefaultBG) == 0x000458, "Member 'UTedEncyclopediaEntrySlot::ClassifiedDefaultBG' has a wrong offset!");
static_assert(offsetof(UTedEncyclopediaEntrySlot, ClassifiedActiveBG) == 0x000460, "Member 'UTedEncyclopediaEntrySlot::ClassifiedActiveBG' has a wrong offset!");
static_assert(offsetof(UTedEncyclopediaEntrySlot, CurrentStatus) == 0x000468, "Member 'UTedEncyclopediaEntrySlot::CurrentStatus' has a wrong offset!");

// Class Tempest.TedEncyclopediaMain
// 0x0030 (0x04B8 - 0x0488)
class UTedEncyclopediaMain final : public UTedMenuScreenPage
{
public:
	class UTedEncyclopediaAbilitiesPanel*         AbilityPanel;                                      // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTedEncyclopediaFactionPanel*           EncyclopediaFactionPanel;                          // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlay*                               AbilitiesArea;                                     // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETedFaction                                   CurrentFaction;                                    // 0x04A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A1[0x7];                                      // 0x04A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTedEncyclopediaDefinitionAsset*> LoadedAssets;                                     // 0x04A8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void DisplayEyclopediaEntry(class UTedEncyclopediaDefinitionAsset* Asset);
	void SetNewFaction(ETedFaction NewFaction);
	void UpdateEntries();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedEncyclopediaMain">();
	}
	static class UTedEncyclopediaMain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedEncyclopediaMain>();
	}
};
static_assert(alignof(UTedEncyclopediaMain) == 0x000008, "Wrong alignment on UTedEncyclopediaMain");
static_assert(sizeof(UTedEncyclopediaMain) == 0x0004B8, "Wrong size on UTedEncyclopediaMain");
static_assert(offsetof(UTedEncyclopediaMain, AbilityPanel) == 0x000488, "Member 'UTedEncyclopediaMain::AbilityPanel' has a wrong offset!");
static_assert(offsetof(UTedEncyclopediaMain, EncyclopediaFactionPanel) == 0x000490, "Member 'UTedEncyclopediaMain::EncyclopediaFactionPanel' has a wrong offset!");
static_assert(offsetof(UTedEncyclopediaMain, AbilitiesArea) == 0x000498, "Member 'UTedEncyclopediaMain::AbilitiesArea' has a wrong offset!");
static_assert(offsetof(UTedEncyclopediaMain, CurrentFaction) == 0x0004A0, "Member 'UTedEncyclopediaMain::CurrentFaction' has a wrong offset!");
static_assert(offsetof(UTedEncyclopediaMain, LoadedAssets) == 0x0004A8, "Member 'UTedEncyclopediaMain::LoadedAssets' has a wrong offset!");

// Class Tempest.TedMedalsScreenContextObject
// 0x0010 (0x0038 - 0x0028)
class UTedMedalsScreenContextObject final : public UObject
{
public:
	bool                                          bVictory;                                          // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ATedPlayerState*                        PlayerState;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UTedMedalsScreenContextObject* New(const bool bInVictory, const class ATedPlayerState* InPlayerState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMedalsScreenContextObject">();
	}
	static class UTedMedalsScreenContextObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMedalsScreenContextObject>();
	}
};
static_assert(alignof(UTedMedalsScreenContextObject) == 0x000008, "Wrong alignment on UTedMedalsScreenContextObject");
static_assert(sizeof(UTedMedalsScreenContextObject) == 0x000038, "Wrong size on UTedMedalsScreenContextObject");
static_assert(offsetof(UTedMedalsScreenContextObject, bVictory) == 0x000028, "Member 'UTedMedalsScreenContextObject::bVictory' has a wrong offset!");
static_assert(offsetof(UTedMedalsScreenContextObject, PlayerState) == 0x000030, "Member 'UTedMedalsScreenContextObject::PlayerState' has a wrong offset!");

// Class Tempest.TedEndGameScreen
// 0x0018 (0x0470 - 0x0458)
class UTedEndGameScreen : public UTedMenuScreenWidget
{
public:
	class UTedUserWidget*                         Button_Retry;                                      // 0x0458(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTedUserWidget*                         Button_RestartMatch;                               // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTedPopup*                              ActivePopup;                                       // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ShowPopup(class UTedUserWidget* InButton);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedEndGameScreen">();
	}
	static class UTedEndGameScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedEndGameScreen>();
	}
};
static_assert(alignof(UTedEndGameScreen) == 0x000008, "Wrong alignment on UTedEndGameScreen");
static_assert(sizeof(UTedEndGameScreen) == 0x000470, "Wrong size on UTedEndGameScreen");
static_assert(offsetof(UTedEndGameScreen, Button_Retry) == 0x000458, "Member 'UTedEndGameScreen::Button_Retry' has a wrong offset!");
static_assert(offsetof(UTedEndGameScreen, Button_RestartMatch) == 0x000460, "Member 'UTedEndGameScreen::Button_RestartMatch' has a wrong offset!");
static_assert(offsetof(UTedEndGameScreen, ActivePopup) == 0x000468, "Member 'UTedEndGameScreen::ActivePopup' has a wrong offset!");

// Class Tempest.TedEnhancedInputSettings
// 0x0000 (0x0120 - 0x0120)
class UTedEnhancedInputSettings final : public UEnhancedInputUserSettings
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedEnhancedInputSettings">();
	}
	static class UTedEnhancedInputSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedEnhancedInputSettings>();
	}
};
static_assert(alignof(UTedEnhancedInputSettings) == 0x000008, "Wrong alignment on UTedEnhancedInputSettings");
static_assert(sizeof(UTedEnhancedInputSettings) == 0x000120, "Wrong size on UTedEnhancedInputSettings");

// Class Tempest.TedEquipmentSlot
// 0x0048 (0x0478 - 0x0430)
class UTedEquipmentSlot final : public UTedContentPanelSlotButton
{
public:
	class FName                                   IconMaterialParam;                                 // 0x0430(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_Icon;                                        // 0x0438(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Title;                                        // 0x0440(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Description;                                  // 0x0448(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_RequisitionCost;                              // 0x0450(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_InventorySpaceCost;                           // 0x0458(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                Button_Buy;                                        // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                Button_Equip;                                      // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                Button_Unequip;                                    // 0x0470(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void K2_RefreshStateVisuals();
	void OnButtonClicked_Buy();
	void OnButtonClicked_Equip();
	void OnButtonClicked_Unequip();
	void RefreshStateVisuals();

	class FText GetDescription() const;
	class UTedEquipmentPanel* GetEquipmentPanel() const;
	class UTexture2D* GetIcon() const;
	int32 GetInventorySpaceCost() const;
	int32 GetRequisitionCost() const;
	const class FText GetTitle() const;
	bool HasRequisitionForEquipment() const;
	bool HasSpaceForEquipment() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedEquipmentSlot">();
	}
	static class UTedEquipmentSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedEquipmentSlot>();
	}
};
static_assert(alignof(UTedEquipmentSlot) == 0x000008, "Wrong alignment on UTedEquipmentSlot");
static_assert(sizeof(UTedEquipmentSlot) == 0x000478, "Wrong size on UTedEquipmentSlot");
static_assert(offsetof(UTedEquipmentSlot, IconMaterialParam) == 0x000430, "Member 'UTedEquipmentSlot::IconMaterialParam' has a wrong offset!");
static_assert(offsetof(UTedEquipmentSlot, Image_Icon) == 0x000438, "Member 'UTedEquipmentSlot::Image_Icon' has a wrong offset!");
static_assert(offsetof(UTedEquipmentSlot, Text_Title) == 0x000440, "Member 'UTedEquipmentSlot::Text_Title' has a wrong offset!");
static_assert(offsetof(UTedEquipmentSlot, Text_Description) == 0x000448, "Member 'UTedEquipmentSlot::Text_Description' has a wrong offset!");
static_assert(offsetof(UTedEquipmentSlot, Text_RequisitionCost) == 0x000450, "Member 'UTedEquipmentSlot::Text_RequisitionCost' has a wrong offset!");
static_assert(offsetof(UTedEquipmentSlot, Text_InventorySpaceCost) == 0x000458, "Member 'UTedEquipmentSlot::Text_InventorySpaceCost' has a wrong offset!");
static_assert(offsetof(UTedEquipmentSlot, Button_Buy) == 0x000460, "Member 'UTedEquipmentSlot::Button_Buy' has a wrong offset!");
static_assert(offsetof(UTedEquipmentSlot, Button_Equip) == 0x000468, "Member 'UTedEquipmentSlot::Button_Equip' has a wrong offset!");
static_assert(offsetof(UTedEquipmentSlot, Button_Unequip) == 0x000470, "Member 'UTedEquipmentSlot::Button_Unequip' has a wrong offset!");

// Class Tempest.TedInfluenceMap_OwnerProxy
// 0x0008 (0x0030 - 0x0028)
class UTedInfluenceMap_OwnerProxy final : public UInfluenceMap
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedInfluenceMap_OwnerProxy">();
	}
	static class UTedInfluenceMap_OwnerProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedInfluenceMap_OwnerProxy>();
	}
};
static_assert(alignof(UTedInfluenceMap_OwnerProxy) == 0x000008, "Wrong alignment on UTedInfluenceMap_OwnerProxy");
static_assert(sizeof(UTedInfluenceMap_OwnerProxy) == 0x000030, "Wrong size on UTedInfluenceMap_OwnerProxy");

// Class Tempest.TedEULAMenuScreenPage
// 0x0000 (0x0488 - 0x0488)
class UTedEULAMenuScreenPage final : public UTedMenuScreenPage
{
public:
	void ShowQuitGamePopUp() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedEULAMenuScreenPage">();
	}
	static class UTedEULAMenuScreenPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedEULAMenuScreenPage>();
	}
};
static_assert(alignof(UTedEULAMenuScreenPage) == 0x000008, "Wrong alignment on UTedEULAMenuScreenPage");
static_assert(sizeof(UTedEULAMenuScreenPage) == 0x000488, "Wrong size on UTedEULAMenuScreenPage");

// Class Tempest.TedFogOfWarAgentActor
// 0x0058 (0x02E8 - 0x0290)
class ATedFogOfWarAgentActor final : public AActor
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedFoWAgentData                       TedFoWAgentData;                                   // 0x0298(0x0050)(Net, SaveGame, RepNotify, Protected, NativeAccessSpecifierProtected)

public:
	void OnRep_FoWAgentData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedFogOfWarAgentActor">();
	}
	static class ATedFogOfWarAgentActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedFogOfWarAgentActor>();
	}
};
static_assert(alignof(ATedFogOfWarAgentActor) == 0x000008, "Wrong alignment on ATedFogOfWarAgentActor");
static_assert(sizeof(ATedFogOfWarAgentActor) == 0x0002E8, "Wrong size on ATedFogOfWarAgentActor");
static_assert(offsetof(ATedFogOfWarAgentActor, TedFoWAgentData) == 0x000298, "Member 'ATedFogOfWarAgentActor::TedFoWAgentData' has a wrong offset!");

// Class Tempest.TedInfluenceMap_ChaseRange
// 0x0000 (0x0028 - 0x0028)
class UTedInfluenceMap_ChaseRange final : public UInfluenceMap
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedInfluenceMap_ChaseRange">();
	}
	static class UTedInfluenceMap_ChaseRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedInfluenceMap_ChaseRange>();
	}
};
static_assert(alignof(UTedInfluenceMap_ChaseRange) == 0x000008, "Wrong alignment on UTedInfluenceMap_ChaseRange");
static_assert(sizeof(UTedInfluenceMap_ChaseRange) == 0x000028, "Wrong size on UTedInfluenceMap_ChaseRange");

// Class Tempest.TedFoliageInteractionConfig
// 0x0190 (0x01C0 - 0x0030)
class UTedFoliageInteractionConfig final : public UDataAsset
{
public:
	struct FFoliageConfig                         FoliageConfig;                                     // 0x0030(0x0190)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedFoliageInteractionConfig">();
	}
	static class UTedFoliageInteractionConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedFoliageInteractionConfig>();
	}
};
static_assert(alignof(UTedFoliageInteractionConfig) == 0x000008, "Wrong alignment on UTedFoliageInteractionConfig");
static_assert(sizeof(UTedFoliageInteractionConfig) == 0x0001C0, "Wrong size on UTedFoliageInteractionConfig");
static_assert(offsetof(UTedFoliageInteractionConfig, FoliageConfig) == 0x000030, "Member 'UTedFoliageInteractionConfig::FoliageConfig' has a wrong offset!");

// Class Tempest.TedFrameUtilityControlKit
// 0x0000 (0x0030 - 0x0030)
class UTedFrameUtilityControlKit final : public UGameInstanceSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedFrameUtilityControlKit">();
	}
	static class UTedFrameUtilityControlKit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedFrameUtilityControlKit>();
	}
};
static_assert(alignof(UTedFrameUtilityControlKit) == 0x000008, "Wrong alignment on UTedFrameUtilityControlKit");
static_assert(sizeof(UTedFrameUtilityControlKit) == 0x000030, "Wrong size on UTedFrameUtilityControlKit");

// Class Tempest.TedInputPreset
// 0x0020 (0x0050 - 0x0030)
class UTedInputPreset final : public UDataAsset
{
public:
	class FText                                   PresetName;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FTedPresetEntry>                Preset;                                            // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedInputPreset">();
	}
	static class UTedInputPreset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedInputPreset>();
	}
};
static_assert(alignof(UTedInputPreset) == 0x000008, "Wrong alignment on UTedInputPreset");
static_assert(sizeof(UTedInputPreset) == 0x000050, "Wrong size on UTedInputPreset");
static_assert(offsetof(UTedInputPreset, PresetName) == 0x000030, "Member 'UTedInputPreset::PresetName' has a wrong offset!");
static_assert(offsetof(UTedInputPreset, Preset) == 0x000040, "Member 'UTedInputPreset::Preset' has a wrong offset!");

// Class Tempest.TedGameCreationPlayersSlot
// 0x00A0 (0x04B0 - 0x0410)
class UTedGameCreationPlayersSlot final : public UTedContentPanelSlotBase
{
public:
	class UTedSettingsPanel*                      PlayerSettings;                                    // 0x0410(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<ETedSessionMemberSettingKey, class UTedSettingsSlot*> PlayerSettingSlots;                   // 0x0418(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Label;                                        // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                Button_AddHumanPlayer;                             // 0x0470(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                Button_AddBotPlayer;                               // 0x0478(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                Button_RemovePlayer;                               // 0x0480(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_Avatar;                                      // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             CurrentAvatar;                                     // 0x0490(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_Ready;                                       // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_LobbyLeader;                                 // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_BotIndicator;                                // 0x04A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnClickedAddBotPlayer();
	void OnClickedAddHumanPlayer();
	void OnClickedRemovePlayer();
	void RequestAddBotPlayer();
	void RequestAddHumanPlayer();

	bool CanRequestAddBotPlayer() const;
	bool CanRequestRemovePlayer() const;
	class UTexture2D* GetAvatar() const;
	class UTedGameCreationPlayersPanel* GetContentPanel() const;
	const class FText GetLabel() const;
	bool GetSettingValue(const ETedSessionMemberSettingKey InKey, int32* OutValue) const;
	bool HasSetting(const ETedSessionMemberSettingKey InKey) const;
	bool IsAdmin() const;
	bool IsBot() const;
	bool IsEmpty() const;
	bool IsHuman() const;
	bool IsReady() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGameCreationPlayersSlot">();
	}
	static class UTedGameCreationPlayersSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedGameCreationPlayersSlot>();
	}
};
static_assert(alignof(UTedGameCreationPlayersSlot) == 0x000008, "Wrong alignment on UTedGameCreationPlayersSlot");
static_assert(sizeof(UTedGameCreationPlayersSlot) == 0x0004B0, "Wrong size on UTedGameCreationPlayersSlot");
static_assert(offsetof(UTedGameCreationPlayersSlot, PlayerSettings) == 0x000410, "Member 'UTedGameCreationPlayersSlot::PlayerSettings' has a wrong offset!");
static_assert(offsetof(UTedGameCreationPlayersSlot, PlayerSettingSlots) == 0x000418, "Member 'UTedGameCreationPlayersSlot::PlayerSettingSlots' has a wrong offset!");
static_assert(offsetof(UTedGameCreationPlayersSlot, Text_Label) == 0x000468, "Member 'UTedGameCreationPlayersSlot::Text_Label' has a wrong offset!");
static_assert(offsetof(UTedGameCreationPlayersSlot, Button_AddHumanPlayer) == 0x000470, "Member 'UTedGameCreationPlayersSlot::Button_AddHumanPlayer' has a wrong offset!");
static_assert(offsetof(UTedGameCreationPlayersSlot, Button_AddBotPlayer) == 0x000478, "Member 'UTedGameCreationPlayersSlot::Button_AddBotPlayer' has a wrong offset!");
static_assert(offsetof(UTedGameCreationPlayersSlot, Button_RemovePlayer) == 0x000480, "Member 'UTedGameCreationPlayersSlot::Button_RemovePlayer' has a wrong offset!");
static_assert(offsetof(UTedGameCreationPlayersSlot, Image_Avatar) == 0x000488, "Member 'UTedGameCreationPlayersSlot::Image_Avatar' has a wrong offset!");
static_assert(offsetof(UTedGameCreationPlayersSlot, CurrentAvatar) == 0x000490, "Member 'UTedGameCreationPlayersSlot::CurrentAvatar' has a wrong offset!");
static_assert(offsetof(UTedGameCreationPlayersSlot, Image_Ready) == 0x000498, "Member 'UTedGameCreationPlayersSlot::Image_Ready' has a wrong offset!");
static_assert(offsetof(UTedGameCreationPlayersSlot, Image_LobbyLeader) == 0x0004A0, "Member 'UTedGameCreationPlayersSlot::Image_LobbyLeader' has a wrong offset!");
static_assert(offsetof(UTedGameCreationPlayersSlot, Image_BotIndicator) == 0x0004A8, "Member 'UTedGameCreationPlayersSlot::Image_BotIndicator' has a wrong offset!");

// Class Tempest.TedJukeboxTrackAsset
// 0x0028 (0x0058 - 0x0030)
class UTedJukeboxTrackAsset final : public UPrimaryDataAsset
{
public:
	class FText                                   TrackTitle;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   TrackAuthor;                                       // 0x0040(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class USoundBase*                             SoundTrackObject;                                  // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedJukeboxTrackAsset">();
	}
	static class UTedJukeboxTrackAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedJukeboxTrackAsset>();
	}
};
static_assert(alignof(UTedJukeboxTrackAsset) == 0x000008, "Wrong alignment on UTedJukeboxTrackAsset");
static_assert(sizeof(UTedJukeboxTrackAsset) == 0x000058, "Wrong size on UTedJukeboxTrackAsset");
static_assert(offsetof(UTedJukeboxTrackAsset, TrackTitle) == 0x000030, "Member 'UTedJukeboxTrackAsset::TrackTitle' has a wrong offset!");
static_assert(offsetof(UTedJukeboxTrackAsset, TrackAuthor) == 0x000040, "Member 'UTedJukeboxTrackAsset::TrackAuthor' has a wrong offset!");
static_assert(offsetof(UTedJukeboxTrackAsset, SoundTrackObject) == 0x000050, "Member 'UTedJukeboxTrackAsset::SoundTrackObject' has a wrong offset!");

// Class Tempest.TedGameCreationSessionMemberContext
// 0x0010 (0x0038 - 0x0028)
class UTedGameCreationSessionMemberContext final : public UObject
{
public:
	class FString                                 HydraId;                                           // 0x0028(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGameCreationSessionMemberContext">();
	}
	static class UTedGameCreationSessionMemberContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedGameCreationSessionMemberContext>();
	}
};
static_assert(alignof(UTedGameCreationSessionMemberContext) == 0x000008, "Wrong alignment on UTedGameCreationSessionMemberContext");
static_assert(sizeof(UTedGameCreationSessionMemberContext) == 0x000038, "Wrong size on UTedGameCreationSessionMemberContext");
static_assert(offsetof(UTedGameCreationSessionMemberContext, HydraId) == 0x000028, "Member 'UTedGameCreationSessionMemberContext::HydraId' has a wrong offset!");

// Class Tempest.TedMovieSequencePlayerWidget
// 0x0018 (0x0418 - 0x0400)
class UTedMovieSequencePlayerWidget final : public UTedUserWidget
{
public:
	struct FGameplayTag                           SequenceTag;                                       // 0x0400(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedMoviePlayerDisplay*                 MovieDisplay;                                      // 0x0408(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATedMovieSequencePlayerActor*           CurrentSequencePlayer;                             // 0x0410(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class ATedMovieSequencePlayerActor* FindSequencePlayerActor() const;
	TArray<class ATedMovieSequencePlayerActor*> FindSequencePlayerActors() const;
	class ATedMovieSequencePlayerActor* GetCurrentSequencePlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMovieSequencePlayerWidget">();
	}
	static class UTedMovieSequencePlayerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMovieSequencePlayerWidget>();
	}
};
static_assert(alignof(UTedMovieSequencePlayerWidget) == 0x000008, "Wrong alignment on UTedMovieSequencePlayerWidget");
static_assert(sizeof(UTedMovieSequencePlayerWidget) == 0x000418, "Wrong size on UTedMovieSequencePlayerWidget");
static_assert(offsetof(UTedMovieSequencePlayerWidget, SequenceTag) == 0x000400, "Member 'UTedMovieSequencePlayerWidget::SequenceTag' has a wrong offset!");
static_assert(offsetof(UTedMovieSequencePlayerWidget, MovieDisplay) == 0x000408, "Member 'UTedMovieSequencePlayerWidget::MovieDisplay' has a wrong offset!");
static_assert(offsetof(UTedMovieSequencePlayerWidget, CurrentSequencePlayer) == 0x000410, "Member 'UTedMovieSequencePlayerWidget::CurrentSequencePlayer' has a wrong offset!");

// Class Tempest.TedGameMode_CC
// 0x0000 (0x03C0 - 0x03C0)
class ATedGameMode_CC final : public ATedGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGameMode_CC">();
	}
	static class ATedGameMode_CC* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedGameMode_CC>();
	}
};
static_assert(alignof(ATedGameMode_CC) == 0x000008, "Wrong alignment on ATedGameMode_CC");
static_assert(sizeof(ATedGameMode_CC) == 0x0003C0, "Wrong size on ATedGameMode_CC");

// Class Tempest.TedGameMode_MainMenu
// 0x0000 (0x03C0 - 0x03C0)
class ATedGameMode_MainMenu final : public ATedGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGameMode_MainMenu">();
	}
	static class ATedGameMode_MainMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedGameMode_MainMenu>();
	}
};
static_assert(alignof(ATedGameMode_MainMenu) == 0x000008, "Wrong alignment on ATedGameMode_MainMenu");
static_assert(sizeof(ATedGameMode_MainMenu) == 0x0003C0, "Wrong size on ATedGameMode_MainMenu");

// Class Tempest.TedNavArea_NoAirUnits
// 0x0000 (0x0048 - 0x0048)
class UTedNavArea_NoAirUnits final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedNavArea_NoAirUnits">();
	}
	static class UTedNavArea_NoAirUnits* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedNavArea_NoAirUnits>();
	}
};
static_assert(alignof(UTedNavArea_NoAirUnits) == 0x000008, "Wrong alignment on UTedNavArea_NoAirUnits");
static_assert(sizeof(UTedNavArea_NoAirUnits) == 0x000048, "Wrong size on UTedNavArea_NoAirUnits");

// Class Tempest.TedGameMode_MP_DestroyPawns
// 0x0048 (0x0490 - 0x0448)
class ATedGameMode_MP_DestroyPawns final : public ATedGameMode_MP
{
public:
	ETedTelemetryMatchType                        TelemetryMatchType;                                // 0x0448(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_449[0x7];                                      // 0x0449(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  RequiredPawns;                                     // 0x0450(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  IgnoredPawns;                                      // 0x0470(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGameMode_MP_DestroyPawns">();
	}
	static class ATedGameMode_MP_DestroyPawns* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedGameMode_MP_DestroyPawns>();
	}
};
static_assert(alignof(ATedGameMode_MP_DestroyPawns) == 0x000008, "Wrong alignment on ATedGameMode_MP_DestroyPawns");
static_assert(sizeof(ATedGameMode_MP_DestroyPawns) == 0x000490, "Wrong size on ATedGameMode_MP_DestroyPawns");
static_assert(offsetof(ATedGameMode_MP_DestroyPawns, TelemetryMatchType) == 0x000448, "Member 'ATedGameMode_MP_DestroyPawns::TelemetryMatchType' has a wrong offset!");
static_assert(offsetof(ATedGameMode_MP_DestroyPawns, RequiredPawns) == 0x000450, "Member 'ATedGameMode_MP_DestroyPawns::RequiredPawns' has a wrong offset!");
static_assert(offsetof(ATedGameMode_MP_DestroyPawns, IgnoredPawns) == 0x000470, "Member 'ATedGameMode_MP_DestroyPawns::IgnoredPawns' has a wrong offset!");

// Class Tempest.TedGameplayCueInterface
// 0x0000 (0x0000 - 0x0000)
class ITedGameplayCueInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGameplayCueInterface">();
	}
	static class ITedGameplayCueInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITedGameplayCueInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITedGameplayCueInterface) == 0x000001, "Wrong alignment on ITedGameplayCueInterface");
static_assert(sizeof(ITedGameplayCueInterface) == 0x000001, "Wrong size on ITedGameplayCueInterface");

// Class Tempest.TedNavArea_Obstacle_Refinery
// 0x0000 (0x0048 - 0x0048)
class UTedNavArea_Obstacle_Refinery final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedNavArea_Obstacle_Refinery">();
	}
	static class UTedNavArea_Obstacle_Refinery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedNavArea_Obstacle_Refinery>();
	}
};
static_assert(alignof(UTedNavArea_Obstacle_Refinery) == 0x000008, "Wrong alignment on UTedNavArea_Obstacle_Refinery");
static_assert(sizeof(UTedNavArea_Obstacle_Refinery) == 0x000048, "Wrong size on UTedNavArea_Obstacle_Refinery");

// Class Tempest.TedGameplayCueNotify_HitBurst
// 0x0058 (0x0098 - 0x0040)
class UTedGameplayCueNotify_HitBurst : public UGameplayCueNotify_Static
{
public:
	bool                                          bSpawnEffectOnTheGround;                           // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GroundLocationZOffset;                             // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             Sound;                                             // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAlwaysPlaySound;                                  // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGCueParticleConfig>            FXAssetConfigs;                                    // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DecalMaterial;                                     // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecalSize;                                         // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecalFadeOutStartDelay;                            // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecalFadeOutDuration;                              // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecalFadeInDuration;                               // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShakeBase>           CameraShakeClass;                                  // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraShakeInnerRadius;                            // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraShakeOuterRadius;                            // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraShakeFalloff;                                // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOrientShakeTowardsEpicenter;                      // 0x0094(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<struct FGCueParticleConfig> K2_GetFXAssetConfigs(const class AActor* TargetActor, const struct FGameplayCueParameters& GCueParams) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGameplayCueNotify_HitBurst">();
	}
	static class UTedGameplayCueNotify_HitBurst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedGameplayCueNotify_HitBurst>();
	}
};
static_assert(alignof(UTedGameplayCueNotify_HitBurst) == 0x000008, "Wrong alignment on UTedGameplayCueNotify_HitBurst");
static_assert(sizeof(UTedGameplayCueNotify_HitBurst) == 0x000098, "Wrong size on UTedGameplayCueNotify_HitBurst");
static_assert(offsetof(UTedGameplayCueNotify_HitBurst, bSpawnEffectOnTheGround) == 0x000040, "Member 'UTedGameplayCueNotify_HitBurst::bSpawnEffectOnTheGround' has a wrong offset!");
static_assert(offsetof(UTedGameplayCueNotify_HitBurst, GroundLocationZOffset) == 0x000044, "Member 'UTedGameplayCueNotify_HitBurst::GroundLocationZOffset' has a wrong offset!");
static_assert(offsetof(UTedGameplayCueNotify_HitBurst, Sound) == 0x000048, "Member 'UTedGameplayCueNotify_HitBurst::Sound' has a wrong offset!");
static_assert(offsetof(UTedGameplayCueNotify_HitBurst, bAlwaysPlaySound) == 0x000050, "Member 'UTedGameplayCueNotify_HitBurst::bAlwaysPlaySound' has a wrong offset!");
static_assert(offsetof(UTedGameplayCueNotify_HitBurst, FXAssetConfigs) == 0x000058, "Member 'UTedGameplayCueNotify_HitBurst::FXAssetConfigs' has a wrong offset!");
static_assert(offsetof(UTedGameplayCueNotify_HitBurst, DecalMaterial) == 0x000068, "Member 'UTedGameplayCueNotify_HitBurst::DecalMaterial' has a wrong offset!");
static_assert(offsetof(UTedGameplayCueNotify_HitBurst, DecalSize) == 0x000070, "Member 'UTedGameplayCueNotify_HitBurst::DecalSize' has a wrong offset!");
static_assert(offsetof(UTedGameplayCueNotify_HitBurst, DecalFadeOutStartDelay) == 0x000074, "Member 'UTedGameplayCueNotify_HitBurst::DecalFadeOutStartDelay' has a wrong offset!");
static_assert(offsetof(UTedGameplayCueNotify_HitBurst, DecalFadeOutDuration) == 0x000078, "Member 'UTedGameplayCueNotify_HitBurst::DecalFadeOutDuration' has a wrong offset!");
static_assert(offsetof(UTedGameplayCueNotify_HitBurst, DecalFadeInDuration) == 0x00007C, "Member 'UTedGameplayCueNotify_HitBurst::DecalFadeInDuration' has a wrong offset!");
static_assert(offsetof(UTedGameplayCueNotify_HitBurst, CameraShakeClass) == 0x000080, "Member 'UTedGameplayCueNotify_HitBurst::CameraShakeClass' has a wrong offset!");
static_assert(offsetof(UTedGameplayCueNotify_HitBurst, CameraShakeInnerRadius) == 0x000088, "Member 'UTedGameplayCueNotify_HitBurst::CameraShakeInnerRadius' has a wrong offset!");
static_assert(offsetof(UTedGameplayCueNotify_HitBurst, CameraShakeOuterRadius) == 0x00008C, "Member 'UTedGameplayCueNotify_HitBurst::CameraShakeOuterRadius' has a wrong offset!");
static_assert(offsetof(UTedGameplayCueNotify_HitBurst, CameraShakeFalloff) == 0x000090, "Member 'UTedGameplayCueNotify_HitBurst::CameraShakeFalloff' has a wrong offset!");
static_assert(offsetof(UTedGameplayCueNotify_HitBurst, bOrientShakeTowardsEpicenter) == 0x000094, "Member 'UTedGameplayCueNotify_HitBurst::bOrientShakeTowardsEpicenter' has a wrong offset!");

// Class Tempest.TedNavFilterCondition
// 0x0008 (0x0030 - 0x0028)
class UTedNavFilterCondition : public UObject
{
public:
	ETedNavFilterCondition                        Condition;                                         // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedNavFilterCondition">();
	}
	static class UTedNavFilterCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedNavFilterCondition>();
	}
};
static_assert(alignof(UTedNavFilterCondition) == 0x000008, "Wrong alignment on UTedNavFilterCondition");
static_assert(sizeof(UTedNavFilterCondition) == 0x000030, "Wrong size on UTedNavFilterCondition");
static_assert(offsetof(UTedNavFilterCondition, Condition) == 0x000028, "Member 'UTedNavFilterCondition::Condition' has a wrong offset!");

// Class Tempest.TedGameplayCueTranslator
// 0x0000 (0x0028 - 0x0028)
class UTedGameplayCueTranslator final : public UGameplayCueTranslator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGameplayCueTranslator">();
	}
	static class UTedGameplayCueTranslator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedGameplayCueTranslator>();
	}
};
static_assert(alignof(UTedGameplayCueTranslator) == 0x000008, "Wrong alignment on UTedGameplayCueTranslator");
static_assert(sizeof(UTedGameplayCueTranslator) == 0x000028, "Wrong size on UTedGameplayCueTranslator");

// Class Tempest.TedGameProgressSubsystem
// 0x00B0 (0x00E0 - 0x0030)
class UTedGameProgressSubsystem final : public UGameInstanceSubsystem
{
public:
	TArray<struct FTedCampaignProgress>           Campaigns;                                         // 0x0030(0x0010)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	struct FTedCampaignTimestamp                  CampaignTimestamp;                                 // 0x0040(0x0010)(SaveGame, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UTedMapInfo*                            CompletedMap;                                      // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSyncedWithProfile;                                // 0x0058(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSimulatingGameProgress;                         // 0x0059(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedSimulatedGameProgress*              SimulatedProgressAsset;                            // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x78];                                      // 0x0068(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGameProgressSubsystem">();
	}
	static class UTedGameProgressSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedGameProgressSubsystem>();
	}
};
static_assert(alignof(UTedGameProgressSubsystem) == 0x000008, "Wrong alignment on UTedGameProgressSubsystem");
static_assert(sizeof(UTedGameProgressSubsystem) == 0x0000E0, "Wrong size on UTedGameProgressSubsystem");
static_assert(offsetof(UTedGameProgressSubsystem, Campaigns) == 0x000030, "Member 'UTedGameProgressSubsystem::Campaigns' has a wrong offset!");
static_assert(offsetof(UTedGameProgressSubsystem, CampaignTimestamp) == 0x000040, "Member 'UTedGameProgressSubsystem::CampaignTimestamp' has a wrong offset!");
static_assert(offsetof(UTedGameProgressSubsystem, CompletedMap) == 0x000050, "Member 'UTedGameProgressSubsystem::CompletedMap' has a wrong offset!");
static_assert(offsetof(UTedGameProgressSubsystem, bSyncedWithProfile) == 0x000058, "Member 'UTedGameProgressSubsystem::bSyncedWithProfile' has a wrong offset!");
static_assert(offsetof(UTedGameProgressSubsystem, bIsSimulatingGameProgress) == 0x000059, "Member 'UTedGameProgressSubsystem::bIsSimulatingGameProgress' has a wrong offset!");
static_assert(offsetof(UTedGameProgressSubsystem, SimulatedProgressAsset) == 0x000060, "Member 'UTedGameProgressSubsystem::SimulatedProgressAsset' has a wrong offset!");

// Class Tempest.TedOnlineLeaderboardManager
// 0x01C8 (0x01F8 - 0x0030)
class UTedOnlineLeaderboardManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x118];                                     // 0x0030(0x0118)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class FString>            ProsLeaderboardIdMappingStaging;                   // 0x0148(0x0050)(Config, NativeAccessSpecifierPrivate)
	TMap<class FString, class FString>            ProsLeaderboardIdMappingProduction;                // 0x0198(0x0050)(Config, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E8[0x10];                                     // 0x01E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static int32 GetCurrentSeason(const class UObject* WorldContextObject);
	static int32 RoundRating(const float& InRating);

	void OnDownloadGameConfigurationComplete(int32 LocalUserNum, const TArray<struct FLayerData>& Layers, EProsdkErrorCodeGameConfiguration ResultCode);

	void OnServerLeaderboardsUpdateAfterMatch(EProsdkErrorCodeLeaderboards ErrorCode) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedOnlineLeaderboardManager">();
	}
	static class UTedOnlineLeaderboardManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedOnlineLeaderboardManager>();
	}
};
static_assert(alignof(UTedOnlineLeaderboardManager) == 0x000008, "Wrong alignment on UTedOnlineLeaderboardManager");
static_assert(sizeof(UTedOnlineLeaderboardManager) == 0x0001F8, "Wrong size on UTedOnlineLeaderboardManager");
static_assert(offsetof(UTedOnlineLeaderboardManager, ProsLeaderboardIdMappingStaging) == 0x000148, "Member 'UTedOnlineLeaderboardManager::ProsLeaderboardIdMappingStaging' has a wrong offset!");
static_assert(offsetof(UTedOnlineLeaderboardManager, ProsLeaderboardIdMappingProduction) == 0x000198, "Member 'UTedOnlineLeaderboardManager::ProsLeaderboardIdMappingProduction' has a wrong offset!");

// Class Tempest.TedGameState
// 0x00B0 (0x03B8 - 0x0308)
class ATedGameState final : public AGameState
{
public:
	uint8                                         Pad_308[0x30];                                     // 0x0308(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedCustomAttitudes                    CustomAttitudes;                                   // 0x0338(0x0010)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         bAllowAttitudeBasedColors : 1;                     // 0x0348(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_349[0x3];                                      // 0x0349(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ServerFPS;                                         // 0x034C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         GameDifficulty;                                    // 0x0350(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BotDifficulty;                                     // 0x0354(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(const TArray<class APlayerState*>& AllPlayers)> OnAllPlayersStarted; // 0x0358(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         matchTimer;                                        // 0x0368(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36C[0xC];                                      // 0x036C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	ETedTeamID                                    WinnerTeam;                                        // 0x0378(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_379[0x7];                                      // 0x0379(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTedPlayerMatchPresence>        PlayerMatchPresence;                               // 0x0380(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTedPlayerDataStatContainer>    PlayerStats;                                       // 0x0390(0x0010)(Net, ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTedPlayerDataStatChartContainer> PlayerCharts;                                    // 0x03A0(0x0010)(Net, ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           ChartUpdaterTimerHandle;                           // 0x03B0(0x0008)(Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void IncrementMatchTimer();
	void MultiCast_FireProjectile(TSubclassOf<class ATedProjectile> InProjectileClass, class AActor* InOwner, TSubclassOf<class UTedDamageType> DamageType, const struct FRadialDamageParams& RadialDamageParams, TSubclassOf<class UGameplayEffect> EffectToApplyOnDamage, bool bDealFullDamageToTarget, const struct FVector2D& TargetLocation, class ATedPawn* TargetPawn, const struct FTedUtilsPawnFilter& PawnFilter, const struct FGameplayTag& TrackedSupportPowerTag);

	void Client_R_OnDisconnect(const class ATedPlayerState* PlayerDisconnected) const;
	void Client_R_OnLogin(const class ATedPlayerState* PlayerLoggedIn) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGameState">();
	}
	static class ATedGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedGameState>();
	}
};
static_assert(alignof(ATedGameState) == 0x000008, "Wrong alignment on ATedGameState");
static_assert(sizeof(ATedGameState) == 0x0003B8, "Wrong size on ATedGameState");
static_assert(offsetof(ATedGameState, CustomAttitudes) == 0x000338, "Member 'ATedGameState::CustomAttitudes' has a wrong offset!");
static_assert(offsetof(ATedGameState, ServerFPS) == 0x00034C, "Member 'ATedGameState::ServerFPS' has a wrong offset!");
static_assert(offsetof(ATedGameState, GameDifficulty) == 0x000350, "Member 'ATedGameState::GameDifficulty' has a wrong offset!");
static_assert(offsetof(ATedGameState, BotDifficulty) == 0x000354, "Member 'ATedGameState::BotDifficulty' has a wrong offset!");
static_assert(offsetof(ATedGameState, OnAllPlayersStarted) == 0x000358, "Member 'ATedGameState::OnAllPlayersStarted' has a wrong offset!");
static_assert(offsetof(ATedGameState, matchTimer) == 0x000368, "Member 'ATedGameState::matchTimer' has a wrong offset!");
static_assert(offsetof(ATedGameState, WinnerTeam) == 0x000378, "Member 'ATedGameState::WinnerTeam' has a wrong offset!");
static_assert(offsetof(ATedGameState, PlayerMatchPresence) == 0x000380, "Member 'ATedGameState::PlayerMatchPresence' has a wrong offset!");
static_assert(offsetof(ATedGameState, PlayerStats) == 0x000390, "Member 'ATedGameState::PlayerStats' has a wrong offset!");
static_assert(offsetof(ATedGameState, PlayerCharts) == 0x0003A0, "Member 'ATedGameState::PlayerCharts' has a wrong offset!");
static_assert(offsetof(ATedGameState, ChartUpdaterTimerHandle) == 0x0003B0, "Member 'ATedGameState::ChartUpdaterTimerHandle' has a wrong offset!");

// Class Tempest.TedOnlineQrCodeManager
// 0x0020 (0x0050 - 0x0030)
class UTedOnlineQrCodeManager final : public UGameInstanceSubsystem
{
public:
	TMulticastInlineDelegate<void(const struct FProsQrCodeState& QrCodeState)> OnGetQrCodeCompleteDelegate; // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetQrCode();

	void GetQrCodeRequestCompleted(const struct FProsAccountServiceStatus& InStatus) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedOnlineQrCodeManager">();
	}
	static class UTedOnlineQrCodeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedOnlineQrCodeManager>();
	}
};
static_assert(alignof(UTedOnlineQrCodeManager) == 0x000008, "Wrong alignment on UTedOnlineQrCodeManager");
static_assert(sizeof(UTedOnlineQrCodeManager) == 0x000050, "Wrong size on UTedOnlineQrCodeManager");
static_assert(offsetof(UTedOnlineQrCodeManager, OnGetQrCodeCompleteDelegate) == 0x000030, "Member 'UTedOnlineQrCodeManager::OnGetQrCodeCompleteDelegate' has a wrong offset!");

// Class Tempest.TedGameViewportClient
// 0x0040 (0x03F0 - 0x03B0)
class UTedGameViewportClient final : public UGameViewportClient
{
public:
	uint8                                         Pad_3B0[0x38];                                     // 0x03B0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            WatermarkOpacityCurve;                             // 0x03E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGameViewportClient">();
	}
	static class UTedGameViewportClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedGameViewportClient>();
	}
};
static_assert(alignof(UTedGameViewportClient) == 0x000008, "Wrong alignment on UTedGameViewportClient");
static_assert(sizeof(UTedGameViewportClient) == 0x0003F0, "Wrong size on UTedGameViewportClient");
static_assert(offsetof(UTedGameViewportClient, WatermarkOpacityCurve) == 0x0003E8, "Member 'UTedGameViewportClient::WatermarkOpacityCurve' has a wrong offset!");

// Class Tempest.ClientConnectionMonitor
// 0x0030 (0x0058 - 0x0028)
class UClientConnectionMonitor final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UNetDriver>              NetDriverPtr;                                      // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientConnectionMonitor">();
	}
	static class UClientConnectionMonitor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClientConnectionMonitor>();
	}
};
static_assert(alignof(UClientConnectionMonitor) == 0x000008, "Wrong alignment on UClientConnectionMonitor");
static_assert(sizeof(UClientConnectionMonitor) == 0x000058, "Wrong size on UClientConnectionMonitor");
static_assert(offsetof(UClientConnectionMonitor, NetDriverPtr) == 0x000030, "Member 'UClientConnectionMonitor::NetDriverPtr' has a wrong offset!");

// Class Tempest.TedGenericDataFunctions
// 0x0000 (0x0028 - 0x0028)
class UTedGenericDataFunctions final : public UBlueprintFunctionLibrary
{
public:
	static bool GetGenericValue_Enum(const struct FGameplayTag& Key, const struct FTedGenericDataContainer& Data, const class UEnum* EnumType, uint8* Value);
	static bool GetGenericValue_Float(const struct FGameplayTag& Key, const struct FTedGenericDataContainer& Data, float* Value);
	static bool GetGenericValue_Int32(const struct FGameplayTag& Key, const struct FTedGenericDataContainer& Data, int32* Value);
	static bool GetGenericValue_Object(const struct FGameplayTag& Key, const struct FTedGenericDataContainer& Data, const TSubclassOf<class UObject> OutputType, class UObject** Value);
	static bool GetGenericValue_SlateBrush(const struct FGameplayTag& Key, const struct FTedGenericDataContainer& Data, struct FSlateBrush* Value);
	static bool GetGenericValue_Text(const struct FGameplayTag& Key, const struct FTedGenericDataContainer& Data, class FText* Value);
	static bool RemoveGenericValue(const struct FGameplayTag& Key, struct FTedGenericDataContainer& Data);
	static bool SetGenericValue_Enum(const struct FGameplayTag& Key, const class UEnum* EnumType, const uint8 Value, struct FTedGenericDataContainer& Data);
	static bool SetGenericValue_Float(const struct FGameplayTag& Key, const float Value, struct FTedGenericDataContainer& Data);
	static bool SetGenericValue_Int32(const struct FGameplayTag& Key, const int32 Value, struct FTedGenericDataContainer& Data);
	static bool SetGenericValue_Object(const struct FGameplayTag& Key, const class UObject* Value, struct FTedGenericDataContainer& Data);
	static bool SetGenericValue_SlateBrush(const struct FGameplayTag& Key, const struct FSlateBrush& Value, struct FTedGenericDataContainer& Data);
	static bool SetGenericValue_Text(const struct FGameplayTag& Key, const class FText& Value, struct FTedGenericDataContainer& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGenericDataFunctions">();
	}
	static class UTedGenericDataFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedGenericDataFunctions>();
	}
};
static_assert(alignof(UTedGenericDataFunctions) == 0x000008, "Wrong alignment on UTedGenericDataFunctions");
static_assert(sizeof(UTedGenericDataFunctions) == 0x000028, "Wrong size on UTedGenericDataFunctions");

// Class Tempest.TedGhostStructure
// 0x00F0 (0x17C0 - 0x16D0)
class ATedGhostStructure final : public ATedGhostPawn
{
public:
	TArray<class UStaticMeshComponent*>           EndCapComponents;                                  // 0x16D0(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   GateMesh;                                          // 0x16E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, InstancedReference, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       GateMIDs;                                          // 0x16E8(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       EndCapMIDs;                                        // 0x16F8(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TArray<class UBoxComponent*>                  HitBoxes;                                          // 0x1708(0x0010)(ExportObject, ZeroConstructor, Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UBoxComponent*                          NavModifier;                                       // 0x1718(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1720[0xA0];                                    // 0x1720(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGhostStructure">();
	}
	static class ATedGhostStructure* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedGhostStructure>();
	}
};
static_assert(alignof(ATedGhostStructure) == 0x000010, "Wrong alignment on ATedGhostStructure");
static_assert(sizeof(ATedGhostStructure) == 0x0017C0, "Wrong size on ATedGhostStructure");
static_assert(offsetof(ATedGhostStructure, EndCapComponents) == 0x0016D0, "Member 'ATedGhostStructure::EndCapComponents' has a wrong offset!");
static_assert(offsetof(ATedGhostStructure, GateMesh) == 0x0016E0, "Member 'ATedGhostStructure::GateMesh' has a wrong offset!");
static_assert(offsetof(ATedGhostStructure, GateMIDs) == 0x0016E8, "Member 'ATedGhostStructure::GateMIDs' has a wrong offset!");
static_assert(offsetof(ATedGhostStructure, EndCapMIDs) == 0x0016F8, "Member 'ATedGhostStructure::EndCapMIDs' has a wrong offset!");
static_assert(offsetof(ATedGhostStructure, HitBoxes) == 0x001708, "Member 'ATedGhostStructure::HitBoxes' has a wrong offset!");
static_assert(offsetof(ATedGhostStructure, NavModifier) == 0x001718, "Member 'ATedGhostStructure::NavModifier' has a wrong offset!");

// Class Tempest.TedOnlineSessionsControllerWidget
// 0x00B0 (0x0508 - 0x0458)
class UTedOnlineSessionsControllerWidget final : public UTedMenuScreenWidget
{
public:
	ETedServerType                                ServerType;                                        // 0x0458(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_459[0x3];                                      // 0x0459(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxPasswordLength;                                 // 0x045C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxLobbyNameLength;                                // 0x0460(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_464[0x4];                                      // 0x0464(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedMapInfo*                            MapInfoCached;                                     // 0x0468(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 LobbyNameCached;                                   // 0x0470(0x0010)(ZeroConstructor, Transient, DuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 PasswordCached;                                    // 0x0480(0x0010)(ZeroConstructor, Transient, DuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ATedLobbyBeaconClient*                  ClientBeacon;                                      // 0x04A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATedLobbyBeaconState*                   LobbyState;                                        // 0x04A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B0[0x1];                                      // 0x04B0(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bUseNewQueueOverlayFeatureFlag : 1;                // 0x04B1(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_4B2[0x6];                                      // 0x04B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedOnlineSessionsPanel*                LobbyBrowser_Lobbies;                              // 0x04B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedMapInfo*                            DefaultLobbyMap;                                   // 0x04C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedGameCreationSettingsWidget*         LobbyBrowser_SelectedLobbySettings;                // 0x04C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedGameCreationPlayersPanel*           LobbyBrowser_SelectedLobbyPlayers;                 // 0x04D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bFillSelectedLobbyPlayersWithEmptyPlayers : 1;     // 0x04D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_4D9[0x7];                                      // 0x04D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedGenericDataContentPanel*            LobbyStartGameIssues;                              // 0x04E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedGameCreationSettingsWidget*         LobbySettings;                                     // 0x04E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedGameCreationPlayersPanel*           LobbyPlayers;                                      // 0x04F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedGameCreationPlayersPanel*           LobbySpectators;                                   // 0x04F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedLobbyConfigurationPopup*            Popup_LobbyConfiguration;                          // 0x0500(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool AreDataCentersAvailable();
	bool CloseServer();
	void CreateLobby();
	bool CreateServer(const class UTedMapInfo* InMapInfo, const class FString& LobbyName, const class FString& Password);
	void EditLobby();
	bool FindRankedSession();
	const struct FMultiplayerScreenSavedData GetMultiplayerMenusData();
	bool JoinRankedSession(const class FString& InURL, const int32 InGamePort);
	bool JoinRemoteSession(const class FString& ServerPassword);
	bool JoinSession(const class FString& ServerPassword);
	void K2_UpdateLobbyBrowserSelectedLobbyInfo(const class UTedOnlineSessionsSlot* InSelectedLobbySlot);
	bool LogIn();
	bool MatchmakingSearch();
	bool MatchmakingSearchCancel();
	void OnActivateLobbyListSlotState(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotState InState, bool bInActivated);
	void OnAdminStatusChange();
	void OnFindRankedSessionFinished(const bool bInWasSuccess, const class FString& InURL, const int32 InGamePort);
	void OnFindRankedSessionStarted();
	void OnHidePopUpWhenLobbyFromParty();
	void OnJoinGameStarted();
	void OnJoinLocalSessionStarted();
	void OnJoinRankedSessionFinished(class ATedLobbyBeaconClient* InClientBeacon, const class FName& InSessionName, const bool bInWasSuccess, const class FText& InFailText);
	void OnJoinRankedSessionStarted();
	void OnJoinRemoteSessionStarted();
	void OnJoinSessionFinished(class ATedLobbyBeaconClient* InClientBeacon, const class FName& InSessionName, const bool bInWasSuccess, const class FText& InFailText);
	void OnJoinSessionStarted();
	void OnLobbyMapChanged(const class UTedMapInfo* InMapInfo);
	void OnLobbyPlayerAdded(class ALobbyBeaconPlayerState* InPlayerState);
	void OnLobbyPlayerRemoved(class ALobbyBeaconPlayerState* InPlayerState);
	void OnLobbySettingsChange();
	void OnLogInFinished(const bool bInWasSuccess);
	void OnLogInStarted();
	void OnMatchmakingSearchCancelFinished(const bool bInWasSuccess);
	void OnMatchmakingSearchCancelStarted();
	void OnMatchmakingSearchFinished(const bool bInWasSuccess);
	void OnMatchmakingSearchStarted();
	void OnPlayerAmountChanged(int32 NewPlayerNum);
	void OnReadLeaderboardsFinished(const bool bInWasSuccess);
	void OnReadLeaderboardsStarted();
	void OnRefreshingSessionsFinished(const bool bInWasSuccess, const class FText& InFailText);
	void OnRefreshingSessionsStarted();
	void OnRequestAddBotPlayer(class UTedGameCreationPlayersPanel* InPlayersPanel);
	void OnRequestKickLobbyPlayer(class UTedGameCreationPlayersPanel* InPlayersPanel, const int32 InSlotIndex);
	void OnRequestLobbyPlayerSettingChange(class UTedGameCreationPlayersPanel* InPlayersPanel, const int32 InContentSlotIndex, const ETedSessionMemberSettingKey InKey, const int32 InNewValue, const int32 InOldValue);
	void OnServerCreationFinished(const bool bInWasSuccess, const class FText& InFailText);
	void OnServerCreationStarted();
	void OnServerTypeChanged(const ETedServerType InPrevServerType);
	void OnStartGameFailed(const class FText& InText);
	void OnUpdateRankedMemberAndSessionSettingsFinished(const bool bInWasSuccess);
	void OnWaitForRankedPlayersFinished(const bool bInWasSuccess);
	void OnWaitForRankedPlayersStarted();
	bool ReadLeaderboards();
	void RefreshReadyVisuals();
	bool RefreshSessions();
	void SaveMultiplayerMenusData(const struct FMultiplayerScreenSavedData& NewData);
	void SetCurrentLobbyName(const class FText& InLobbyName);
	void SetLobbyBrowserLobbies(class UTedOnlineSessionsPanel* InWidget);
	void SetLobbyBrowserSelectedLobbyPlayers(class UTedGameCreationPlayersPanel* InWidget);
	void SetLobbyBrowserSelectedLobbySettings(class UTedGameCreationSettingsWidget* InWidget);
	void SetRankedFactionType(const ETedRankedFaction InFaction);
	void SetRankedTeamType(const ETedRankedTeam InTeam);
	void SetReadyState(const bool bInReady);
	void SetServerType(const ETedServerType InType, bool bForce);
	bool StartGame();
	void UpdateLobbyBrowserSelectedLobbyInfo();
	void UpdateRankedMemberAndSessionSettings();
	void WaitForRankedPlayers();

	bool CanEditLobby() const;
	bool CanEverCreateServer() const;
	bool CanStartGame() const;
	class ATedLobbyBeaconClient* GetClientBeacon() const;
	const class UTedMapInfo* GetLobbySelectedMap() const;
	const class UTedOnlineSessionsSlot* GetSelectedLobbySlot() const;
	ETedServerType GetServerType() const;
	bool IsInSession() const;
	bool IsLoggedIn() const;
	bool IsMatchmakingSearchInProgress() const;
	bool IsReady() const;
	bool IsSpectator() const;
	bool WereRankedMapsSaved() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedOnlineSessionsControllerWidget">();
	}
	static class UTedOnlineSessionsControllerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedOnlineSessionsControllerWidget>();
	}
};
static_assert(alignof(UTedOnlineSessionsControllerWidget) == 0x000008, "Wrong alignment on UTedOnlineSessionsControllerWidget");
static_assert(sizeof(UTedOnlineSessionsControllerWidget) == 0x000508, "Wrong size on UTedOnlineSessionsControllerWidget");
static_assert(offsetof(UTedOnlineSessionsControllerWidget, ServerType) == 0x000458, "Member 'UTedOnlineSessionsControllerWidget::ServerType' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionsControllerWidget, MaxPasswordLength) == 0x00045C, "Member 'UTedOnlineSessionsControllerWidget::MaxPasswordLength' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionsControllerWidget, MaxLobbyNameLength) == 0x000460, "Member 'UTedOnlineSessionsControllerWidget::MaxLobbyNameLength' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionsControllerWidget, MapInfoCached) == 0x000468, "Member 'UTedOnlineSessionsControllerWidget::MapInfoCached' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionsControllerWidget, LobbyNameCached) == 0x000470, "Member 'UTedOnlineSessionsControllerWidget::LobbyNameCached' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionsControllerWidget, PasswordCached) == 0x000480, "Member 'UTedOnlineSessionsControllerWidget::PasswordCached' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionsControllerWidget, ClientBeacon) == 0x0004A0, "Member 'UTedOnlineSessionsControllerWidget::ClientBeacon' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionsControllerWidget, LobbyState) == 0x0004A8, "Member 'UTedOnlineSessionsControllerWidget::LobbyState' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionsControllerWidget, LobbyBrowser_Lobbies) == 0x0004B8, "Member 'UTedOnlineSessionsControllerWidget::LobbyBrowser_Lobbies' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionsControllerWidget, DefaultLobbyMap) == 0x0004C0, "Member 'UTedOnlineSessionsControllerWidget::DefaultLobbyMap' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionsControllerWidget, LobbyBrowser_SelectedLobbySettings) == 0x0004C8, "Member 'UTedOnlineSessionsControllerWidget::LobbyBrowser_SelectedLobbySettings' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionsControllerWidget, LobbyBrowser_SelectedLobbyPlayers) == 0x0004D0, "Member 'UTedOnlineSessionsControllerWidget::LobbyBrowser_SelectedLobbyPlayers' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionsControllerWidget, LobbyStartGameIssues) == 0x0004E0, "Member 'UTedOnlineSessionsControllerWidget::LobbyStartGameIssues' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionsControllerWidget, LobbySettings) == 0x0004E8, "Member 'UTedOnlineSessionsControllerWidget::LobbySettings' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionsControllerWidget, LobbyPlayers) == 0x0004F0, "Member 'UTedOnlineSessionsControllerWidget::LobbyPlayers' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionsControllerWidget, LobbySpectators) == 0x0004F8, "Member 'UTedOnlineSessionsControllerWidget::LobbySpectators' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionsControllerWidget, Popup_LobbyConfiguration) == 0x000500, "Member 'UTedOnlineSessionsControllerWidget::Popup_LobbyConfiguration' has a wrong offset!");

// Class Tempest.TedGlobalTags
// 0x0000 (0x0028 - 0x0028)
class UTedGlobalTags final : public UBlueprintFunctionLibrary
{
public:
	static const struct FGameplayTag Ability();
	static const struct FGameplayTag Ability_Attack();
	static const struct FGameplayTag Ability_Attack_Looping();
	static const struct FGameplayTag Ability_Blocked();
	static const struct FGameplayTag Ability_CaptureStructure();
	static const struct FGameplayTag Ability_Death();
	static const struct FGameplayTag Ability_DeployStructure();
	static const struct FGameplayTag Ability_DepositResource();
	static const struct FGameplayTag Ability_DismantleStructure();
	static const struct FGameplayTag Ability_Enqueue();
	static const struct FGameplayTag Ability_Plan();
	static const struct FGameplayTag Ability_Ranged();
	static const struct FGameplayTag Ability_SpawnUnit();
	static const struct FGameplayTag Ability_SpawnUnit_Enlightened();
	static const struct FGameplayTag Ability_Stealth();
	static const struct FGameplayTag Ability_Stealth_Blocked();
	static const struct FGameplayTag Ability_Teleport();
	static const struct FGameplayTag AbilityActivationFailure_BlockedTag();
	static const struct FGameplayTag AbilityActivationFailure_Cooldown();
	static const struct FGameplayTag AbilityActivationFailure_Cost();
	static const struct FGameplayTag AbilityActivationFailure_MissingTag();
	static const struct FGameplayTag Aircraft();
	static const struct FGameplayTag AnimMontage_Attack();
	static const struct FGameplayTag AnimMontage_Attack_Crawling();
	static const struct FGameplayTag AnimMontage_Attack_Standing();
	static const struct FGameplayTag AnimMontage_Death();
	static const struct FGameplayTag AnimMontage_Death_Crawling();
	static const struct FGameplayTag AnimMontage_Death_Standing();
	static const struct FGameplayTag AnimMontage_OpenDoor();
	static const struct FGameplayTag Announcement_UnderAttack();
	static const struct FGameplayTag Behavior_Command();
	static const struct FGameplayTag Behavior_Idle();
	static const struct FGameplayTag Command_Autocast();
	static const struct FGameplayTag CommandType_Attack();
	static const struct FGameplayTag CommandType_AttackGround();
	static const struct FGameplayTag CommandType_AutoHarvest();
	static const struct FGameplayTag CommandType_CaptureStructure();
	static const struct FGameplayTag CommandType_Deconstruct();
	static const struct FGameplayTag CommandType_DeployStructure();
	static const struct FGameplayTag CommandType_DisarmMine();
	static const struct FGameplayTag CommandType_EnterContainer();
	static const struct FGameplayTag CommandType_Escort();
	static const struct FGameplayTag CommandType_Follow();
	static const struct FGameplayTag CommandType_GuardLocation();
	static const struct FGameplayTag CommandType_Harvest();
	static const struct FGameplayTag CommandType_HoldPosition();
	static const struct FGameplayTag CommandType_Move();
	static const struct FGameplayTag CommandType_Patrol();
	static const struct FGameplayTag CommandType_Repair();
	static const struct FGameplayTag CommandType_SetRallyPoint();
	static const struct FGameplayTag CommandType_Stop();
	static const struct FGameplayTag CommandType_SubjugationSpawn();
	static const struct FGameplayTag CommandType_SupportPower();
	static const struct FGameplayTag CommandType_UnloadContainer();
	static const struct FGameplayTag Definition_Mutable_TempestCharge();
	static const struct FGameplayTag Destructible();
	static const struct FGameplayTag Domain_Air();
	static const struct FGameplayTag Domain_Ground();
	static const struct FGameplayTag DYN_Harvester();
	static const struct FGameplayTag DYN_Structure_AirFactory();
	static const struct FGameplayTag DYN_Structure_Airpad();
	static const struct FGameplayTag DYN_Structure_Barracks();
	static const struct FGameplayTag DYN_Structure_ConcreteWall();
	static const struct FGameplayTag DYN_Structure_ConstructionYard();
	static const struct FGameplayTag DYN_Structure_PowerPlant();
	static const struct FGameplayTag DYN_Structure_Radar();
	static const struct FGameplayTag Error_BlockedGroundTargeting();
	static const struct FGameplayTag Error_DeadTarget();
	static const struct FGameplayTag Error_InvalidAttitude();
	static const struct FGameplayTag Error_InvalidOwner();
	static const struct FGameplayTag Error_InvalidPowerState();
	static const struct FGameplayTag Error_InvalidTag();
	static const struct FGameplayTag Error_InvalidTarget();
	static const struct FGameplayTag Error_InvalidTargetDomain();
	static const struct FGameplayTag Error_InvalidTargetLocation();
	static const struct FGameplayTag Error_InvisibleTarget();
	static const struct FGameplayTag Error_MissingGameplayTagAssetInterface();
	static const struct FGameplayTag Error_MissingPrerequisites();
	static const struct FGameplayTag Error_NotInRange();
	static const struct FGameplayTag Error_RequiredAirTarget();
	static const struct FGameplayTag Error_RequiredGroundTarget();
	static const struct FGameplayTag Error_UnitCantMove();
	static const struct FGameplayTag Error_WeaponNotFound();
	static const struct FGameplayTag Error_WeaponRequirementsNotMet();
	static const struct FGameplayTag Event();
	static const struct FGameplayTag Event_DealDamage();
	static const struct FGameplayTag Event_DeployParachute();
	static const struct FGameplayTag Event_DeployPawn();
	static const struct FGameplayTag Event_ShootProjectile();
	static const struct FGameplayTag Event_SpawnPawn();
	static const struct FGameplayTag GameplayCue();
	static const struct FGameplayTag GameplayCue_RepFull();
	static const struct FGameplayTag GameplayCue_RepMinimal();
	static const struct FGameplayTag GDF_Harvester();
	static const struct FGameplayTag GDF_Structure_AdvancedPowerPlant();
	static const struct FGameplayTag GDF_Structure_Airfield();
	static const struct FGameplayTag GDF_Structure_Airpad();
	static const struct FGameplayTag GDF_Structure_Barracks();
	static const struct FGameplayTag GDF_Structure_ConcreteWall();
	static const struct FGameplayTag GDF_Structure_ConstructionYard();
	static const struct FGameplayTag GDF_Structure_Fence();
	static const struct FGameplayTag GDF_Structure_PowerPlant();
	static const struct FGameplayTag GDF_Structure_SatelliteUplink();
	static const struct FGameplayTag GroundTargetingBlocked();
	static const struct FGameplayTag Infantry();
	static const struct FGameplayTag Infantry_Heavy();
	static const struct FGameplayTag InputSettings_Error_ConflictingMapping();
	static const struct FGameplayTag InputSettings_Error_RestrictedMapping();
	static const struct FGameplayTag Mine();
	static const struct FGameplayTag NEU_AnyPawn();
	static const struct FGameplayTag PlayerData_AllowInsufficientPower();
	static const struct FGameplayTag PlayerData_AllowPlayerCommands();
	static const struct FGameplayTag PlayerData_AllowPowerDown();
	static const struct FGameplayTag PlayerData_BuildOnlyInFactoryRadius();
	static const struct FGameplayTag PlayerData_InsufficientPowerSlowDown();
	static const struct FGameplayTag PlayerData_LowPowerImmune();
	static const struct FGameplayTag PlayerData_NoConstruction();
	static const struct FGameplayTag PlayerData_NoGarrison();
	static const struct FGameplayTag PlayerData_NoSell();
	static const struct FGameplayTag PlayerData_NotCapturable();
	static const struct FGameplayTag PlayerData_PowerDown();
	static const struct FGameplayTag PlayerData_SimultaneousConstruction();
	static const struct FGameplayTag PlayerData_Worker();
	static const struct FGameplayTag Status_AIInvisible();
	static const struct FGameplayTag Status_Awakening1();
	static const struct FGameplayTag Status_Awakening2();
	static const struct FGameplayTag Status_Awakening3();
	static const struct FGameplayTag Status_Mutable();
	static const struct FGameplayTag Status_Mutable_Alive();
	static const struct FGameplayTag Status_Mutable_AttackBlocked();
	static const struct FGameplayTag Status_Mutable_Autoharvesting();
	static const struct FGameplayTag Status_Mutable_Commandeered();
	static const struct FGameplayTag Status_Mutable_Disarmed();
	static const struct FGameplayTag Status_Mutable_DisarmingMine();
	static const struct FGameplayTag Status_Mutable_DistributionMode();
	static const struct FGameplayTag Status_Mutable_DistributionMode_Source();
	static const struct FGameplayTag Status_Mutable_EnlightenedSacrifice();
	static const struct FGameplayTag Status_Mutable_ForceUserPowerDown();
	static const struct FGameplayTag Status_Mutable_HarvesterIdle();
	static const struct FGameplayTag Status_Mutable_Immobilized();
	static const struct FGameplayTag Status_Mutable_Marked();
	static const struct FGameplayTag Status_Mutable_Moving();
	static const struct FGameplayTag Status_Mutable_Overridden();
	static const struct FGameplayTag Status_Mutable_PowerDown();
	static const struct FGameplayTag Status_Mutable_ResearchingUpgrade();
	static const struct FGameplayTag Status_Mutable_RiotSuppression();
	static const struct FGameplayTag Status_Mutable_Stealth();
	static const struct FGameplayTag Status_Mutable_Subjugated();
	static const struct FGameplayTag Status_Mutable_Suppressed();
	static const struct FGameplayTag Status_Mutable_TempestCharge();
	static const struct FGameplayTag Status_RecentlyDamaged();
	static const struct FGameplayTag Status_TempestChargeBlocked();
	static const struct FGameplayTag Status_Uncrushable();
	static const struct FGameplayTag Structure();
	static const struct FGameplayTag Structure_Airfield();
	static const struct FGameplayTag Structure_Conformation();
	static const struct FGameplayTag Structure_Conformation_Bridge();
	static const struct FGameplayTagContainer Structure_ConstructionYard_Any();
	static const struct FGameplayTag Structure_Defensive();
	static const struct FGameplayTagContainer Structure_Gate_Any();
	static const struct FGameplayTagContainer Structure_Radar_Any();
	static const struct FGameplayTagContainer Structure_Sandbags_Any();
	static const struct FGameplayTag Structure_Tower();
	static const struct FGameplayTag Structure_Wall();
	static const struct FGameplayTagContainer Structure_Wall_Any();
	static const struct FGameplayTag UI_Anim_Hide();
	static const struct FGameplayTag UI_Anim_Objective_Completed();
	static const struct FGameplayTag UI_Anim_Objective_Failed();
	static const struct FGameplayTag UI_Anim_Objective_New();
	static const struct FGameplayTag UI_Anim_Objective_Updated();
	static const struct FGameplayTag UI_Anim_Show();
	static const struct FGameplayTag UI_Anim_StartupSequence();
	static const struct FGameplayTag UI_Event();
	static const struct FGameplayTag UI_Event_CC_FramedMovie_Play();
	static const struct FGameplayTag UI_Event_CC_FramedMovie_Stop();
	static const struct FGameplayTag UI_Event_ChatParty_AdjustForScoreScreen();
	static const struct FGameplayTag UI_Event_HudPopup_Hide();
	static const struct FGameplayTag UI_Event_HudPopup_Show();
	static const struct FGameplayTag UI_Event_HudPopup_ShowSide();
	static const struct FGameplayTag UI_HidingContext_HidingHUD();
	static const struct FGameplayTag UI_HidingContext_PlayingMovie();
	static const struct FGameplayTag UI_HidingContext_Spectator();
	static const struct FGameplayTag UI_HidingContext_Spectator_Ally();
	static const struct FGameplayTag UI_HidingContext_Spectator_Match();
	static const struct FGameplayTag UI_Marker_Context_Primary();
	static const struct FGameplayTag UI_Marker_Context_Primary_DYN();
	static const struct FGameplayTag UI_Marker_Context_Primary_GDF();
	static const struct FGameplayTag UI_Marker_Context_Secondary();
	static const struct FGameplayTag UI_MenuScreen_CampaignSelection();
	static const struct FGameplayTag UI_MenuScreen_CommandCompound();
	static const struct FGameplayTag UI_MenuScreen_EndGame();
	static const struct FGameplayTag UI_MenuScreen_FactionSelection();
	static const struct FGameplayTag UI_MenuScreen_GameMenu();
	static const struct FGameplayTag UI_MenuScreen_MainMenu();
	static const struct FGameplayTag UI_MenuScreen_MapScreen();
	static const struct FGameplayTag UI_MenuScreen_MedalsScreen_MP();
	static const struct FGameplayTag UI_MenuScreen_MedalsScreen_SP();
	static const struct FGameplayTag UI_MenuScreen_ScoreScreen();
	static const struct FGameplayTag UI_MovieSequence_ConnectionLost();
	static const struct FGameplayTag UI_SkippableSequence_CC_Briefing();
	static const struct FGameplayTag UI_SkippableSequence_CC_MapScreen();
	static const struct FGameplayTag UI_SkippableSequence_Movie();
	static const struct FGameplayTag Unit();
	static const struct FGameplayTagContainer Unit_MCV_Any();
	static const struct FGameplayTag Vehicle();
	static const struct FGameplayTag Vehicle_Heavy();
	static const struct FGameplayTag VETI_Structure_TempestHeart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGlobalTags">();
	}
	static class UTedGlobalTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedGlobalTags>();
	}
};
static_assert(alignof(UTedGlobalTags) == 0x000008, "Wrong alignment on UTedGlobalTags");
static_assert(sizeof(UTedGlobalTags) == 0x000028, "Wrong size on UTedGlobalTags");

// Class Tempest.TedGlowWidget
// 0x0010 (0x0410 - 0x0400)
class UTedGlowWidget : public UTedUserWidget
{
public:
	class URetainerBox*                           RetainerBox;                                       // 0x0400(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     GlowMaterial;                                      // 0x0408(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetGlowMaterial(class UMaterialInterface* InMaterial);

	class UMaterialInstanceDynamic* GetGlowMaterial() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGlowWidget">();
	}
	static class UTedGlowWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedGlowWidget>();
	}
};
static_assert(alignof(UTedGlowWidget) == 0x000008, "Wrong alignment on UTedGlowWidget");
static_assert(sizeof(UTedGlowWidget) == 0x000410, "Wrong size on UTedGlowWidget");
static_assert(offsetof(UTedGlowWidget, RetainerBox) == 0x000400, "Member 'UTedGlowWidget::RetainerBox' has a wrong offset!");
static_assert(offsetof(UTedGlowWidget, GlowMaterial) == 0x000408, "Member 'UTedGlowWidget::GlowMaterial' has a wrong offset!");

// Class Tempest.TedTempestVinesBase
// 0x0040 (0x03D0 - 0x0390)
class ATedTempestVinesBase : public ATedGridAreaVolume
{
public:
	uint8                                         Pad_390[0x40];                                     // 0x0390(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedTempestVinesBase">();
	}
	static class ATedTempestVinesBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedTempestVinesBase>();
	}
};
static_assert(alignof(ATedTempestVinesBase) == 0x000008, "Wrong alignment on ATedTempestVinesBase");
static_assert(sizeof(ATedTempestVinesBase) == 0x0003D0, "Wrong size on ATedTempestVinesBase");

// Class Tempest.TedNoBuildVolume
// 0x0260 (0x0630 - 0x03D0)
class ATedNoBuildVolume final : public ATedTempestVinesBase
{
public:
	uint8                                         Pad_3D0[0x8];                                      // 0x03D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPendingBeginPlayNavigationUpdate;                 // 0x03D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D9[0x7];                                      // 0x03D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ATedPawn*, struct FTempestFieldOverlappedPawnGEData> OverlappedPawnGEData;            // 0x03E0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bDebugFieldGrid;                                   // 0x0430(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_431[0x3];                                      // 0x0431(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RandomSeed;                                        // 0x0434(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RootLocation;                                      // 0x0438(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTempestFieldConfigAsset> FieldConfigAsset;                                 // 0x0450(0x0028)(Edit, DisableEditOnTemplate, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedNoBuildVolumeStage                        StartStage;                                        // 0x0478(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_479[0x7];                                      // 0x0479(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTempestFieldConfigAsset*               FieldConfig;                                       // 0x0480(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_488[0x68];                                     // 0x0488(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFieldTileData>                 FieldTileData;                                     // 0x04F0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FTempestFieldRepStage                  RepFieldTileStage;                                 // 0x0500(0x0020)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FTempestFieldRepVisibility             RepFieldTilesVisibility;                           // 0x0520(0x0020)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_540[0x8];                                      // 0x0540(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFieldTileElement>              FieldTileElements;                                 // 0x0548(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UTempestFieldElementProxy*>      FieldProxies;                                      // 0x0558(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UInstancedStaticMeshComponent*>  FieldISMCs;                                        // 0x0568(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class USceneComponent*, float>           PendingDestroyFieldElementComponents;              // 0x0578(0x0050)(Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSet<class UPrimitiveComponent*>              PendingRenderStateDirtyElementComponents;          // 0x05C8(0x0050)(ExportObject, Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_618[0x8];                                      // 0x0618(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ASquareNavGrid*                         PlacementGrid;                                     // 0x0620(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_628[0x8];                                      // 0x0628(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_RepFieldTileStage();
	void OnRep_RepFieldTilesVisibility();
	void SetDestStage(ETedNoBuildVolumeStage InStage, bool bInstantChange);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedNoBuildVolume">();
	}
	static class ATedNoBuildVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedNoBuildVolume>();
	}
};
static_assert(alignof(ATedNoBuildVolume) == 0x000008, "Wrong alignment on ATedNoBuildVolume");
static_assert(sizeof(ATedNoBuildVolume) == 0x000630, "Wrong size on ATedNoBuildVolume");
static_assert(offsetof(ATedNoBuildVolume, bPendingBeginPlayNavigationUpdate) == 0x0003D8, "Member 'ATedNoBuildVolume::bPendingBeginPlayNavigationUpdate' has a wrong offset!");
static_assert(offsetof(ATedNoBuildVolume, OverlappedPawnGEData) == 0x0003E0, "Member 'ATedNoBuildVolume::OverlappedPawnGEData' has a wrong offset!");
static_assert(offsetof(ATedNoBuildVolume, bDebugFieldGrid) == 0x000430, "Member 'ATedNoBuildVolume::bDebugFieldGrid' has a wrong offset!");
static_assert(offsetof(ATedNoBuildVolume, RandomSeed) == 0x000434, "Member 'ATedNoBuildVolume::RandomSeed' has a wrong offset!");
static_assert(offsetof(ATedNoBuildVolume, RootLocation) == 0x000438, "Member 'ATedNoBuildVolume::RootLocation' has a wrong offset!");
static_assert(offsetof(ATedNoBuildVolume, FieldConfigAsset) == 0x000450, "Member 'ATedNoBuildVolume::FieldConfigAsset' has a wrong offset!");
static_assert(offsetof(ATedNoBuildVolume, StartStage) == 0x000478, "Member 'ATedNoBuildVolume::StartStage' has a wrong offset!");
static_assert(offsetof(ATedNoBuildVolume, FieldConfig) == 0x000480, "Member 'ATedNoBuildVolume::FieldConfig' has a wrong offset!");
static_assert(offsetof(ATedNoBuildVolume, FieldTileData) == 0x0004F0, "Member 'ATedNoBuildVolume::FieldTileData' has a wrong offset!");
static_assert(offsetof(ATedNoBuildVolume, RepFieldTileStage) == 0x000500, "Member 'ATedNoBuildVolume::RepFieldTileStage' has a wrong offset!");
static_assert(offsetof(ATedNoBuildVolume, RepFieldTilesVisibility) == 0x000520, "Member 'ATedNoBuildVolume::RepFieldTilesVisibility' has a wrong offset!");
static_assert(offsetof(ATedNoBuildVolume, FieldTileElements) == 0x000548, "Member 'ATedNoBuildVolume::FieldTileElements' has a wrong offset!");
static_assert(offsetof(ATedNoBuildVolume, FieldProxies) == 0x000558, "Member 'ATedNoBuildVolume::FieldProxies' has a wrong offset!");
static_assert(offsetof(ATedNoBuildVolume, FieldISMCs) == 0x000568, "Member 'ATedNoBuildVolume::FieldISMCs' has a wrong offset!");
static_assert(offsetof(ATedNoBuildVolume, PendingDestroyFieldElementComponents) == 0x000578, "Member 'ATedNoBuildVolume::PendingDestroyFieldElementComponents' has a wrong offset!");
static_assert(offsetof(ATedNoBuildVolume, PendingRenderStateDirtyElementComponents) == 0x0005C8, "Member 'ATedNoBuildVolume::PendingRenderStateDirtyElementComponents' has a wrong offset!");
static_assert(offsetof(ATedNoBuildVolume, PlacementGrid) == 0x000620, "Member 'ATedNoBuildVolume::PlacementGrid' has a wrong offset!");

// Class Tempest.TedGridOutlineComponent
// 0x0000 (0x0580 - 0x0580)
class UTedGridOutlineComponent final : public UGridOutlineComponent
{
public:
	float                                         HeightOffset;                                      // 0x0578(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_57C[0x4];                                      // 0x057C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedGridOutlineComponent">();
	}
	static class UTedGridOutlineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedGridOutlineComponent>();
	}
};
static_assert(alignof(UTedGridOutlineComponent) == 0x000010, "Wrong alignment on UTedGridOutlineComponent");
static_assert(sizeof(UTedGridOutlineComponent) == 0x000580, "Wrong size on UTedGridOutlineComponent");
static_assert(offsetof(UTedGridOutlineComponent, HeightOffset) == 0x000578, "Member 'UTedGridOutlineComponent::HeightOffset' has a wrong offset!");

// Class Tempest.TedHarvesterInterface
// 0x0000 (0x0000 - 0x0000)
class ITedHarvesterInterface final
{
public:
	float K2_GetCurrentResource() const;
	struct FHarvesterData K2_GetHarvesterData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedHarvesterInterface">();
	}
	static class ITedHarvesterInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITedHarvesterInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITedHarvesterInterface) == 0x000001, "Wrong alignment on ITedHarvesterInterface");
static_assert(sizeof(ITedHarvesterInterface) == 0x000001, "Wrong size on ITedHarvesterInterface");

// Class Tempest.TedObjectiveCondition_BlueprintBase
// 0x0000 (0x00E8 - 0x00E8)
class UTedObjectiveCondition_BlueprintBase : public UTedObjectiveConditionBase
{
public:
	void K2_SetConditionState(const EObjectiveConditionState InState);
	void OnActivate();
	void OnDeactivate();

	void OnDescribeForDebugger(class FString* OutString) const;
	void OnDescribeForUI(class FText* OutDisplayText) const;
	EObjectiveConditionState OnIsAlreadyMet() const;
	bool OnIsValidSetup(class FString* OutFailReason) const;
	bool OnSupportsNotMetState() const;
	bool OnSupportsRuntimeData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveCondition_BlueprintBase">();
	}
	static class UTedObjectiveCondition_BlueprintBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveCondition_BlueprintBase>();
	}
};
static_assert(alignof(UTedObjectiveCondition_BlueprintBase) == 0x000008, "Wrong alignment on UTedObjectiveCondition_BlueprintBase");
static_assert(sizeof(UTedObjectiveCondition_BlueprintBase) == 0x0000E8, "Wrong size on UTedObjectiveCondition_BlueprintBase");

// Class Tempest.TedHintsAsset
// 0x00E8 (0x0118 - 0x0030)
class UTedHintsAsset final : public UPrimaryDataAsset
{
public:
	class FText                                   HintWidgetTitle;                                   // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTedFormattedText                      HintWidgetDescription;                             // 0x0040(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   HintWorldText;                                     // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UObject*                                HintMedia;                                         // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UTedCommand>>        AbilitiesToHighlight;                              // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	EHintMarkedActorDestroyedBehaviour            MarkedActorDestroyedBehaviour;                     // 0x00C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxLifetime;                                       // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHintSpawnType                                HintSpawnType;                                     // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ActorTags;                                         // 0x00D8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AActor>>          ActorsToAttach;                                    // 0x00F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        WorldLocations;                                    // 0x0108(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedHintsAsset">();
	}
	static class UTedHintsAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedHintsAsset>();
	}
};
static_assert(alignof(UTedHintsAsset) == 0x000008, "Wrong alignment on UTedHintsAsset");
static_assert(sizeof(UTedHintsAsset) == 0x000118, "Wrong size on UTedHintsAsset");
static_assert(offsetof(UTedHintsAsset, HintWidgetTitle) == 0x000030, "Member 'UTedHintsAsset::HintWidgetTitle' has a wrong offset!");
static_assert(offsetof(UTedHintsAsset, HintWidgetDescription) == 0x000040, "Member 'UTedHintsAsset::HintWidgetDescription' has a wrong offset!");
static_assert(offsetof(UTedHintsAsset, HintWorldText) == 0x0000A0, "Member 'UTedHintsAsset::HintWorldText' has a wrong offset!");
static_assert(offsetof(UTedHintsAsset, HintMedia) == 0x0000B0, "Member 'UTedHintsAsset::HintMedia' has a wrong offset!");
static_assert(offsetof(UTedHintsAsset, AbilitiesToHighlight) == 0x0000B8, "Member 'UTedHintsAsset::AbilitiesToHighlight' has a wrong offset!");
static_assert(offsetof(UTedHintsAsset, MarkedActorDestroyedBehaviour) == 0x0000C8, "Member 'UTedHintsAsset::MarkedActorDestroyedBehaviour' has a wrong offset!");
static_assert(offsetof(UTedHintsAsset, MaxLifetime) == 0x0000CC, "Member 'UTedHintsAsset::MaxLifetime' has a wrong offset!");
static_assert(offsetof(UTedHintsAsset, HintSpawnType) == 0x0000D0, "Member 'UTedHintsAsset::HintSpawnType' has a wrong offset!");
static_assert(offsetof(UTedHintsAsset, ActorTags) == 0x0000D8, "Member 'UTedHintsAsset::ActorTags' has a wrong offset!");
static_assert(offsetof(UTedHintsAsset, ActorsToAttach) == 0x0000F8, "Member 'UTedHintsAsset::ActorsToAttach' has a wrong offset!");
static_assert(offsetof(UTedHintsAsset, WorldLocations) == 0x000108, "Member 'UTedHintsAsset::WorldLocations' has a wrong offset!");

// Class Tempest.TedHintsSubsystem
// 0x0080 (0x00B0 - 0x0030)
class UTedHintsSubsystem final : public UWorldSubsystem
{
public:
	TMulticastInlineDelegate<void(int32 TotalNewHints)> OnNewHintAdded;                              // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnHintHidden;                                      // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTedHintsAsset* HintToFocus)> OnHintUIFocusRequested;        // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class UTedHintsAsset*, struct FHintData> HintsArchive;                                      // 0x0060(0x0050)(NativeAccessSpecifierPrivate)

public:
	bool CanHintBeFocused(class UTedHintsAsset* Hint);
	void FocusHintOnUI(class UTedHintsAsset* HintToFocus);
	void HideHint(class UTedHintsAsset* HintToHide);
	void NotifyCommandButtonPressed(TSubclassOf<class UTedCommand> CommandUsed);
	void OnMarkeddActorRemoved(class UTedHintsAsset* Hint, class ATedWorldHintActor* WorldHintActor, class AActor* MarkedActor);
	void PlayHintSFX();
	void SetHintsEnabled(bool bInEnableHints);
	bool ShouldAbilityBeHighlighted(TSubclassOf<class UTedCommand> CommandToCheck);
	void TriggerNewHint(class UTedHintsAsset* NewHint);
	void TryFocusWorldHint(class UTedHintsAsset* HintToFocus);
	void TryMarkHintAsRead(class UTedHintsAsset* HintToMark);

	int32 GetNumOfActiveHints() const;
	int32 GetNumOfUnreadHints() const;
	TArray<class UTedHintsAsset*> GetShownHints() const;
	bool WasHintRead(class UTedHintsAsset* Hint) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedHintsSubsystem">();
	}
	static class UTedHintsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedHintsSubsystem>();
	}
};
static_assert(alignof(UTedHintsSubsystem) == 0x000008, "Wrong alignment on UTedHintsSubsystem");
static_assert(sizeof(UTedHintsSubsystem) == 0x0000B0, "Wrong size on UTedHintsSubsystem");
static_assert(offsetof(UTedHintsSubsystem, OnNewHintAdded) == 0x000030, "Member 'UTedHintsSubsystem::OnNewHintAdded' has a wrong offset!");
static_assert(offsetof(UTedHintsSubsystem, OnHintHidden) == 0x000040, "Member 'UTedHintsSubsystem::OnHintHidden' has a wrong offset!");
static_assert(offsetof(UTedHintsSubsystem, OnHintUIFocusRequested) == 0x000050, "Member 'UTedHintsSubsystem::OnHintUIFocusRequested' has a wrong offset!");
static_assert(offsetof(UTedHintsSubsystem, HintsArchive) == 0x000060, "Member 'UTedHintsSubsystem::HintsArchive' has a wrong offset!");

// Class Tempest.TedObjectiveCondition_DepleteRipenField
// 0x0030 (0x0118 - 0x00E8)
class UTedObjectiveCondition_DepleteRipenField final : public UTedObjectiveConditionBase
{
public:
	TSoftObjectPtr<class ATempestFieldVolume>     ResourceVolume;                                    // 0x00E8(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bExpectDepleted : 1;                               // 0x0110(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveCondition_DepleteRipenField">();
	}
	static class UTedObjectiveCondition_DepleteRipenField* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveCondition_DepleteRipenField>();
	}
};
static_assert(alignof(UTedObjectiveCondition_DepleteRipenField) == 0x000008, "Wrong alignment on UTedObjectiveCondition_DepleteRipenField");
static_assert(sizeof(UTedObjectiveCondition_DepleteRipenField) == 0x000118, "Wrong size on UTedObjectiveCondition_DepleteRipenField");
static_assert(offsetof(UTedObjectiveCondition_DepleteRipenField, ResourceVolume) == 0x0000E8, "Member 'UTedObjectiveCondition_DepleteRipenField::ResourceVolume' has a wrong offset!");

// Class Tempest.TedHotspotSubsystem
// 0x0080 (0x00B0 - 0x0030)
class UTedHotspotSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTedHotspot>                    Hotspots;                                          // 0x0048(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           TH_NotifyHotspotsChange;                           // 0x0058(0x0008)(Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FTedHotspotHandle, struct FTimerHandle> AutoDeleteTimerHandles;                      // 0x0060(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedHotspotSubsystem">();
	}
	static class UTedHotspotSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedHotspotSubsystem>();
	}
};
static_assert(alignof(UTedHotspotSubsystem) == 0x000008, "Wrong alignment on UTedHotspotSubsystem");
static_assert(sizeof(UTedHotspotSubsystem) == 0x0000B0, "Wrong size on UTedHotspotSubsystem");
static_assert(offsetof(UTedHotspotSubsystem, Hotspots) == 0x000048, "Member 'UTedHotspotSubsystem::Hotspots' has a wrong offset!");
static_assert(offsetof(UTedHotspotSubsystem, TH_NotifyHotspotsChange) == 0x000058, "Member 'UTedHotspotSubsystem::TH_NotifyHotspotsChange' has a wrong offset!");
static_assert(offsetof(UTedHotspotSubsystem, AutoDeleteTimerHandles) == 0x000060, "Member 'UTedHotspotSubsystem::AutoDeleteTimerHandles' has a wrong offset!");

// Class Tempest.TedHUD
// 0x09E0 (0x0D60 - 0x0380)
class ATedHUD : public AHUD
{
public:
	float                                         MinSelectionBoxSizeToShow;                         // 0x0380(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           SelectionBoxBorderColor;                           // 0x0384(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           SelectionBoxFillColor;                             // 0x0394(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SelectionBoxBorderThickness;                       // 0x03A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0x140];                                    // 0x03A8(0x0140)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ATedPawn*, float>                  SelectionCandidates;                               // 0x04E8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class ATedPawn*, struct FTedHitBox>      CachedHitBoxes;                                    // 0x0538(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_588[0x50];                                     // 0x0588(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  HidingContexts;                                    // 0x05D8(0x0020)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FStandaloneWidgetConfig>        StandaloneWidgetConfigs;                           // 0x05F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class UTedUserWidget*>                 StandaloneWidgets;                                 // 0x0608(0x0010)(ExportObject, ZeroConstructor, Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UTedUserWidget*>                 LooseStandaloneWidgets;                            // 0x0618(0x0010)(ExportObject, ZeroConstructor, Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UTedPopup*                              ActivePopupWidget;                                 // 0x0628(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class ATedHUD* InHUD, const struct FGameplayTag& InMenuScreen, const class UObject* InContext, const bool bInInstant)> OnOpenMenuScreen; // 0x0630(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_640[0x18];                                     // 0x0640(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ATedHUD* InHUD, const struct FGameplayTag& InMenuScreen, const class UObject* InContext, const bool bInInstant)> OnCloseMenuScreen; // 0x0658(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_668[0x18];                                     // 0x0668(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              UIAction_Enter;                                    // 0x0680(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FMenuScreenConfig> AvailableMenuScreens;                        // 0x0690(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSet<struct FGameplayTag>                     EnabledMenuScreens;                                // 0x06E0(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           CurrentMenuScreen;                                 // 0x0730(0x0008)(Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, class UTedMenuScreenWidget*> MenuScreens;                              // 0x0738(0x0050)(ExportObject, Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSet<class UTedUserWidget*>                   WidgetsUnderCursor;                                // 0x0788(0x0050)(ExportObject, Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class UClass*, class UTedTooltipWidget*> ExistingTooltips;                                  // 0x07D8(0x0050)(ExportObject, Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<ETedMovieType, class UTedMoviePlayerConfig*> MovieConfigs;                                  // 0x0828(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ETedMovieType, class UTedMoviePlayerController*> MovieControllers;                          // 0x0878(0x0050)(Edit, Transient, EditConst, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	struct FTedMoviePlayParams                    EndGameMovieParams;                                // 0x08C8(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_8E0[0x60];                                     // 0x08E0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           MPC;                                               // 0x0940(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MousePosXAlpha_Param;                              // 0x0948(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MousePosYAlpha_Param;                              // 0x0950(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   Theme_Param;                                       // 0x0958(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CinematicMode_Param;                               // 0x0960(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   GameTime_Param;                                    // 0x0968(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PreOrder_UseSelectionBox;                          // 0x0970(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PreOrder_UseSelectionShape;                        // 0x0978(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bCachePlayerColorsInMPC : 1;                       // 0x0980(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_981[0x7];                                      // 0x0981(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETedPlayerID, class FName>               PlayerColorParams;                                 // 0x0988(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ETedFaction, ERTSColor>                  DefaultFactionColors;                              // 0x09D8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ERTSAttitudeType, class FName>           SelectionColorParams;                              // 0x0A28(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UMaterialParameterCollectionInstance*   MPCInstance;                                       // 0x0A78(0x0008)(Edit, ZeroConstructor, Transient, EditConst, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bEnableStartupSequence : 1;                        // 0x0A80(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_A81[0x7];                                      // 0x0A81(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETedFaction, class UFileMediaSource*>    StartupMovies;                                     // 0x0A88(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTedMoviePlayParams                    StartupMovieParams;                                // 0x0AD8(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSet<class UTedUserWidget*>                   RunningStandaloneStartupWidgets;                   // 0x0AF0(0x0050)(ExportObject, Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         bSuppressedStartupSequence : 1;                    // 0x0B40(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bStartupSequenceMovieFinished : 1;                 // 0x0B40(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bStartupSequenceFinished : 1;                      // 0x0B40(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_B41[0x37];                                     // 0x0B41(0x0037)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTedSkippableSequence>          SkippableSequences;                                // 0x0B78(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B88[0xF8];                                     // 0x0B88(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	ETedFaction                                   Theme;                                             // 0x0C80(0x0001)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C81[0x3F];                                     // 0x0C81(0x003F)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnControlMappingsChange;                           // 0x0CC0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD0[0x20];                                     // 0x0CD0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UFont>                   PlayerLeftMPSessionNotificationFont;               // 0x0CF0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D18[0x18];                                     // 0x0D18(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UEffectsAnimationCurve*                 EffectsAnimationData;                              // 0x0D30(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USmartDataCollection*                   StatusCollection;                                  // 0x0D38(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedSpectatorMode                             ActiveSpectatorMode;                               // 0x0D40(0x0001)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D41[0x1F];                                     // 0x0D41(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ATedHUD* K2_GetLocalHUD(const class UObject* InWorldContext);

	void ClearActivePopupWidget();
	void HideTooltip(TSubclassOf<class UTedTooltipWidget> InClass, class UWidget* InTargetWidget);
	void OnStartupSequenceWidgetAnimationEnd(class UTedUserWidget* InWidget, const struct FGameplayTag& InAnim);
	void SetActivePopupWidget(class UTedPopup* InPopupWidget);
	void SetTheme(const ETedFaction InTheme);
	void ShowDebugForSelected();
	bool ShowEndGameScreen(const bool bWinner);
	void ShowTooltipFor(TSubclassOf<class UTedTooltipWidget> InClass, class UWidget* InWidget, const struct FTedTooltipDisplayParams& InDisplayParams);

	ETedSpectatorMode GetActiveSpectatorMode() const;
	TArray<class FName> GetMaterialCollectionParamNames_Scallars() const;
	TArray<class FName> GetMaterialCollectionParamNames_Vectors() const;
	class UTedMenuScreenWidget* GetMenuScreen(const struct FGameplayTag& InID) const;
	const TArray<class UTedUserWidget*> GetStandaloneWidgets() const;
	ETedFaction GetTheme() const;
	bool IsAnyWidgetUnderCursor() const;
	bool IsSpectatorModeActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedHUD">();
	}
	static class ATedHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedHUD>();
	}
};
static_assert(alignof(ATedHUD) == 0x000008, "Wrong alignment on ATedHUD");
static_assert(sizeof(ATedHUD) == 0x000D60, "Wrong size on ATedHUD");
static_assert(offsetof(ATedHUD, MinSelectionBoxSizeToShow) == 0x000380, "Member 'ATedHUD::MinSelectionBoxSizeToShow' has a wrong offset!");
static_assert(offsetof(ATedHUD, SelectionBoxBorderColor) == 0x000384, "Member 'ATedHUD::SelectionBoxBorderColor' has a wrong offset!");
static_assert(offsetof(ATedHUD, SelectionBoxFillColor) == 0x000394, "Member 'ATedHUD::SelectionBoxFillColor' has a wrong offset!");
static_assert(offsetof(ATedHUD, SelectionBoxBorderThickness) == 0x0003A4, "Member 'ATedHUD::SelectionBoxBorderThickness' has a wrong offset!");
static_assert(offsetof(ATedHUD, SelectionCandidates) == 0x0004E8, "Member 'ATedHUD::SelectionCandidates' has a wrong offset!");
static_assert(offsetof(ATedHUD, CachedHitBoxes) == 0x000538, "Member 'ATedHUD::CachedHitBoxes' has a wrong offset!");
static_assert(offsetof(ATedHUD, HidingContexts) == 0x0005D8, "Member 'ATedHUD::HidingContexts' has a wrong offset!");
static_assert(offsetof(ATedHUD, StandaloneWidgetConfigs) == 0x0005F8, "Member 'ATedHUD::StandaloneWidgetConfigs' has a wrong offset!");
static_assert(offsetof(ATedHUD, StandaloneWidgets) == 0x000608, "Member 'ATedHUD::StandaloneWidgets' has a wrong offset!");
static_assert(offsetof(ATedHUD, LooseStandaloneWidgets) == 0x000618, "Member 'ATedHUD::LooseStandaloneWidgets' has a wrong offset!");
static_assert(offsetof(ATedHUD, ActivePopupWidget) == 0x000628, "Member 'ATedHUD::ActivePopupWidget' has a wrong offset!");
static_assert(offsetof(ATedHUD, OnOpenMenuScreen) == 0x000630, "Member 'ATedHUD::OnOpenMenuScreen' has a wrong offset!");
static_assert(offsetof(ATedHUD, OnCloseMenuScreen) == 0x000658, "Member 'ATedHUD::OnCloseMenuScreen' has a wrong offset!");
static_assert(offsetof(ATedHUD, UIAction_Enter) == 0x000680, "Member 'ATedHUD::UIAction_Enter' has a wrong offset!");
static_assert(offsetof(ATedHUD, AvailableMenuScreens) == 0x000690, "Member 'ATedHUD::AvailableMenuScreens' has a wrong offset!");
static_assert(offsetof(ATedHUD, EnabledMenuScreens) == 0x0006E0, "Member 'ATedHUD::EnabledMenuScreens' has a wrong offset!");
static_assert(offsetof(ATedHUD, CurrentMenuScreen) == 0x000730, "Member 'ATedHUD::CurrentMenuScreen' has a wrong offset!");
static_assert(offsetof(ATedHUD, MenuScreens) == 0x000738, "Member 'ATedHUD::MenuScreens' has a wrong offset!");
static_assert(offsetof(ATedHUD, WidgetsUnderCursor) == 0x000788, "Member 'ATedHUD::WidgetsUnderCursor' has a wrong offset!");
static_assert(offsetof(ATedHUD, ExistingTooltips) == 0x0007D8, "Member 'ATedHUD::ExistingTooltips' has a wrong offset!");
static_assert(offsetof(ATedHUD, MovieConfigs) == 0x000828, "Member 'ATedHUD::MovieConfigs' has a wrong offset!");
static_assert(offsetof(ATedHUD, MovieControllers) == 0x000878, "Member 'ATedHUD::MovieControllers' has a wrong offset!");
static_assert(offsetof(ATedHUD, EndGameMovieParams) == 0x0008C8, "Member 'ATedHUD::EndGameMovieParams' has a wrong offset!");
static_assert(offsetof(ATedHUD, MPC) == 0x000940, "Member 'ATedHUD::MPC' has a wrong offset!");
static_assert(offsetof(ATedHUD, MousePosXAlpha_Param) == 0x000948, "Member 'ATedHUD::MousePosXAlpha_Param' has a wrong offset!");
static_assert(offsetof(ATedHUD, MousePosYAlpha_Param) == 0x000950, "Member 'ATedHUD::MousePosYAlpha_Param' has a wrong offset!");
static_assert(offsetof(ATedHUD, Theme_Param) == 0x000958, "Member 'ATedHUD::Theme_Param' has a wrong offset!");
static_assert(offsetof(ATedHUD, CinematicMode_Param) == 0x000960, "Member 'ATedHUD::CinematicMode_Param' has a wrong offset!");
static_assert(offsetof(ATedHUD, GameTime_Param) == 0x000968, "Member 'ATedHUD::GameTime_Param' has a wrong offset!");
static_assert(offsetof(ATedHUD, PreOrder_UseSelectionBox) == 0x000970, "Member 'ATedHUD::PreOrder_UseSelectionBox' has a wrong offset!");
static_assert(offsetof(ATedHUD, PreOrder_UseSelectionShape) == 0x000978, "Member 'ATedHUD::PreOrder_UseSelectionShape' has a wrong offset!");
static_assert(offsetof(ATedHUD, PlayerColorParams) == 0x000988, "Member 'ATedHUD::PlayerColorParams' has a wrong offset!");
static_assert(offsetof(ATedHUD, DefaultFactionColors) == 0x0009D8, "Member 'ATedHUD::DefaultFactionColors' has a wrong offset!");
static_assert(offsetof(ATedHUD, SelectionColorParams) == 0x000A28, "Member 'ATedHUD::SelectionColorParams' has a wrong offset!");
static_assert(offsetof(ATedHUD, MPCInstance) == 0x000A78, "Member 'ATedHUD::MPCInstance' has a wrong offset!");
static_assert(offsetof(ATedHUD, StartupMovies) == 0x000A88, "Member 'ATedHUD::StartupMovies' has a wrong offset!");
static_assert(offsetof(ATedHUD, StartupMovieParams) == 0x000AD8, "Member 'ATedHUD::StartupMovieParams' has a wrong offset!");
static_assert(offsetof(ATedHUD, RunningStandaloneStartupWidgets) == 0x000AF0, "Member 'ATedHUD::RunningStandaloneStartupWidgets' has a wrong offset!");
static_assert(offsetof(ATedHUD, SkippableSequences) == 0x000B78, "Member 'ATedHUD::SkippableSequences' has a wrong offset!");
static_assert(offsetof(ATedHUD, Theme) == 0x000C80, "Member 'ATedHUD::Theme' has a wrong offset!");
static_assert(offsetof(ATedHUD, OnControlMappingsChange) == 0x000CC0, "Member 'ATedHUD::OnControlMappingsChange' has a wrong offset!");
static_assert(offsetof(ATedHUD, PlayerLeftMPSessionNotificationFont) == 0x000CF0, "Member 'ATedHUD::PlayerLeftMPSessionNotificationFont' has a wrong offset!");
static_assert(offsetof(ATedHUD, EffectsAnimationData) == 0x000D30, "Member 'ATedHUD::EffectsAnimationData' has a wrong offset!");
static_assert(offsetof(ATedHUD, StatusCollection) == 0x000D38, "Member 'ATedHUD::StatusCollection' has a wrong offset!");
static_assert(offsetof(ATedHUD, ActiveSpectatorMode) == 0x000D40, "Member 'ATedHUD::ActiveSpectatorMode' has a wrong offset!");

// Class Tempest.TedUnitGarrisonProcessor
// 0x0000 (0x0038 - 0x0038)
class UTedUnitGarrisonProcessor final : public UTedHUDInstancedValueProcessor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitGarrisonProcessor">();
	}
	static class UTedUnitGarrisonProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUnitGarrisonProcessor>();
	}
};
static_assert(alignof(UTedUnitGarrisonProcessor) == 0x000008, "Wrong alignment on UTedUnitGarrisonProcessor");
static_assert(sizeof(UTedUnitGarrisonProcessor) == 0x000038, "Wrong size on UTedUnitGarrisonProcessor");

// Class Tempest.TedMenuScreenBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UTedMenuScreenBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool CanCloseMenuScreen(const class UObject* InWorldContextObject, const class UObject* InContext);
	static bool CanGoBackMenuScreen(const class UObject* InWorldContextObject);
	static bool CanOpenMenuScreen(const class UObject* InWorldContextObject, const struct FGameplayTag& InID, const class UObject* InContext);
	static bool CloseMenuScreen(const class UObject* InWorldContextObject, const class UObject* InContext, const bool bInInstant);
	static void GetOpenedMenuScreen(const class UObject* InWorldContextObject, struct FGameplayTag* OutMenuScreen);
	static void GoBackMenuScreen(const class UObject* InWorldContextObject);
	static bool IsAnyMenuScreenOpened(const class UObject* InWorldContextObject);
	static bool IsMenuScreenEnabled(const class UObject* InWorldContextObject, const struct FGameplayTag& InID);
	static bool IsMenuScreenOpened(const class UObject* InWorldContextObject, const struct FGameplayTag& InID);
	static bool OpenMenuScreen(const class UObject* InWorldContextObject, const struct FGameplayTag& InID, const class UObject* InContext, const bool bInInstant);
	static void SetMenuScreenEnabled(const class UObject* InWorldContextObject, const struct FGameplayTag& InID, const bool bInEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMenuScreenBlueprintLibrary">();
	}
	static class UTedMenuScreenBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMenuScreenBlueprintLibrary>();
	}
};
static_assert(alignof(UTedMenuScreenBlueprintLibrary) == 0x000008, "Wrong alignment on UTedMenuScreenBlueprintLibrary");
static_assert(sizeof(UTedMenuScreenBlueprintLibrary) == 0x000028, "Wrong size on UTedMenuScreenBlueprintLibrary");

// Class Tempest.TedDebuffProcessor
// 0x00A8 (0x00E0 - 0x0038)
class UTedDebuffProcessor final : public UTedHUDInstancedValueProcessor
{
public:
	int32                                         DefaultMaxCharges;                                 // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETedDebuffType, TSubclassOf<class UGameplayEffect>> GameplayEffect;                         // 0x0040(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<ETedDebuffType, int32>                   ChargeCache;                                       // 0x0090(0x0050)(Edit, Transient, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedDebuffProcessor">();
	}
	static class UTedDebuffProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedDebuffProcessor>();
	}
};
static_assert(alignof(UTedDebuffProcessor) == 0x000008, "Wrong alignment on UTedDebuffProcessor");
static_assert(sizeof(UTedDebuffProcessor) == 0x0000E0, "Wrong size on UTedDebuffProcessor");
static_assert(offsetof(UTedDebuffProcessor, DefaultMaxCharges) == 0x000038, "Member 'UTedDebuffProcessor::DefaultMaxCharges' has a wrong offset!");
static_assert(offsetof(UTedDebuffProcessor, GameplayEffect) == 0x000040, "Member 'UTedDebuffProcessor::GameplayEffect' has a wrong offset!");
static_assert(offsetof(UTedDebuffProcessor, ChargeCache) == 0x000090, "Member 'UTedDebuffProcessor::ChargeCache' has a wrong offset!");

// Class Tempest.TedDebuffAndVeterancyProcessor
// 0x0000 (0x0038 - 0x0038)
class UTedDebuffAndVeterancyProcessor final : public UTedHUDInstancedValueProcessor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedDebuffAndVeterancyProcessor">();
	}
	static class UTedDebuffAndVeterancyProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedDebuffAndVeterancyProcessor>();
	}
};
static_assert(alignof(UTedDebuffAndVeterancyProcessor) == 0x000008, "Wrong alignment on UTedDebuffAndVeterancyProcessor");
static_assert(sizeof(UTedDebuffAndVeterancyProcessor) == 0x000038, "Wrong size on UTedDebuffAndVeterancyProcessor");

// Class Tempest.TedMinefieldProxy
// 0x0030 (0x0058 - 0x0028)
class UTedMinefieldProxy : public UObject
{
public:
	struct FMinefieldData                         MinefieldData;                                     // 0x0028(0x0030)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMinefieldProxy">();
	}
	static class UTedMinefieldProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMinefieldProxy>();
	}
};
static_assert(alignof(UTedMinefieldProxy) == 0x000008, "Wrong alignment on UTedMinefieldProxy");
static_assert(sizeof(UTedMinefieldProxy) == 0x000058, "Wrong size on UTedMinefieldProxy");
static_assert(offsetof(UTedMinefieldProxy, MinefieldData) == 0x000028, "Member 'UTedMinefieldProxy::MinefieldData' has a wrong offset!");

// Class Tempest.TedImageSequencePlayer
// 0x0078 (0x0478 - 0x0400)
class UTedImageSequencePlayer final : public UTedUserWidget
{
public:
	TMulticastInlineDelegate<void(class UTedImageSequencePlayer* InPlayerWidget, const class UTedImageSequenceSource* InSequence)> OnPlay; // 0x0400(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTedImageSequencePlayer* InPlayerWidget, const class UTedImageSequenceSource* InSequence)> OnStop; // 0x0410(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         bSupportsSound : 1;                                // 0x0420(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_421[0x7];                                      // 0x0421(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedImageSequenceSource*                AutoPlaySequence;                                  // 0x0428(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_Player;                                      // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     PlayerMaterial;                                    // 0x0438(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PlayerMaterialTextureParam;                        // 0x0440(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               PlayerMID;                                         // 0x0448(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMediaPlayer*                           MediaPlayer;                                       // 0x0450(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMediaTexture*                          MediaTexture;                                      // 0x0458(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedImageSequenceSource*                PlayingSequence;                                   // 0x0460(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        SoundComponent;                                    // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           TH_OnSequenceEnd;                                  // 0x0470(0x0008)(Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnSequenceEnd();
	void OnSequenceOpened(const class FString& InOpenedUrl);
	bool Play(const class UTedImageSequenceSource* InSequence);
	void SetPlayerMaterial(class UMaterialInterface* InMaterial);
	void Stop();

	const class UTedImageSequenceSource* GetPlayingSequence() const;
	bool IsPlaying() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedImageSequencePlayer">();
	}
	static class UTedImageSequencePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedImageSequencePlayer>();
	}
};
static_assert(alignof(UTedImageSequencePlayer) == 0x000008, "Wrong alignment on UTedImageSequencePlayer");
static_assert(sizeof(UTedImageSequencePlayer) == 0x000478, "Wrong size on UTedImageSequencePlayer");
static_assert(offsetof(UTedImageSequencePlayer, OnPlay) == 0x000400, "Member 'UTedImageSequencePlayer::OnPlay' has a wrong offset!");
static_assert(offsetof(UTedImageSequencePlayer, OnStop) == 0x000410, "Member 'UTedImageSequencePlayer::OnStop' has a wrong offset!");
static_assert(offsetof(UTedImageSequencePlayer, AutoPlaySequence) == 0x000428, "Member 'UTedImageSequencePlayer::AutoPlaySequence' has a wrong offset!");
static_assert(offsetof(UTedImageSequencePlayer, Image_Player) == 0x000430, "Member 'UTedImageSequencePlayer::Image_Player' has a wrong offset!");
static_assert(offsetof(UTedImageSequencePlayer, PlayerMaterial) == 0x000438, "Member 'UTedImageSequencePlayer::PlayerMaterial' has a wrong offset!");
static_assert(offsetof(UTedImageSequencePlayer, PlayerMaterialTextureParam) == 0x000440, "Member 'UTedImageSequencePlayer::PlayerMaterialTextureParam' has a wrong offset!");
static_assert(offsetof(UTedImageSequencePlayer, PlayerMID) == 0x000448, "Member 'UTedImageSequencePlayer::PlayerMID' has a wrong offset!");
static_assert(offsetof(UTedImageSequencePlayer, MediaPlayer) == 0x000450, "Member 'UTedImageSequencePlayer::MediaPlayer' has a wrong offset!");
static_assert(offsetof(UTedImageSequencePlayer, MediaTexture) == 0x000458, "Member 'UTedImageSequencePlayer::MediaTexture' has a wrong offset!");
static_assert(offsetof(UTedImageSequencePlayer, PlayingSequence) == 0x000460, "Member 'UTedImageSequencePlayer::PlayingSequence' has a wrong offset!");
static_assert(offsetof(UTedImageSequencePlayer, SoundComponent) == 0x000468, "Member 'UTedImageSequencePlayer::SoundComponent' has a wrong offset!");
static_assert(offsetof(UTedImageSequencePlayer, TH_OnSequenceEnd) == 0x000470, "Member 'UTedImageSequencePlayer::TH_OnSequenceEnd' has a wrong offset!");

// Class Tempest.TedInfantry
// 0x0110 (0x1BC0 - 0x1AB0)
class ATedInfantry : public ATedUnitBase
{
public:
	uint8                                         bCanCrawl : 1;                                     // 0x1AB0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCrawlToShoot : 1;                                 // 0x1AB0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1AB1[0x7];                                     // 0x1AB1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            CrawlingGE;                                        // 0x1AB8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CrawlingRecoveryTime;                              // 0x1AC0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CrawlToAttackTargetDistanceMultiplier;             // 0x1AC4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  CrawlBlockingTags;                                 // 0x1AC8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  CrawlBlockingCommandTypes;                         // 0x1AE8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         CrawlHealthLimit;                                  // 0x1B08(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CrawlingTransitionTime;                            // 0x1B0C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForcedCrawl;                                      // 0x1B10(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B11[0x3];                                     // 0x1B11(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MatParam_BodyBlood;                                // 0x1B14(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B1C[0x4];                                     // 0x1B1C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDecalComponent*                        DeathSplatterDecalComp;                            // 0x1B20(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B28[0x1C];                                    // 0x1B28(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAdjustRotationToTerrainOnDeath;                   // 0x1B44(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B45[0x43];                                    // 0x1B45(0x0043)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInterface*>             DeathSplatterDecalMaterials;                       // 0x1B88(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class ATedUnitBase>               UnitClassToSpawnOnSubjugationDeath;                // 0x1B98(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayCueTag                        SubjugationDeathGameplayCueTag;                    // 0x1BA0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         SubjugationVisualsDelay;                           // 0x1BA8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SubjugationHideSkeletonDuration;                   // 0x1BAC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1BB0[0x8];                                     // 0x1BB0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bCrawling : 1;                                     // 0x1BB8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_1BB9[0x7];                                     // 0x1BB9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleSubjugationVisuals();

	bool CanCrawl() const;
	bool IsCrawling() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedInfantry">();
	}
	static class ATedInfantry* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedInfantry>();
	}
};
static_assert(alignof(ATedInfantry) == 0x000010, "Wrong alignment on ATedInfantry");
static_assert(sizeof(ATedInfantry) == 0x001BC0, "Wrong size on ATedInfantry");
static_assert(offsetof(ATedInfantry, CrawlingGE) == 0x001AB8, "Member 'ATedInfantry::CrawlingGE' has a wrong offset!");
static_assert(offsetof(ATedInfantry, CrawlingRecoveryTime) == 0x001AC0, "Member 'ATedInfantry::CrawlingRecoveryTime' has a wrong offset!");
static_assert(offsetof(ATedInfantry, CrawlToAttackTargetDistanceMultiplier) == 0x001AC4, "Member 'ATedInfantry::CrawlToAttackTargetDistanceMultiplier' has a wrong offset!");
static_assert(offsetof(ATedInfantry, CrawlBlockingTags) == 0x001AC8, "Member 'ATedInfantry::CrawlBlockingTags' has a wrong offset!");
static_assert(offsetof(ATedInfantry, CrawlBlockingCommandTypes) == 0x001AE8, "Member 'ATedInfantry::CrawlBlockingCommandTypes' has a wrong offset!");
static_assert(offsetof(ATedInfantry, CrawlHealthLimit) == 0x001B08, "Member 'ATedInfantry::CrawlHealthLimit' has a wrong offset!");
static_assert(offsetof(ATedInfantry, CrawlingTransitionTime) == 0x001B0C, "Member 'ATedInfantry::CrawlingTransitionTime' has a wrong offset!");
static_assert(offsetof(ATedInfantry, bForcedCrawl) == 0x001B10, "Member 'ATedInfantry::bForcedCrawl' has a wrong offset!");
static_assert(offsetof(ATedInfantry, MatParam_BodyBlood) == 0x001B14, "Member 'ATedInfantry::MatParam_BodyBlood' has a wrong offset!");
static_assert(offsetof(ATedInfantry, DeathSplatterDecalComp) == 0x001B20, "Member 'ATedInfantry::DeathSplatterDecalComp' has a wrong offset!");
static_assert(offsetof(ATedInfantry, bAdjustRotationToTerrainOnDeath) == 0x001B44, "Member 'ATedInfantry::bAdjustRotationToTerrainOnDeath' has a wrong offset!");
static_assert(offsetof(ATedInfantry, DeathSplatterDecalMaterials) == 0x001B88, "Member 'ATedInfantry::DeathSplatterDecalMaterials' has a wrong offset!");
static_assert(offsetof(ATedInfantry, UnitClassToSpawnOnSubjugationDeath) == 0x001B98, "Member 'ATedInfantry::UnitClassToSpawnOnSubjugationDeath' has a wrong offset!");
static_assert(offsetof(ATedInfantry, SubjugationDeathGameplayCueTag) == 0x001BA0, "Member 'ATedInfantry::SubjugationDeathGameplayCueTag' has a wrong offset!");
static_assert(offsetof(ATedInfantry, SubjugationVisualsDelay) == 0x001BA8, "Member 'ATedInfantry::SubjugationVisualsDelay' has a wrong offset!");
static_assert(offsetof(ATedInfantry, SubjugationHideSkeletonDuration) == 0x001BAC, "Member 'ATedInfantry::SubjugationHideSkeletonDuration' has a wrong offset!");

// Class Tempest.TedMissionClock
// 0x0118 (0x0518 - 0x0400)
class UTedMissionClock : public UTedUserWidget
{
public:
	uint8                                         bSupportMissionTime : 1;                           // 0x0400(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSupportMatchDuration : 1;                         // 0x0400(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_401[0x7];                                      // 0x0401(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETedFaction, class UFileMediaSource*>    MovieAnim_Show;                                    // 0x0408(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TMap<ETedFaction, class UFileMediaSource*>    MovieAnim_Hide;                                    // 0x0458(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FTedMoviePlayParams                    MovieAnimPlayParams;                               // 0x04A8(0x0018)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UTedMoviePlayerWidgetV2*                MovieAnimPlayer;                                   // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       WidgetAnim_Show;                                   // 0x04C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       WidgetAnim_Hide;                                   // 0x04D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_Time;                                    // 0x04D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimespan                              Time;                                              // 0x04E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   TimeText;                                          // 0x04E8(0x0010)(BlueprintVisible, BlueprintReadOnly, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	class UTedObjectiveCondition_Time*            ContextCondition;                                  // 0x04F8(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_500[0x8];                                      // 0x0500(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFileMediaSource*                       CachedMovieAnim_Show;                              // 0x0508(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFileMediaSource*                       CachedMovieAnim_Hide;                              // 0x0510(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DisplayCentralTimerNotification(const struct FTimespan& InTime);
	void OnMovieAnimFinished(class UTedMoviePlayerWidgetV2* InWidget, const class UFileMediaSource* InSource);
	void OnMovieAnimStarted(class UTedMoviePlayerWidgetV2* InWidget, const class UFileMediaSource* InSource);
	void OnRefreshMatchTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMissionClock">();
	}
	static class UTedMissionClock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMissionClock>();
	}
};
static_assert(alignof(UTedMissionClock) == 0x000008, "Wrong alignment on UTedMissionClock");
static_assert(sizeof(UTedMissionClock) == 0x000518, "Wrong size on UTedMissionClock");
static_assert(offsetof(UTedMissionClock, MovieAnim_Show) == 0x000408, "Member 'UTedMissionClock::MovieAnim_Show' has a wrong offset!");
static_assert(offsetof(UTedMissionClock, MovieAnim_Hide) == 0x000458, "Member 'UTedMissionClock::MovieAnim_Hide' has a wrong offset!");
static_assert(offsetof(UTedMissionClock, MovieAnimPlayParams) == 0x0004A8, "Member 'UTedMissionClock::MovieAnimPlayParams' has a wrong offset!");
static_assert(offsetof(UTedMissionClock, MovieAnimPlayer) == 0x0004C0, "Member 'UTedMissionClock::MovieAnimPlayer' has a wrong offset!");
static_assert(offsetof(UTedMissionClock, WidgetAnim_Show) == 0x0004C8, "Member 'UTedMissionClock::WidgetAnim_Show' has a wrong offset!");
static_assert(offsetof(UTedMissionClock, WidgetAnim_Hide) == 0x0004D0, "Member 'UTedMissionClock::WidgetAnim_Hide' has a wrong offset!");
static_assert(offsetof(UTedMissionClock, TextBlock_Time) == 0x0004D8, "Member 'UTedMissionClock::TextBlock_Time' has a wrong offset!");
static_assert(offsetof(UTedMissionClock, Time) == 0x0004E0, "Member 'UTedMissionClock::Time' has a wrong offset!");
static_assert(offsetof(UTedMissionClock, TimeText) == 0x0004E8, "Member 'UTedMissionClock::TimeText' has a wrong offset!");
static_assert(offsetof(UTedMissionClock, ContextCondition) == 0x0004F8, "Member 'UTedMissionClock::ContextCondition' has a wrong offset!");
static_assert(offsetof(UTedMissionClock, CachedMovieAnim_Show) == 0x000508, "Member 'UTedMissionClock::CachedMovieAnim_Show' has a wrong offset!");
static_assert(offsetof(UTedMissionClock, CachedMovieAnim_Hide) == 0x000510, "Member 'UTedMissionClock::CachedMovieAnim_Hide' has a wrong offset!");

// Class Tempest.TedInfantry_Harvester
// 0x0050 (0x1C10 - 0x1BC0)
class ATedInfantry_Harvester : public ATedInfantry
{
public:
	uint8                                         Pad_1BC0[0x30];                                    // 0x1BC0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OwnerBBKeyName;                                    // 0x1BF0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHarvesterData                         HarvesterData;                                     // 0x1BF8(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         CurrentResource;                                   // 0x1C08(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C0C[0x4];                                     // 0x1C0C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_OnResourceChange(float ResourceToMaxCapacityPct) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedInfantry_Harvester">();
	}
	static class ATedInfantry_Harvester* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedInfantry_Harvester>();
	}
};
static_assert(alignof(ATedInfantry_Harvester) == 0x000010, "Wrong alignment on ATedInfantry_Harvester");
static_assert(sizeof(ATedInfantry_Harvester) == 0x001C10, "Wrong size on ATedInfantry_Harvester");
static_assert(offsetof(ATedInfantry_Harvester, OwnerBBKeyName) == 0x001BF0, "Member 'ATedInfantry_Harvester::OwnerBBKeyName' has a wrong offset!");
static_assert(offsetof(ATedInfantry_Harvester, HarvesterData) == 0x001BF8, "Member 'ATedInfantry_Harvester::HarvesterData' has a wrong offset!");
static_assert(offsetof(ATedInfantry_Harvester, CurrentResource) == 0x001C08, "Member 'ATedInfantry_Harvester::CurrentResource' has a wrong offset!");

// Class Tempest.TedMobileRefineryInterface
// 0x0000 (0x0000 - 0x0000)
class ITedMobileRefineryInterface final
{
public:
	bool IsAutoharvestEnabled();
	void IssueAuthoharvestCommand();
	void SetTargetResourceVolume(class ATempestFieldVolume* InVolume);

	int32 GetHarvesterLimit() const;
	class ATempestFieldVolume* GetTargetResourceVolume() const;
	class FName GetTargetResourceVolumeBBKeyName() const;
	TArray<class ATedUnitBase*> K2_GetHarvesters() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMobileRefineryInterface">();
	}
	static class ITedMobileRefineryInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITedMobileRefineryInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITedMobileRefineryInterface) == 0x000001, "Wrong alignment on ITedMobileRefineryInterface");
static_assert(sizeof(ITedMobileRefineryInterface) == 0x000001, "Wrong size on ITedMobileRefineryInterface");

// Class Tempest.TedInfluenceMap_EnemyProxy
// 0x0000 (0x0038 - 0x0038)
class UTedInfluenceMap_EnemyProxy final : public UTedInfluenceMap_Pawn
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedInfluenceMap_EnemyProxy">();
	}
	static class UTedInfluenceMap_EnemyProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedInfluenceMap_EnemyProxy>();
	}
};
static_assert(alignof(UTedInfluenceMap_EnemyProxy) == 0x000008, "Wrong alignment on UTedInfluenceMap_EnemyProxy");
static_assert(sizeof(UTedInfluenceMap_EnemyProxy) == 0x000038, "Wrong size on UTedInfluenceMap_EnemyProxy");

// Class Tempest.TedInfluenceMap_EnemyThreat
// 0x0000 (0x0038 - 0x0038)
class UTedInfluenceMap_EnemyThreat final : public UTedInfluenceMap_Threat
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedInfluenceMap_EnemyThreat">();
	}
	static class UTedInfluenceMap_EnemyThreat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedInfluenceMap_EnemyThreat>();
	}
};
static_assert(alignof(UTedInfluenceMap_EnemyThreat) == 0x000008, "Wrong alignment on UTedInfluenceMap_EnemyThreat");
static_assert(sizeof(UTedInfluenceMap_EnemyThreat) == 0x000038, "Wrong size on UTedInfluenceMap_EnemyThreat");

// Class Tempest.TedInfluenceMap_FriendlyThreatWithoutOwner
// 0x0000 (0x0038 - 0x0038)
class UTedInfluenceMap_FriendlyThreatWithoutOwner final : public UTedInfluenceMap_FriendlyThreat
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedInfluenceMap_FriendlyThreatWithoutOwner">();
	}
	static class UTedInfluenceMap_FriendlyThreatWithoutOwner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedInfluenceMap_FriendlyThreatWithoutOwner>();
	}
};
static_assert(alignof(UTedInfluenceMap_FriendlyThreatWithoutOwner) == 0x000008, "Wrong alignment on UTedInfluenceMap_FriendlyThreatWithoutOwner");
static_assert(sizeof(UTedInfluenceMap_FriendlyThreatWithoutOwner) == 0x000038, "Wrong size on UTedInfluenceMap_FriendlyThreatWithoutOwner");

// Class Tempest.TedInfluenceMap_OwnerThreat
// 0x0000 (0x0028 - 0x0028)
class UTedInfluenceMap_OwnerThreat final : public UInfluenceMap
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedInfluenceMap_OwnerThreat">();
	}
	static class UTedInfluenceMap_OwnerThreat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedInfluenceMap_OwnerThreat>();
	}
};
static_assert(alignof(UTedInfluenceMap_OwnerThreat) == 0x000008, "Wrong alignment on UTedInfluenceMap_OwnerThreat");
static_assert(sizeof(UTedInfluenceMap_OwnerThreat) == 0x000028, "Wrong size on UTedInfluenceMap_OwnerThreat");

// Class Tempest.TedInfluenceMap_DamageSources
// 0x0000 (0x0028 - 0x0028)
class UTedInfluenceMap_DamageSources final : public UInfluenceMap
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedInfluenceMap_DamageSources">();
	}
	static class UTedInfluenceMap_DamageSources* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedInfluenceMap_DamageSources>();
	}
};
static_assert(alignof(UTedInfluenceMap_DamageSources) == 0x000008, "Wrong alignment on UTedInfluenceMap_DamageSources");
static_assert(sizeof(UTedInfluenceMap_DamageSources) == 0x000028, "Wrong size on UTedInfluenceMap_DamageSources");

// Class Tempest.TedInfluenceMap_LastEvadeLocations
// 0x0000 (0x0028 - 0x0028)
class UTedInfluenceMap_LastEvadeLocations final : public UInfluenceMap
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedInfluenceMap_LastEvadeLocations">();
	}
	static class UTedInfluenceMap_LastEvadeLocations* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedInfluenceMap_LastEvadeLocations>();
	}
};
static_assert(alignof(UTedInfluenceMap_LastEvadeLocations) == 0x000008, "Wrong alignment on UTedInfluenceMap_LastEvadeLocations");
static_assert(sizeof(UTedInfluenceMap_LastEvadeLocations) == 0x000028, "Wrong size on UTedInfluenceMap_LastEvadeLocations");

// Class Tempest.TedInputMappingPicker
// 0x0038 (0x0438 - 0x0400)
class UTedInputMappingPicker : public UTedUserWidget
{
public:
	class FText                                   ContextDisplayText;                                // 0x0400(0x0010)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_410[0x20];                                     // 0x0410(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedPopup*                              Popup;                                             // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandlePopupButtonClick_Ok(const int32 InButtonIndex);
	void Hide();
	void NotifyOnCancel();
	void NotifyOnPick(const struct FInputChord& InChord);

	const class FText GetInputDisplayText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedInputMappingPicker">();
	}
	static class UTedInputMappingPicker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedInputMappingPicker>();
	}
};
static_assert(alignof(UTedInputMappingPicker) == 0x000008, "Wrong alignment on UTedInputMappingPicker");
static_assert(sizeof(UTedInputMappingPicker) == 0x000438, "Wrong size on UTedInputMappingPicker");
static_assert(offsetof(UTedInputMappingPicker, ContextDisplayText) == 0x000400, "Member 'UTedInputMappingPicker::ContextDisplayText' has a wrong offset!");
static_assert(offsetof(UTedInputMappingPicker, Popup) == 0x000430, "Member 'UTedInputMappingPicker::Popup' has a wrong offset!");

// Class Tempest.TedInputSettings
// 0x0050 (0x0088 - 0x0038)
class UTedInputSettings final : public UDeveloperSettings
{
public:
	TArray<struct FTedInputSectionData>           AvailableInputSections;                            // 0x0038(0x0010)(Edit, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTedInputUIData>                AvailableInputs;                                   // 0x0048(0x0010)(Edit, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTedKeyDisplayNameOverrides>    KeyNameOverrides;                                  // 0x0058(0x0010)(Edit, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTedInputDisplay>               AdditionalReadOnlyBindings;                        // 0x0068(0x0010)(Edit, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UTedInputPreset>> Presets;                                           // 0x0078(0x0010)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	TArray<class FName> GetAvailableInputNames() const;
	TArray<class FName> GetAvailableSectionNames() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedInputSettings">();
	}
	static class UTedInputSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedInputSettings>();
	}
};
static_assert(alignof(UTedInputSettings) == 0x000008, "Wrong alignment on UTedInputSettings");
static_assert(sizeof(UTedInputSettings) == 0x000088, "Wrong size on UTedInputSettings");
static_assert(offsetof(UTedInputSettings, AvailableInputSections) == 0x000038, "Member 'UTedInputSettings::AvailableInputSections' has a wrong offset!");
static_assert(offsetof(UTedInputSettings, AvailableInputs) == 0x000048, "Member 'UTedInputSettings::AvailableInputs' has a wrong offset!");
static_assert(offsetof(UTedInputSettings, KeyNameOverrides) == 0x000058, "Member 'UTedInputSettings::KeyNameOverrides' has a wrong offset!");
static_assert(offsetof(UTedInputSettings, AdditionalReadOnlyBindings) == 0x000068, "Member 'UTedInputSettings::AdditionalReadOnlyBindings' has a wrong offset!");
static_assert(offsetof(UTedInputSettings, Presets) == 0x000078, "Member 'UTedInputSettings::Presets' has a wrong offset!");

// Class Tempest.TedIpcManager
// 0x0030 (0x0058 - 0x0028)
class UTedIpcManager final : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedIpcManager">();
	}
	static class UTedIpcManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedIpcManager>();
	}
};
static_assert(alignof(UTedIpcManager) == 0x000008, "Wrong alignment on UTedIpcManager");
static_assert(sizeof(UTedIpcManager) == 0x000058, "Wrong size on UTedIpcManager");

// Class Tempest.TedJukeboxSubsystem
// 0x00F8 (0x0128 - 0x0030)
class UTedJukeboxSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool NewActive)> OnMissionTrackModeChanged;                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool NewActive)> OnRepeatModeChanged;                              // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool NewActive)> OnShuffleModeChanged;                             // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTedJukeboxTrackAsset* NewTrack)> OnNewTrackPlayed;          // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTrackAssetsLoaded;                               // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool NewActive)> OnPauseModeChanged;                               // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bHasFinishedLoadingTracks;                         // 0x0098(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentPercentagePlayed;                           // 0x009C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float NewPercentage)> OnPlaybackPercentageChanged;                 // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UTedJukeboxTrackAsset*                  CurrentTrack;                                      // 0x00B0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTedJukeboxTrackAsset*                  PreviousTrack;                                     // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UTedJukeboxTrackAsset*>          LoadedAssets;                                      // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UTedJukeboxTrackAsset*>          CurrentPlayList;                                   // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UTedJukeboxTrackAsset*>          ShuffledPlayList;                                  // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x10];                                      // 0x00F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        CurrentSoundComponent;                             // 0x0100(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class USoundClass*>                    AffectingSoundClasses;                             // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x10];                                     // 0x0118(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FadeOutTrack(float FadeOutDuration);
	class FText GetPlaytimeText();
	bool IsPaused();
	void OnSoundSettingsChanged();
	void OnTrackAssetsLoaded_Internal(const TArray<struct FPrimaryAssetId>& AssetsLoaded);
	void OnTrackFinishedCallBack();
	void Play(class UTedJukeboxTrackAsset* NewTrack);
	void PlayBackPercentageCallBack(const class USoundWave* SoundWave, const float Percentage);
	void PlayEndGameTrack(bool bInVictory);
	void PlayNext(bool bForceNewTrack);
	void PlayNext_Muted(bool bForceNewTrack);
	void PlayPrevious(bool bForceNewTrack);
	void SetMissionTrackMode(bool NewActive);
	void SetPause(bool NewPause);
	void SetPlayPercentage(float Value);
	void SetRepeatMode(bool NewActive);
	void SetShuffleMode(bool NewActive);

	const TArray<class UTedJukeboxTrackAsset*> GetAllTracks() const;
	class UTedJukeboxTrackAsset* GetCurrentPlayedTrack() const;
	const TArray<class UTedJukeboxTrackAsset*> GetCurrentPlaylist() const;
	float GetCurrenttrackPlayTime() const;
	bool IsMissionTrackMode() const;
	bool IsRepeatMode() const;
	bool IsShuffleMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedJukeboxSubsystem">();
	}
	static class UTedJukeboxSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedJukeboxSubsystem>();
	}
};
static_assert(alignof(UTedJukeboxSubsystem) == 0x000008, "Wrong alignment on UTedJukeboxSubsystem");
static_assert(sizeof(UTedJukeboxSubsystem) == 0x000128, "Wrong size on UTedJukeboxSubsystem");
static_assert(offsetof(UTedJukeboxSubsystem, OnMissionTrackModeChanged) == 0x000038, "Member 'UTedJukeboxSubsystem::OnMissionTrackModeChanged' has a wrong offset!");
static_assert(offsetof(UTedJukeboxSubsystem, OnRepeatModeChanged) == 0x000048, "Member 'UTedJukeboxSubsystem::OnRepeatModeChanged' has a wrong offset!");
static_assert(offsetof(UTedJukeboxSubsystem, OnShuffleModeChanged) == 0x000058, "Member 'UTedJukeboxSubsystem::OnShuffleModeChanged' has a wrong offset!");
static_assert(offsetof(UTedJukeboxSubsystem, OnNewTrackPlayed) == 0x000068, "Member 'UTedJukeboxSubsystem::OnNewTrackPlayed' has a wrong offset!");
static_assert(offsetof(UTedJukeboxSubsystem, OnTrackAssetsLoaded) == 0x000078, "Member 'UTedJukeboxSubsystem::OnTrackAssetsLoaded' has a wrong offset!");
static_assert(offsetof(UTedJukeboxSubsystem, OnPauseModeChanged) == 0x000088, "Member 'UTedJukeboxSubsystem::OnPauseModeChanged' has a wrong offset!");
static_assert(offsetof(UTedJukeboxSubsystem, bHasFinishedLoadingTracks) == 0x000098, "Member 'UTedJukeboxSubsystem::bHasFinishedLoadingTracks' has a wrong offset!");
static_assert(offsetof(UTedJukeboxSubsystem, CurrentPercentagePlayed) == 0x00009C, "Member 'UTedJukeboxSubsystem::CurrentPercentagePlayed' has a wrong offset!");
static_assert(offsetof(UTedJukeboxSubsystem, OnPlaybackPercentageChanged) == 0x0000A0, "Member 'UTedJukeboxSubsystem::OnPlaybackPercentageChanged' has a wrong offset!");
static_assert(offsetof(UTedJukeboxSubsystem, CurrentTrack) == 0x0000B0, "Member 'UTedJukeboxSubsystem::CurrentTrack' has a wrong offset!");
static_assert(offsetof(UTedJukeboxSubsystem, PreviousTrack) == 0x0000B8, "Member 'UTedJukeboxSubsystem::PreviousTrack' has a wrong offset!");
static_assert(offsetof(UTedJukeboxSubsystem, LoadedAssets) == 0x0000C0, "Member 'UTedJukeboxSubsystem::LoadedAssets' has a wrong offset!");
static_assert(offsetof(UTedJukeboxSubsystem, CurrentPlayList) == 0x0000D0, "Member 'UTedJukeboxSubsystem::CurrentPlayList' has a wrong offset!");
static_assert(offsetof(UTedJukeboxSubsystem, ShuffledPlayList) == 0x0000E0, "Member 'UTedJukeboxSubsystem::ShuffledPlayList' has a wrong offset!");
static_assert(offsetof(UTedJukeboxSubsystem, CurrentSoundComponent) == 0x000100, "Member 'UTedJukeboxSubsystem::CurrentSoundComponent' has a wrong offset!");
static_assert(offsetof(UTedJukeboxSubsystem, AffectingSoundClasses) == 0x000108, "Member 'UTedJukeboxSubsystem::AffectingSoundClasses' has a wrong offset!");

// Class Tempest.TedJukeboxTrackEntry
// 0x0028 (0x0458 - 0x0430)
class UTedJukeboxTrackEntry : public UTedContentPanelSlotButton
{
public:
	class UTextBlock*                             NameText;                                          // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TotalTimeText;                                     // 0x0438(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AuthorText;                                        // 0x0440(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Number;                                            // 0x0448(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                PlayBTN;                                           // 0x0450(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void PlayBTNOnClicked();

	class UTedJukeboxTrackAsset* GetContent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedJukeboxTrackEntry">();
	}
	static class UTedJukeboxTrackEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedJukeboxTrackEntry>();
	}
};
static_assert(alignof(UTedJukeboxTrackEntry) == 0x000008, "Wrong alignment on UTedJukeboxTrackEntry");
static_assert(sizeof(UTedJukeboxTrackEntry) == 0x000458, "Wrong size on UTedJukeboxTrackEntry");
static_assert(offsetof(UTedJukeboxTrackEntry, NameText) == 0x000430, "Member 'UTedJukeboxTrackEntry::NameText' has a wrong offset!");
static_assert(offsetof(UTedJukeboxTrackEntry, TotalTimeText) == 0x000438, "Member 'UTedJukeboxTrackEntry::TotalTimeText' has a wrong offset!");
static_assert(offsetof(UTedJukeboxTrackEntry, AuthorText) == 0x000440, "Member 'UTedJukeboxTrackEntry::AuthorText' has a wrong offset!");
static_assert(offsetof(UTedJukeboxTrackEntry, Number) == 0x000448, "Member 'UTedJukeboxTrackEntry::Number' has a wrong offset!");
static_assert(offsetof(UTedJukeboxTrackEntry, PlayBTN) == 0x000450, "Member 'UTedJukeboxTrackEntry::PlayBTN' has a wrong offset!");

// Class Tempest.TedJukeboxTrackPanel
// 0x0010 (0x07C0 - 0x07B0)
class UTedJukeboxTrackPanel : public UTedContentPanelDynamic
{
public:
	TArray<class UTedJukeboxTrackAsset*>          content;                                           // 0x07B0(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)

public:
	void SetContent(const TArray<class UTedJukeboxTrackAsset*>& NewContent);

	class UTedJukeboxTrackAsset* GetContent(int32 Index_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedJukeboxTrackPanel">();
	}
	static class UTedJukeboxTrackPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedJukeboxTrackPanel>();
	}
};
static_assert(alignof(UTedJukeboxTrackPanel) == 0x000008, "Wrong alignment on UTedJukeboxTrackPanel");
static_assert(sizeof(UTedJukeboxTrackPanel) == 0x0007C0, "Wrong size on UTedJukeboxTrackPanel");
static_assert(offsetof(UTedJukeboxTrackPanel, content) == 0x0007B0, "Member 'UTedJukeboxTrackPanel::content' has a wrong offset!");

// Class Tempest.TedJukeboxWidgetMain
// 0x0070 (0x04C8 - 0x0458)
class UTedJukeboxWidgetMain : public UTedMenuScreenWidget
{
public:
	class UTedJukeboxTrackPanel*                  JukeboxTrackPanel;                                 // 0x0458(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ShuffleText;                                       // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             RepeatText;                                        // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MissionTrackText;                                  // 0x0470(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayPauseText;                                     // 0x0478(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                ShuffleBTN;                                        // 0x0480(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                RepeatBTN;                                         // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                MTMBTN;                                            // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                PausePlayBTN;                                      // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                PreviousBTN;                                       // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                NextBTN;                                           // 0x04A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TrackName;                                         // 0x04B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TrackAuthor;                                       // 0x04B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TrackTotalTime;                                    // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void MTMBTNNOnClicked();
	void NextBTNOnClicked();
	void OnAssetLoaded();
	void OnMissionModeStateChangeCallback(bool NewActive);
	void OnPauseModeStateChangeCallback(bool NewActive);
	void OnShuffleModeStateChangeCallback(bool NewActive);
	void OnTrackFinishedCallack(class UTedJukeboxTrackAsset* NewTrack);
	void PausePlayBTNOnClicked();
	void PreviousBTNOnClicked();
	void RefreshTrack(class UTedJukeboxTrackAsset* NewTrack);
	void RepeatBTNOnClicked();
	void ShuffleBTNOnClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedJukeboxWidgetMain">();
	}
	static class UTedJukeboxWidgetMain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedJukeboxWidgetMain>();
	}
};
static_assert(alignof(UTedJukeboxWidgetMain) == 0x000008, "Wrong alignment on UTedJukeboxWidgetMain");
static_assert(sizeof(UTedJukeboxWidgetMain) == 0x0004C8, "Wrong size on UTedJukeboxWidgetMain");
static_assert(offsetof(UTedJukeboxWidgetMain, JukeboxTrackPanel) == 0x000458, "Member 'UTedJukeboxWidgetMain::JukeboxTrackPanel' has a wrong offset!");
static_assert(offsetof(UTedJukeboxWidgetMain, ShuffleText) == 0x000460, "Member 'UTedJukeboxWidgetMain::ShuffleText' has a wrong offset!");
static_assert(offsetof(UTedJukeboxWidgetMain, RepeatText) == 0x000468, "Member 'UTedJukeboxWidgetMain::RepeatText' has a wrong offset!");
static_assert(offsetof(UTedJukeboxWidgetMain, MissionTrackText) == 0x000470, "Member 'UTedJukeboxWidgetMain::MissionTrackText' has a wrong offset!");
static_assert(offsetof(UTedJukeboxWidgetMain, PlayPauseText) == 0x000478, "Member 'UTedJukeboxWidgetMain::PlayPauseText' has a wrong offset!");
static_assert(offsetof(UTedJukeboxWidgetMain, ShuffleBTN) == 0x000480, "Member 'UTedJukeboxWidgetMain::ShuffleBTN' has a wrong offset!");
static_assert(offsetof(UTedJukeboxWidgetMain, RepeatBTN) == 0x000488, "Member 'UTedJukeboxWidgetMain::RepeatBTN' has a wrong offset!");
static_assert(offsetof(UTedJukeboxWidgetMain, MTMBTN) == 0x000490, "Member 'UTedJukeboxWidgetMain::MTMBTN' has a wrong offset!");
static_assert(offsetof(UTedJukeboxWidgetMain, PausePlayBTN) == 0x000498, "Member 'UTedJukeboxWidgetMain::PausePlayBTN' has a wrong offset!");
static_assert(offsetof(UTedJukeboxWidgetMain, PreviousBTN) == 0x0004A0, "Member 'UTedJukeboxWidgetMain::PreviousBTN' has a wrong offset!");
static_assert(offsetof(UTedJukeboxWidgetMain, NextBTN) == 0x0004A8, "Member 'UTedJukeboxWidgetMain::NextBTN' has a wrong offset!");
static_assert(offsetof(UTedJukeboxWidgetMain, TrackName) == 0x0004B0, "Member 'UTedJukeboxWidgetMain::TrackName' has a wrong offset!");
static_assert(offsetof(UTedJukeboxWidgetMain, TrackAuthor) == 0x0004B8, "Member 'UTedJukeboxWidgetMain::TrackAuthor' has a wrong offset!");
static_assert(offsetof(UTedJukeboxWidgetMain, TrackTotalTime) == 0x0004C0, "Member 'UTedJukeboxWidgetMain::TrackTotalTime' has a wrong offset!");

// Class Tempest.AirDropInVolumeBlueprintNode
// 0x0000 (0x0028 - 0x0028)
class UAirDropInVolumeBlueprintNode final : public UBlueprintFunctionLibrary
{
public:
	static void RequestAirDropInVolume(class UObject* InWorldContext, EAirDropInVolumeInputs In, EAirDropInVolumeOutputs* Out, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo, class ATedUnitSpawner_Volume* Spawner, TArray<class ATedUnitBase*>* DroppedUnits);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AirDropInVolumeBlueprintNode">();
	}
	static class UAirDropInVolumeBlueprintNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAirDropInVolumeBlueprintNode>();
	}
};
static_assert(alignof(UAirDropInVolumeBlueprintNode) == 0x000008, "Wrong alignment on UAirDropInVolumeBlueprintNode");
static_assert(sizeof(UAirDropInVolumeBlueprintNode) == 0x000028, "Wrong size on UAirDropInVolumeBlueprintNode");

// Class Tempest.BatchSpawnBlueprintNode
// 0x0000 (0x0028 - 0x0028)
class UBatchSpawnBlueprintNode final : public UBlueprintFunctionLibrary
{
public:
	static void RequestBatchSpawn(class UObject* InWorldContext, EBatchSpawnInputs In, EBatchSpawnOutputs* Out, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo, const TArray<class ATedUnitSpawner*>& Spawners, TArray<class ATedUnitBase*>* SpawnedUnits);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BatchSpawnBlueprintNode">();
	}
	static class UBatchSpawnBlueprintNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBatchSpawnBlueprintNode>();
	}
};
static_assert(alignof(UBatchSpawnBlueprintNode) == 0x000008, "Wrong alignment on UBatchSpawnBlueprintNode");
static_assert(sizeof(UBatchSpawnBlueprintNode) == 0x000028, "Wrong size on UBatchSpawnBlueprintNode");

// Class Tempest.SpawnBlueprintNode
// 0x0000 (0x0028 - 0x0028)
class USpawnBlueprintNode final : public UBlueprintFunctionLibrary
{
public:
	static void RequestSpawn(class UObject* InWorldContext, EBatchSpawnInputs In, EBatchSpawnOutputs* Out, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo, class ATedUnitSpawner* Spawner, class ATedUnitBase** SpawnedUnit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnBlueprintNode">();
	}
	static class USpawnBlueprintNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnBlueprintNode>();
	}
};
static_assert(alignof(USpawnBlueprintNode) == 0x000008, "Wrong alignment on USpawnBlueprintNode");
static_assert(sizeof(USpawnBlueprintNode) == 0x000028, "Wrong size on USpawnBlueprintNode");

// Class Tempest.SpawnStaggeredBlueprintNode
// 0x0000 (0x0028 - 0x0028)
class USpawnStaggeredBlueprintNode final : public UBlueprintFunctionLibrary
{
public:
	static void RequestSpawnInVolumeStaggered(class UObject* InWorldContext, ESpawnStaggeredInputs In, ESpawnStaggeredOutputs* Out, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo, class ATedUnitSpawner_Volume* Spawner, float DelayMin, float DelayMax, TArray<class ATedUnitBase*>* SpawnedUnits);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnStaggeredBlueprintNode">();
	}
	static class USpawnStaggeredBlueprintNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnStaggeredBlueprintNode>();
	}
};
static_assert(alignof(USpawnStaggeredBlueprintNode) == 0x000008, "Wrong alignment on USpawnStaggeredBlueprintNode");
static_assert(sizeof(USpawnStaggeredBlueprintNode) == 0x000028, "Wrong size on USpawnStaggeredBlueprintNode");

// Class Tempest.WaitForProductionBlueprintNode
// 0x0000 (0x0028 - 0x0028)
class UWaitForProductionBlueprintNode final : public UBlueprintFunctionLibrary
{
public:
	static void WaitForProduction(class UObject* InWorldContext, ELatentActionWaitForProductionInputs In, ELatentActionWaitForProductionOutputs* Out, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo, const ETedPlayerID PlayerID, const bool bStopAfterProduction, const int32 StopAfterProducingAmount, const struct FTedPawnFilter& Filter, class ATedStructureBase** OutProductionStructure, class ATedUnitBase** OutProducedUnit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaitForProductionBlueprintNode">();
	}
	static class UWaitForProductionBlueprintNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWaitForProductionBlueprintNode>();
	}
};
static_assert(alignof(UWaitForProductionBlueprintNode) == 0x000008, "Wrong alignment on UWaitForProductionBlueprintNode");
static_assert(sizeof(UWaitForProductionBlueprintNode) == 0x000028, "Wrong size on UWaitForProductionBlueprintNode");

// Class Tempest.TedLatentFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UTedLatentFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ActorDamagedTag(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const struct FGameplayTagContainer& ActorTags, TSubclassOf<class AActor> ActorClass, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void ActorEntersVolume_FilterByActorClasses(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const struct FSoftActorPtr& Volume, const TArray<TSoftClassPtr<class UClass>>& Classes, const bool bExactClasses, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void ActorEntersVolume_FilterByActorTags(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const struct FSoftActorPtr& Volume, const struct FGameplayTagContainer& ActorTags, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void ActorEntersVolume_FilterByDefinitions(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const struct FSoftActorPtr& Volume, const TArray<TSoftObjectPtr<class UTedEntityDefinitionAsset>>& Definitions, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void ActorEntersVolume_FilterByPawnFilter(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const struct FSoftActorPtr& Volume, const struct FTedPawnFilter& InFilter, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void ActorEntersVolume_FilterByPlayer(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const struct FSoftActorPtr& Volume, const ETedPlayerID Player, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void ActorEntersVolume_FilterByPrerequisites(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const struct FSoftActorPtr& Volume, const struct FTedPrerequisiteContainer& Prerequisites, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void ActorEntersVolume_FilterByTech(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const struct FSoftActorPtr& Volume, const struct FGameplayTagContainer& TechTags, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void ActorExist(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const struct FSoftActorPtr& Actor, const bool bInverse, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void ActorLeavesVolume_FilterByActorClasses(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const struct FSoftActorPtr& Volume, const TArray<TSoftClassPtr<class UClass>>& Classes, const bool bExactClasses, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void ActorLeavesVolume_FilterByActorTags(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const struct FSoftActorPtr& Volume, const struct FGameplayTagContainer& ActorTags, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void ActorLeavesVolume_FilterByDefinitions(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const struct FSoftActorPtr& Volume, const TArray<TSoftObjectPtr<class UTedEntityDefinitionAsset>>& Definitions, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void ActorLeavesVolume_FilterByPawnFilter(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const struct FSoftActorPtr& Volume, const struct FTedPawnFilter& InFilter, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void ActorLeavesVolume_FilterByPlayer(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const struct FSoftActorPtr& Volume, const ETedPlayerID Player, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void ActorLeavesVolume_FilterByPrerequisites(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const struct FSoftActorPtr& Volume, const struct FTedPrerequisiteContainer& Prerequisites, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void ActorLeavesVolume_FilterByTech(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const struct FSoftActorPtr& Volume, const struct FGameplayTagContainer& TechTags, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void ActorsExist(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const TSet<struct FSoftActorPtr>& Actors, const int32 ExpectedAmount, const EComparison Comparison, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void ActorsExistTag(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const struct FGameplayTagContainer& ActorTags, TSubclassOf<class AActor> ActorClass, const int32 ExpectedAmount_B, const EComparison Comparison, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void AnyActorEntersVolume(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const struct FSoftActorPtr& Volume, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void AnyActorLeavesVolume(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const struct FSoftActorPtr& Volume, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void DisarmMinesTag(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const struct FGameplayTagContainer& ActorTags, const int32 ExpectedAmount_B, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void DisarmMinesTagFiltered(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const struct FGameplayTagContainer& MineActorTags, const int32 ExpectedAmount_B, const ETedPawnFilterMode FilteringMode, const struct FGameplayTagContainer& DisarmingActorTags, const struct FGameplayTagContainer& DisarmingActorTech, const TSet<ETedPlayerID>& DisarmingActorOwners, const TArray<TSoftClassPtr<class UClass>>& DisarmingActorClassess, const bool bExactDisarmingActorClass, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void DownloadOnlinePlayerProfile(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void EndGame_SP(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const bool bInVictory, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void EndGame_SP_Advanced(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const bool bInVictory, const bool bInSkipMovie, const bool bInSkipScoreScreen, const bool bInSkipLevelRestart, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void FadeCamera(const class UObject* InWorldContext, const ETedMovieFadeType FadeType, const float Duration, const struct FLinearColor& Color, const bool bShouldFadeAudio, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void FullScreenMovieEnd(const ETedLatentLink LinkAction);
	static void InterpolateCamera(const class UObject* InWorldContext, const struct FVector& TargetLocation, const float InterpTime, const float InterpExponent, const float OverrideZoomPct, const float LockTargetLocationTime, const bool bReturnToStartLocation, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void ObjectiveState(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const class UTedObjectiveObj* Objective, const EObjectiveState State, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void OpenMenuScreen(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const struct FGameplayTag& Screen, const class UObject* InContext, const bool bInstant, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void PawnDead(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const struct FSoftActorPtr& Pawn, const bool bInverse, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void PawnsDead(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const TSet<struct FSoftActorPtr>& Pawns, const int32 ExpectedAmount, const EComparison Comparison, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void PawnsDeadTag(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const struct FGameplayTagContainer& ActorTags, TSubclassOf<class ATedPawn> PawnClass, const int32 ExpectedAmount_B, const EComparison Comparison, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void PawnsOwnerTag(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const struct FGameplayTagContainer& ActorTags, TSubclassOf<class ATedPawn> PawnClass, const ETedPlayerID Player, const bool bInverseOwnerCheck, const int32 ExpectedAmount_B, const EComparison Comparison, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void PlayerCredits(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const ETedPlayerID Player, const int32 Amount_B, const EComparison Comparison, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void PlayerIntel(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const ETedPlayerID Player, const int32 Amount_B, const EComparison Comparison, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void PlayerOwns_ByDefinition(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const ETedPlayerID Player, const TSoftObjectPtr<class UTedEntityDefinitionAsset> InDefinition, const int32 ExpectedAmount, const EComparison Comparison, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void PlayerOwns_ByTag(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const ETedPlayerID Player, const struct FGameplayTag& OwnedTag, const int32 ExpectedAmount, const EComparison Comparison, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void PlayerOwnsMultiple(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const ETedPlayerID Player, const TArray<struct FWaitForPlayerOwnsOption>& Owned, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void PlayerOwnTech(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const ETedPlayerID Player, const struct FGameplayTag& Tech, const bool bInverse, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void PlayerOwnTechs(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const ETedPlayerID Player, const TSet<struct FGameplayTag>& Techs, const int32 ExpectedAmount, const EComparison Comparison, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void PlayerPower(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const ETedPlayerID Player, const int32 Amount_B, const EComparison Comparison, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void PlayerPowerConsumption(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const ETedPlayerID Player, const int32 Amount_B, const EComparison Comparison, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void PlayMovie(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo, const ETedMovieType MovieType, const class UFileMediaSource* Movie, const bool bSilent, const float FadeIn, const float FadeOut, const bool bLoop, const ETedMovieGamePauseInteraction InPauseInteraction);
	static void PlayMovie_MissionDialogue(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo, const class UFileMediaSource* Movie);
	static void ResourceFieldDepleted(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const struct FSoftActorPtr& ResourceVolume, const bool bInverse, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void ResourceFieldsDepleted(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const TSet<struct FSoftActorPtr>& ResourceFields, const int32 ExpectedAmount, const EComparison Comparison, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void StructureOwner(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const struct FSoftActorPtr& Structure, const ETedPlayerID ExpectedPlayer, const bool bInverse, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void StructuresOwner(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const TSet<struct FSoftActorPtr>& Structures, const ETedPlayerID ExpectedPlayer, const int32 ExpectedAmount, const EComparison Comparison, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void WaitForAIMissionState(const class UObject* WorldContextObject, const ETedLatentLink LinkAction, class UAIMission* Mission, EAIMissionState MissionState, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void WaitForCommandUsage(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const struct FGameplayTag& Command, const ETedObjectiveCommandTracking Track, const ETedPlayerID CommandPlayer, const struct FGameplayTagContainer& CommandActors, const struct FGameplayTagContainer& TargetActors, const float TargetDistanceTolerance, const int32 ExpectedAmount, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo);
	static void WaitForMovieEnd(const class UObject* InWorldContext, const ETedLatentLink LinkAction, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo, const ETedMovieType MovieType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedLatentFunctionLibrary">();
	}
	static class UTedLatentFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedLatentFunctionLibrary>();
	}
};
static_assert(alignof(UTedLatentFunctionLibrary) == 0x000008, "Wrong alignment on UTedLatentFunctionLibrary");
static_assert(sizeof(UTedLatentFunctionLibrary) == 0x000028, "Wrong size on UTedLatentFunctionLibrary");

// Class Tempest.TedLeaderboardPlayersPanel
// 0x0048 (0x07F8 - 0x07B0)
class UTedLeaderboardPlayersPanel final : public UTedContentPanelDynamic
{
public:
	TArray<struct FTedLeaderboardDataPanel>       content;                                           // 0x07B0(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTedLeaderboardDataPanel>       FilteredContent;                                   // 0x07C0(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	class FString                                 FilterString;                                      // 0x07D0(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SortingMethod;                                     // 0x07E0(0x0008)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAscendingSort : 1;                                // 0x07E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	bool                                          bSingleRowData;                                    // 0x07E9(0x0001)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7EA[0x6];                                      // 0x07EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedLeaderboardHeadersPanel*            HeadersPanel;                                      // 0x07F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	struct FTedLeaderboardDataPanel GetContent(const int32 InSlotIndex);
	void OnActivateHeaderSlotState(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotState InState, bool bInActivated);
	void SetAscendingSorting(const bool bInAscending);
	void SetFilterString(const class FString& InFilter);
	void SetSingleRowData(const bool bInSingleRowData);
	void SetSortingMethod(const class FName InSortingMethod);

	class UTedLeaderboardHeadersPanel* GetHeadersPanel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedLeaderboardPlayersPanel">();
	}
	static class UTedLeaderboardPlayersPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedLeaderboardPlayersPanel>();
	}
};
static_assert(alignof(UTedLeaderboardPlayersPanel) == 0x000008, "Wrong alignment on UTedLeaderboardPlayersPanel");
static_assert(sizeof(UTedLeaderboardPlayersPanel) == 0x0007F8, "Wrong size on UTedLeaderboardPlayersPanel");
static_assert(offsetof(UTedLeaderboardPlayersPanel, content) == 0x0007B0, "Member 'UTedLeaderboardPlayersPanel::content' has a wrong offset!");
static_assert(offsetof(UTedLeaderboardPlayersPanel, FilteredContent) == 0x0007C0, "Member 'UTedLeaderboardPlayersPanel::FilteredContent' has a wrong offset!");
static_assert(offsetof(UTedLeaderboardPlayersPanel, FilterString) == 0x0007D0, "Member 'UTedLeaderboardPlayersPanel::FilterString' has a wrong offset!");
static_assert(offsetof(UTedLeaderboardPlayersPanel, SortingMethod) == 0x0007E0, "Member 'UTedLeaderboardPlayersPanel::SortingMethod' has a wrong offset!");
static_assert(offsetof(UTedLeaderboardPlayersPanel, bSingleRowData) == 0x0007E9, "Member 'UTedLeaderboardPlayersPanel::bSingleRowData' has a wrong offset!");
static_assert(offsetof(UTedLeaderboardPlayersPanel, HeadersPanel) == 0x0007F0, "Member 'UTedLeaderboardPlayersPanel::HeadersPanel' has a wrong offset!");

// Class Tempest.TedLeaderboardPlayersPanel_V2
// 0x00A8 (0x0858 - 0x07B0)
class UTedLeaderboardPlayersPanel_V2 final : public UTedContentPanelDynamic
{
public:
	uint8                                         Pad_7B0[0x10];                                     // 0x07B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bDownloading)> OnLeaderboardsPanelStateChange;                // 0x07C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	int32                                         LeaderboardRowAmount;                              // 0x07D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7D4[0x84];                                     // 0x07D4(0x0084)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeLeaderboards(const struct FTedLeaderboardsRetrieveFilter& InFilter, const bool bForceRefresh);
	void Sort(const struct FGameplayTag& SortType, const bool bAscending);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedLeaderboardPlayersPanel_V2">();
	}
	static class UTedLeaderboardPlayersPanel_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedLeaderboardPlayersPanel_V2>();
	}
};
static_assert(alignof(UTedLeaderboardPlayersPanel_V2) == 0x000008, "Wrong alignment on UTedLeaderboardPlayersPanel_V2");
static_assert(sizeof(UTedLeaderboardPlayersPanel_V2) == 0x000858, "Wrong size on UTedLeaderboardPlayersPanel_V2");
static_assert(offsetof(UTedLeaderboardPlayersPanel_V2, OnLeaderboardsPanelStateChange) == 0x0007C0, "Member 'UTedLeaderboardPlayersPanel_V2::OnLeaderboardsPanelStateChange' has a wrong offset!");
static_assert(offsetof(UTedLeaderboardPlayersPanel_V2, LeaderboardRowAmount) == 0x0007D0, "Member 'UTedLeaderboardPlayersPanel_V2::LeaderboardRowAmount' has a wrong offset!");

// Class Tempest.TedLeaderboardPlayersSlot
// 0x0000 (0x0430 - 0x0430)
class UTedLeaderboardPlayersSlot final : public UTedContentPanelSlotButton
{
public:
	void K2_DescribeAvatar(const class UTexture2D* AvatarTexture);
	void K2_DescribeFaction(const ETedRankedFaction Faction);
	void K2_DescribeMedal(const struct FTedMedalTableRow_Ranked& Medal, const bool bFoundMedal);
	void K2_DescribePlayerName(const class FText& PlayerName);
	void K2_DescribePosition(const int32 position);
	void K2_DescribeRating(const int32 Rating);
	void K2_DescribeWins(const int32 Wins);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedLeaderboardPlayersSlot">();
	}
	static class UTedLeaderboardPlayersSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedLeaderboardPlayersSlot>();
	}
};
static_assert(alignof(UTedLeaderboardPlayersSlot) == 0x000008, "Wrong alignment on UTedLeaderboardPlayersSlot");
static_assert(sizeof(UTedLeaderboardPlayersSlot) == 0x000430, "Wrong size on UTedLeaderboardPlayersSlot");

// Class Tempest.TedLevelSequenceDirector
// 0x0008 (0x0050 - 0x0048)
class UTedLevelSequenceDirector final : public ULevelSequenceDirector
{
public:
	class UFileMediaSource*                       PlayingMovie;                                      // 0x0048(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	TArray<class FString> GetAvailableMarkedFrames();
	void OnSequenceStoppedDuringTransitionMovie();
	void PlayFramedMovie(const struct FGameplayTag& Frame, const class UFileMediaSource* Movie, const bool bLoop, const class UFileMediaSource* FrameIntroOverride);
	void PlayTransitionMovie(const class UFileMediaSource* Movie);
	void QuickSkip(const class FString& MarkedFrame, const bool bDoSkip);
	void StopFramedMovie(const struct FGameplayTag& Frame);

	void AutoFocusCamera(const TSoftObjectPtr<class ACameraActor> CameraActor, const TSoftObjectPtr<class AActor> ActorToFocus, const class FName JointName, const float FocusOffset) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedLevelSequenceDirector">();
	}
	static class UTedLevelSequenceDirector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedLevelSequenceDirector>();
	}
};
static_assert(alignof(UTedLevelSequenceDirector) == 0x000008, "Wrong alignment on UTedLevelSequenceDirector");
static_assert(sizeof(UTedLevelSequenceDirector) == 0x000050, "Wrong size on UTedLevelSequenceDirector");
static_assert(offsetof(UTedLevelSequenceDirector, PlayingMovie) == 0x000048, "Member 'UTedLevelSequenceDirector::PlayingMovie' has a wrong offset!");

// Class Tempest.TedLobbyBeaconClient
// 0x00A8 (0x0460 - 0x03B8)
class ATedLobbyBeaconClient final : public ALobbyBeaconClient
{
public:
	ETedConnectionRejectReason                    RejectionReason;                                   // 0x03B8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B9[0x7];                                      // 0x03B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class FText& InKickReasonText)> OnNotifyClientKicked;        // 0x03C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 CachedServerPassword;                              // 0x03D0(0x0010)(Net, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E0[0x80];                                     // 0x03E0(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientLeaveLobby(const EClientLeaveLobbyReason InReason);
	void ClientStartGameFailed();
	void DebugUpdateHydraSession(const class FString& InMode);
	void NotifyClientKicked(const class FString& SessionId, bool bKickAll);
	void OnRep_AdminFromPlayerState();
	void RejectConnection(const ETedConnectionRejectReason InDisconnectType);
	void ServerAddBot();
	void ServerChangeLobbyMap(const class UTedMapInfo* InMap);
	void ServerChangeMemberSetting_FString(class ALobbyBeaconPlayerState* InMember, const ETedSessionMemberSettingKey InKey, const class FString& InValue);
	void ServerChangeMemberSetting_Int32(class ALobbyBeaconPlayerState* InMember, const ETedSessionMemberSettingKey InKey, const int32 InValue);
	void ServerChangePassword(const class FString& InLobbyPassword);
	void ServerChangeSessionSetting_Int32(const ETedSessionSettingKey InKey, const int32 InValue);
	void ServerChangeSessionSetting_String(const ETedSessionSettingKey InKey, const class FString& InValue);
	void ServerDevPrintSessionState();
	void ServerKickClient(const struct FUniqueNetIdRepl& PlayerToKick);
	void ServerRemoveBot(const struct FUniqueNetIdRepl& InBotID);
	void ServerStartGame();
	void ServerUpdateMemberDataInSessionAndLobby();

	struct FUniqueNetIdRepl GetUniqueNetId() const;
	bool IsAdmin() const;
	bool MatchesNetID(const struct FUniqueNetIdRepl& NetId) const;
	void ServerDebugSetNetSim(const TArray<class FString>& InArgs, class UWorld* InWorld) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedLobbyBeaconClient">();
	}
	static class ATedLobbyBeaconClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedLobbyBeaconClient>();
	}
};
static_assert(alignof(ATedLobbyBeaconClient) == 0x000008, "Wrong alignment on ATedLobbyBeaconClient");
static_assert(sizeof(ATedLobbyBeaconClient) == 0x000460, "Wrong size on ATedLobbyBeaconClient");
static_assert(offsetof(ATedLobbyBeaconClient, RejectionReason) == 0x0003B8, "Member 'ATedLobbyBeaconClient::RejectionReason' has a wrong offset!");
static_assert(offsetof(ATedLobbyBeaconClient, OnNotifyClientKicked) == 0x0003C0, "Member 'ATedLobbyBeaconClient::OnNotifyClientKicked' has a wrong offset!");
static_assert(offsetof(ATedLobbyBeaconClient, CachedServerPassword) == 0x0003D0, "Member 'ATedLobbyBeaconClient::CachedServerPassword' has a wrong offset!");

// Class Tempest.TedLobbyBeaconHost
// 0x0010 (0x0300 - 0x02F0)
class ATedLobbyBeaconHost final : public ALobbyBeaconHost
{
public:
	uint8                                         Pad_2F0[0x10];                                     // 0x02F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ServerKickClient(const struct FUniqueNetIdRepl& PlayerToKick, bool bKickAll);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedLobbyBeaconHost">();
	}
	static class ATedLobbyBeaconHost* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedLobbyBeaconHost>();
	}
};
static_assert(alignof(ATedLobbyBeaconHost) == 0x000008, "Wrong alignment on ATedLobbyBeaconHost");
static_assert(sizeof(ATedLobbyBeaconHost) == 0x000300, "Wrong size on ATedLobbyBeaconHost");

// Class Tempest.TedLobbyBeaconState
// 0x02B0 (0x06E8 - 0x0438)
class ATedLobbyBeaconState final : public ALobbyBeaconState
{
public:
	struct FTedSessionSettingArray                SessionSettings;                                   // 0x0438(0x0118)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FTedSessionMemberSettingsContainerArray MemberSettings;                                   // 0x0550(0x0118)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	class UTedMapInfo*                            SelectedMapInfo;                                   // 0x0668(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FLobbyStatusMemberData>         MembersData;                                       // 0x0670(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_680[0x60];                                     // 0x0680(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReplID;                                            // 0x06E0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6E4[0x4];                                      // 0x06E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_MemberData();
	void OnRep_MemberSettings();
	void OnRep_SelectedMapInfo();
	void OnRep_SessionSettings();

	int32 GetPlayersCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedLobbyBeaconState">();
	}
	static class ATedLobbyBeaconState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedLobbyBeaconState>();
	}
};
static_assert(alignof(ATedLobbyBeaconState) == 0x000008, "Wrong alignment on ATedLobbyBeaconState");
static_assert(sizeof(ATedLobbyBeaconState) == 0x0006E8, "Wrong size on ATedLobbyBeaconState");
static_assert(offsetof(ATedLobbyBeaconState, SessionSettings) == 0x000438, "Member 'ATedLobbyBeaconState::SessionSettings' has a wrong offset!");
static_assert(offsetof(ATedLobbyBeaconState, MemberSettings) == 0x000550, "Member 'ATedLobbyBeaconState::MemberSettings' has a wrong offset!");
static_assert(offsetof(ATedLobbyBeaconState, SelectedMapInfo) == 0x000668, "Member 'ATedLobbyBeaconState::SelectedMapInfo' has a wrong offset!");
static_assert(offsetof(ATedLobbyBeaconState, MembersData) == 0x000670, "Member 'ATedLobbyBeaconState::MembersData' has a wrong offset!");
static_assert(offsetof(ATedLobbyBeaconState, ReplID) == 0x0006E0, "Member 'ATedLobbyBeaconState::ReplID' has a wrong offset!");

// Class Tempest.TedPopupContext
// 0x0050 (0x0078 - 0x0028)
class UTedPopupContext : public UObject
{
public:
	class FText                                   HeaderText;                                        // 0x0028(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   BodyText;                                          // 0x0038(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FTedPopupButton>                Buttons;                                           // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FText                                   DropDownTitleText;                                 // 0x0058(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x10];                                      // 0x0068(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPopupContext">();
	}
	static class UTedPopupContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPopupContext>();
	}
};
static_assert(alignof(UTedPopupContext) == 0x000008, "Wrong alignment on UTedPopupContext");
static_assert(sizeof(UTedPopupContext) == 0x000078, "Wrong size on UTedPopupContext");
static_assert(offsetof(UTedPopupContext, HeaderText) == 0x000028, "Member 'UTedPopupContext::HeaderText' has a wrong offset!");
static_assert(offsetof(UTedPopupContext, BodyText) == 0x000038, "Member 'UTedPopupContext::BodyText' has a wrong offset!");
static_assert(offsetof(UTedPopupContext, Buttons) == 0x000048, "Member 'UTedPopupContext::Buttons' has a wrong offset!");
static_assert(offsetof(UTedPopupContext, DropDownTitleText) == 0x000058, "Member 'UTedPopupContext::DropDownTitleText' has a wrong offset!");

// Class Tempest.TedLobbyConfigurationPopupContext
// 0x0038 (0x00B0 - 0x0078)
class UTedLobbyConfigurationPopupContext final : public UTedPopupContext
{
public:
	struct FTedLobbyConfiguration                 Configuration;                                     // 0x0078(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedLobbyConfigurationPopupContext">();
	}
	static class UTedLobbyConfigurationPopupContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedLobbyConfigurationPopupContext>();
	}
};
static_assert(alignof(UTedLobbyConfigurationPopupContext) == 0x000008, "Wrong alignment on UTedLobbyConfigurationPopupContext");
static_assert(sizeof(UTedLobbyConfigurationPopupContext) == 0x0000B0, "Wrong size on UTedLobbyConfigurationPopupContext");
static_assert(offsetof(UTedLobbyConfigurationPopupContext, Configuration) == 0x000078, "Member 'UTedLobbyConfigurationPopupContext::Configuration' has a wrong offset!");

// Class Tempest.TedLobbyConfigurationPopup
// 0x0078 (0x0500 - 0x0488)
class UTedLobbyConfigurationPopup final : public UTedPopup
{
public:
	uint8                                         bUpdateLobbyNameOnTextChanged : 1;                 // 0x0488(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUpdateLobbyNameOnTextCommitted : 1;               // 0x0488(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUpdateLobbyPasswordOnTextChanged : 1;             // 0x0488(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUpdateLobbyPasswordOnTextCommitted : 1;           // 0x0488(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_489[0x7];                                      // 0x0489(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UEditableTextBox*                       Input_LobbyName;                                   // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEditableTextBox*                       Input_Password;                                    // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_PasswordIssue;                                // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedContentPanelInstanced*              LobbyTypeSelector;                                 // 0x04A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedContentPanelInstanced*              PasswordModeSelector;                              // 0x04B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                Button_ShowPassword;                               // 0x04B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCheckBox*                              Checkbox_AffectPassword;                           // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTedLobbyConfiguration                 Configuration;                                     // 0x04C8(0x0038)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)

public:
	void OnChangePasswordCheckboxChanged(bool bIsChecked);
	void OnLobbyNameChanged(const class FText& InText);
	void OnLobbyNameCommitted(const class FText& InText, ETextCommit InCommitMethod);
	void OnLobbyPasswordChanged(const class FText& InText);
	void OnLobbyPasswordCommitted(const class FText& InText, ETextCommit InCommitMethod);
	void OnShowPasswordButtonPressed();
	void OnShowPasswordButtonReleased();
	void OnTriggerLobbyTypeSlotAction(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction);
	void OnTriggerPasswordModeSlotAction(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction);
	bool SetAffectPassword(const bool bInAffectPassword);
	bool SetLobbyName(const class FString& InName);
	bool SetLobbyType(const ETedServerType InType);
	bool SetPassword(const class FString& InPassword);
	bool SetPasswordMode(const ETedLobbyPasswordMode InMode);
	void SetShowPassword(const bool bInShow);

	bool CanConfirm() const;
	bool DoesAffectPassword() const;
	ETedLobbyAffectPasswordMode GetAffectPasswordMode() const;
	const struct FTedLobbyConfiguration GetConfiguration() const;
	class FString GetLobbyName() const;
	class FText GetLobbyNameText() const;
	ETedServerType GetLobbyType() const;
	int32 GetLobbyTypeSlotIndex(const ETedServerType InType) const;
	class FString GetPassword() const;
	ETedLobbyPasswordMode GetPasswordMode() const;
	int32 GetPasswordModeSlotIndex(const ETedLobbyPasswordMode InMode) const;
	class FText GetPasswordText() const;
	bool IsLobbyTypeReadOnly() const;
	bool IsPasswordRequired() const;
	bool ShouldShowAffectPassword() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedLobbyConfigurationPopup">();
	}
	static class UTedLobbyConfigurationPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedLobbyConfigurationPopup>();
	}
};
static_assert(alignof(UTedLobbyConfigurationPopup) == 0x000008, "Wrong alignment on UTedLobbyConfigurationPopup");
static_assert(sizeof(UTedLobbyConfigurationPopup) == 0x000500, "Wrong size on UTedLobbyConfigurationPopup");
static_assert(offsetof(UTedLobbyConfigurationPopup, Input_LobbyName) == 0x000490, "Member 'UTedLobbyConfigurationPopup::Input_LobbyName' has a wrong offset!");
static_assert(offsetof(UTedLobbyConfigurationPopup, Input_Password) == 0x000498, "Member 'UTedLobbyConfigurationPopup::Input_Password' has a wrong offset!");
static_assert(offsetof(UTedLobbyConfigurationPopup, Text_PasswordIssue) == 0x0004A0, "Member 'UTedLobbyConfigurationPopup::Text_PasswordIssue' has a wrong offset!");
static_assert(offsetof(UTedLobbyConfigurationPopup, LobbyTypeSelector) == 0x0004A8, "Member 'UTedLobbyConfigurationPopup::LobbyTypeSelector' has a wrong offset!");
static_assert(offsetof(UTedLobbyConfigurationPopup, PasswordModeSelector) == 0x0004B0, "Member 'UTedLobbyConfigurationPopup::PasswordModeSelector' has a wrong offset!");
static_assert(offsetof(UTedLobbyConfigurationPopup, Button_ShowPassword) == 0x0004B8, "Member 'UTedLobbyConfigurationPopup::Button_ShowPassword' has a wrong offset!");
static_assert(offsetof(UTedLobbyConfigurationPopup, Checkbox_AffectPassword) == 0x0004C0, "Member 'UTedLobbyConfigurationPopup::Checkbox_AffectPassword' has a wrong offset!");
static_assert(offsetof(UTedLobbyConfigurationPopup, Configuration) == 0x0004C8, "Member 'UTedLobbyConfigurationPopup::Configuration' has a wrong offset!");

// Class Tempest.TedLobbyContentPanel
// 0x0018 (0x07C8 - 0x07B0)
class UTedLobbyContentPanel : public UTedContentPanelDynamic
{
public:
	uint8                                         bUseLobbyState : 1;                                // 0x07B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_7B1[0x7];                                      // 0x07B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ATedLobbyBeaconClient*                  ViewingClient;                                     // 0x07B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATedLobbyBeaconState*                   DisplayedLobbyState;                               // 0x07C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void K2_OnDisplayedLobbyStateChange(class ATedLobbyBeaconState* InOld, class ATedLobbyBeaconState* InNew);
	void K2_OnViewingClientChange(class ATedLobbyBeaconClient* InOld, class ATedLobbyBeaconClient* InNew);
	void SetDisplayedLobbyState(class ATedLobbyBeaconState* InLobbyState);
	void SetViewingClient(class ATedLobbyBeaconClient* InClient);

	class ATedLobbyBeaconClient* GetViewingClient() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedLobbyContentPanel">();
	}
	static class UTedLobbyContentPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedLobbyContentPanel>();
	}
};
static_assert(alignof(UTedLobbyContentPanel) == 0x000008, "Wrong alignment on UTedLobbyContentPanel");
static_assert(sizeof(UTedLobbyContentPanel) == 0x0007C8, "Wrong size on UTedLobbyContentPanel");
static_assert(offsetof(UTedLobbyContentPanel, ViewingClient) == 0x0007B8, "Member 'UTedLobbyContentPanel::ViewingClient' has a wrong offset!");
static_assert(offsetof(UTedLobbyContentPanel, DisplayedLobbyState) == 0x0007C0, "Member 'UTedLobbyContentPanel::DisplayedLobbyState' has a wrong offset!");

// Class Tempest.TedLobbyTypeFunctions
// 0x0000 (0x0028 - 0x0028)
class UTedLobbyTypeFunctions final : public UBlueprintFunctionLibrary
{
public:
	static const class FName GetContentID_LobbyType(const ETedServerType InType);
	static const class FName GetContentID_PasswordMode(const ETedLobbyPasswordMode InMode);
	static ETedServerType GetLobbyTypeFromContentID(const class FName& InID);
	static ETedLobbyPasswordMode GetPasswordModeFromContentID(const class FName& InID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedLobbyTypeFunctions">();
	}
	static class UTedLobbyTypeFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedLobbyTypeFunctions>();
	}
};
static_assert(alignof(UTedLobbyTypeFunctions) == 0x000008, "Wrong alignment on UTedLobbyTypeFunctions");
static_assert(sizeof(UTedLobbyTypeFunctions) == 0x000028, "Wrong size on UTedLobbyTypeFunctions");

// Class Tempest.TedMainMenuScreenProfileButton
// 0x0000 (0x0400 - 0x0400)
class UTedMainMenuScreenProfileButton final : public UTedUserWidget
{
public:
	class UImage* GetPlayerProfileAvatarImage();
	void OnProfileButtonClicked(class UTedUserWidget* InWidget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMainMenuScreenProfileButton">();
	}
	static class UTedMainMenuScreenProfileButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMainMenuScreenProfileButton>();
	}
};
static_assert(alignof(UTedMainMenuScreenProfileButton) == 0x000008, "Wrong alignment on UTedMainMenuScreenProfileButton");
static_assert(sizeof(UTedMainMenuScreenProfileButton) == 0x000400, "Wrong size on UTedMainMenuScreenProfileButton");

// Class Tempest.TedMainMenuScreen
// 0x0060 (0x04B8 - 0x0458)
class UTedMainMenuScreen final : public UTedMenuScreenWidget
{
public:
	TArray<struct FTedUserRating>                 CachedLocalPlayerRatings;                          // 0x0458(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UWidget* PageWidget, const class FName& PageName)> OnTabSelected; // 0x0468(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class FName>                           PagesToTriggerBlur;                                // 0x0478(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       WidgetAnim_BlurFade;                               // 0x0488(0x0008)(Edit, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOverlay*                               BlurOverlay;                                       // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTedContentPanelStatic*                 ButtonsPanel;                                      // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTedQrCodeWidget*                       QrCode;                                            // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTedMainMenuScreenProfileButton*        ProfileButton;                                     // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTedPopup*                              ExitGamePopup;                                     // 0x04B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UTedMainMenuScreen* Get(const class UObject* WorldContextObject);

	float GetCachedLocalPlayerRating(const ETedRankedTeam Team, const ETedRankedFaction Faction);
	void K2_OnLocalPlayerRatingsReceived();
	void OnActivateMultiplayerTab();
	void OnButtonsPanelActivateSlotState(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotState InState, bool bInActivated);
	void OnPageVisibilityChanged(ESlateVisibility InVisibility);
	void OnPreorderSettingChanged(const class FName& SettingChanged);
	void ShowQuitGamePopUp();

	class UWidget* GetCurrentOpenPage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMainMenuScreen">();
	}
	static class UTedMainMenuScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMainMenuScreen>();
	}
};
static_assert(alignof(UTedMainMenuScreen) == 0x000008, "Wrong alignment on UTedMainMenuScreen");
static_assert(sizeof(UTedMainMenuScreen) == 0x0004B8, "Wrong size on UTedMainMenuScreen");
static_assert(offsetof(UTedMainMenuScreen, CachedLocalPlayerRatings) == 0x000458, "Member 'UTedMainMenuScreen::CachedLocalPlayerRatings' has a wrong offset!");
static_assert(offsetof(UTedMainMenuScreen, OnTabSelected) == 0x000468, "Member 'UTedMainMenuScreen::OnTabSelected' has a wrong offset!");
static_assert(offsetof(UTedMainMenuScreen, PagesToTriggerBlur) == 0x000478, "Member 'UTedMainMenuScreen::PagesToTriggerBlur' has a wrong offset!");
static_assert(offsetof(UTedMainMenuScreen, WidgetAnim_BlurFade) == 0x000488, "Member 'UTedMainMenuScreen::WidgetAnim_BlurFade' has a wrong offset!");
static_assert(offsetof(UTedMainMenuScreen, BlurOverlay) == 0x000490, "Member 'UTedMainMenuScreen::BlurOverlay' has a wrong offset!");
static_assert(offsetof(UTedMainMenuScreen, ButtonsPanel) == 0x000498, "Member 'UTedMainMenuScreen::ButtonsPanel' has a wrong offset!");
static_assert(offsetof(UTedMainMenuScreen, QrCode) == 0x0004A0, "Member 'UTedMainMenuScreen::QrCode' has a wrong offset!");
static_assert(offsetof(UTedMainMenuScreen, ProfileButton) == 0x0004A8, "Member 'UTedMainMenuScreen::ProfileButton' has a wrong offset!");
static_assert(offsetof(UTedMainMenuScreen, ExitGamePopup) == 0x0004B0, "Member 'UTedMainMenuScreen::ExitGamePopup' has a wrong offset!");

// Class Tempest.TedMapContentPanel
// 0x0010 (0x07C0 - 0x07B0)
class UTedMapContentPanel final : public UTedContentPanelDynamic
{
public:
	TArray<class FName>                           content;                                           // 0x07B0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void OpenBriefingLevel(const int32 InSlotIndex);
	void OpenLevel(const int32 InSlotIndex, const ETedGameDifficulty Difficulty);

	bool GetContent(const int32 InSlotIndex, class FName* OutContent) const;
	const class UTedMapInfo* GetContentMapInfo(const int32 InSlotIndex, class FName* OutMapName) const;
	bool HasBriefing(const int32 InSlotIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMapContentPanel">();
	}
	static class UTedMapContentPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMapContentPanel>();
	}
};
static_assert(alignof(UTedMapContentPanel) == 0x000008, "Wrong alignment on UTedMapContentPanel");
static_assert(sizeof(UTedMapContentPanel) == 0x0007C0, "Wrong size on UTedMapContentPanel");
static_assert(offsetof(UTedMapContentPanel, content) == 0x0007B0, "Member 'UTedMapContentPanel::content' has a wrong offset!");

// Class Tempest.TedMapInfoPanel
// 0x0040 (0x07F0 - 0x07B0)
class UTedMapInfoPanel : public UTedContentPanelDynamic
{
public:
	struct FInt32Range                            HumanNumFilter;                                    // 0x07B0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTedMapInfo*>                    content;                                           // 0x07C0(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TArray<class UTedMapInfo*>                    FilteredContent;                                   // 0x07D0(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	class FString                                 FilterString;                                      // 0x07E0(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ClearFilterString();
	void SetFilterString(const class FString& InFilter);
	void SetHumanNumFilter(const struct FInt32Range& InRange);

	const class UTedMapInfo* GetContent(const int32 InSlotIndex) const;
	const class UTedMapInfo* GetContentByState(const ETedContentSlotState InState, const int32 InIndex) const;
	const struct FInt32Range GetHumanNumFilter() const;
	const class UTedMapInfo* GetSelectedContent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMapInfoPanel">();
	}
	static class UTedMapInfoPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMapInfoPanel>();
	}
};
static_assert(alignof(UTedMapInfoPanel) == 0x000008, "Wrong alignment on UTedMapInfoPanel");
static_assert(sizeof(UTedMapInfoPanel) == 0x0007F0, "Wrong size on UTedMapInfoPanel");
static_assert(offsetof(UTedMapInfoPanel, HumanNumFilter) == 0x0007B0, "Member 'UTedMapInfoPanel::HumanNumFilter' has a wrong offset!");
static_assert(offsetof(UTedMapInfoPanel, content) == 0x0007C0, "Member 'UTedMapInfoPanel::content' has a wrong offset!");
static_assert(offsetof(UTedMapInfoPanel, FilteredContent) == 0x0007D0, "Member 'UTedMapInfoPanel::FilteredContent' has a wrong offset!");
static_assert(offsetof(UTedMapInfoPanel, FilterString) == 0x0007E0, "Member 'UTedMapInfoPanel::FilterString' has a wrong offset!");

// Class Tempest.TedMapInfoPanelMissionSelect
// 0x0000 (0x07F0 - 0x07F0)
class UTedMapInfoPanelMissionSelect final : public UTedMapInfoPanel
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMapInfoPanelMissionSelect">();
	}
	static class UTedMapInfoPanelMissionSelect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMapInfoPanelMissionSelect>();
	}
};
static_assert(alignof(UTedMapInfoPanelMissionSelect) == 0x000008, "Wrong alignment on UTedMapInfoPanelMissionSelect");
static_assert(sizeof(UTedMapInfoPanelMissionSelect) == 0x0007F0, "Wrong size on UTedMapInfoPanelMissionSelect");

// Class Tempest.TedMapInfoPanelRanked
// 0x0038 (0x0828 - 0x07F0)
class UTedMapInfoPanelRanked final : public UTedMapInfoPanel
{
public:
	uint8                                         Pad_7F0[0x20];                                     // 0x07F0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(int32 VetosLeft)> OnVetosUpdated;                                  // 0x0810(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         MinPlayers;                                        // 0x0820(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_824[0x4];                                      // 0x0824(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DecVetos();
	bool IncVetos();
	bool LoadMapState(const class UTedMapInfo* InMapInfo);
	void RefreshMapStates();
	bool SaveAllowedMapsForSession();
	void SetMultiplayerCurrentData(ETedServerType ServerType, ETedRankedTeam TeamType);
	bool UpdateMapState(const class UTedMapInfo* InMapInfo, const bool InChecked);

	int32 GetMaxVetos() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMapInfoPanelRanked">();
	}
	static class UTedMapInfoPanelRanked* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMapInfoPanelRanked>();
	}
};
static_assert(alignof(UTedMapInfoPanelRanked) == 0x000008, "Wrong alignment on UTedMapInfoPanelRanked");
static_assert(sizeof(UTedMapInfoPanelRanked) == 0x000828, "Wrong size on UTedMapInfoPanelRanked");
static_assert(offsetof(UTedMapInfoPanelRanked, OnVetosUpdated) == 0x000810, "Member 'UTedMapInfoPanelRanked::OnVetosUpdated' has a wrong offset!");
static_assert(offsetof(UTedMapInfoPanelRanked, MinPlayers) == 0x000820, "Member 'UTedMapInfoPanelRanked::MinPlayers' has a wrong offset!");

// Class Tempest.TedMarkerFunctionsLibrary
// 0x0000 (0x0028 - 0x0028)
class UTedMarkerFunctionsLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FTedMarkerHandle AddMarkerAtLocation(const class UObject* WorldContext, const class UTedMarkerConfig* Config, const struct FVector& Location);
	static struct FTedMarkerHandle AddMarkerAttached(const class UObject* WorldContext, const class UTedMarkerConfig* Config, const class AActor* Target);
	static bool RemoveMarkerByHandle(const class UObject* WorldContext, const struct FTedMarkerHandle& Handle);
	static bool RemoveMarkerByTarget(const class UObject* WorldContext, const class AActor* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMarkerFunctionsLibrary">();
	}
	static class UTedMarkerFunctionsLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMarkerFunctionsLibrary>();
	}
};
static_assert(alignof(UTedMarkerFunctionsLibrary) == 0x000008, "Wrong alignment on UTedMarkerFunctionsLibrary");
static_assert(sizeof(UTedMarkerFunctionsLibrary) == 0x000028, "Wrong size on UTedMarkerFunctionsLibrary");

// Class Tempest.TedMarkerOverlayWidget
// 0x0030 (0x0430 - 0x0400)
class UTedMarkerOverlayWidget : public UTedUserWidget
{
public:
	struct FFloatRange                            AnimRange;                                         // 0x0400(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimDuration;                                      // 0x0410(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEasingFunc                                   AnimFunc;                                          // 0x0414(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_415[0x3];                                      // 0x0415(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimFuncExp;                                       // 0x0418(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AnimFuncSteps;                                     // 0x041C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTedMarkerOverlayInstanceData>  InstancesData;                                     // 0x0420(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMarkerOverlayWidget">();
	}
	static class UTedMarkerOverlayWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMarkerOverlayWidget>();
	}
};
static_assert(alignof(UTedMarkerOverlayWidget) == 0x000008, "Wrong alignment on UTedMarkerOverlayWidget");
static_assert(sizeof(UTedMarkerOverlayWidget) == 0x000430, "Wrong size on UTedMarkerOverlayWidget");
static_assert(offsetof(UTedMarkerOverlayWidget, AnimRange) == 0x000400, "Member 'UTedMarkerOverlayWidget::AnimRange' has a wrong offset!");
static_assert(offsetof(UTedMarkerOverlayWidget, AnimDuration) == 0x000410, "Member 'UTedMarkerOverlayWidget::AnimDuration' has a wrong offset!");
static_assert(offsetof(UTedMarkerOverlayWidget, AnimFunc) == 0x000414, "Member 'UTedMarkerOverlayWidget::AnimFunc' has a wrong offset!");
static_assert(offsetof(UTedMarkerOverlayWidget, AnimFuncExp) == 0x000418, "Member 'UTedMarkerOverlayWidget::AnimFuncExp' has a wrong offset!");
static_assert(offsetof(UTedMarkerOverlayWidget, AnimFuncSteps) == 0x00041C, "Member 'UTedMarkerOverlayWidget::AnimFuncSteps' has a wrong offset!");
static_assert(offsetof(UTedMarkerOverlayWidget, InstancesData) == 0x000420, "Member 'UTedMarkerOverlayWidget::InstancesData' has a wrong offset!");

// Class Tempest.TedMarkerShapeActor_Spline
// 0x00C0 (0x0370 - 0x02B0)
class ATedMarkerShapeActor_Spline final : public ATedMarkerShapeActor
{
public:
	class USplineComponent*                       Spline;                                            // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FLinearColor> Colors;                                           // 0x02B8(0x0050)(Edit, Config, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FLinearColor> ThemeColors;                                      // 0x0308(0x0050)(Edit, Config, Protected, NativeAccessSpecifierProtected)
	ETedMarkerShapeSplineArrowMode                Arrow;                                             // 0x0358(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDrawMarkerIcon : 1;                               // 0x0359(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_35A[0x2];                                      // 0x035A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           CurrentColor;                                      // 0x035C(0x0010)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36C[0x4];                                      // 0x036C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMarkerShapeActor_Spline">();
	}
	static class ATedMarkerShapeActor_Spline* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedMarkerShapeActor_Spline>();
	}
};
static_assert(alignof(ATedMarkerShapeActor_Spline) == 0x000008, "Wrong alignment on ATedMarkerShapeActor_Spline");
static_assert(sizeof(ATedMarkerShapeActor_Spline) == 0x000370, "Wrong size on ATedMarkerShapeActor_Spline");
static_assert(offsetof(ATedMarkerShapeActor_Spline, Spline) == 0x0002B0, "Member 'ATedMarkerShapeActor_Spline::Spline' has a wrong offset!");
static_assert(offsetof(ATedMarkerShapeActor_Spline, Colors) == 0x0002B8, "Member 'ATedMarkerShapeActor_Spline::Colors' has a wrong offset!");
static_assert(offsetof(ATedMarkerShapeActor_Spline, ThemeColors) == 0x000308, "Member 'ATedMarkerShapeActor_Spline::ThemeColors' has a wrong offset!");
static_assert(offsetof(ATedMarkerShapeActor_Spline, Arrow) == 0x000358, "Member 'ATedMarkerShapeActor_Spline::Arrow' has a wrong offset!");
static_assert(offsetof(ATedMarkerShapeActor_Spline, CurrentColor) == 0x00035C, "Member 'ATedMarkerShapeActor_Spline::CurrentColor' has a wrong offset!");

// Class Tempest.TedMarkerSubsystem
// 0x00B0 (0x00E0 - 0x0030)
class UTedMarkerSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x30];                                      // 0x0030(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTedMarker>                     Markers;                                           // 0x0060(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           TH_NotifyMarkersChange;                            // 0x0070(0x0008)(Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FTedMarkerHandle, struct FTimerHandle> AutoDeletTimerHandles;                        // 0x0078(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TArray<class UTedMarkerConfig*>               NonTrackedMarkers;                                 // 0x00C8(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           TH_NotifyMarkersVisibilityChange;                  // 0x00D8(0x0008)(Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMarkerSubsystem">();
	}
	static class UTedMarkerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMarkerSubsystem>();
	}
};
static_assert(alignof(UTedMarkerSubsystem) == 0x000008, "Wrong alignment on UTedMarkerSubsystem");
static_assert(sizeof(UTedMarkerSubsystem) == 0x0000E0, "Wrong size on UTedMarkerSubsystem");
static_assert(offsetof(UTedMarkerSubsystem, Markers) == 0x000060, "Member 'UTedMarkerSubsystem::Markers' has a wrong offset!");
static_assert(offsetof(UTedMarkerSubsystem, TH_NotifyMarkersChange) == 0x000070, "Member 'UTedMarkerSubsystem::TH_NotifyMarkersChange' has a wrong offset!");
static_assert(offsetof(UTedMarkerSubsystem, AutoDeletTimerHandles) == 0x000078, "Member 'UTedMarkerSubsystem::AutoDeletTimerHandles' has a wrong offset!");
static_assert(offsetof(UTedMarkerSubsystem, NonTrackedMarkers) == 0x0000C8, "Member 'UTedMarkerSubsystem::NonTrackedMarkers' has a wrong offset!");
static_assert(offsetof(UTedMarkerSubsystem, TH_NotifyMarkersVisibilityChange) == 0x0000D8, "Member 'UTedMarkerSubsystem::TH_NotifyMarkersVisibilityChange' has a wrong offset!");

// Class Tempest.TedMarkerTargetInterface
// 0x0000 (0x0000 - 0x0000)
class ITedMarkerTargetInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMarkerTargetInterface">();
	}
	static class ITedMarkerTargetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITedMarkerTargetInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITedMarkerTargetInterface) == 0x000001, "Wrong alignment on ITedMarkerTargetInterface");
static_assert(sizeof(ITedMarkerTargetInterface) == 0x000001, "Wrong size on ITedMarkerTargetInterface");

// Class Tempest.TedMatchHistorySlot_Expansion
// 0x0000 (0x0400 - 0x0400)
class UTedMatchHistorySlot_Expansion final : public UTedUserWidget
{
public:
	void K2_DescribePlayerPortrait(class UTexture2D* InPortrait, const class FString& InHydraId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMatchHistorySlot_Expansion">();
	}
	static class UTedMatchHistorySlot_Expansion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMatchHistorySlot_Expansion>();
	}
};
static_assert(alignof(UTedMatchHistorySlot_Expansion) == 0x000008, "Wrong alignment on UTedMatchHistorySlot_Expansion");
static_assert(sizeof(UTedMatchHistorySlot_Expansion) == 0x000400, "Wrong size on UTedMatchHistorySlot_Expansion");

// Class Tempest.TedMatchHistorySlot
// 0x0028 (0x0458 - 0x0430)
class UTedMatchHistorySlot final : public UTedContentPanelSlotButton
{
public:
	uint8                                         Pad_430[0x20];                                     // 0x0430(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedMatchHistorySlot_Expansion*         CachedExpansionSlot;                               // 0x0450(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void K2_DescribeDate(const struct FDateTime& Time);
	void K2_DescribeFaction(const ETedFaction Faction);
	void K2_DescribeMap(const class UTedMapInfo* Map);
	void K2_DescribeMatchName(const class FText& MatchName);
	void K2_DescribeServerType(const ETedServerType ServerType);
	void K2_DescribeTeamType(const ETedRankedTeam Team);
	void K2_DescribeTimespan(const struct FTimespan& Time);
	void K2_DescribeVictoryOrDefeat(const bool bVictory);
	TArray<struct FTedMatchHistorySlot_Expansion_PlayerContent> MakeContentForExpansion();
	void RequestUserInfosForExpansionContent(const TArray<struct FTedMatchHistorySlot_Expansion_PlayerContent>& InContent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMatchHistorySlot">();
	}
	static class UTedMatchHistorySlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMatchHistorySlot>();
	}
};
static_assert(alignof(UTedMatchHistorySlot) == 0x000008, "Wrong alignment on UTedMatchHistorySlot");
static_assert(sizeof(UTedMatchHistorySlot) == 0x000458, "Wrong size on UTedMatchHistorySlot");
static_assert(offsetof(UTedMatchHistorySlot, CachedExpansionSlot) == 0x000450, "Member 'UTedMatchHistorySlot::CachedExpansionSlot' has a wrong offset!");

// Class Tempest.TedMedalsLibrary
// 0x0000 (0x0028 - 0x0028)
class UTedMedalsLibrary final : public UBlueprintFunctionLibrary
{
public:
	static const struct FTedMedalTableRow_Ranked GetMedalByRating(const float InRating, const ETedFaction InFaction, bool* bOutSuccess);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMedalsLibrary">();
	}
	static class UTedMedalsLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMedalsLibrary>();
	}
};
static_assert(alignof(UTedMedalsLibrary) == 0x000008, "Wrong alignment on UTedMedalsLibrary");
static_assert(sizeof(UTedMedalsLibrary) == 0x000028, "Wrong size on UTedMedalsLibrary");

// Class Tempest.TedMedalsScreen
// 0x00F0 (0x0548 - 0x0458)
class UTedMedalsScreen : public UTedMenuScreenWidget
{
public:
	class UTedContentPanelInstanced*              ButtonsPanel;                                      // 0x0458(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedMedalsScreenContextObject*          Context;                                           // 0x0460(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayMainMedalAnimations;                          // 0x0468(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlaySideMedalAnimations;                          // 0x0469(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_46A[0x2];                                      // 0x046A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SwitchMedalDelay;                                  // 0x046C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentMedalIndex;                                 // 0x0470(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_474[0x24];                                     // 0x0474(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             CurrentMedalsDatatable;                            // 0x0498(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A0[0x8];                                      // 0x04A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETedFaction, class UDataTable*>          MainMedalDatatables;                               // 0x04A8(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<ETedFaction, class UDataTable*>          SideMedalDatatables;                               // 0x04F8(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	class UTexture2D* GetFirstMedalOfType(const ETedMedalsType Type);
	void K2_OnAllMedalAnimationsFinished();
	void K2_OnSwitchMainMedal(int32 NewMedalIndex, const struct FTedMedalTableRow& DataRow, bool bIsLastMedal);
	void K2_OnSwitchSideMedal(int32 NewMedalIndex, const struct FTedMedalTableRow& DataRow, bool bIsLastMedal);
	void OnButtonActivatedState(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotState InState, bool bInActivated);
	void SetMedalAnimationTimerDelay(float InDelay);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMedalsScreen">();
	}
	static class UTedMedalsScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMedalsScreen>();
	}
};
static_assert(alignof(UTedMedalsScreen) == 0x000008, "Wrong alignment on UTedMedalsScreen");
static_assert(sizeof(UTedMedalsScreen) == 0x000548, "Wrong size on UTedMedalsScreen");
static_assert(offsetof(UTedMedalsScreen, ButtonsPanel) == 0x000458, "Member 'UTedMedalsScreen::ButtonsPanel' has a wrong offset!");
static_assert(offsetof(UTedMedalsScreen, Context) == 0x000460, "Member 'UTedMedalsScreen::Context' has a wrong offset!");
static_assert(offsetof(UTedMedalsScreen, bPlayMainMedalAnimations) == 0x000468, "Member 'UTedMedalsScreen::bPlayMainMedalAnimations' has a wrong offset!");
static_assert(offsetof(UTedMedalsScreen, bPlaySideMedalAnimations) == 0x000469, "Member 'UTedMedalsScreen::bPlaySideMedalAnimations' has a wrong offset!");
static_assert(offsetof(UTedMedalsScreen, SwitchMedalDelay) == 0x00046C, "Member 'UTedMedalsScreen::SwitchMedalDelay' has a wrong offset!");
static_assert(offsetof(UTedMedalsScreen, CurrentMedalIndex) == 0x000470, "Member 'UTedMedalsScreen::CurrentMedalIndex' has a wrong offset!");
static_assert(offsetof(UTedMedalsScreen, CurrentMedalsDatatable) == 0x000498, "Member 'UTedMedalsScreen::CurrentMedalsDatatable' has a wrong offset!");
static_assert(offsetof(UTedMedalsScreen, MainMedalDatatables) == 0x0004A8, "Member 'UTedMedalsScreen::MainMedalDatatables' has a wrong offset!");
static_assert(offsetof(UTedMedalsScreen, SideMedalDatatables) == 0x0004F8, "Member 'UTedMedalsScreen::SideMedalDatatables' has a wrong offset!");

// Class Tempest.TedMedalsScreen_Ranked
// 0x0028 (0x0570 - 0x0548)
class UTedMedalsScreen_Ranked final : public UTedMedalsScreen
{
public:
	class UTedLeaderboardPlayersPanel_V2*         Leaderboards;                                      // 0x0548(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTedUserWidget*                         Text_VictoryDefeat;                                // 0x0550(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             Text_RatingAddition;                               // 0x0558(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTedContentPanelInstanced*              PlayerContextButtonsPanel;                         // 0x0560(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RatingDifference;                                  // 0x0568(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rating;                                            // 0x056C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMedalsScreen_Ranked">();
	}
	static class UTedMedalsScreen_Ranked* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMedalsScreen_Ranked>();
	}
};
static_assert(alignof(UTedMedalsScreen_Ranked) == 0x000008, "Wrong alignment on UTedMedalsScreen_Ranked");
static_assert(sizeof(UTedMedalsScreen_Ranked) == 0x000570, "Wrong size on UTedMedalsScreen_Ranked");
static_assert(offsetof(UTedMedalsScreen_Ranked, Leaderboards) == 0x000548, "Member 'UTedMedalsScreen_Ranked::Leaderboards' has a wrong offset!");
static_assert(offsetof(UTedMedalsScreen_Ranked, Text_VictoryDefeat) == 0x000550, "Member 'UTedMedalsScreen_Ranked::Text_VictoryDefeat' has a wrong offset!");
static_assert(offsetof(UTedMedalsScreen_Ranked, Text_RatingAddition) == 0x000558, "Member 'UTedMedalsScreen_Ranked::Text_RatingAddition' has a wrong offset!");
static_assert(offsetof(UTedMedalsScreen_Ranked, PlayerContextButtonsPanel) == 0x000560, "Member 'UTedMedalsScreen_Ranked::PlayerContextButtonsPanel' has a wrong offset!");
static_assert(offsetof(UTedMedalsScreen_Ranked, RatingDifference) == 0x000568, "Member 'UTedMedalsScreen_Ranked::RatingDifference' has a wrong offset!");
static_assert(offsetof(UTedMedalsScreen_Ranked, Rating) == 0x00056C, "Member 'UTedMedalsScreen_Ranked::Rating' has a wrong offset!");

// Class Tempest.TedMedalsScreen_SP
// 0x0010 (0x0558 - 0x0548)
class UTedMedalsScreen_SP : public UTedMedalsScreen
{
public:
	int32                                         CurrentSelectedIndex;                              // 0x0548(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CachedAmountOfSucceededMainObjectives;             // 0x054C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CachedAmountOfSucceededSideObjectives;             // 0x0550(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_554[0x4];                                      // 0x0554(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMedalsScreen_SP">();
	}
	static class UTedMedalsScreen_SP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMedalsScreen_SP>();
	}
};
static_assert(alignof(UTedMedalsScreen_SP) == 0x000008, "Wrong alignment on UTedMedalsScreen_SP");
static_assert(sizeof(UTedMedalsScreen_SP) == 0x000558, "Wrong size on UTedMedalsScreen_SP");
static_assert(offsetof(UTedMedalsScreen_SP, CurrentSelectedIndex) == 0x000548, "Member 'UTedMedalsScreen_SP::CurrentSelectedIndex' has a wrong offset!");
static_assert(offsetof(UTedMedalsScreen_SP, CachedAmountOfSucceededMainObjectives) == 0x00054C, "Member 'UTedMedalsScreen_SP::CachedAmountOfSucceededMainObjectives' has a wrong offset!");
static_assert(offsetof(UTedMedalsScreen_SP, CachedAmountOfSucceededSideObjectives) == 0x000550, "Member 'UTedMedalsScreen_SP::CachedAmountOfSucceededSideObjectives' has a wrong offset!");

// Class Tempest.TedMeshWidget
// 0x0078 (0x0478 - 0x0400)
class UTedMeshWidget final : public UTedUserWidget
{
public:
	struct FGameplayTag                           TargetTag;                                         // 0x0400(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MeshDisplayMaterialTextureParam;                   // 0x0408(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_MeshDisplay;                                 // 0x0410(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class ATedMeshWidgetActor*>              RelevantMeshWidgetActors;                          // 0x0418(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           PendingUpdateRenderTargetHandle;                   // 0x0468(0x0008)(Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATedMeshWidgetActor*                    ShowingMeshWidgetActor;                            // 0x0470(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddRelevantMeshWidgetActor(class ATedMeshWidgetActor* InActor);
	void OnMeshWidgetEndPlay(class AActor* InActor, EEndPlayReason InEndPlayReason);
	void RemoveRelevantMeshWidgetActor(class ATedMeshWidgetActor* InActor);

	class UObject* GetShowingMeshWidgetActorContextObject() const;
	bool IsDisplayingAnything() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMeshWidget">();
	}
	static class UTedMeshWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMeshWidget>();
	}
};
static_assert(alignof(UTedMeshWidget) == 0x000008, "Wrong alignment on UTedMeshWidget");
static_assert(sizeof(UTedMeshWidget) == 0x000478, "Wrong size on UTedMeshWidget");
static_assert(offsetof(UTedMeshWidget, TargetTag) == 0x000400, "Member 'UTedMeshWidget::TargetTag' has a wrong offset!");
static_assert(offsetof(UTedMeshWidget, MeshDisplayMaterialTextureParam) == 0x000408, "Member 'UTedMeshWidget::MeshDisplayMaterialTextureParam' has a wrong offset!");
static_assert(offsetof(UTedMeshWidget, Image_MeshDisplay) == 0x000410, "Member 'UTedMeshWidget::Image_MeshDisplay' has a wrong offset!");
static_assert(offsetof(UTedMeshWidget, RelevantMeshWidgetActors) == 0x000418, "Member 'UTedMeshWidget::RelevantMeshWidgetActors' has a wrong offset!");
static_assert(offsetof(UTedMeshWidget, PendingUpdateRenderTargetHandle) == 0x000468, "Member 'UTedMeshWidget::PendingUpdateRenderTargetHandle' has a wrong offset!");
static_assert(offsetof(UTedMeshWidget, ShowingMeshWidgetActor) == 0x000470, "Member 'UTedMeshWidget::ShowingMeshWidgetActor' has a wrong offset!");

// Class Tempest.TedMeshWidgetActorCaptureComponent
// 0x0010 (0x0B10 - 0x0B00)
class UTedMeshWidgetActorCaptureComponent final : public USceneCaptureComponent2D
{
public:
	struct FGameplayTag                           TargetTag;                                         // 0x0B00(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B08[0x8];                                      // 0x0B08(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMeshWidgetActorCaptureComponent">();
	}
	static class UTedMeshWidgetActorCaptureComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMeshWidgetActorCaptureComponent>();
	}
};
static_assert(alignof(UTedMeshWidgetActorCaptureComponent) == 0x000010, "Wrong alignment on UTedMeshWidgetActorCaptureComponent");
static_assert(sizeof(UTedMeshWidgetActorCaptureComponent) == 0x000B10, "Wrong size on UTedMeshWidgetActorCaptureComponent");
static_assert(offsetof(UTedMeshWidgetActorCaptureComponent, TargetTag) == 0x000B00, "Member 'UTedMeshWidgetActorCaptureComponent::TargetTag' has a wrong offset!");

// Class Tempest.TedMineActor
// 0x0100 (0x17B0 - 0x16B0)
class ATedMineActor final : public ATedPawn
{
public:
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x16A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<TSubclassOf<class UNavArea>>             InvalidNavAreas;                                   // 0x16B0(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  BlacklistFactoryTypeTags;                          // 0x1700(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  BlacklistEntityTags;                               // 0x1720(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  BlacklistGameplayTags;                             // 0x1740(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         DelayBeforeArmed;                                  // 0x1760(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OverlapRadius;                                     // 0x1764(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bArmed : 1;                                        // 0x1768(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1769[0x3F];                                    // 0x1769(0x003F)(Fixing Size After Last Property [ Dumper-7 ])
	class ATedPawn*                               CachedriggerPawn;                                  // 0x17A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Arm();
	void Disarm(class AActor* DisarmingActor);
	void NetMulticast_TriggeredBy(class ATedPawn* TriggerPawn);
	void OnRep_Armed();
	void ReceiveArmedChanged(const bool bNewArmed);
	void ReceiveTriggeredBy(class ATedPawn* TriggerPawn);
	void TriggerMine(class ATedPawn* TriggerPawn);

	bool CanTrigger(const class ATedPawn* Pawn) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMineActor">();
	}
	static class ATedMineActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedMineActor>();
	}
};
static_assert(alignof(ATedMineActor) == 0x000010, "Wrong alignment on ATedMineActor");
static_assert(sizeof(ATedMineActor) == 0x0017B0, "Wrong size on ATedMineActor");
static_assert(offsetof(ATedMineActor, CapsuleComponent) == 0x0016A8, "Member 'ATedMineActor::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(ATedMineActor, InvalidNavAreas) == 0x0016B0, "Member 'ATedMineActor::InvalidNavAreas' has a wrong offset!");
static_assert(offsetof(ATedMineActor, BlacklistFactoryTypeTags) == 0x001700, "Member 'ATedMineActor::BlacklistFactoryTypeTags' has a wrong offset!");
static_assert(offsetof(ATedMineActor, BlacklistEntityTags) == 0x001720, "Member 'ATedMineActor::BlacklistEntityTags' has a wrong offset!");
static_assert(offsetof(ATedMineActor, BlacklistGameplayTags) == 0x001740, "Member 'ATedMineActor::BlacklistGameplayTags' has a wrong offset!");
static_assert(offsetof(ATedMineActor, DelayBeforeArmed) == 0x001760, "Member 'ATedMineActor::DelayBeforeArmed' has a wrong offset!");
static_assert(offsetof(ATedMineActor, OverlapRadius) == 0x001764, "Member 'ATedMineActor::OverlapRadius' has a wrong offset!");
static_assert(offsetof(ATedMineActor, CachedriggerPawn) == 0x0017A8, "Member 'ATedMineActor::CachedriggerPawn' has a wrong offset!");

// Class Tempest.TedMinimapMarkerConfig
// 0x00E0 (0x0210 - 0x0130)
class UTedMinimapMarkerConfig : public UTedMarkerConfig
{
public:
	struct FMinimapMarkerData                     MinimapMarkerData;                                 // 0x0130(0x00E0)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	const struct FMinimapMarkerData GetMinimapMarkerData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMinimapMarkerConfig">();
	}
	static class UTedMinimapMarkerConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMinimapMarkerConfig>();
	}
};
static_assert(alignof(UTedMinimapMarkerConfig) == 0x000010, "Wrong alignment on UTedMinimapMarkerConfig");
static_assert(sizeof(UTedMinimapMarkerConfig) == 0x000210, "Wrong size on UTedMinimapMarkerConfig");
static_assert(offsetof(UTedMinimapMarkerConfig, MinimapMarkerData) == 0x000130, "Member 'UTedMinimapMarkerConfig::MinimapMarkerData' has a wrong offset!");

// Class Tempest.TedObjectiveMinimapMarkerConfig
// 0x00D0 (0x02E0 - 0x0210)
class UTedObjectiveMinimapMarkerConfig final : public UTedMinimapMarkerConfig
{
public:
	struct FSlateBrush                            ListBrush;                                         // 0x0210(0x00D0)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	const struct FSlateBrush GetListBrush() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveMinimapMarkerConfig">();
	}
	static class UTedObjectiveMinimapMarkerConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveMinimapMarkerConfig>();
	}
};
static_assert(alignof(UTedObjectiveMinimapMarkerConfig) == 0x000010, "Wrong alignment on UTedObjectiveMinimapMarkerConfig");
static_assert(sizeof(UTedObjectiveMinimapMarkerConfig) == 0x0002E0, "Wrong size on UTedObjectiveMinimapMarkerConfig");
static_assert(offsetof(UTedObjectiveMinimapMarkerConfig, ListBrush) == 0x000210, "Member 'UTedObjectiveMinimapMarkerConfig::ListBrush' has a wrong offset!");

// Class Tempest.TedMinimapWidget
// 0x0370 (0x0770 - 0x0400)
class UTedMinimapWidget : public UTedUserWidget
{
public:
	class UTexture2D*                             OfflineMinimapTexture;                             // 0x0400(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     MinimapMaterial;                                   // 0x0408(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinimapWidth;                                      // 0x0410(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinimapHeight;                                     // 0x0414(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDrawUnits : 1;                                    // 0x0418(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDrawStructures : 1;                               // 0x0418(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDrawFogOfWar : 1;                                 // 0x0418(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDrawFrustum : 1;                                  // 0x0418(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDrawTerrain : 1;                                  // 0x0418(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDrawMapMarkers : 1;                               // 0x0418(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDrawResources : 1;                                // 0x0418(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_419[0x7];                                      // 0x0419(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            UnitBrush;                                         // 0x0420(0x00D0)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            StructureBrush;                                    // 0x04F0(0x00D0)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            ResourceBrush;                                     // 0x05C0(0x00D0)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         DamageFlashDuration;                               // 0x0690(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_694[0x4];                                      // 0x0694(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              ShowSound;                                         // 0x0698(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              HideSound;                                         // 0x06A0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTedAnnouncement>           ShowAnnouncement;                                  // 0x06A8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTedAnnouncement>           HideAnnouncement;                                  // 0x06B0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               MinimapTextureMID;                                 // 0x06B8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             CachedMinimapTexture;                              // 0x06C0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 MinimapImage;                                      // 0x06C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedMoviePlayerWidgetV2*                FactionLogoWidget;                                 // 0x06D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<ETedFaction, class UFileMediaSource*>    FactionLogoMovies;                                 // 0x06D8(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         bIgnoreMinimapRequirements : 1;                    // 0x0728(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         MiniMapState;                                      // 0x0729(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_72A[0x6];                                      // 0x072A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 World;                                             // 0x0730(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ATedPlayerController*                   OwningPlayer;                                      // 0x0738(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTedPlayerData*                         OwningPlayerData;                                  // 0x0740(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTedProceduralMeshWidget*               InstancedShapesWidget;                             // 0x0748(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         InstancedUnitBrushID;                              // 0x0750(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         InstancedStructureID;                              // 0x0754(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         InstancedResourceID;                               // 0x0758(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_75C[0x4];                                      // 0x075C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        LastUnderAttackEventTime;                          // 0x0760(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_768[0x8];                                      // 0x0768(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnReplicatePlayerState(class ATedPlayerController* InPlayerController);
	void SetDrawFogOfWar(bool bInDrawFogOfWar);
	void SetDrawFrustum(bool bInDrawFrustum);
	void SetDrawMapMarkers(bool bInDrawMapMarkers);
	void SetDrawResources(bool bInDrawFrustum);
	void SetDrawStructures(bool bInDrawStructures);
	void SetDrawTerrain(bool bInDrawTerrain);
	void SetDrawUnits(bool bInDrawUnits);
	void SetMiniMapStateFlag(EMinimapStateFlag InFlag, bool bInBool);

	const class UFileMediaSource* GetFactionLogoMovie() const;
	struct FVector2D GetMinimapSize() const;
	bool HasMiniMapStateFlag(const EMinimapStateFlag InFlag) const;
	void OnMinimapStateChanged(bool bFullMode) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMinimapWidget">();
	}
	static class UTedMinimapWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMinimapWidget>();
	}
};
static_assert(alignof(UTedMinimapWidget) == 0x000010, "Wrong alignment on UTedMinimapWidget");
static_assert(sizeof(UTedMinimapWidget) == 0x000770, "Wrong size on UTedMinimapWidget");
static_assert(offsetof(UTedMinimapWidget, OfflineMinimapTexture) == 0x000400, "Member 'UTedMinimapWidget::OfflineMinimapTexture' has a wrong offset!");
static_assert(offsetof(UTedMinimapWidget, MinimapMaterial) == 0x000408, "Member 'UTedMinimapWidget::MinimapMaterial' has a wrong offset!");
static_assert(offsetof(UTedMinimapWidget, MinimapWidth) == 0x000410, "Member 'UTedMinimapWidget::MinimapWidth' has a wrong offset!");
static_assert(offsetof(UTedMinimapWidget, MinimapHeight) == 0x000414, "Member 'UTedMinimapWidget::MinimapHeight' has a wrong offset!");
static_assert(offsetof(UTedMinimapWidget, UnitBrush) == 0x000420, "Member 'UTedMinimapWidget::UnitBrush' has a wrong offset!");
static_assert(offsetof(UTedMinimapWidget, StructureBrush) == 0x0004F0, "Member 'UTedMinimapWidget::StructureBrush' has a wrong offset!");
static_assert(offsetof(UTedMinimapWidget, ResourceBrush) == 0x0005C0, "Member 'UTedMinimapWidget::ResourceBrush' has a wrong offset!");
static_assert(offsetof(UTedMinimapWidget, DamageFlashDuration) == 0x000690, "Member 'UTedMinimapWidget::DamageFlashDuration' has a wrong offset!");
static_assert(offsetof(UTedMinimapWidget, ShowSound) == 0x000698, "Member 'UTedMinimapWidget::ShowSound' has a wrong offset!");
static_assert(offsetof(UTedMinimapWidget, HideSound) == 0x0006A0, "Member 'UTedMinimapWidget::HideSound' has a wrong offset!");
static_assert(offsetof(UTedMinimapWidget, ShowAnnouncement) == 0x0006A8, "Member 'UTedMinimapWidget::ShowAnnouncement' has a wrong offset!");
static_assert(offsetof(UTedMinimapWidget, HideAnnouncement) == 0x0006B0, "Member 'UTedMinimapWidget::HideAnnouncement' has a wrong offset!");
static_assert(offsetof(UTedMinimapWidget, MinimapTextureMID) == 0x0006B8, "Member 'UTedMinimapWidget::MinimapTextureMID' has a wrong offset!");
static_assert(offsetof(UTedMinimapWidget, CachedMinimapTexture) == 0x0006C0, "Member 'UTedMinimapWidget::CachedMinimapTexture' has a wrong offset!");
static_assert(offsetof(UTedMinimapWidget, MinimapImage) == 0x0006C8, "Member 'UTedMinimapWidget::MinimapImage' has a wrong offset!");
static_assert(offsetof(UTedMinimapWidget, FactionLogoWidget) == 0x0006D0, "Member 'UTedMinimapWidget::FactionLogoWidget' has a wrong offset!");
static_assert(offsetof(UTedMinimapWidget, FactionLogoMovies) == 0x0006D8, "Member 'UTedMinimapWidget::FactionLogoMovies' has a wrong offset!");
static_assert(offsetof(UTedMinimapWidget, MiniMapState) == 0x000729, "Member 'UTedMinimapWidget::MiniMapState' has a wrong offset!");
static_assert(offsetof(UTedMinimapWidget, World) == 0x000730, "Member 'UTedMinimapWidget::World' has a wrong offset!");
static_assert(offsetof(UTedMinimapWidget, OwningPlayer) == 0x000738, "Member 'UTedMinimapWidget::OwningPlayer' has a wrong offset!");
static_assert(offsetof(UTedMinimapWidget, OwningPlayerData) == 0x000740, "Member 'UTedMinimapWidget::OwningPlayerData' has a wrong offset!");
static_assert(offsetof(UTedMinimapWidget, InstancedShapesWidget) == 0x000748, "Member 'UTedMinimapWidget::InstancedShapesWidget' has a wrong offset!");
static_assert(offsetof(UTedMinimapWidget, InstancedUnitBrushID) == 0x000750, "Member 'UTedMinimapWidget::InstancedUnitBrushID' has a wrong offset!");
static_assert(offsetof(UTedMinimapWidget, InstancedStructureID) == 0x000754, "Member 'UTedMinimapWidget::InstancedStructureID' has a wrong offset!");
static_assert(offsetof(UTedMinimapWidget, InstancedResourceID) == 0x000758, "Member 'UTedMinimapWidget::InstancedResourceID' has a wrong offset!");
static_assert(offsetof(UTedMinimapWidget, LastUnderAttackEventTime) == 0x000760, "Member 'UTedMinimapWidget::LastUnderAttackEventTime' has a wrong offset!");

// Class Tempest.TedMoviePlayerDisplay
// 0x0010 (0x0410 - 0x0400)
class UTedMoviePlayerDisplay : public UTedUserWidget
{
public:
	ESlateVisibility                              IntroVisibility;                                   // 0x0400(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESlateVisibility                              PlayingVisibility;                                 // 0x0401(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESlateVisibility                              PausedVisibility;                                  // 0x0402(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESlateVisibility                              NotStartedVisibility;                              // 0x0403(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bSyncWithExpectedVisibility : 1;                   // 0x0404(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDisplayMovieFromHUD : 1;                          // 0x0404(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	ETedMovieType                                 HUDMovie;                                          // 0x0405(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_406[0x2];                                      // 0x0406(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedMoviePlayerController*              MoviePlayerController;                             // 0x0408(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetMovieController(class UTedMoviePlayerController* InController);

	struct FSlateBrush DetermineBrush() const;
	ESlateVisibility GetExpectedVisibility() const;
	const class UFileMediaSource* GetStartedMovie() const;
	bool IsPaused() const;
	bool IsPlaying() const;
	bool IsPlayingIntro() const;
	bool IsStarted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMoviePlayerDisplay">();
	}
	static class UTedMoviePlayerDisplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMoviePlayerDisplay>();
	}
};
static_assert(alignof(UTedMoviePlayerDisplay) == 0x000008, "Wrong alignment on UTedMoviePlayerDisplay");
static_assert(sizeof(UTedMoviePlayerDisplay) == 0x000410, "Wrong size on UTedMoviePlayerDisplay");
static_assert(offsetof(UTedMoviePlayerDisplay, IntroVisibility) == 0x000400, "Member 'UTedMoviePlayerDisplay::IntroVisibility' has a wrong offset!");
static_assert(offsetof(UTedMoviePlayerDisplay, PlayingVisibility) == 0x000401, "Member 'UTedMoviePlayerDisplay::PlayingVisibility' has a wrong offset!");
static_assert(offsetof(UTedMoviePlayerDisplay, PausedVisibility) == 0x000402, "Member 'UTedMoviePlayerDisplay::PausedVisibility' has a wrong offset!");
static_assert(offsetof(UTedMoviePlayerDisplay, NotStartedVisibility) == 0x000403, "Member 'UTedMoviePlayerDisplay::NotStartedVisibility' has a wrong offset!");
static_assert(offsetof(UTedMoviePlayerDisplay, HUDMovie) == 0x000405, "Member 'UTedMoviePlayerDisplay::HUDMovie' has a wrong offset!");
static_assert(offsetof(UTedMoviePlayerDisplay, MoviePlayerController) == 0x000408, "Member 'UTedMoviePlayerDisplay::MoviePlayerController' has a wrong offset!");

// Class Tempest.TedMissionDialogueWidget
// 0x00C8 (0x04D8 - 0x0410)
class UTedMissionDialogueWidget : public UTedMoviePlayerDisplay
{
public:
	struct FTedThemeMovie                         Anim_Intro;                                        // 0x0410(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FTedThemeMovie                         Anim_Outro;                                        // 0x0460(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FTedMoviePlayParams                    AnimPlayParams;                                    // 0x04B0(0x0018)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UTedMoviePlayerWidgetV2*                AnimPlayer;                                        // 0x04C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedSubtitleWidget*                     Subtitles;                                         // 0x04D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void K2_OnIntroFinished();
	void K2_OnIntroStarted();
	void K2_OnOutroFinished();
	void K2_OnOutroStarted();
	void OnIntroFinished(class UTedMoviePlayerWidgetV2* InWidget, const class UFileMediaSource* InSource);
	void OnOutroFinished(class UTedMoviePlayerWidgetV2* InWidget, const class UFileMediaSource* InSource);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMissionDialogueWidget">();
	}
	static class UTedMissionDialogueWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMissionDialogueWidget>();
	}
};
static_assert(alignof(UTedMissionDialogueWidget) == 0x000008, "Wrong alignment on UTedMissionDialogueWidget");
static_assert(sizeof(UTedMissionDialogueWidget) == 0x0004D8, "Wrong size on UTedMissionDialogueWidget");
static_assert(offsetof(UTedMissionDialogueWidget, Anim_Intro) == 0x000410, "Member 'UTedMissionDialogueWidget::Anim_Intro' has a wrong offset!");
static_assert(offsetof(UTedMissionDialogueWidget, Anim_Outro) == 0x000460, "Member 'UTedMissionDialogueWidget::Anim_Outro' has a wrong offset!");
static_assert(offsetof(UTedMissionDialogueWidget, AnimPlayParams) == 0x0004B0, "Member 'UTedMissionDialogueWidget::AnimPlayParams' has a wrong offset!");
static_assert(offsetof(UTedMissionDialogueWidget, AnimPlayer) == 0x0004C8, "Member 'UTedMissionDialogueWidget::AnimPlayer' has a wrong offset!");
static_assert(offsetof(UTedMissionDialogueWidget, Subtitles) == 0x0004D0, "Member 'UTedMissionDialogueWidget::Subtitles' has a wrong offset!");

// Class Tempest.TedMissionSelect_MapInfo
// 0x0010 (0x0410 - 0x0400)
class UTedMissionSelect_MapInfo final : public UTedUserWidget
{
public:
	class UTedObjectivePanel*                     Content_Objectives_Main;                           // 0x0400(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedObjectivePanel*                     Content_Objectives_Side;                           // 0x0408(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void GetObjectivesData(const class UTedMapInfo* InMapInfo, int32* OutCompleteObjectives, int32* OutTotalObjectives);
	void LoadObjectivesData(class UTedMapInfo* InMapInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMissionSelect_MapInfo">();
	}
	static class UTedMissionSelect_MapInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMissionSelect_MapInfo>();
	}
};
static_assert(alignof(UTedMissionSelect_MapInfo) == 0x000008, "Wrong alignment on UTedMissionSelect_MapInfo");
static_assert(sizeof(UTedMissionSelect_MapInfo) == 0x000410, "Wrong size on UTedMissionSelect_MapInfo");
static_assert(offsetof(UTedMissionSelect_MapInfo, Content_Objectives_Main) == 0x000400, "Member 'UTedMissionSelect_MapInfo::Content_Objectives_Main' has a wrong offset!");
static_assert(offsetof(UTedMissionSelect_MapInfo, Content_Objectives_Side) == 0x000408, "Member 'UTedMissionSelect_MapInfo::Content_Objectives_Side' has a wrong offset!");

// Class Tempest.TedMoviePlayerConfig
// 0x0018 (0x0048 - 0x0030)
class UTedMoviePlayerConfig final : public UDataAsset
{
public:
	class UBinkMediaPlayer*                       PlayerTemplate;                                    // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBinkMediaTexture*                      TextureTemplate;                                   // 0x0038(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           HidingHUDContext;                                  // 0x0040(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMoviePlayerConfig">();
	}
	static class UTedMoviePlayerConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMoviePlayerConfig>();
	}
};
static_assert(alignof(UTedMoviePlayerConfig) == 0x000008, "Wrong alignment on UTedMoviePlayerConfig");
static_assert(sizeof(UTedMoviePlayerConfig) == 0x000048, "Wrong size on UTedMoviePlayerConfig");
static_assert(offsetof(UTedMoviePlayerConfig, PlayerTemplate) == 0x000030, "Member 'UTedMoviePlayerConfig::PlayerTemplate' has a wrong offset!");
static_assert(offsetof(UTedMoviePlayerConfig, TextureTemplate) == 0x000038, "Member 'UTedMoviePlayerConfig::TextureTemplate' has a wrong offset!");
static_assert(offsetof(UTedMoviePlayerConfig, HidingHUDContext) == 0x000040, "Member 'UTedMoviePlayerConfig::HidingHUDContext' has a wrong offset!");

// Class Tempest.TedMoviePlayerController
// 0x0100 (0x0128 - 0x0028)
class UTedMoviePlayerController final : public UObject
{
public:
	uint8                                         Pad_28[0xA0];                                      // 0x0028(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedMoviePlayerConfig*                  ConfigTemplate;                                    // 0x00C8(0x0008)(Edit, ZeroConstructor, Transient, EditConst, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBinkMediaPlayer*                       Player;                                            // 0x00D0(0x0008)(Edit, ZeroConstructor, Transient, EditConst, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBinkMediaTexture*                      MediaTexture;                                      // 0x00D8(0x0008)(Edit, ZeroConstructor, Transient, EditConst, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFileMediaSource*                       OpenedSource;                                      // 0x00E0(0x0008)(Edit, ZeroConstructor, Transient, EditConst, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTedMoviePlayParams                    StartParams;                                       // 0x00E8(0x0018)(Edit, Transient, EditConst, DuplicateTransient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USoundMix*>                      PushedSoundMixes;                                  // 0x0108(0x0010)(Edit, ZeroConstructor, Transient, EditConst, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	uint8                                         bWaitingForFade : 1;                               // 0x0118(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Transient, EditConst, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bWaitingForIntro : 1;                              // 0x0118(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Transient, EditConst, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayingVolume;                                     // 0x011C(0x0004)(Edit, ZeroConstructor, Transient, EditConst, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMuted;                                          // 0x0120(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMediaReachedEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMoviePlayerController">();
	}
	static class UTedMoviePlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMoviePlayerController>();
	}
};
static_assert(alignof(UTedMoviePlayerController) == 0x000008, "Wrong alignment on UTedMoviePlayerController");
static_assert(sizeof(UTedMoviePlayerController) == 0x000128, "Wrong size on UTedMoviePlayerController");
static_assert(offsetof(UTedMoviePlayerController, ConfigTemplate) == 0x0000C8, "Member 'UTedMoviePlayerController::ConfigTemplate' has a wrong offset!");
static_assert(offsetof(UTedMoviePlayerController, Player) == 0x0000D0, "Member 'UTedMoviePlayerController::Player' has a wrong offset!");
static_assert(offsetof(UTedMoviePlayerController, MediaTexture) == 0x0000D8, "Member 'UTedMoviePlayerController::MediaTexture' has a wrong offset!");
static_assert(offsetof(UTedMoviePlayerController, OpenedSource) == 0x0000E0, "Member 'UTedMoviePlayerController::OpenedSource' has a wrong offset!");
static_assert(offsetof(UTedMoviePlayerController, StartParams) == 0x0000E8, "Member 'UTedMoviePlayerController::StartParams' has a wrong offset!");
static_assert(offsetof(UTedMoviePlayerController, PushedSoundMixes) == 0x000108, "Member 'UTedMoviePlayerController::PushedSoundMixes' has a wrong offset!");
static_assert(offsetof(UTedMoviePlayerController, PlayingVolume) == 0x00011C, "Member 'UTedMoviePlayerController::PlayingVolume' has a wrong offset!");
static_assert(offsetof(UTedMoviePlayerController, bIsMuted) == 0x000120, "Member 'UTedMoviePlayerController::bIsMuted' has a wrong offset!");

// Class Tempest.TedScoreMenuScreen
// 0x0368 (0x07C0 - 0x0458)
class UTedScoreMenuScreen : public UTedMenuScreenWidget
{
public:
	class UTedContentPanelInstanced*              TabsPanel;                                         // 0x0458(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WidgetSwitcher_Content;                            // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedScoreScreenStatsTableTab*           Content_Summary;                                   // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedScoreScreenStatsTableTab*           Content_Units;                                     // 0x0470(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedScoreScreenStatsTableTab*           Content_Structures;                                // 0x0478(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedScoreScreenStatsTableTab*           Content_Resources;                                 // 0x0480(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedScoreScreenGraphTab*                Content_Graph;                                     // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                Content_Objectives;                                // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedContentPanelInstanced*              ButtonsPanel;                                      // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedPopup*                              Popup;                                             // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTedPopup>                  PopupClass;                                        // 0x04A8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimespan                              MatchDuration;                                     // 0x04B0(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTedTextWidgetThemedConfig             TitleVictoryStyle;                                 // 0x04B8(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FTedTextWidgetThemedConfig             TitleDefeatStyle;                                  // 0x0540(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FTedTextWidgetThemedConfig             MapNameStyle;                                      // 0x05C8(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FTedTextWidgetThemedConfig             DifficultyStyle;                                   // 0x0650(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FTedTextWidgetThemedConfig             MatchDurationStyle;                                // 0x06D8(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	class UWidget*                                TitleTextWidget;                                   // 0x0760(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                MapTextWidget;                                     // 0x0768(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                DifficultyTextWidget;                              // 0x0770(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                MatchDurationTextWidget;                           // 0x0778(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedObjectivePanel*                     Content_Objectives_Main;                           // 0x0780(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedObjectivePanel*                     Content_Objectives_Side;                           // 0x0788(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedScoreScreenRewardValueWidget*       RewardedRequisitionPointsWidget;                   // 0x0790(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedScoreScreenRewardValueWidget*       RewardedDoctrinePointsWidget;                      // 0x0798(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedScoreScreenRewardValueWidget*       RewardedDoctrineResetPointsWidget;                 // 0x07A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedScoreScreenRewardValueWidget*       RewardedEquipmentResetPointsWidget;                // 0x07A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedScoreScreenRewardValueWidget*       RewardedEquipmentSpaceWidget;                      // 0x07B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsVictoryScreen : 1;                              // 0x07B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_7B9[0x7];                                      // 0x07B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActivateTabSlotState(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotState InState, bool bInActivated);
	void OnTriggerButtonSlotAction(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction);

	ETedGameDifficulty GetCurrentGameDifficulty() const;
	const class UTedMapInfo* GetCurrentMap() const;
	ETedFaction GetCurrentTheme() const;
	class FText GetDifficultyText() const;
	class FText GetMapNameText() const;
	struct FTimespan GetMatchDuration() const;
	class FText GetMatchDurationText() const;
	bool IsVictoryScreen() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedScoreMenuScreen">();
	}
	static class UTedScoreMenuScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedScoreMenuScreen>();
	}
};
static_assert(alignof(UTedScoreMenuScreen) == 0x000008, "Wrong alignment on UTedScoreMenuScreen");
static_assert(sizeof(UTedScoreMenuScreen) == 0x0007C0, "Wrong size on UTedScoreMenuScreen");
static_assert(offsetof(UTedScoreMenuScreen, TabsPanel) == 0x000458, "Member 'UTedScoreMenuScreen::TabsPanel' has a wrong offset!");
static_assert(offsetof(UTedScoreMenuScreen, WidgetSwitcher_Content) == 0x000460, "Member 'UTedScoreMenuScreen::WidgetSwitcher_Content' has a wrong offset!");
static_assert(offsetof(UTedScoreMenuScreen, Content_Summary) == 0x000468, "Member 'UTedScoreMenuScreen::Content_Summary' has a wrong offset!");
static_assert(offsetof(UTedScoreMenuScreen, Content_Units) == 0x000470, "Member 'UTedScoreMenuScreen::Content_Units' has a wrong offset!");
static_assert(offsetof(UTedScoreMenuScreen, Content_Structures) == 0x000478, "Member 'UTedScoreMenuScreen::Content_Structures' has a wrong offset!");
static_assert(offsetof(UTedScoreMenuScreen, Content_Resources) == 0x000480, "Member 'UTedScoreMenuScreen::Content_Resources' has a wrong offset!");
static_assert(offsetof(UTedScoreMenuScreen, Content_Graph) == 0x000488, "Member 'UTedScoreMenuScreen::Content_Graph' has a wrong offset!");
static_assert(offsetof(UTedScoreMenuScreen, Content_Objectives) == 0x000490, "Member 'UTedScoreMenuScreen::Content_Objectives' has a wrong offset!");
static_assert(offsetof(UTedScoreMenuScreen, ButtonsPanel) == 0x000498, "Member 'UTedScoreMenuScreen::ButtonsPanel' has a wrong offset!");
static_assert(offsetof(UTedScoreMenuScreen, Popup) == 0x0004A0, "Member 'UTedScoreMenuScreen::Popup' has a wrong offset!");
static_assert(offsetof(UTedScoreMenuScreen, PopupClass) == 0x0004A8, "Member 'UTedScoreMenuScreen::PopupClass' has a wrong offset!");
static_assert(offsetof(UTedScoreMenuScreen, MatchDuration) == 0x0004B0, "Member 'UTedScoreMenuScreen::MatchDuration' has a wrong offset!");
static_assert(offsetof(UTedScoreMenuScreen, TitleVictoryStyle) == 0x0004B8, "Member 'UTedScoreMenuScreen::TitleVictoryStyle' has a wrong offset!");
static_assert(offsetof(UTedScoreMenuScreen, TitleDefeatStyle) == 0x000540, "Member 'UTedScoreMenuScreen::TitleDefeatStyle' has a wrong offset!");
static_assert(offsetof(UTedScoreMenuScreen, MapNameStyle) == 0x0005C8, "Member 'UTedScoreMenuScreen::MapNameStyle' has a wrong offset!");
static_assert(offsetof(UTedScoreMenuScreen, DifficultyStyle) == 0x000650, "Member 'UTedScoreMenuScreen::DifficultyStyle' has a wrong offset!");
static_assert(offsetof(UTedScoreMenuScreen, MatchDurationStyle) == 0x0006D8, "Member 'UTedScoreMenuScreen::MatchDurationStyle' has a wrong offset!");
static_assert(offsetof(UTedScoreMenuScreen, TitleTextWidget) == 0x000760, "Member 'UTedScoreMenuScreen::TitleTextWidget' has a wrong offset!");
static_assert(offsetof(UTedScoreMenuScreen, MapTextWidget) == 0x000768, "Member 'UTedScoreMenuScreen::MapTextWidget' has a wrong offset!");
static_assert(offsetof(UTedScoreMenuScreen, DifficultyTextWidget) == 0x000770, "Member 'UTedScoreMenuScreen::DifficultyTextWidget' has a wrong offset!");
static_assert(offsetof(UTedScoreMenuScreen, MatchDurationTextWidget) == 0x000778, "Member 'UTedScoreMenuScreen::MatchDurationTextWidget' has a wrong offset!");
static_assert(offsetof(UTedScoreMenuScreen, Content_Objectives_Main) == 0x000780, "Member 'UTedScoreMenuScreen::Content_Objectives_Main' has a wrong offset!");
static_assert(offsetof(UTedScoreMenuScreen, Content_Objectives_Side) == 0x000788, "Member 'UTedScoreMenuScreen::Content_Objectives_Side' has a wrong offset!");
static_assert(offsetof(UTedScoreMenuScreen, RewardedRequisitionPointsWidget) == 0x000790, "Member 'UTedScoreMenuScreen::RewardedRequisitionPointsWidget' has a wrong offset!");
static_assert(offsetof(UTedScoreMenuScreen, RewardedDoctrinePointsWidget) == 0x000798, "Member 'UTedScoreMenuScreen::RewardedDoctrinePointsWidget' has a wrong offset!");
static_assert(offsetof(UTedScoreMenuScreen, RewardedDoctrineResetPointsWidget) == 0x0007A0, "Member 'UTedScoreMenuScreen::RewardedDoctrineResetPointsWidget' has a wrong offset!");
static_assert(offsetof(UTedScoreMenuScreen, RewardedEquipmentResetPointsWidget) == 0x0007A8, "Member 'UTedScoreMenuScreen::RewardedEquipmentResetPointsWidget' has a wrong offset!");
static_assert(offsetof(UTedScoreMenuScreen, RewardedEquipmentSpaceWidget) == 0x0007B0, "Member 'UTedScoreMenuScreen::RewardedEquipmentSpaceWidget' has a wrong offset!");

// Class Tempest.TedMultiplayerScoreMenuScreen
// 0x0020 (0x07E0 - 0x07C0)
class UTedMultiplayerScoreMenuScreen final : public UTedScoreMenuScreen
{
public:
	class UTedContentPanelInstanced*              InfoPanelRight;                                    // 0x07C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedContentPanelInstanced*              InfoPanelLeft;                                     // 0x07C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedScoreScreenOnlinePlayersPanel*      PlayerOverview_VictoriousTeam;                     // 0x07D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedScoreScreenOnlinePlayersPanel*      PlayerOverview_DefeatedTeams;                      // 0x07D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetupCustomScreen() const;
	void SetupUnrankedScreen() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedMultiplayerScoreMenuScreen">();
	}
	static class UTedMultiplayerScoreMenuScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedMultiplayerScoreMenuScreen>();
	}
};
static_assert(alignof(UTedMultiplayerScoreMenuScreen) == 0x000008, "Wrong alignment on UTedMultiplayerScoreMenuScreen");
static_assert(sizeof(UTedMultiplayerScoreMenuScreen) == 0x0007E0, "Wrong size on UTedMultiplayerScoreMenuScreen");
static_assert(offsetof(UTedMultiplayerScoreMenuScreen, InfoPanelRight) == 0x0007C0, "Member 'UTedMultiplayerScoreMenuScreen::InfoPanelRight' has a wrong offset!");
static_assert(offsetof(UTedMultiplayerScoreMenuScreen, InfoPanelLeft) == 0x0007C8, "Member 'UTedMultiplayerScoreMenuScreen::InfoPanelLeft' has a wrong offset!");
static_assert(offsetof(UTedMultiplayerScoreMenuScreen, PlayerOverview_VictoriousTeam) == 0x0007D0, "Member 'UTedMultiplayerScoreMenuScreen::PlayerOverview_VictoriousTeam' has a wrong offset!");
static_assert(offsetof(UTedMultiplayerScoreMenuScreen, PlayerOverview_DefeatedTeams) == 0x0007D8, "Member 'UTedMultiplayerScoreMenuScreen::PlayerOverview_DefeatedTeams' has a wrong offset!");

// Class Tempest.TedNavArea_NoGroundUnits
// 0x0000 (0x0048 - 0x0048)
class UTedNavArea_NoGroundUnits final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedNavArea_NoGroundUnits">();
	}
	static class UTedNavArea_NoGroundUnits* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedNavArea_NoGroundUnits>();
	}
};
static_assert(alignof(UTedNavArea_NoGroundUnits) == 0x000008, "Wrong alignment on UTedNavArea_NoGroundUnits");
static_assert(sizeof(UTedNavArea_NoGroundUnits) == 0x000048, "Wrong size on UTedNavArea_NoGroundUnits");

// Class Tempest.TedNavArea_NoMines
// 0x0000 (0x0048 - 0x0048)
class UTedNavArea_NoMines final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedNavArea_NoMines">();
	}
	static class UTedNavArea_NoMines* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedNavArea_NoMines>();
	}
};
static_assert(alignof(UTedNavArea_NoMines) == 0x000008, "Wrong alignment on UTedNavArea_NoMines");
static_assert(sizeof(UTedNavArea_NoMines) == 0x000048, "Wrong size on UTedNavArea_NoMines");

// Class Tempest.TedNavArea_TempestField
// 0x0000 (0x0048 - 0x0048)
class UTedNavArea_TempestField final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedNavArea_TempestField">();
	}
	static class UTedNavArea_TempestField* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedNavArea_TempestField>();
	}
};
static_assert(alignof(UTedNavArea_TempestField) == 0x000008, "Wrong alignment on UTedNavArea_TempestField");
static_assert(sizeof(UTedNavArea_TempestField) == 0x000048, "Wrong size on UTedNavArea_TempestField");

// Class Tempest.TedNavArea_TempestFieldCrater
// 0x0000 (0x0048 - 0x0048)
class UTedNavArea_TempestFieldCrater final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedNavArea_TempestFieldCrater">();
	}
	static class UTedNavArea_TempestFieldCrater* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedNavArea_TempestFieldCrater>();
	}
};
static_assert(alignof(UTedNavArea_TempestFieldCrater) == 0x000008, "Wrong alignment on UTedNavArea_TempestFieldCrater");
static_assert(sizeof(UTedNavArea_TempestFieldCrater) == 0x000048, "Wrong size on UTedNavArea_TempestFieldCrater");

// Class Tempest.TedNavFilterCondition_NavArea
// 0x0008 (0x0038 - 0x0030)
class UTedNavFilterCondition_NavArea final : public UTedNavFilterCondition
{
public:
	TSubclassOf<class UNavArea>                   RequiredNavArea;                                   // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedNavFilterCondition_NavArea">();
	}
	static class UTedNavFilterCondition_NavArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedNavFilterCondition_NavArea>();
	}
};
static_assert(alignof(UTedNavFilterCondition_NavArea) == 0x000008, "Wrong alignment on UTedNavFilterCondition_NavArea");
static_assert(sizeof(UTedNavFilterCondition_NavArea) == 0x000038, "Wrong size on UTedNavFilterCondition_NavArea");
static_assert(offsetof(UTedNavFilterCondition_NavArea, RequiredNavArea) == 0x000030, "Member 'UTedNavFilterCondition_NavArea::RequiredNavArea' has a wrong offset!");

// Class Tempest.TedNavFilterCondition_Command
// 0x0010 (0x0040 - 0x0030)
class UTedNavFilterCondition_Command final : public UTedNavFilterCondition
{
public:
	TSubclassOf<class UTedPawnCommandWithBehavior> RequiredCommand;                                  // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCommandRequiresValidTarget;                       // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedNavFilterCondition_Command">();
	}
	static class UTedNavFilterCondition_Command* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedNavFilterCondition_Command>();
	}
};
static_assert(alignof(UTedNavFilterCondition_Command) == 0x000008, "Wrong alignment on UTedNavFilterCondition_Command");
static_assert(sizeof(UTedNavFilterCondition_Command) == 0x000040, "Wrong size on UTedNavFilterCondition_Command");
static_assert(offsetof(UTedNavFilterCondition_Command, RequiredCommand) == 0x000030, "Member 'UTedNavFilterCondition_Command::RequiredCommand' has a wrong offset!");
static_assert(offsetof(UTedNavFilterCondition_Command, bCommandRequiresValidTarget) == 0x000038, "Member 'UTedNavFilterCondition_Command::bCommandRequiresValidTarget' has a wrong offset!");

// Class Tempest.TedNavFilterSelector
// 0x0018 (0x0048 - 0x0030)
class UTedNavFilterSelector final : public UDataAsset
{
public:
	TSubclassOf<class UTedNavFilter_UnitBase>     Result;                                            // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTedNavFilterCondition*>         Filters;                                           // 0x0038(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedNavFilterSelector">();
	}
	static class UTedNavFilterSelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedNavFilterSelector>();
	}
};
static_assert(alignof(UTedNavFilterSelector) == 0x000008, "Wrong alignment on UTedNavFilterSelector");
static_assert(sizeof(UTedNavFilterSelector) == 0x000048, "Wrong size on UTedNavFilterSelector");
static_assert(offsetof(UTedNavFilterSelector, Result) == 0x000030, "Member 'UTedNavFilterSelector::Result' has a wrong offset!");
static_assert(offsetof(UTedNavFilterSelector, Filters) == 0x000038, "Member 'UTedNavFilterSelector::Filters' has a wrong offset!");

// Class Tempest.TedNavFilter_Vehicle
// 0x0000 (0x0048 - 0x0048)
class UTedNavFilter_Vehicle : public UTedNavFilter_UnitBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedNavFilter_Vehicle">();
	}
	static class UTedNavFilter_Vehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedNavFilter_Vehicle>();
	}
};
static_assert(alignof(UTedNavFilter_Vehicle) == 0x000008, "Wrong alignment on UTedNavFilter_Vehicle");
static_assert(sizeof(UTedNavFilter_Vehicle) == 0x000048, "Wrong size on UTedNavFilter_Vehicle");

// Class Tempest.TedNavFilter_Vehicle_Heavy
// 0x0000 (0x0048 - 0x0048)
class UTedNavFilter_Vehicle_Heavy : public UTedNavFilter_Vehicle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedNavFilter_Vehicle_Heavy">();
	}
	static class UTedNavFilter_Vehicle_Heavy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedNavFilter_Vehicle_Heavy>();
	}
};
static_assert(alignof(UTedNavFilter_Vehicle_Heavy) == 0x000008, "Wrong alignment on UTedNavFilter_Vehicle_Heavy");
static_assert(sizeof(UTedNavFilter_Vehicle_Heavy) == 0x000048, "Wrong size on UTedNavFilter_Vehicle_Heavy");

// Class Tempest.TedNavFilter_Harvester
// 0x0000 (0x0048 - 0x0048)
class UTedNavFilter_Harvester final : public UTedNavFilter_Vehicle_Heavy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedNavFilter_Harvester">();
	}
	static class UTedNavFilter_Harvester* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedNavFilter_Harvester>();
	}
};
static_assert(alignof(UTedNavFilter_Harvester) == 0x000008, "Wrong alignment on UTedNavFilter_Harvester");
static_assert(sizeof(UTedNavFilter_Harvester) == 0x000048, "Wrong size on UTedNavFilter_Harvester");

// Class Tempest.TedNavFilter_Vehicle_AvoidTempest
// 0x0000 (0x0048 - 0x0048)
class UTedNavFilter_Vehicle_AvoidTempest final : public UTedNavFilter_Vehicle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedNavFilter_Vehicle_AvoidTempest">();
	}
	static class UTedNavFilter_Vehicle_AvoidTempest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedNavFilter_Vehicle_AvoidTempest>();
	}
};
static_assert(alignof(UTedNavFilter_Vehicle_AvoidTempest) == 0x000008, "Wrong alignment on UTedNavFilter_Vehicle_AvoidTempest");
static_assert(sizeof(UTedNavFilter_Vehicle_AvoidTempest) == 0x000048, "Wrong size on UTedNavFilter_Vehicle_AvoidTempest");

// Class Tempest.TedNavFilter_Vehicle_Air
// 0x0000 (0x0048 - 0x0048)
class UTedNavFilter_Vehicle_Air : public UTedNavFilter_UnitBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedNavFilter_Vehicle_Air">();
	}
	static class UTedNavFilter_Vehicle_Air* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedNavFilter_Vehicle_Air>();
	}
};
static_assert(alignof(UTedNavFilter_Vehicle_Air) == 0x000008, "Wrong alignment on UTedNavFilter_Vehicle_Air");
static_assert(sizeof(UTedNavFilter_Vehicle_Air) == 0x000048, "Wrong size on UTedNavFilter_Vehicle_Air");

// Class Tempest.TedNavFilter_Vehicle_Air_VetiDomeDisabled
// 0x0000 (0x0048 - 0x0048)
class UTedNavFilter_Vehicle_Air_VetiDomeDisabled final : public UTedNavFilter_Vehicle_Air
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedNavFilter_Vehicle_Air_VetiDomeDisabled">();
	}
	static class UTedNavFilter_Vehicle_Air_VetiDomeDisabled* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedNavFilter_Vehicle_Air_VetiDomeDisabled>();
	}
};
static_assert(alignof(UTedNavFilter_Vehicle_Air_VetiDomeDisabled) == 0x000008, "Wrong alignment on UTedNavFilter_Vehicle_Air_VetiDomeDisabled");
static_assert(sizeof(UTedNavFilter_Vehicle_Air_VetiDomeDisabled) == 0x000048, "Wrong size on UTedNavFilter_Vehicle_Air_VetiDomeDisabled");

// Class Tempest.TedNavMesh
// 0x0048 (0x06D0 - 0x0688)
class ATedNavMesh final : public ARecastNavMesh
{
public:
	bool                                          bDebugLogTileInfo;                                 // 0x0688(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_689[0x3];                                      // 0x0689(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntVector                             DebugLogTileCoordinate;                            // 0x068C(0x000C)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugLogDetailTriangles;                          // 0x0698(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugShowTreeNodeBounds;                          // 0x0699(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSmoothing;                                  // 0x069A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69B[0x1];                                      // 0x069B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntVector                             TileCoordinate;                                    // 0x069C(0x000C)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TileCoordDelta;                                    // 0x06A8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinHeight;                                         // 0x06AC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SimplifyVerticesDelta;                             // 0x06B0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumTileSmoothingIterations;                        // 0x06B4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumVerticesSmoothingIterations;                    // 0x06B8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6BC[0x14];                                     // 0x06BC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedNavMesh">();
	}
	static class ATedNavMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedNavMesh>();
	}
};
static_assert(alignof(ATedNavMesh) == 0x000008, "Wrong alignment on ATedNavMesh");
static_assert(sizeof(ATedNavMesh) == 0x0006D0, "Wrong size on ATedNavMesh");
static_assert(offsetof(ATedNavMesh, bDebugLogTileInfo) == 0x000688, "Member 'ATedNavMesh::bDebugLogTileInfo' has a wrong offset!");
static_assert(offsetof(ATedNavMesh, DebugLogTileCoordinate) == 0x00068C, "Member 'ATedNavMesh::DebugLogTileCoordinate' has a wrong offset!");
static_assert(offsetof(ATedNavMesh, bDebugLogDetailTriangles) == 0x000698, "Member 'ATedNavMesh::bDebugLogDetailTriangles' has a wrong offset!");
static_assert(offsetof(ATedNavMesh, bDebugShowTreeNodeBounds) == 0x000699, "Member 'ATedNavMesh::bDebugShowTreeNodeBounds' has a wrong offset!");
static_assert(offsetof(ATedNavMesh, bEnableSmoothing) == 0x00069A, "Member 'ATedNavMesh::bEnableSmoothing' has a wrong offset!");
static_assert(offsetof(ATedNavMesh, TileCoordinate) == 0x00069C, "Member 'ATedNavMesh::TileCoordinate' has a wrong offset!");
static_assert(offsetof(ATedNavMesh, TileCoordDelta) == 0x0006A8, "Member 'ATedNavMesh::TileCoordDelta' has a wrong offset!");
static_assert(offsetof(ATedNavMesh, MinHeight) == 0x0006AC, "Member 'ATedNavMesh::MinHeight' has a wrong offset!");
static_assert(offsetof(ATedNavMesh, SimplifyVerticesDelta) == 0x0006B0, "Member 'ATedNavMesh::SimplifyVerticesDelta' has a wrong offset!");
static_assert(offsetof(ATedNavMesh, NumTileSmoothingIterations) == 0x0006B4, "Member 'ATedNavMesh::NumTileSmoothingIterations' has a wrong offset!");
static_assert(offsetof(ATedNavMesh, NumVerticesSmoothingIterations) == 0x0006B8, "Member 'ATedNavMesh::NumVerticesSmoothingIterations' has a wrong offset!");

// Class Tempest.TedNavmeshSettings
// 0x0020 (0x0058 - 0x0038)
class UTedNavmeshSettings final : public UDeveloperSettings
{
public:
	struct FColor                                 NavAreaColor_NoGroundUnits;                        // 0x0038(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 NavAreaColor_NoAirUnits;                           // 0x003C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 NavAreaColor_NoMines;                              // 0x0040(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 NavAreaColor_NoStructures;                         // 0x0044(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 NavAreaColor_ObstacleRefinery;                     // 0x0048(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 NavAreaColor_TempestField;                         // 0x004C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 NavAreaColor_TempestFieldCrater;                   // 0x0050(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 NavAreaColor_VetiDome;                             // 0x0054(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedNavmeshSettings">();
	}
	static class UTedNavmeshSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedNavmeshSettings>();
	}
};
static_assert(alignof(UTedNavmeshSettings) == 0x000008, "Wrong alignment on UTedNavmeshSettings");
static_assert(sizeof(UTedNavmeshSettings) == 0x000058, "Wrong size on UTedNavmeshSettings");
static_assert(offsetof(UTedNavmeshSettings, NavAreaColor_NoGroundUnits) == 0x000038, "Member 'UTedNavmeshSettings::NavAreaColor_NoGroundUnits' has a wrong offset!");
static_assert(offsetof(UTedNavmeshSettings, NavAreaColor_NoAirUnits) == 0x00003C, "Member 'UTedNavmeshSettings::NavAreaColor_NoAirUnits' has a wrong offset!");
static_assert(offsetof(UTedNavmeshSettings, NavAreaColor_NoMines) == 0x000040, "Member 'UTedNavmeshSettings::NavAreaColor_NoMines' has a wrong offset!");
static_assert(offsetof(UTedNavmeshSettings, NavAreaColor_NoStructures) == 0x000044, "Member 'UTedNavmeshSettings::NavAreaColor_NoStructures' has a wrong offset!");
static_assert(offsetof(UTedNavmeshSettings, NavAreaColor_ObstacleRefinery) == 0x000048, "Member 'UTedNavmeshSettings::NavAreaColor_ObstacleRefinery' has a wrong offset!");
static_assert(offsetof(UTedNavmeshSettings, NavAreaColor_TempestField) == 0x00004C, "Member 'UTedNavmeshSettings::NavAreaColor_TempestField' has a wrong offset!");
static_assert(offsetof(UTedNavmeshSettings, NavAreaColor_TempestFieldCrater) == 0x000050, "Member 'UTedNavmeshSettings::NavAreaColor_TempestFieldCrater' has a wrong offset!");
static_assert(offsetof(UTedNavmeshSettings, NavAreaColor_VetiDome) == 0x000054, "Member 'UTedNavmeshSettings::NavAreaColor_VetiDome' has a wrong offset!");

// Class Tempest.TedNavPylon
// 0x0000 (0x0290 - 0x0290)
class ATedNavPylon final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedNavPylon">();
	}
	static class ATedNavPylon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedNavPylon>();
	}
};
static_assert(alignof(ATedNavPylon) == 0x000008, "Wrong alignment on ATedNavPylon");
static_assert(sizeof(ATedNavPylon) == 0x000290, "Wrong size on ATedNavPylon");

// Class Tempest.TedNewsPanel
// 0x00A0 (0x0850 - 0x07B0)
class UTedNewsPanel final : public UTedContentPanelDynamic
{
public:
	uint8                                         bAutoCycleSelection : 1;                           // 0x07B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bBreakAutoCycleOnHover : 1;                        // 0x07B0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bBreakAutoCycleOnSelection : 1;                    // 0x07B0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bScopeAutomaticallySelecting : 1;                  // 0x07B0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_7B1[0x7];                                      // 0x07B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedNewsTransitionConfig               ExtendAnimation;                                   // 0x07B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           OnCycleNewsHandle;                                 // 0x07D0(0x0008)(Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7D8[0x20];                                     // 0x07D8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTedNewsContent>                content;                                           // 0x07F8(0x0010)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, DuplicateTransient, NativeAccessSpecifierPrivate)
	class UButton*                                Button_GoRight;                                    // 0x0808(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UButton*                                Button_GoLeft;                                     // 0x0810(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Image_ExtendArrow;                                 // 0x0818(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOverlay*                               Overlay_Banner;                                    // 0x0820(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USizeBox*                               SizeBox_GoLeft;                                    // 0x0828(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USizeBox*                               SizeBox_GoRight;                                   // 0x0830(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Image_Header;                                      // 0x0838(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_840[0x10];                                     // 0x0840(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CacheAndDisplayBanners(const struct FProsBannerConfig& BannerConfig, const TArray<struct FProsBanner>& Banners);
	struct FEventReply ChangeDisplay(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent);
	void CycleToFollowingBanner();
	void CycleToPrecedingBanner();

	const TArray<struct FTedNewsContent> GetAllContent() const;
	bool GetContent(const int32 InSlotIndex, struct FTedNewsContent* OutContent) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedNewsPanel">();
	}
	static class UTedNewsPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedNewsPanel>();
	}
};
static_assert(alignof(UTedNewsPanel) == 0x000008, "Wrong alignment on UTedNewsPanel");
static_assert(sizeof(UTedNewsPanel) == 0x000850, "Wrong size on UTedNewsPanel");
static_assert(offsetof(UTedNewsPanel, ExtendAnimation) == 0x0007B8, "Member 'UTedNewsPanel::ExtendAnimation' has a wrong offset!");
static_assert(offsetof(UTedNewsPanel, OnCycleNewsHandle) == 0x0007D0, "Member 'UTedNewsPanel::OnCycleNewsHandle' has a wrong offset!");
static_assert(offsetof(UTedNewsPanel, content) == 0x0007F8, "Member 'UTedNewsPanel::content' has a wrong offset!");
static_assert(offsetof(UTedNewsPanel, Button_GoRight) == 0x000808, "Member 'UTedNewsPanel::Button_GoRight' has a wrong offset!");
static_assert(offsetof(UTedNewsPanel, Button_GoLeft) == 0x000810, "Member 'UTedNewsPanel::Button_GoLeft' has a wrong offset!");
static_assert(offsetof(UTedNewsPanel, Image_ExtendArrow) == 0x000818, "Member 'UTedNewsPanel::Image_ExtendArrow' has a wrong offset!");
static_assert(offsetof(UTedNewsPanel, Overlay_Banner) == 0x000820, "Member 'UTedNewsPanel::Overlay_Banner' has a wrong offset!");
static_assert(offsetof(UTedNewsPanel, SizeBox_GoLeft) == 0x000828, "Member 'UTedNewsPanel::SizeBox_GoLeft' has a wrong offset!");
static_assert(offsetof(UTedNewsPanel, SizeBox_GoRight) == 0x000830, "Member 'UTedNewsPanel::SizeBox_GoRight' has a wrong offset!");
static_assert(offsetof(UTedNewsPanel, Image_Header) == 0x000838, "Member 'UTedNewsPanel::Image_Header' has a wrong offset!");

// Class Tempest.TedNewsSlot
// 0x0058 (0x0488 - 0x0430)
class UTedNewsSlot final : public UTedContentPanelSlotButton
{
public:
	float                                         ExtendedHeight;                                    // 0x0430(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_434[0x4];                                      // 0x0434(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USizeBox*                               SizeBox_Content;                                   // 0x0438(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentExtendState;                                // 0x0440(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_444[0x4];                                      // 0x0444(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 Image_Picture;                                     // 0x0448(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Image_Loading;                                     // 0x0450(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             TextBlock_Title;                                   // 0x0458(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             TextBlock_Body;                                    // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTedGlowWidget*                         GlowingText_ReadMore;                              // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UButton*                                Button_ReadMore;                                   // 0x0470(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               CachedGlowMaterialForGlowingText;                  // 0x0478(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAsyncTaskDownloadImage*                DownloadImageTask;                                 // 0x0480(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddExtendedState(const struct FTedNewsTransitionConfig& InConfig, const float InChange);
	void LaunchURL();
	void RemoveGlowMaterialFromReadMoreText();
	void SetGlowMaterialToReadMoreText();
	void SetPicture(class UTexture2DDynamic* Texture);

	bool GetContent(struct FTedNewsContent* OutContent) const;
	class UTedNewsPanel* GetParentNewsPanel() const;
	bool IsExtendTransitionFinished() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedNewsSlot">();
	}
	static class UTedNewsSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedNewsSlot>();
	}
};
static_assert(alignof(UTedNewsSlot) == 0x000008, "Wrong alignment on UTedNewsSlot");
static_assert(sizeof(UTedNewsSlot) == 0x000488, "Wrong size on UTedNewsSlot");
static_assert(offsetof(UTedNewsSlot, ExtendedHeight) == 0x000430, "Member 'UTedNewsSlot::ExtendedHeight' has a wrong offset!");
static_assert(offsetof(UTedNewsSlot, SizeBox_Content) == 0x000438, "Member 'UTedNewsSlot::SizeBox_Content' has a wrong offset!");
static_assert(offsetof(UTedNewsSlot, CurrentExtendState) == 0x000440, "Member 'UTedNewsSlot::CurrentExtendState' has a wrong offset!");
static_assert(offsetof(UTedNewsSlot, Image_Picture) == 0x000448, "Member 'UTedNewsSlot::Image_Picture' has a wrong offset!");
static_assert(offsetof(UTedNewsSlot, Image_Loading) == 0x000450, "Member 'UTedNewsSlot::Image_Loading' has a wrong offset!");
static_assert(offsetof(UTedNewsSlot, TextBlock_Title) == 0x000458, "Member 'UTedNewsSlot::TextBlock_Title' has a wrong offset!");
static_assert(offsetof(UTedNewsSlot, TextBlock_Body) == 0x000460, "Member 'UTedNewsSlot::TextBlock_Body' has a wrong offset!");
static_assert(offsetof(UTedNewsSlot, GlowingText_ReadMore) == 0x000468, "Member 'UTedNewsSlot::GlowingText_ReadMore' has a wrong offset!");
static_assert(offsetof(UTedNewsSlot, Button_ReadMore) == 0x000470, "Member 'UTedNewsSlot::Button_ReadMore' has a wrong offset!");
static_assert(offsetof(UTedNewsSlot, CachedGlowMaterialForGlowingText) == 0x000478, "Member 'UTedNewsSlot::CachedGlowMaterialForGlowingText' has a wrong offset!");
static_assert(offsetof(UTedNewsSlot, DownloadImageTask) == 0x000480, "Member 'UTedNewsSlot::DownloadImageTask' has a wrong offset!");

// Class Tempest.TedObjectiveObj
// 0x0078 (0x00A0 - 0x0028)
class UTedObjectiveObj final : public UObject
{
public:
	class FText                                   Title;                                             // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   ScoreScreenTitleOverride;                          // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	EObjectiveDisplayMode                         DisplayMode;                                       // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedMarkerConfig*                       DefaultMarker;                                     // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedObjectiveConditionBase*             Condition;                                         // 0x0058(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   DescriptiveCauseOfFailure;                         // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTedObjectiveObj>        CauseOfFailure_ObjectiveTitleOverride;             // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         DoctrinePoints;                                    // 0x0098(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_99[0x1];                                       // 0x0099(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        RequisitionPoints;                                 // 0x009A(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         EquipmentSpace;                                    // 0x009C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         DoctrineResetPoints;                               // 0x009D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         EquipmentResetPoints;                              // 0x009E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAttemptedEquipmentSpaceFixup : 1;                 // 0x009F(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))

public:
	bool CanBeDisplayedOnUI() const;
	const TSoftObjectPtr<class UTedObjectiveObj> GetCauseOfFailureObjectiveTitleOverride() const;
	const class FText GetDescriptiveCauseOfFailure() const;
	int32 GetRequisitionPoints() const;
	class FText TryGetDisplayTitle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveObj">();
	}
	static class UTedObjectiveObj* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveObj>();
	}
};
static_assert(alignof(UTedObjectiveObj) == 0x000008, "Wrong alignment on UTedObjectiveObj");
static_assert(sizeof(UTedObjectiveObj) == 0x0000A0, "Wrong size on UTedObjectiveObj");
static_assert(offsetof(UTedObjectiveObj, Title) == 0x000028, "Member 'UTedObjectiveObj::Title' has a wrong offset!");
static_assert(offsetof(UTedObjectiveObj, ScoreScreenTitleOverride) == 0x000038, "Member 'UTedObjectiveObj::ScoreScreenTitleOverride' has a wrong offset!");
static_assert(offsetof(UTedObjectiveObj, DisplayMode) == 0x000048, "Member 'UTedObjectiveObj::DisplayMode' has a wrong offset!");
static_assert(offsetof(UTedObjectiveObj, DefaultMarker) == 0x000050, "Member 'UTedObjectiveObj::DefaultMarker' has a wrong offset!");
static_assert(offsetof(UTedObjectiveObj, Condition) == 0x000058, "Member 'UTedObjectiveObj::Condition' has a wrong offset!");
static_assert(offsetof(UTedObjectiveObj, DescriptiveCauseOfFailure) == 0x000060, "Member 'UTedObjectiveObj::DescriptiveCauseOfFailure' has a wrong offset!");
static_assert(offsetof(UTedObjectiveObj, CauseOfFailure_ObjectiveTitleOverride) == 0x000070, "Member 'UTedObjectiveObj::CauseOfFailure_ObjectiveTitleOverride' has a wrong offset!");
static_assert(offsetof(UTedObjectiveObj, DoctrinePoints) == 0x000098, "Member 'UTedObjectiveObj::DoctrinePoints' has a wrong offset!");
static_assert(offsetof(UTedObjectiveObj, RequisitionPoints) == 0x00009A, "Member 'UTedObjectiveObj::RequisitionPoints' has a wrong offset!");
static_assert(offsetof(UTedObjectiveObj, EquipmentSpace) == 0x00009C, "Member 'UTedObjectiveObj::EquipmentSpace' has a wrong offset!");
static_assert(offsetof(UTedObjectiveObj, DoctrineResetPoints) == 0x00009D, "Member 'UTedObjectiveObj::DoctrineResetPoints' has a wrong offset!");
static_assert(offsetof(UTedObjectiveObj, EquipmentResetPoints) == 0x00009E, "Member 'UTedObjectiveObj::EquipmentResetPoints' has a wrong offset!");

// Class Tempest.TedObjectiveCondition_Container
// 0x0020 (0x0108 - 0x00E8)
class UTedObjectiveCondition_Container : public UTedObjectiveConditionBase
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EObjectiveResult                              ExpectedResult;                                    // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTedObjectiveConditionBase*>     Conditions;                                        // 0x00F8(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveCondition_Container">();
	}
	static class UTedObjectiveCondition_Container* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveCondition_Container>();
	}
};
static_assert(alignof(UTedObjectiveCondition_Container) == 0x000008, "Wrong alignment on UTedObjectiveCondition_Container");
static_assert(sizeof(UTedObjectiveCondition_Container) == 0x000108, "Wrong size on UTedObjectiveCondition_Container");
static_assert(offsetof(UTedObjectiveCondition_Container, ExpectedResult) == 0x0000F0, "Member 'UTedObjectiveCondition_Container::ExpectedResult' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_Container, Conditions) == 0x0000F8, "Member 'UTedObjectiveCondition_Container::Conditions' has a wrong offset!");

// Class Tempest.TedObjectiveCondition_Container_OR
// 0x0000 (0x0108 - 0x0108)
class UTedObjectiveCondition_Container_OR final : public UTedObjectiveCondition_Container
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveCondition_Container_OR">();
	}
	static class UTedObjectiveCondition_Container_OR* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveCondition_Container_OR>();
	}
};
static_assert(alignof(UTedObjectiveCondition_Container_OR) == 0x000008, "Wrong alignment on UTedObjectiveCondition_Container_OR");
static_assert(sizeof(UTedObjectiveCondition_Container_OR) == 0x000108, "Wrong size on UTedObjectiveCondition_Container_OR");

// Class Tempest.TedObjectiveCondition_Container_AND
// 0x0000 (0x0108 - 0x0108)
class UTedObjectiveCondition_Container_AND final : public UTedObjectiveCondition_Container
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveCondition_Container_AND">();
	}
	static class UTedObjectiveCondition_Container_AND* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveCondition_Container_AND>();
	}
};
static_assert(alignof(UTedObjectiveCondition_Container_AND) == 0x000008, "Wrong alignment on UTedObjectiveCondition_Container_AND");
static_assert(sizeof(UTedObjectiveCondition_Container_AND) == 0x000108, "Wrong size on UTedObjectiveCondition_Container_AND");

// Class Tempest.TedObjectiveCondition_DisarmMine
// 0x03A0 (0x0500 - 0x0160)
class UTedObjectiveCondition_DisarmMine final : public UTedObjectiveCondition_ActorTag
{
public:
	uint8                                         Pad_160[0x8];                                      // 0x0160(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bCountDeathAsDisarm : 1;                           // 0x0168(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         ExpectedAmount;                                    // 0x0169(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bFilterDisarmingActor : 1;                         // 0x016A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_16B[0x5];                                      // 0x016B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedPawnFilter                         FilterDisarmingActor;                              // 0x0170(0x01C0)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         bNotMetOnTrigger : 1;                              // 0x0330(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_331[0x7];                                      // 0x0331(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedPawnFilter                         FilterTriggeringActor;                             // 0x0338(0x01C0)(Edit, Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentAmount;                                     // 0x04F8(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4FC[0x4];                                      // 0x04FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveCondition_DisarmMine">();
	}
	static class UTedObjectiveCondition_DisarmMine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveCondition_DisarmMine>();
	}
};
static_assert(alignof(UTedObjectiveCondition_DisarmMine) == 0x000008, "Wrong alignment on UTedObjectiveCondition_DisarmMine");
static_assert(sizeof(UTedObjectiveCondition_DisarmMine) == 0x000500, "Wrong size on UTedObjectiveCondition_DisarmMine");
static_assert(offsetof(UTedObjectiveCondition_DisarmMine, ExpectedAmount) == 0x000169, "Member 'UTedObjectiveCondition_DisarmMine::ExpectedAmount' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_DisarmMine, FilterDisarmingActor) == 0x000170, "Member 'UTedObjectiveCondition_DisarmMine::FilterDisarmingActor' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_DisarmMine, FilterTriggeringActor) == 0x000338, "Member 'UTedObjectiveCondition_DisarmMine::FilterTriggeringActor' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_DisarmMine, CurrentAmount) == 0x0004F8, "Member 'UTedObjectiveCondition_DisarmMine::CurrentAmount' has a wrong offset!");

// Class Tempest.TedObjectiveCondition_HasPrerequisites
// 0x0288 (0x0370 - 0x00E8)
class UTedObjectiveCondition_HasPrerequisites final : public UTedObjectiveConditionBase
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ETedPlayerID                                  PlayerID;                                          // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETedHasPrerequisitesTracking                  TrackingMethod;                                    // 0x00F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F2[0x6];                                       // 0x00F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTedObjectiveCondition_HasPrerequisites_PrerequisiteRequirements> RequiredPrerequisites; // 0x00F8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x250];                                    // 0x0108(0x0250)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AcceptanceThreshold;                               // 0x0358(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EComparison                                   ComparisonMethod;                                  // 0x035C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_35D[0x3];                                      // 0x035D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentSatisfiedAmount;                            // 0x0360(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_364[0xC];                                      // 0x0364(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayerDataOwnedTagsChange(class UTedPlayerData* InPlayerData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveCondition_HasPrerequisites">();
	}
	static class UTedObjectiveCondition_HasPrerequisites* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveCondition_HasPrerequisites>();
	}
};
static_assert(alignof(UTedObjectiveCondition_HasPrerequisites) == 0x000008, "Wrong alignment on UTedObjectiveCondition_HasPrerequisites");
static_assert(sizeof(UTedObjectiveCondition_HasPrerequisites) == 0x000370, "Wrong size on UTedObjectiveCondition_HasPrerequisites");
static_assert(offsetof(UTedObjectiveCondition_HasPrerequisites, PlayerID) == 0x0000F0, "Member 'UTedObjectiveCondition_HasPrerequisites::PlayerID' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_HasPrerequisites, TrackingMethod) == 0x0000F1, "Member 'UTedObjectiveCondition_HasPrerequisites::TrackingMethod' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_HasPrerequisites, RequiredPrerequisites) == 0x0000F8, "Member 'UTedObjectiveCondition_HasPrerequisites::RequiredPrerequisites' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_HasPrerequisites, AcceptanceThreshold) == 0x000358, "Member 'UTedObjectiveCondition_HasPrerequisites::AcceptanceThreshold' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_HasPrerequisites, ComparisonMethod) == 0x00035C, "Member 'UTedObjectiveCondition_HasPrerequisites::ComparisonMethod' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_HasPrerequisites, CurrentSatisfiedAmount) == 0x000360, "Member 'UTedObjectiveCondition_HasPrerequisites::CurrentSatisfiedAmount' has a wrong offset!");

// Class Tempest.TedObjectiveCondition_HavePawnsOfType
// 0x0058 (0x0140 - 0x00E8)
class UTedObjectiveCondition_HavePawnsOfType final : public UTedObjectiveConditionBase
{
public:
	uint8                                         PlayerIndex;                                       // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TSoftClassPtr<class UClass>>             Types;                                             // 0x00F0(0x0050)(Edit, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveCondition_HavePawnsOfType">();
	}
	static class UTedObjectiveCondition_HavePawnsOfType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveCondition_HavePawnsOfType>();
	}
};
static_assert(alignof(UTedObjectiveCondition_HavePawnsOfType) == 0x000008, "Wrong alignment on UTedObjectiveCondition_HavePawnsOfType");
static_assert(sizeof(UTedObjectiveCondition_HavePawnsOfType) == 0x000140, "Wrong size on UTedObjectiveCondition_HavePawnsOfType");
static_assert(offsetof(UTedObjectiveCondition_HavePawnsOfType, PlayerIndex) == 0x0000E8, "Member 'UTedObjectiveCondition_HavePawnsOfType::PlayerIndex' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_HavePawnsOfType, Types) == 0x0000F0, "Member 'UTedObjectiveCondition_HavePawnsOfType::Types' has a wrong offset!");

// Class Tempest.TedObjectiveCondition_HaveResource_Credits
// 0x0008 (0x0100 - 0x00F8)
class UTedObjectiveCondition_HaveResource_Credits final : public UTedObjectiveCondition_HaveResourceBase
{
public:
	uint8                                         bPercentage : 1;                                   // 0x00F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveCondition_HaveResource_Credits">();
	}
	static class UTedObjectiveCondition_HaveResource_Credits* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveCondition_HaveResource_Credits>();
	}
};
static_assert(alignof(UTedObjectiveCondition_HaveResource_Credits) == 0x000008, "Wrong alignment on UTedObjectiveCondition_HaveResource_Credits");
static_assert(sizeof(UTedObjectiveCondition_HaveResource_Credits) == 0x000100, "Wrong size on UTedObjectiveCondition_HaveResource_Credits");

// Class Tempest.TedObjectiveCondition_HaveResource_Power
// 0x0000 (0x00F8 - 0x00F8)
class UTedObjectiveCondition_HaveResource_Power final : public UTedObjectiveCondition_HaveResourceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveCondition_HaveResource_Power">();
	}
	static class UTedObjectiveCondition_HaveResource_Power* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveCondition_HaveResource_Power>();
	}
};
static_assert(alignof(UTedObjectiveCondition_HaveResource_Power) == 0x000008, "Wrong alignment on UTedObjectiveCondition_HaveResource_Power");
static_assert(sizeof(UTedObjectiveCondition_HaveResource_Power) == 0x0000F8, "Wrong size on UTedObjectiveCondition_HaveResource_Power");

// Class Tempest.TedObjectiveCondition_HaveResource_Intel
// 0x0000 (0x00F8 - 0x00F8)
class UTedObjectiveCondition_HaveResource_Intel final : public UTedObjectiveCondition_HaveResourceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveCondition_HaveResource_Intel">();
	}
	static class UTedObjectiveCondition_HaveResource_Intel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveCondition_HaveResource_Intel>();
	}
};
static_assert(alignof(UTedObjectiveCondition_HaveResource_Intel) == 0x000008, "Wrong alignment on UTedObjectiveCondition_HaveResource_Intel");
static_assert(sizeof(UTedObjectiveCondition_HaveResource_Intel) == 0x0000F8, "Wrong size on UTedObjectiveCondition_HaveResource_Intel");

// Class Tempest.TedObjectiveCondition_HaveTech
// 0x0108 (0x01F0 - 0x00E8)
class UTedObjectiveCondition_HaveTech final : public UTedObjectiveConditionBase
{
public:
	ETedHaveTechTracking                          Track;                                             // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedPlayerID                                  PlayerID;                                          // 0x00E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EComparison                                   TechComparison;                                    // 0x00EA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EB[0x5];                                       // 0x00EB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, uint32>             Tech2;                                             // 0x00F0(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	uint32                                        ExpectedAmount;                                    // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EComparison                                   ComparisonMethod;                                  // 0x0144(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_145[0x3];                                      // 0x0145(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, uint32>             CurrentTechCount;                                  // 0x0148(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	uint32                                        CurrentTotalCount;                                 // 0x0198(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_19C[0x4];                                      // 0x019C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FGameplayTag>                     Tech;                                              // 0x01A0(0x0050)(Deprecated, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveCondition_HaveTech">();
	}
	static class UTedObjectiveCondition_HaveTech* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveCondition_HaveTech>();
	}
};
static_assert(alignof(UTedObjectiveCondition_HaveTech) == 0x000008, "Wrong alignment on UTedObjectiveCondition_HaveTech");
static_assert(sizeof(UTedObjectiveCondition_HaveTech) == 0x0001F0, "Wrong size on UTedObjectiveCondition_HaveTech");
static_assert(offsetof(UTedObjectiveCondition_HaveTech, Track) == 0x0000E8, "Member 'UTedObjectiveCondition_HaveTech::Track' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_HaveTech, PlayerID) == 0x0000E9, "Member 'UTedObjectiveCondition_HaveTech::PlayerID' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_HaveTech, TechComparison) == 0x0000EA, "Member 'UTedObjectiveCondition_HaveTech::TechComparison' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_HaveTech, Tech2) == 0x0000F0, "Member 'UTedObjectiveCondition_HaveTech::Tech2' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_HaveTech, ExpectedAmount) == 0x000140, "Member 'UTedObjectiveCondition_HaveTech::ExpectedAmount' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_HaveTech, ComparisonMethod) == 0x000144, "Member 'UTedObjectiveCondition_HaveTech::ComparisonMethod' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_HaveTech, CurrentTechCount) == 0x000148, "Member 'UTedObjectiveCondition_HaveTech::CurrentTechCount' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_HaveTech, CurrentTotalCount) == 0x000198, "Member 'UTedObjectiveCondition_HaveTech::CurrentTotalCount' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_HaveTech, Tech) == 0x0001A0, "Member 'UTedObjectiveCondition_HaveTech::Tech' has a wrong offset!");

// Class Tempest.TedObjectiveCondition_HaveUpgrade
// 0x00B8 (0x01A0 - 0x00E8)
class UTedObjectiveCondition_HaveUpgrade final : public UTedObjectiveConditionBase
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ETedHaveUpgradesTracking                      Track;                                             // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedPlayerID                                  PlayerID;                                          // 0x00F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F2[0x6];                                       // 0x00F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TSoftObjectPtr<class UTedUpgrade>>       upgrades;                                          // 0x00F8(0x0050)(Edit, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint32                                        ExpectedAmount;                                    // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EComparison                                   ComparisonMethod;                                  // 0x014C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14D[0x3];                                      // 0x014D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TSoftObjectPtr<class UTedUpgrade>>       CurrentUpgrades;                                   // 0x0150(0x0050)(Transient, DuplicateTransient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveCondition_HaveUpgrade">();
	}
	static class UTedObjectiveCondition_HaveUpgrade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveCondition_HaveUpgrade>();
	}
};
static_assert(alignof(UTedObjectiveCondition_HaveUpgrade) == 0x000008, "Wrong alignment on UTedObjectiveCondition_HaveUpgrade");
static_assert(sizeof(UTedObjectiveCondition_HaveUpgrade) == 0x0001A0, "Wrong size on UTedObjectiveCondition_HaveUpgrade");
static_assert(offsetof(UTedObjectiveCondition_HaveUpgrade, Track) == 0x0000F0, "Member 'UTedObjectiveCondition_HaveUpgrade::Track' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_HaveUpgrade, PlayerID) == 0x0000F1, "Member 'UTedObjectiveCondition_HaveUpgrade::PlayerID' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_HaveUpgrade, upgrades) == 0x0000F8, "Member 'UTedObjectiveCondition_HaveUpgrade::upgrades' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_HaveUpgrade, ExpectedAmount) == 0x000148, "Member 'UTedObjectiveCondition_HaveUpgrade::ExpectedAmount' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_HaveUpgrade, ComparisonMethod) == 0x00014C, "Member 'UTedObjectiveCondition_HaveUpgrade::ComparisonMethod' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_HaveUpgrade, CurrentUpgrades) == 0x000150, "Member 'UTedObjectiveCondition_HaveUpgrade::CurrentUpgrades' has a wrong offset!");

// Class Tempest.TedObjectiveCondition_KillActorsV2
// 0x0010 (0x0170 - 0x0160)
class UTedObjectiveCondition_KillActorsV2 final : public UTedObjectiveCondition_ActorTag
{
public:
	uint8                                         Pad_160[0x8];                                      // 0x0160(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         ExpectedAmount;                                    // 0x0168(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreActorTagAddedNotification;                  // 0x0169(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16A[0x2];                                      // 0x016A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KilledActors;                                      // 0x016C(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveCondition_KillActorsV2">();
	}
	static class UTedObjectiveCondition_KillActorsV2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveCondition_KillActorsV2>();
	}
};
static_assert(alignof(UTedObjectiveCondition_KillActorsV2) == 0x000008, "Wrong alignment on UTedObjectiveCondition_KillActorsV2");
static_assert(sizeof(UTedObjectiveCondition_KillActorsV2) == 0x000170, "Wrong size on UTedObjectiveCondition_KillActorsV2");
static_assert(offsetof(UTedObjectiveCondition_KillActorsV2, ExpectedAmount) == 0x000168, "Member 'UTedObjectiveCondition_KillActorsV2::ExpectedAmount' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_KillActorsV2, bIgnoreActorTagAddedNotification) == 0x000169, "Member 'UTedObjectiveCondition_KillActorsV2::bIgnoreActorTagAddedNotification' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_KillActorsV2, KilledActors) == 0x00016C, "Member 'UTedObjectiveCondition_KillActorsV2::KilledActors' has a wrong offset!");

// Class Tempest.TedObjectiveCondition_LatentActionBase
// 0x0018 (0x0100 - 0x00E8)
class UTedObjectiveCondition_LatentActionBase : public UTedObjectiveConditionBase
{
public:
	uint8                                         Pad_E8[0x18];                                      // 0x00E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveCondition_LatentActionBase">();
	}
	static class UTedObjectiveCondition_LatentActionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveCondition_LatentActionBase>();
	}
};
static_assert(alignof(UTedObjectiveCondition_LatentActionBase) == 0x000008, "Wrong alignment on UTedObjectiveCondition_LatentActionBase");
static_assert(sizeof(UTedObjectiveCondition_LatentActionBase) == 0x000100, "Wrong size on UTedObjectiveCondition_LatentActionBase");

// Class Tempest.TedObjectiveCondition_PlayerResource_Credits_LatentActionTest
// 0x0008 (0x0108 - 0x0100)
class UTedObjectiveCondition_PlayerResource_Credits_LatentActionTest final : public UTedObjectiveCondition_LatentActionBase
{
public:
	ETedPlayerID                                  Player;                                            // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EComparison                                   ComparisonMethod;                                  // 0x0101(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_102[0x2];                                      // 0x0102(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        ExpectedAmount;                                    // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveCondition_PlayerResource_Credits_LatentActionTest">();
	}
	static class UTedObjectiveCondition_PlayerResource_Credits_LatentActionTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveCondition_PlayerResource_Credits_LatentActionTest>();
	}
};
static_assert(alignof(UTedObjectiveCondition_PlayerResource_Credits_LatentActionTest) == 0x000008, "Wrong alignment on UTedObjectiveCondition_PlayerResource_Credits_LatentActionTest");
static_assert(sizeof(UTedObjectiveCondition_PlayerResource_Credits_LatentActionTest) == 0x000108, "Wrong size on UTedObjectiveCondition_PlayerResource_Credits_LatentActionTest");
static_assert(offsetof(UTedObjectiveCondition_PlayerResource_Credits_LatentActionTest, Player) == 0x000100, "Member 'UTedObjectiveCondition_PlayerResource_Credits_LatentActionTest::Player' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_PlayerResource_Credits_LatentActionTest, ComparisonMethod) == 0x000101, "Member 'UTedObjectiveCondition_PlayerResource_Credits_LatentActionTest::ComparisonMethod' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_PlayerResource_Credits_LatentActionTest, ExpectedAmount) == 0x000104, "Member 'UTedObjectiveCondition_PlayerResource_Credits_LatentActionTest::ExpectedAmount' has a wrong offset!");

// Class Tempest.TedObjectiveCondition_Objective
// 0x0200 (0x02E8 - 0x00E8)
class UTedObjectiveCondition_Objective final : public UTedObjectiveConditionBase
{
public:
	class UTedObjectiveObj*                       Objective;                                         // 0x00E8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EObjectiveState                               ExpectedResult;                                    // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class AVolume>                 ActivationVolume;                                  // 0x00F8(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTedPawnFilter                         ActivationVolumeFilter;                            // 0x0120(0x01C0)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnVolumeBeginOverlap_Handler(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveCondition_Objective">();
	}
	static class UTedObjectiveCondition_Objective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveCondition_Objective>();
	}
};
static_assert(alignof(UTedObjectiveCondition_Objective) == 0x000008, "Wrong alignment on UTedObjectiveCondition_Objective");
static_assert(sizeof(UTedObjectiveCondition_Objective) == 0x0002E8, "Wrong size on UTedObjectiveCondition_Objective");
static_assert(offsetof(UTedObjectiveCondition_Objective, Objective) == 0x0000E8, "Member 'UTedObjectiveCondition_Objective::Objective' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_Objective, ExpectedResult) == 0x0000F0, "Member 'UTedObjectiveCondition_Objective::ExpectedResult' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_Objective, ActivationVolume) == 0x0000F8, "Member 'UTedObjectiveCondition_Objective::ActivationVolume' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_Objective, ActivationVolumeFilter) == 0x000120, "Member 'UTedObjectiveCondition_Objective::ActivationVolumeFilter' has a wrong offset!");

// Class Tempest.TedObjectiveCondition_OwnPawn
// 0x0058 (0x01B8 - 0x0160)
class UTedObjectiveCondition_OwnPawn final : public UTedObjectiveCondition_ActorTag
{
public:
	uint8                                         Pad_160[0x8];                                      // 0x0160(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ETedPlayerID                                  Player;                                            // 0x0168(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bInverseCondition : 1;                             // 0x0169(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         ExpectedAmount;                                    // 0x016A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EComparison                                   Comparison;                                        // 0x016B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentAmount;                                     // 0x016C(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bOverride_HandleKilledPawns : 1;                   // 0x0170(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_171[0x7];                                      // 0x0171(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedLatentAction_ActorTagCounter_KillActors_Wrapper HandleKilledPawns;                    // 0x0178(0x0040)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveCondition_OwnPawn">();
	}
	static class UTedObjectiveCondition_OwnPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveCondition_OwnPawn>();
	}
};
static_assert(alignof(UTedObjectiveCondition_OwnPawn) == 0x000008, "Wrong alignment on UTedObjectiveCondition_OwnPawn");
static_assert(sizeof(UTedObjectiveCondition_OwnPawn) == 0x0001B8, "Wrong size on UTedObjectiveCondition_OwnPawn");
static_assert(offsetof(UTedObjectiveCondition_OwnPawn, Player) == 0x000168, "Member 'UTedObjectiveCondition_OwnPawn::Player' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_OwnPawn, ExpectedAmount) == 0x00016A, "Member 'UTedObjectiveCondition_OwnPawn::ExpectedAmount' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_OwnPawn, Comparison) == 0x00016B, "Member 'UTedObjectiveCondition_OwnPawn::Comparison' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_OwnPawn, CurrentAmount) == 0x00016C, "Member 'UTedObjectiveCondition_OwnPawn::CurrentAmount' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_OwnPawn, HandleKilledPawns) == 0x000178, "Member 'UTedObjectiveCondition_OwnPawn::HandleKilledPawns' has a wrong offset!");

// Class Tempest.TedObjectiveCondition_Pickup
// 0x0010 (0x0170 - 0x0160)
class UTedObjectiveCondition_Pickup final : public UTedObjectiveCondition_ActorTag
{
public:
	uint8                                         Pad_160[0x8];                                      // 0x0160(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         ExpectedAmount;                                    // 0x0168(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_169[0x3];                                      // 0x0169(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentAmount;                                     // 0x016C(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPickup(class ATedUnitBase* InPickedUpBy, class ATedPickupActor* InPickup);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveCondition_Pickup">();
	}
	static class UTedObjectiveCondition_Pickup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveCondition_Pickup>();
	}
};
static_assert(alignof(UTedObjectiveCondition_Pickup) == 0x000008, "Wrong alignment on UTedObjectiveCondition_Pickup");
static_assert(sizeof(UTedObjectiveCondition_Pickup) == 0x000170, "Wrong size on UTedObjectiveCondition_Pickup");
static_assert(offsetof(UTedObjectiveCondition_Pickup, ExpectedAmount) == 0x000168, "Member 'UTedObjectiveCondition_Pickup::ExpectedAmount' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_Pickup, CurrentAmount) == 0x00016C, "Member 'UTedObjectiveCondition_Pickup::CurrentAmount' has a wrong offset!");

// Class Tempest.TedObjectiveCondition_Time
// 0x0030 (0x0118 - 0x00E8)
class UTedObjectiveCondition_Time final : public UTedObjectiveConditionBase
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    DifficultyPreset;                                  // 0x00F0(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         ExpectedTimeMinutes;                               // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           TH_Waiting;                                        // 0x0108(0x0008)(Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           TH_UpdatingProgress;                               // 0x0110(0x0008)(Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void PassRuntimeData(const float InExpectedTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveCondition_Time">();
	}
	static class UTedObjectiveCondition_Time* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveCondition_Time>();
	}
};
static_assert(alignof(UTedObjectiveCondition_Time) == 0x000008, "Wrong alignment on UTedObjectiveCondition_Time");
static_assert(sizeof(UTedObjectiveCondition_Time) == 0x000118, "Wrong size on UTedObjectiveCondition_Time");
static_assert(offsetof(UTedObjectiveCondition_Time, DifficultyPreset) == 0x0000F0, "Member 'UTedObjectiveCondition_Time::DifficultyPreset' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_Time, ExpectedTimeMinutes) == 0x000100, "Member 'UTedObjectiveCondition_Time::ExpectedTimeMinutes' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_Time, TH_Waiting) == 0x000108, "Member 'UTedObjectiveCondition_Time::TH_Waiting' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_Time, TH_UpdatingProgress) == 0x000110, "Member 'UTedObjectiveCondition_Time::TH_UpdatingProgress' has a wrong offset!");

// Class Tempest.TedObjectiveCondition_UseCommand
// 0x00D0 (0x01B8 - 0x00E8)
class UTedObjectiveCondition_UseCommand final : public UTedObjectiveConditionBase
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           Command;                                           // 0x00F0(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedObjectiveCommandTracking                  Tracking;                                          // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedPlayerID                                  CommandPlayer;                                     // 0x00F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FA[0x6];                                       // 0x00FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  CommandActors;                                     // 0x0100(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  TargetActors;                                      // 0x0120(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         TargetDistanceTolerance;                           // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ExpectedAmount;                                    // 0x0144(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedObjectiveCommandConditionMarker           MarkerVisibility;                                  // 0x0148(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AActor*>                           CachedCommandActors;                               // 0x0150(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentAmount;                                     // 0x01A0(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A4[0x4];                                      // 0x01A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedMarkerConfig*                       CommandActorMarker;                                // 0x01A8(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedMarkerConfig*                       TargetActorMarker;                                 // 0x01B0(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveCondition_UseCommand">();
	}
	static class UTedObjectiveCondition_UseCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveCondition_UseCommand>();
	}
};
static_assert(alignof(UTedObjectiveCondition_UseCommand) == 0x000008, "Wrong alignment on UTedObjectiveCondition_UseCommand");
static_assert(sizeof(UTedObjectiveCondition_UseCommand) == 0x0001B8, "Wrong size on UTedObjectiveCondition_UseCommand");
static_assert(offsetof(UTedObjectiveCondition_UseCommand, Command) == 0x0000F0, "Member 'UTedObjectiveCondition_UseCommand::Command' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_UseCommand, Tracking) == 0x0000F8, "Member 'UTedObjectiveCondition_UseCommand::Tracking' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_UseCommand, CommandPlayer) == 0x0000F9, "Member 'UTedObjectiveCondition_UseCommand::CommandPlayer' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_UseCommand, CommandActors) == 0x000100, "Member 'UTedObjectiveCondition_UseCommand::CommandActors' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_UseCommand, TargetActors) == 0x000120, "Member 'UTedObjectiveCondition_UseCommand::TargetActors' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_UseCommand, TargetDistanceTolerance) == 0x000140, "Member 'UTedObjectiveCondition_UseCommand::TargetDistanceTolerance' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_UseCommand, ExpectedAmount) == 0x000144, "Member 'UTedObjectiveCondition_UseCommand::ExpectedAmount' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_UseCommand, MarkerVisibility) == 0x000148, "Member 'UTedObjectiveCondition_UseCommand::MarkerVisibility' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_UseCommand, CachedCommandActors) == 0x000150, "Member 'UTedObjectiveCondition_UseCommand::CachedCommandActors' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_UseCommand, CurrentAmount) == 0x0001A0, "Member 'UTedObjectiveCondition_UseCommand::CurrentAmount' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_UseCommand, CommandActorMarker) == 0x0001A8, "Member 'UTedObjectiveCondition_UseCommand::CommandActorMarker' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_UseCommand, TargetActorMarker) == 0x0001B0, "Member 'UTedObjectiveCondition_UseCommand::TargetActorMarker' has a wrong offset!");

// Class Tempest.TedObjectiveCondition_Volume
// 0x03F0 (0x04D8 - 0x00E8)
class UTedObjectiveCondition_Volume final : public UTedObjectiveConditionBase
{
public:
	TSoftObjectPtr<class AVolume>                 Volume;                                            // 0x00E8(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bEnablePlacementVolume : 1;                        // 0x0110(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bTrackEntering : 1;                                // 0x0110(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedPawnFilter                         EnteringPawnFilter;                                // 0x0118(0x01C0)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         bTrackLeaving : 1;                                 // 0x02D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2D9[0x7];                                      // 0x02D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedPawnFilter                         LeavingPawnFilter;                                 // 0x02E0(0x01C0)(Edit, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class AActor>                  MarkerActorOverride;                               // 0x04A0(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AVolume*                                VolumeActor;                                       // 0x04C8(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedMarkerConfig*                       MarkerConfig;                                      // 0x04D0(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnVolumeBeginOverlap_Handler(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnVolumeEndOverlap_Handler(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveCondition_Volume">();
	}
	static class UTedObjectiveCondition_Volume* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveCondition_Volume>();
	}
};
static_assert(alignof(UTedObjectiveCondition_Volume) == 0x000008, "Wrong alignment on UTedObjectiveCondition_Volume");
static_assert(sizeof(UTedObjectiveCondition_Volume) == 0x0004D8, "Wrong size on UTedObjectiveCondition_Volume");
static_assert(offsetof(UTedObjectiveCondition_Volume, Volume) == 0x0000E8, "Member 'UTedObjectiveCondition_Volume::Volume' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_Volume, EnteringPawnFilter) == 0x000118, "Member 'UTedObjectiveCondition_Volume::EnteringPawnFilter' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_Volume, LeavingPawnFilter) == 0x0002E0, "Member 'UTedObjectiveCondition_Volume::LeavingPawnFilter' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_Volume, MarkerActorOverride) == 0x0004A0, "Member 'UTedObjectiveCondition_Volume::MarkerActorOverride' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_Volume, VolumeActor) == 0x0004C8, "Member 'UTedObjectiveCondition_Volume::VolumeActor' has a wrong offset!");
static_assert(offsetof(UTedObjectiveCondition_Volume, MarkerConfig) == 0x0004D0, "Member 'UTedObjectiveCondition_Volume::MarkerConfig' has a wrong offset!");

// Class Tempest.TedObjectiveFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UTedObjectiveFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ActivateObjective(const class UObject* InWorldContext, const class UTedObjectiveObj* Objective, const class UTedObjectiveObj* OptionalParent);
	static void BranchObjectiveState(const class UObject* InWorldContext, const class UTedObjectiveObj* Objective, EObjectiveState* State);
	static void DeactivateObjective(const class UObject* InWorldContext, const class UTedObjectiveObj* Objective);
	static void FailAllActiveObjectives(const class UObject* InWorldContext);
	static void FinishObjective(const class UObject* InWorldContext, const class UTedObjectiveObj* Objective, const EObjectiveResult Result);
	static class UTedObjectiveConditionBase* GetConditionByClass(const class UObject* InWorldContext, const class UTedObjectiveObj* Objective, TSubclassOf<class UTedObjectiveConditionBase> Class_0);
	static class UTedObjectiveConditionBase* GetConditionByID(const class UObject* InWorldContext, const class UTedObjectiveObj* Objective, const struct FGameplayTag& RuntimeID);
	static EObjectiveState GetObjectiveState(const class UObject* InWorldContext, const class UTedObjectiveObj* Objective);
	static int32 GetRuntimeObjectivesAmountByState(const class UObject* InWorldContext, const EObjectiveDisplayMode DisplayMode, const EObjectiveState State);
	static bool IsObjectiveInState(const class UObject* InWorldContext, const class UTedObjectiveObj* Objective, const EObjectiveState State);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveFunctionLibrary">();
	}
	static class UTedObjectiveFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveFunctionLibrary>();
	}
};
static_assert(alignof(UTedObjectiveFunctionLibrary) == 0x000008, "Wrong alignment on UTedObjectiveFunctionLibrary");
static_assert(sizeof(UTedObjectiveFunctionLibrary) == 0x000028, "Wrong size on UTedObjectiveFunctionLibrary");

// Class Tempest.TedObjectiveManager
// 0x0080 (0x00B0 - 0x0030)
class UTedObjectiveManager final : public UWorldSubsystem
{
public:
	TMap<class UTedObjectiveObj*, struct FTedObjectiveInstance> Objectives;                          // 0x0030(0x0050)(Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FTedObjectiveCauseOfFailureData        CauseOfFailureData;                                // 0x0080(0x0018)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0x18];                                      // 0x0098(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FTedObjectiveCauseOfFailureData GetObjectiveCauseOfFailureData(const class UObject* InWorldContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveManager">();
	}
	static class UTedObjectiveManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveManager>();
	}
};
static_assert(alignof(UTedObjectiveManager) == 0x000008, "Wrong alignment on UTedObjectiveManager");
static_assert(sizeof(UTedObjectiveManager) == 0x0000B0, "Wrong size on UTedObjectiveManager");
static_assert(offsetof(UTedObjectiveManager, Objectives) == 0x000030, "Member 'UTedObjectiveManager::Objectives' has a wrong offset!");
static_assert(offsetof(UTedObjectiveManager, CauseOfFailureData) == 0x000080, "Member 'UTedObjectiveManager::CauseOfFailureData' has a wrong offset!");

// Class Tempest.TedObjectivePanel
// 0x0228 (0x09D8 - 0x07B0)
class UTedObjectivePanel : public UTedContentPanelDynamic
{
public:
	uint8                                         bAutoHideWhenEmpty : 1;                            // 0x07B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAutoContent : 1;                                  // 0x07B0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAutoContentConditions : 1;                        // 0x07B0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_7B1[0x7];                                      // 0x07B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<EObjectiveState>                         AutoContentStatesToAdd;                            // 0x07B8(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TSet<EObjectiveState>                         AutoContentStatesToKeep;                           // 0x0808(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TSet<EObjectiveState>                         AutoContentStatesToRemoveAfterAnim;                // 0x0858(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	EObjectiveDisplayMode                         AutoContentDisplayMode;                            // 0x08A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8A9[0x7];                                      // 0x08A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   NotificationPriority;                              // 0x08B0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<EObjectiveState, struct FGameplayTag>    ObjectiveStateToNotificationMap;                   // 0x08C0(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         bSupportTracking : 1;                              // 0x0910(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_911[0x7];                                      // 0x0911(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTedObjectivePanelContent>      content;                                           // 0x0918(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_928[0x8];                                      // 0x0928(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UObject*, struct FGameplayTag>     PendingNotifications;                              // 0x0930(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TMap<class UObject*, struct FGameplayTag>     PlayingNotifications;                              // 0x0980(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           TH_ProcessingPendingNotifications;                 // 0x09D0(0x0008)(Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnObjectiveSlotAnimEnd(class UTedUserWidget* InWidget, const struct FGameplayTag& InAnimation);
	void OnObjectiveSlotAnimStart(class UTedUserWidget* InWidget, const struct FGameplayTag& InAnimation);
	void SetContentObjectives(const TArray<class UTedObjectiveObj*>& InContent);

	bool HasChildren(const int32 InSlotIndex) const;
	bool HasParentObjective(const int32 InSlotIndex) const;
	bool IsCondition(const int32 InSlotIndex) const;
	bool IsObjective(const int32 InSlotIndex) const;
	bool IsOptional(const int32 InSlotIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectivePanel">();
	}
	static class UTedObjectivePanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectivePanel>();
	}
};
static_assert(alignof(UTedObjectivePanel) == 0x000008, "Wrong alignment on UTedObjectivePanel");
static_assert(sizeof(UTedObjectivePanel) == 0x0009D8, "Wrong size on UTedObjectivePanel");
static_assert(offsetof(UTedObjectivePanel, AutoContentStatesToAdd) == 0x0007B8, "Member 'UTedObjectivePanel::AutoContentStatesToAdd' has a wrong offset!");
static_assert(offsetof(UTedObjectivePanel, AutoContentStatesToKeep) == 0x000808, "Member 'UTedObjectivePanel::AutoContentStatesToKeep' has a wrong offset!");
static_assert(offsetof(UTedObjectivePanel, AutoContentStatesToRemoveAfterAnim) == 0x000858, "Member 'UTedObjectivePanel::AutoContentStatesToRemoveAfterAnim' has a wrong offset!");
static_assert(offsetof(UTedObjectivePanel, AutoContentDisplayMode) == 0x0008A8, "Member 'UTedObjectivePanel::AutoContentDisplayMode' has a wrong offset!");
static_assert(offsetof(UTedObjectivePanel, NotificationPriority) == 0x0008B0, "Member 'UTedObjectivePanel::NotificationPriority' has a wrong offset!");
static_assert(offsetof(UTedObjectivePanel, ObjectiveStateToNotificationMap) == 0x0008C0, "Member 'UTedObjectivePanel::ObjectiveStateToNotificationMap' has a wrong offset!");
static_assert(offsetof(UTedObjectivePanel, content) == 0x000918, "Member 'UTedObjectivePanel::content' has a wrong offset!");
static_assert(offsetof(UTedObjectivePanel, PendingNotifications) == 0x000930, "Member 'UTedObjectivePanel::PendingNotifications' has a wrong offset!");
static_assert(offsetof(UTedObjectivePanel, PlayingNotifications) == 0x000980, "Member 'UTedObjectivePanel::PlayingNotifications' has a wrong offset!");
static_assert(offsetof(UTedObjectivePanel, TH_ProcessingPendingNotifications) == 0x0009D0, "Member 'UTedObjectivePanel::TH_ProcessingPendingNotifications' has a wrong offset!");

// Class Tempest.TedObjectiveProgressInterface_IntegerCounter
// 0x0000 (0x0000 - 0x0000)
class ITedObjectiveProgressInterface_IntegerCounter final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveProgressInterface_IntegerCounter">();
	}
	static class ITedObjectiveProgressInterface_IntegerCounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITedObjectiveProgressInterface_IntegerCounter>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITedObjectiveProgressInterface_IntegerCounter) == 0x000001, "Wrong alignment on ITedObjectiveProgressInterface_IntegerCounter");
static_assert(sizeof(ITedObjectiveProgressInterface_IntegerCounter) == 0x000001, "Wrong size on ITedObjectiveProgressInterface_IntegerCounter");

// Class Tempest.TedObjectiveProgressInterface_TimeCountdown
// 0x0000 (0x0000 - 0x0000)
class ITedObjectiveProgressInterface_TimeCountdown final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveProgressInterface_TimeCountdown">();
	}
	static class ITedObjectiveProgressInterface_TimeCountdown* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITedObjectiveProgressInterface_TimeCountdown>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITedObjectiveProgressInterface_TimeCountdown) == 0x000001, "Wrong alignment on ITedObjectiveProgressInterface_TimeCountdown");
static_assert(sizeof(ITedObjectiveProgressInterface_TimeCountdown) == 0x000001, "Wrong size on ITedObjectiveProgressInterface_TimeCountdown");

// Class Tempest.TedObjectiveProgressWidget_TimeCountdown
// 0x0020 (0x0420 - 0x0400)
class UTedObjectiveProgressWidget_TimeCountdown : public UTedObjectiveProgressWidget
{
public:
	class UProgressBar*                           ProgressBar_ElapsedTime;                           // 0x0400(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           ProgressBar_RemainingTime;                         // 0x0408(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_RemainingTime;                           // 0x0410(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                Text_RemainingTime;                                // 0x0418(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveProgressWidget_TimeCountdown">();
	}
	static class UTedObjectiveProgressWidget_TimeCountdown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveProgressWidget_TimeCountdown>();
	}
};
static_assert(alignof(UTedObjectiveProgressWidget_TimeCountdown) == 0x000008, "Wrong alignment on UTedObjectiveProgressWidget_TimeCountdown");
static_assert(sizeof(UTedObjectiveProgressWidget_TimeCountdown) == 0x000420, "Wrong size on UTedObjectiveProgressWidget_TimeCountdown");
static_assert(offsetof(UTedObjectiveProgressWidget_TimeCountdown, ProgressBar_ElapsedTime) == 0x000400, "Member 'UTedObjectiveProgressWidget_TimeCountdown::ProgressBar_ElapsedTime' has a wrong offset!");
static_assert(offsetof(UTedObjectiveProgressWidget_TimeCountdown, ProgressBar_RemainingTime) == 0x000408, "Member 'UTedObjectiveProgressWidget_TimeCountdown::ProgressBar_RemainingTime' has a wrong offset!");
static_assert(offsetof(UTedObjectiveProgressWidget_TimeCountdown, TextBlock_RemainingTime) == 0x000410, "Member 'UTedObjectiveProgressWidget_TimeCountdown::TextBlock_RemainingTime' has a wrong offset!");
static_assert(offsetof(UTedObjectiveProgressWidget_TimeCountdown, Text_RemainingTime) == 0x000418, "Member 'UTedObjectiveProgressWidget_TimeCountdown::Text_RemainingTime' has a wrong offset!");

// Class Tempest.TedObjectiveProgress_IntegerCounter
// 0x0000 (0x0028 - 0x0028)
class UTedObjectiveProgress_IntegerCounter final : public UTedObjectiveProgress
{
public:
	int32 GetCurrentValue() const;
	int32 GetMaxValue() const;
	float GetPercent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveProgress_IntegerCounter">();
	}
	static class UTedObjectiveProgress_IntegerCounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveProgress_IntegerCounter>();
	}
};
static_assert(alignof(UTedObjectiveProgress_IntegerCounter) == 0x000008, "Wrong alignment on UTedObjectiveProgress_IntegerCounter");
static_assert(sizeof(UTedObjectiveProgress_IntegerCounter) == 0x000028, "Wrong size on UTedObjectiveProgress_IntegerCounter");

// Class Tempest.TedObjectiveProgress_TimeCountdown
// 0x0000 (0x0028 - 0x0028)
class UTedObjectiveProgress_TimeCountdown final : public UTedObjectiveProgress
{
public:
	struct FTimespan GetDuration() const;
	float GetElapsedPercent() const;
	struct FTimespan GetElapsedTime() const;
	float GetRemainingPercent() const;
	struct FTimespan GetRemainingTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveProgress_TimeCountdown">();
	}
	static class UTedObjectiveProgress_TimeCountdown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveProgress_TimeCountdown>();
	}
};
static_assert(alignof(UTedObjectiveProgress_TimeCountdown) == 0x000008, "Wrong alignment on UTedObjectiveProgress_TimeCountdown");
static_assert(sizeof(UTedObjectiveProgress_TimeCountdown) == 0x000028, "Wrong size on UTedObjectiveProgress_TimeCountdown");

// Class Tempest.TedObjectiveSlot
// 0x0010 (0x0440 - 0x0430)
class UTedObjectiveSlot : public UTedContentPanelSlotButton
{
public:
	TArray<class UTedObjectiveProgressWidget*>    ProgressWidgets;                                   // 0x0430(0x0010)(ExportObject, ZeroConstructor, Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void RefreshTrackingVisuals();
	void ResetVisuals();
	void SetTracked(const bool bInTracked);

	bool CanChangeTracked() const;
	bool GetAppearanceBrush(struct FSlateBrush* OutBrush) const;
	const class UTedObjectiveObj* GetCachedObjectiveContentData(class FText* OutPrimaryText, class FText* OutSecondaryText, EObjectiveState* OutObjectiveState) const;
	const class FText GetDisplayText() const;
	float GetIndentLevel() const;
	const class UTedMarkerConfig* GetMarker() const;
	const class UTedObjectiveObj* GetObjectiveContentData(class FText* OutPrimaryText, class FText* OutSecondaryText, EObjectiveState* OutObjectiveState) const;
	class UTedObjectivePanel* GetObjectivePanel() const;
	int32 GetRequisition() const;
	EObjectiveState GetState() const;
	bool HasChildren() const;
	bool HasParentObjective() const;
	bool IsTracked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedObjectiveSlot">();
	}
	static class UTedObjectiveSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedObjectiveSlot>();
	}
};
static_assert(alignof(UTedObjectiveSlot) == 0x000008, "Wrong alignment on UTedObjectiveSlot");
static_assert(sizeof(UTedObjectiveSlot) == 0x000440, "Wrong size on UTedObjectiveSlot");
static_assert(offsetof(UTedObjectiveSlot, ProgressWidgets) == 0x000430, "Member 'UTedObjectiveSlot::ProgressWidgets' has a wrong offset!");

// Class Tempest.TedOnlineBannerManager
// 0x0010 (0x0040 - 0x0030)
class UTedOnlineBannerManager final : public UGameInstanceSubsystem
{
public:
	TMulticastInlineDelegate<void(const struct FProsBannerConfig& BannerConfig, const TArray<struct FProsBanner>& Banners)> OnGetBannersCompleteDelegate; // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static void GetLocalizedBannerMessage(const struct FProsBannerMessage& InMessage, class FString* OutID, class FText* OutText);

	void GetBanners();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedOnlineBannerManager">();
	}
	static class UTedOnlineBannerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedOnlineBannerManager>();
	}
};
static_assert(alignof(UTedOnlineBannerManager) == 0x000008, "Wrong alignment on UTedOnlineBannerManager");
static_assert(sizeof(UTedOnlineBannerManager) == 0x000040, "Wrong size on UTedOnlineBannerManager");
static_assert(offsetof(UTedOnlineBannerManager, OnGetBannersCompleteDelegate) == 0x000030, "Member 'UTedOnlineBannerManager::OnGetBannersCompleteDelegate' has a wrong offset!");

// Class Tempest.TedOnlineFriendsManager
// 0x0128 (0x0158 - 0x0030)
class UTedOnlineFriendsManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTedOnlineFriendData>           FriendsData;                                       // 0x0080(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x70];                                      // 0x0090(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ETedServerType>                        SpectatorWhitelistedServerTypes;                   // 0x0100(0x0010)(ZeroConstructor, Transient, Config, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x48];                                     // 0x0110(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFillFriendsWithHydraIdsComplete(const TArray<struct FUserIdentityResolveResult>& Results, EProsdkErrorCodeDefault ResultCode);
	void OnFriendChatMessageUpdateFromSteam(uint64 InSteamId, int32 InMessageId);
	void OnFriendStatusUpdateFromSteam(const uint64 InSteamId, const int32 InChangeFlags);
	void OnReadFriendsListComplete(int32 LocalUserNum, bool bWasSuccessful, const class FString& ListName, const class FString& ErrorStr);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedOnlineFriendsManager">();
	}
	static class UTedOnlineFriendsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedOnlineFriendsManager>();
	}
};
static_assert(alignof(UTedOnlineFriendsManager) == 0x000008, "Wrong alignment on UTedOnlineFriendsManager");
static_assert(sizeof(UTedOnlineFriendsManager) == 0x000158, "Wrong size on UTedOnlineFriendsManager");
static_assert(offsetof(UTedOnlineFriendsManager, FriendsData) == 0x000080, "Member 'UTedOnlineFriendsManager::FriendsData' has a wrong offset!");
static_assert(offsetof(UTedOnlineFriendsManager, SpectatorWhitelistedServerTypes) == 0x000100, "Member 'UTedOnlineFriendsManager::SpectatorWhitelistedServerTypes' has a wrong offset!");

// Class Tempest.TedOnlinePlayerProfileLibrary
// 0x0000 (0x0028 - 0x0028)
class UTedOnlinePlayerProfileLibrary final : public UBlueprintFunctionLibrary
{
public:
	static ETedRankedFaction ConvertFactionToRankedFaction(const ETedFaction Faction, bool* bSuccess);
	static struct FTedMatchCumulativeData GetCumulativeData_Averages(const struct FTedStatistics& InProfile, const TArray<ETedServerType>& ServerType, const TArray<ETedRankedFaction>& Factions);
	static struct FTedMatchCumulativeData GetCumulativeData_Totals(const struct FTedStatistics& InProfile, const TArray<ETedServerType>& ServerType, const TArray<ETedRankedFaction>& Factions);
	static const class FString GetLocalHydraId();
	static struct FTedMatchData GetLocalLastMatch(const class UObject* WCO);
	static const class FString GetLocalProviderId();
	static int32 GetLocalTotalMapWins(const class UObject* WCO, const class UTedMapInfo* Map, const TArray<ETedServerType>& ServerType, const TArray<ETedRankedFaction>& Factions);
	static int32 GetLocalTotalWins(const class UObject* WCO, const TArray<ETedServerType>& ServerType, const TArray<ETedRankedFaction>& Factions);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedOnlinePlayerProfileLibrary">();
	}
	static class UTedOnlinePlayerProfileLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedOnlinePlayerProfileLibrary>();
	}
};
static_assert(alignof(UTedOnlinePlayerProfileLibrary) == 0x000008, "Wrong alignment on UTedOnlinePlayerProfileLibrary");
static_assert(sizeof(UTedOnlinePlayerProfileLibrary) == 0x000028, "Wrong size on UTedOnlinePlayerProfileLibrary");

// Class Tempest.TedOnlinePlayerProfileWidget
// 0x0080 (0x0480 - 0x0400)
class UTedOnlinePlayerProfileWidget final : public UTedUserWidget
{
public:
	float                                         ScrollContentPartialWidth;                         // 0x0400(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScrollContentFullWidth;                            // 0x0404(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_408[0x8];                                      // 0x0408(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedPlayerProfileStatisticsOverview*    StatisticsOverview;                                // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpacer*                                StatisticsSpacer;                                  // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTedRankingProgressionWidget*           RankingProgression;                                // 0x0420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTedUserWidget*                         Leaderboards;                                      // 0x0428(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTedUserWidget*                         MatchHistory;                                      // 0x0430(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetSwitcher*                        LoadingSwitcher;                                   // 0x0438(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UScrollBox*                             ScrollBox_Content;                                 // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTedContentPanelInstanced*              TabsPanel;                                         // 0x0448(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTedContentPanelInstanced*              LowerButtonsPanel;                                 // 0x0450(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      BackButtonMaterial;                                // 0x0458(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstance*                      CloseButtonMaterial;                               // 0x0460(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedOnlinePlayerProfileWidgetContext*   ProfileContext;                                    // 0x0468(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTedUserWidget*                         CurrentlyShownPage;                                // 0x0470(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTedMainMenuScreen*                     CachedMainMenu;                                    // 0x0478(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static void Close();
	static bool IsCurrentPlayerProfilePreorder(const class UUserWidget* InUserWidget);
	static void Show(const class FString& InHydraId, const struct FTedOnlinePlayerProfileWidgetContextParams& InAdditionalParams);

	const class UTedOnlinePlayerProfileWidgetContext* GetProfileContext();
	void OnLowerButtonsPanelSlotAction(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction);
	void OnMainMenuPageOpenedOrClosed(bool bOpened);
	void OnSeasonSelectionChanged(int32 NewSeason);
	void OnTabsPanelSlotAction(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction);

	class UTedRankingProgressionWidget* GetRankingProgression() const;
	class UTedPlayerProfileStatisticsOverview* GetStatsOverview() const;
	class UTedContentPanelInstanced* GetTabsPanel() const;
	int32 StatsOverview_GetSelectedSeason() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedOnlinePlayerProfileWidget">();
	}
	static class UTedOnlinePlayerProfileWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedOnlinePlayerProfileWidget>();
	}
};
static_assert(alignof(UTedOnlinePlayerProfileWidget) == 0x000008, "Wrong alignment on UTedOnlinePlayerProfileWidget");
static_assert(sizeof(UTedOnlinePlayerProfileWidget) == 0x000480, "Wrong size on UTedOnlinePlayerProfileWidget");
static_assert(offsetof(UTedOnlinePlayerProfileWidget, ScrollContentPartialWidth) == 0x000400, "Member 'UTedOnlinePlayerProfileWidget::ScrollContentPartialWidth' has a wrong offset!");
static_assert(offsetof(UTedOnlinePlayerProfileWidget, ScrollContentFullWidth) == 0x000404, "Member 'UTedOnlinePlayerProfileWidget::ScrollContentFullWidth' has a wrong offset!");
static_assert(offsetof(UTedOnlinePlayerProfileWidget, StatisticsOverview) == 0x000410, "Member 'UTedOnlinePlayerProfileWidget::StatisticsOverview' has a wrong offset!");
static_assert(offsetof(UTedOnlinePlayerProfileWidget, StatisticsSpacer) == 0x000418, "Member 'UTedOnlinePlayerProfileWidget::StatisticsSpacer' has a wrong offset!");
static_assert(offsetof(UTedOnlinePlayerProfileWidget, RankingProgression) == 0x000420, "Member 'UTedOnlinePlayerProfileWidget::RankingProgression' has a wrong offset!");
static_assert(offsetof(UTedOnlinePlayerProfileWidget, Leaderboards) == 0x000428, "Member 'UTedOnlinePlayerProfileWidget::Leaderboards' has a wrong offset!");
static_assert(offsetof(UTedOnlinePlayerProfileWidget, MatchHistory) == 0x000430, "Member 'UTedOnlinePlayerProfileWidget::MatchHistory' has a wrong offset!");
static_assert(offsetof(UTedOnlinePlayerProfileWidget, LoadingSwitcher) == 0x000438, "Member 'UTedOnlinePlayerProfileWidget::LoadingSwitcher' has a wrong offset!");
static_assert(offsetof(UTedOnlinePlayerProfileWidget, ScrollBox_Content) == 0x000440, "Member 'UTedOnlinePlayerProfileWidget::ScrollBox_Content' has a wrong offset!");
static_assert(offsetof(UTedOnlinePlayerProfileWidget, TabsPanel) == 0x000448, "Member 'UTedOnlinePlayerProfileWidget::TabsPanel' has a wrong offset!");
static_assert(offsetof(UTedOnlinePlayerProfileWidget, LowerButtonsPanel) == 0x000450, "Member 'UTedOnlinePlayerProfileWidget::LowerButtonsPanel' has a wrong offset!");
static_assert(offsetof(UTedOnlinePlayerProfileWidget, BackButtonMaterial) == 0x000458, "Member 'UTedOnlinePlayerProfileWidget::BackButtonMaterial' has a wrong offset!");
static_assert(offsetof(UTedOnlinePlayerProfileWidget, CloseButtonMaterial) == 0x000460, "Member 'UTedOnlinePlayerProfileWidget::CloseButtonMaterial' has a wrong offset!");
static_assert(offsetof(UTedOnlinePlayerProfileWidget, ProfileContext) == 0x000468, "Member 'UTedOnlinePlayerProfileWidget::ProfileContext' has a wrong offset!");
static_assert(offsetof(UTedOnlinePlayerProfileWidget, CurrentlyShownPage) == 0x000470, "Member 'UTedOnlinePlayerProfileWidget::CurrentlyShownPage' has a wrong offset!");
static_assert(offsetof(UTedOnlinePlayerProfileWidget, CachedMainMenu) == 0x000478, "Member 'UTedOnlinePlayerProfileWidget::CachedMainMenu' has a wrong offset!");

// Class Tempest.TedOnlineRatingSubsystem
// 0x0140 (0x0170 - 0x0030)
class UTedOnlineRatingSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x140];                                     // 0x0030(0x0140)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedOnlineRatingSubsystem">();
	}
	static class UTedOnlineRatingSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedOnlineRatingSubsystem>();
	}
};
static_assert(alignof(UTedOnlineRatingSubsystem) == 0x000008, "Wrong alignment on UTedOnlineRatingSubsystem");
static_assert(sizeof(UTedOnlineRatingSubsystem) == 0x000170, "Wrong size on UTedOnlineRatingSubsystem");

// Class Tempest.TedOnlineReconnectAPI
// 0x0120 (0x0150 - 0x0030)
class UTedOnlineReconnectAPI final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x30];                                      // 0x0030(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UNetDriver>              NetDriverPtr;                                      // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x20];                                      // 0x0068(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UClientConnectionMonitor*               ClientConnectionMonitor;                           // 0x0088(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UReconnectNetGame*                      ReconnectNetGame;                                  // 0x0090(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FDateTime>                      DisconnectTimes;                                   // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FTedReconnectPlayerStateInfo>   InactivePlayers;                                   // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x60];                                      // 0x00B8(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APlayerState*>                   DeSyncPS;                                          // 0x0118(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x10];                                     // 0x0128(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APlayerState*>                   KilledPS;                                          // 0x0138(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedOnlineReconnectAPI">();
	}
	static class UTedOnlineReconnectAPI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedOnlineReconnectAPI>();
	}
};
static_assert(alignof(UTedOnlineReconnectAPI) == 0x000008, "Wrong alignment on UTedOnlineReconnectAPI");
static_assert(sizeof(UTedOnlineReconnectAPI) == 0x000150, "Wrong size on UTedOnlineReconnectAPI");
static_assert(offsetof(UTedOnlineReconnectAPI, NetDriverPtr) == 0x000060, "Member 'UTedOnlineReconnectAPI::NetDriverPtr' has a wrong offset!");
static_assert(offsetof(UTedOnlineReconnectAPI, ClientConnectionMonitor) == 0x000088, "Member 'UTedOnlineReconnectAPI::ClientConnectionMonitor' has a wrong offset!");
static_assert(offsetof(UTedOnlineReconnectAPI, ReconnectNetGame) == 0x000090, "Member 'UTedOnlineReconnectAPI::ReconnectNetGame' has a wrong offset!");
static_assert(offsetof(UTedOnlineReconnectAPI, DisconnectTimes) == 0x000098, "Member 'UTedOnlineReconnectAPI::DisconnectTimes' has a wrong offset!");
static_assert(offsetof(UTedOnlineReconnectAPI, InactivePlayers) == 0x0000A8, "Member 'UTedOnlineReconnectAPI::InactivePlayers' has a wrong offset!");
static_assert(offsetof(UTedOnlineReconnectAPI, DeSyncPS) == 0x000118, "Member 'UTedOnlineReconnectAPI::DeSyncPS' has a wrong offset!");
static_assert(offsetof(UTedOnlineReconnectAPI, KilledPS) == 0x000138, "Member 'UTedOnlineReconnectAPI::KilledPS' has a wrong offset!");

// Class Tempest.TedOnlineSession
// 0x0000 (0x0028 - 0x0028)
class UTedOnlineSession final : public UOnlineSession
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedOnlineSession">();
	}
	static class UTedOnlineSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedOnlineSession>();
	}
};
static_assert(alignof(UTedOnlineSession) == 0x000008, "Wrong alignment on UTedOnlineSession");
static_assert(sizeof(UTedOnlineSession) == 0x000028, "Wrong size on UTedOnlineSession");

// Class Tempest.TedOnlineSessionPlayersPanel
// 0x0138 (0x0900 - 0x07C8)
class UTedOnlineSessionPlayersPanel final : public UTedLobbyContentPanel
{
public:
	ETedTeamID                                    Team;                                              // 0x07C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         MinSlots;                                          // 0x07C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         MaxSlots;                                          // 0x07CA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedOnlineSessionPlayerContext                InfoContext;                                       // 0x07CB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7CC[0x4];                                      // 0x07CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTedOnlineSessionPlayerContent> content;                                           // 0x07D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_7E0[0x120];                                    // 0x07E0(0x0120)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_SetContextSearchResult(const struct FTedOnlineSessionSearchResultWrappper& InSearchResult);

	bool GetContent(const int32 InSlotIndex, struct FTedOnlineSessionPlayerContent* OutContent) const;
	bool IsEmpty(const int32 InSlotIndex) const;
	bool IsReady(const int32 InSlotIndex) const;
	void Kick(class ALobbyBeaconPlayerState* Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedOnlineSessionPlayersPanel">();
	}
	static class UTedOnlineSessionPlayersPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedOnlineSessionPlayersPanel>();
	}
};
static_assert(alignof(UTedOnlineSessionPlayersPanel) == 0x000008, "Wrong alignment on UTedOnlineSessionPlayersPanel");
static_assert(sizeof(UTedOnlineSessionPlayersPanel) == 0x000900, "Wrong size on UTedOnlineSessionPlayersPanel");
static_assert(offsetof(UTedOnlineSessionPlayersPanel, Team) == 0x0007C8, "Member 'UTedOnlineSessionPlayersPanel::Team' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionPlayersPanel, MinSlots) == 0x0007C9, "Member 'UTedOnlineSessionPlayersPanel::MinSlots' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionPlayersPanel, MaxSlots) == 0x0007CA, "Member 'UTedOnlineSessionPlayersPanel::MaxSlots' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionPlayersPanel, InfoContext) == 0x0007CB, "Member 'UTedOnlineSessionPlayersPanel::InfoContext' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionPlayersPanel, content) == 0x0007D0, "Member 'UTedOnlineSessionPlayersPanel::content' has a wrong offset!");

// Class Tempest.TedOnlineSessionSettingsPanel
// 0x0020 (0x07E8 - 0x07C8)
class UTedOnlineSessionSettingsPanel final : public UTedLobbyContentPanel
{
public:
	uint8                                         bMemberSettings : 1;                               // 0x07C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_7C9[0x7];                                      // 0x07C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTedOnlineSessionSettingsContent> content;                                         // 0x07D0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class ALobbyBeaconPlayerState*                MemberState;                                       // 0x07E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool ChangeSettingValue_Int32(const int32 InSlotIndex, const int32 InValue);
	void SetMemberState(class ALobbyBeaconPlayerState* InMember);

	bool CheckReadyUp(const int32 InSlotIndex, const bool bIsReadOnly) const;
	bool GetContent(const int32 InSlotIndex, struct FTedOnlineSessionSettingsContent* OutContent) const;
	bool IsReadOnly(const int32 InSlotIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedOnlineSessionSettingsPanel">();
	}
	static class UTedOnlineSessionSettingsPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedOnlineSessionSettingsPanel>();
	}
};
static_assert(alignof(UTedOnlineSessionSettingsPanel) == 0x000008, "Wrong alignment on UTedOnlineSessionSettingsPanel");
static_assert(sizeof(UTedOnlineSessionSettingsPanel) == 0x0007E8, "Wrong size on UTedOnlineSessionSettingsPanel");
static_assert(offsetof(UTedOnlineSessionSettingsPanel, content) == 0x0007D0, "Member 'UTedOnlineSessionSettingsPanel::content' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionSettingsPanel, MemberState) == 0x0007E0, "Member 'UTedOnlineSessionSettingsPanel::MemberState' has a wrong offset!");

// Class Tempest.TedOnlineSessionsPanel
// 0x00A0 (0x0850 - 0x07B0)
class UTedOnlineSessionsPanel final : public UTedContentPanelDynamic
{
public:
	class FName                                   DefaultSorting;                                    // 0x07B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDefaultAscSorting : 1;                            // 0x07B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_7B9[0x17];                                     // 0x07B9(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 FilteredContent;                                   // 0x07D0(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	class FString                                 FilterString;                                      // 0x07E0(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedContentPanelInstanced*              LobbyTypeSelector;                                 // 0x07F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedContentPanelInstanced*              HeadersPanel;                                      // 0x07F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_800[0x50];                                     // 0x0800(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static ETedContentSlotState K2_GetOnlineSessionsPanelState_SortingAscending();
	static ETedContentSlotState K2_GetOnlineSessionsPanelState_SortingEnabled();

	void ClearFilterString();
	void FallbackToDefaultSorting();
	void OnActivateHeaderSlotState(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotState InState, bool bInActivated);
	void OnHeaderContentChange(class UTedContentPanelDynamic* InContentPanel);
	void OnTriggerHeaderSlotAction(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction);
	void OnTriggerLobbyTypeSlotAction(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction);
	void SetFilterString(const class FString& InFilterString);
	void SortContent(const bool bInSkipRefreshUI);

	bool AreSpectatorsEnabledOnUI() const;
	bool Authenticate(const class FString& InPassword, int32 InSlotIndex) const;
	uint8 GetCurrentPlayers(const int32 InSlotIndex) const;
	class FName GetCurrentSorting(bool* OutAscending) const;
	uint8 GetCurrentSpectators(const int32 InSlotIndex) const;
	bool GetFStrByKey(const int32 InSlotIndex, class FString* OutValue, ETedSessionSettingKey SettingKey, bool bValidateEmptyStrings) const;
	class FText GetHostName(const int32 InSlotIndex) const;
	class FText GetLobbyName(const int32 InSlotIndex) const;
	const class UTedMapInfo* GetMap(const int32 InSlotIndex) const;
	class UTexture2D* GetMapMinimap(const int32 InSlotIndex) const;
	class FText GetMapName(const int32 InSlotIndex) const;
	uint8 GetMaxPlayers(const int32 InSlotIndex) const;
	uint8 GetMaxSpectators(const int32 InSlotIndex) const;
	int32 GetPing(const int32 InSlotIndex) const;
	ETedServerType GetSelectedLobbyType() const;
	bool IsPasswordProtected(int32 InSlotIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedOnlineSessionsPanel">();
	}
	static class UTedOnlineSessionsPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedOnlineSessionsPanel>();
	}
};
static_assert(alignof(UTedOnlineSessionsPanel) == 0x000008, "Wrong alignment on UTedOnlineSessionsPanel");
static_assert(sizeof(UTedOnlineSessionsPanel) == 0x000850, "Wrong size on UTedOnlineSessionsPanel");
static_assert(offsetof(UTedOnlineSessionsPanel, DefaultSorting) == 0x0007B0, "Member 'UTedOnlineSessionsPanel::DefaultSorting' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionsPanel, FilteredContent) == 0x0007D0, "Member 'UTedOnlineSessionsPanel::FilteredContent' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionsPanel, FilterString) == 0x0007E0, "Member 'UTedOnlineSessionsPanel::FilterString' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionsPanel, LobbyTypeSelector) == 0x0007F0, "Member 'UTedOnlineSessionsPanel::LobbyTypeSelector' has a wrong offset!");
static_assert(offsetof(UTedOnlineSessionsPanel, HeadersPanel) == 0x0007F8, "Member 'UTedOnlineSessionsPanel::HeadersPanel' has a wrong offset!");

// Class Tempest.TedParachute
// 0x01D8 (0x0468 - 0x0290)
class ATedParachute : public AActor
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   MeshComp;                                          // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<ETedFaction, class UMaterialInterface*>  FactionMaterials;                                  // 0x02A0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FRuntimeFloatCurve                     OpeningCurve;                                      // 0x02F0(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FRuntimeFloatCurve                     FoldingCurve;                                      // 0x0378(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   MatParam_Opening;                                  // 0x0400(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MatParam_Folding;                                  // 0x0408(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MatParam_Random;                                   // 0x0410(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OpeningProgressToConsiderDeployed;                 // 0x0418(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OpeningDuration;                                   // 0x041C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FoldingDuration;                                   // 0x0420(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HideDelay;                                         // 0x0424(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HideDuration;                                      // 0x0428(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_42C[0x4];                                      // 0x042C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               Mid;                                               // 0x0430(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_438[0x30];                                     // 0x0438(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedParachute">();
	}
	static class ATedParachute* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedParachute>();
	}
};
static_assert(alignof(ATedParachute) == 0x000008, "Wrong alignment on ATedParachute");
static_assert(sizeof(ATedParachute) == 0x000468, "Wrong size on ATedParachute");
static_assert(offsetof(ATedParachute, MeshComp) == 0x000298, "Member 'ATedParachute::MeshComp' has a wrong offset!");
static_assert(offsetof(ATedParachute, FactionMaterials) == 0x0002A0, "Member 'ATedParachute::FactionMaterials' has a wrong offset!");
static_assert(offsetof(ATedParachute, OpeningCurve) == 0x0002F0, "Member 'ATedParachute::OpeningCurve' has a wrong offset!");
static_assert(offsetof(ATedParachute, FoldingCurve) == 0x000378, "Member 'ATedParachute::FoldingCurve' has a wrong offset!");
static_assert(offsetof(ATedParachute, MatParam_Opening) == 0x000400, "Member 'ATedParachute::MatParam_Opening' has a wrong offset!");
static_assert(offsetof(ATedParachute, MatParam_Folding) == 0x000408, "Member 'ATedParachute::MatParam_Folding' has a wrong offset!");
static_assert(offsetof(ATedParachute, MatParam_Random) == 0x000410, "Member 'ATedParachute::MatParam_Random' has a wrong offset!");
static_assert(offsetof(ATedParachute, OpeningProgressToConsiderDeployed) == 0x000418, "Member 'ATedParachute::OpeningProgressToConsiderDeployed' has a wrong offset!");
static_assert(offsetof(ATedParachute, OpeningDuration) == 0x00041C, "Member 'ATedParachute::OpeningDuration' has a wrong offset!");
static_assert(offsetof(ATedParachute, FoldingDuration) == 0x000420, "Member 'ATedParachute::FoldingDuration' has a wrong offset!");
static_assert(offsetof(ATedParachute, HideDelay) == 0x000424, "Member 'ATedParachute::HideDelay' has a wrong offset!");
static_assert(offsetof(ATedParachute, HideDuration) == 0x000428, "Member 'ATedParachute::HideDuration' has a wrong offset!");
static_assert(offsetof(ATedParachute, Mid) == 0x000430, "Member 'ATedParachute::Mid' has a wrong offset!");

// Class Tempest.TedPartyManager
// 0x0270 (0x02A0 - 0x0030)
class UTedPartyManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x270];                                     // 0x0030(0x0270)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPartyCreateComplete(int32 LocalUserNum, EProsdkErrorCodePresence ResultCode);
	void OnPartyDisbandComplete(int32 LocalUserNum, EProsdkErrorCodePresence ResultCode);
	void OnPartyGetInvite(int32 LocalUserNum, const class FString& FromUserId, const EHydra5InviteEventType& EventType);
	void OnPartyInviteAcceptComplete(int32 LocalUserNum, EProsdkErrorCodePresence ResultCode);
	void OnPartyInviteRejectComplete(int32 LocalUserNum, EProsdkErrorCodePresence ResultCode);
	void OnPartyInviteRevokeComplete(int32 LocalUserNum, EProsdkErrorCodePresence ResultCode);
	void OnPartyInviteSendComplete(int32 LocalUserNum, EProsdkErrorCodePresence ResultCode);
	void OnPartyJoinCodeGenerateComplete(int32 LocalUserNum, EProsdkErrorCodePresence ResultCode);
	void OnPartyJoinCodeResetComplete(int32 LocalUserNum, EProsdkErrorCodePresence ResultCode);
	void OnPartyJoinCodeUseComplete(int32 LocalUserNum, EProsdkErrorCodePresence ResultCode);
	void OnPartyJoinComplete(int32 LocalUserNum, EProsdkErrorCodePresence ResultCode);
	void OnPartyLeaveComplete(int32 LocalUserNum, EProsdkErrorCodePresence ResultCode);
	void OnPartyRemoveMemberComplete(int32 LocalUserNum, EProsdkErrorCodePresence ResultCode);
	void OnPartySetLeaderComplete(int32 LocalUserNum, EProsdkErrorCodePresence ResultCode);
	void OnPartyUpdate(int32 AuthorizationIndex, const struct FPartyStatus& PartyStatus, const struct FPartyStatusUpdateReason& Reason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPartyManager">();
	}
	static class UTedPartyManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPartyManager>();
	}
};
static_assert(alignof(UTedPartyManager) == 0x000008, "Wrong alignment on UTedPartyManager");
static_assert(sizeof(UTedPartyManager) == 0x0002A0, "Wrong size on UTedPartyManager");

// Class Tempest.TedPassiveAbilityDefinitionAsset
// 0x0088 (0x00C0 - 0x0038)
class UTedPassiveAbilityDefinitionAsset final : public USmartDataAsset
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           AssetIdentifier;                                   // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             Icon;                                              // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   DisplayName;                                       // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTedFormattedText                      Description;                                       // 0x0060(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPassiveAbilityDefinitionAsset">();
	}
	static class UTedPassiveAbilityDefinitionAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPassiveAbilityDefinitionAsset>();
	}
};
static_assert(alignof(UTedPassiveAbilityDefinitionAsset) == 0x000008, "Wrong alignment on UTedPassiveAbilityDefinitionAsset");
static_assert(sizeof(UTedPassiveAbilityDefinitionAsset) == 0x0000C0, "Wrong size on UTedPassiveAbilityDefinitionAsset");
static_assert(offsetof(UTedPassiveAbilityDefinitionAsset, AssetIdentifier) == 0x000040, "Member 'UTedPassiveAbilityDefinitionAsset::AssetIdentifier' has a wrong offset!");
static_assert(offsetof(UTedPassiveAbilityDefinitionAsset, Icon) == 0x000048, "Member 'UTedPassiveAbilityDefinitionAsset::Icon' has a wrong offset!");
static_assert(offsetof(UTedPassiveAbilityDefinitionAsset, DisplayName) == 0x000050, "Member 'UTedPassiveAbilityDefinitionAsset::DisplayName' has a wrong offset!");
static_assert(offsetof(UTedPassiveAbilityDefinitionAsset, Description) == 0x000060, "Member 'UTedPassiveAbilityDefinitionAsset::Description' has a wrong offset!");

// Class Tempest.TedPassiveAbilitySlot
// 0x0018 (0x0428 - 0x0410)
class UTedPassiveAbilitySlot : public UTedContentPanelSlotBase
{
public:
	class UImage*                                 Image_Icon_Texture;                                // 0x0410(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_DisplayName;                                  // 0x0418(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Description;                                  // 0x0420(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	const class UTedPassiveAbilityDefinitionAsset* GetContent() const;
	bool GetContentDescription(class FText* OutText) const;
	bool GetContentDisplayName(class FText* OutText) const;
	class UTexture2D* GetContentIcon() const;
	class UTedPassiveAbilityPanel* GetParentPanel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPassiveAbilitySlot">();
	}
	static class UTedPassiveAbilitySlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPassiveAbilitySlot>();
	}
};
static_assert(alignof(UTedPassiveAbilitySlot) == 0x000008, "Wrong alignment on UTedPassiveAbilitySlot");
static_assert(sizeof(UTedPassiveAbilitySlot) == 0x000428, "Wrong size on UTedPassiveAbilitySlot");
static_assert(offsetof(UTedPassiveAbilitySlot, Image_Icon_Texture) == 0x000410, "Member 'UTedPassiveAbilitySlot::Image_Icon_Texture' has a wrong offset!");
static_assert(offsetof(UTedPassiveAbilitySlot, Text_DisplayName) == 0x000418, "Member 'UTedPassiveAbilitySlot::Text_DisplayName' has a wrong offset!");
static_assert(offsetof(UTedPassiveAbilitySlot, Text_Description) == 0x000420, "Member 'UTedPassiveAbilitySlot::Text_Description' has a wrong offset!");

// Class Tempest.TedPathFollowingComponent
// 0x0040 (0x0330 - 0x02F0)
class UTedPathFollowingComponent final : public UPathFollowingComponent
{
public:
	class ATedUnitBase*                           OwnerUnit;                                         // 0x02F0(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x38];                                     // 0x02F8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPathFollowingComponent">();
	}
	static class UTedPathFollowingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPathFollowingComponent>();
	}
};
static_assert(alignof(UTedPathFollowingComponent) == 0x000008, "Wrong alignment on UTedPathFollowingComponent");
static_assert(sizeof(UTedPathFollowingComponent) == 0x000330, "Wrong size on UTedPathFollowingComponent");
static_assert(offsetof(UTedPathFollowingComponent, OwnerUnit) == 0x0002F0, "Member 'UTedPathFollowingComponent::OwnerUnit' has a wrong offset!");

// Class Tempest.TedPauseMenuScreen
// 0x0038 (0x0490 - 0x0458)
class UTedPauseMenuScreen : public UTedMenuScreenWidget
{
public:
	class UTedContentPanelStatic*                 ButtonsPanel;                                      // 0x0458(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedContentPanelSlotBase*               Slot_Resume;                                       // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedContentPanelSlotBase*               Slot_RestartOrSurrender;                           // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedContentPanelSlotBase*               Slot_Jukebox;                                      // 0x0470(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedContentPanelSlotBase*               Slot_MainMenu;                                     // 0x0478(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedContentPanelSlotBase*               Slot_Quit;                                         // 0x0480(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedPopup*                              CachedPauseMenuPopup;                              // 0x0488(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnPauseMenuButtonSlotAction(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction);

	class UTedPopup* GetPauseMenuPopup() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPauseMenuScreen">();
	}
	static class UTedPauseMenuScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPauseMenuScreen>();
	}
};
static_assert(alignof(UTedPauseMenuScreen) == 0x000008, "Wrong alignment on UTedPauseMenuScreen");
static_assert(sizeof(UTedPauseMenuScreen) == 0x000490, "Wrong size on UTedPauseMenuScreen");
static_assert(offsetof(UTedPauseMenuScreen, ButtonsPanel) == 0x000458, "Member 'UTedPauseMenuScreen::ButtonsPanel' has a wrong offset!");
static_assert(offsetof(UTedPauseMenuScreen, Slot_Resume) == 0x000460, "Member 'UTedPauseMenuScreen::Slot_Resume' has a wrong offset!");
static_assert(offsetof(UTedPauseMenuScreen, Slot_RestartOrSurrender) == 0x000468, "Member 'UTedPauseMenuScreen::Slot_RestartOrSurrender' has a wrong offset!");
static_assert(offsetof(UTedPauseMenuScreen, Slot_Jukebox) == 0x000470, "Member 'UTedPauseMenuScreen::Slot_Jukebox' has a wrong offset!");
static_assert(offsetof(UTedPauseMenuScreen, Slot_MainMenu) == 0x000478, "Member 'UTedPauseMenuScreen::Slot_MainMenu' has a wrong offset!");
static_assert(offsetof(UTedPauseMenuScreen, Slot_Quit) == 0x000480, "Member 'UTedPauseMenuScreen::Slot_Quit' has a wrong offset!");
static_assert(offsetof(UTedPauseMenuScreen, CachedPauseMenuPopup) == 0x000488, "Member 'UTedPauseMenuScreen::CachedPauseMenuPopup' has a wrong offset!");

// Class Tempest.TedPawnCarrierInterface
// 0x0000 (0x0000 - 0x0000)
class ITedPawnCarrierInterface final
{
public:
	TArray<class ATedPawn*> GetLoad() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCarrierInterface">();
	}
	static class ITedPawnCarrierInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITedPawnCarrierInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITedPawnCarrierInterface) == 0x000001, "Wrong alignment on ITedPawnCarrierInterface");
static_assert(sizeof(ITedPawnCarrierInterface) == 0x000001, "Wrong size on ITedPawnCarrierInterface");

// Class Tempest.TedPawnCommandPreview_Conformation
// 0x0090 (0x04E8 - 0x0458)
class ATedPawnCommandPreview_Conformation : public ATedPawnCommandPreviewActor
{
public:
	class USceneComponent*                        OffsetComponent;                                   // 0x0458(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     PreviewMaterial;                                   // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ColorParamName;                                    // 0x0468(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           Color;                                             // 0x0470(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATedConformationBase*                   ConformationTarget;                                // 0x0480(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       MIDs;                                              // 0x0488(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCommandData                   ConformationCommandData;                           // 0x0498(0x0048)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	class UMeshComponent*                         PreviewMeshComponent;                              // 0x04E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommandPreview_Conformation">();
	}
	static class ATedPawnCommandPreview_Conformation* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedPawnCommandPreview_Conformation>();
	}
};
static_assert(alignof(ATedPawnCommandPreview_Conformation) == 0x000008, "Wrong alignment on ATedPawnCommandPreview_Conformation");
static_assert(sizeof(ATedPawnCommandPreview_Conformation) == 0x0004E8, "Wrong size on ATedPawnCommandPreview_Conformation");
static_assert(offsetof(ATedPawnCommandPreview_Conformation, OffsetComponent) == 0x000458, "Member 'ATedPawnCommandPreview_Conformation::OffsetComponent' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_Conformation, PreviewMaterial) == 0x000460, "Member 'ATedPawnCommandPreview_Conformation::PreviewMaterial' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_Conformation, ColorParamName) == 0x000468, "Member 'ATedPawnCommandPreview_Conformation::ColorParamName' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_Conformation, Color) == 0x000470, "Member 'ATedPawnCommandPreview_Conformation::Color' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_Conformation, ConformationTarget) == 0x000480, "Member 'ATedPawnCommandPreview_Conformation::ConformationTarget' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_Conformation, MIDs) == 0x000488, "Member 'ATedPawnCommandPreview_Conformation::MIDs' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_Conformation, ConformationCommandData) == 0x000498, "Member 'ATedPawnCommandPreview_Conformation::ConformationCommandData' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_Conformation, PreviewMeshComponent) == 0x0004E0, "Member 'ATedPawnCommandPreview_Conformation::PreviewMeshComponent' has a wrong offset!");

// Class Tempest.TedPawnCommandPreview_DeployStructure
// 0x0050 (0x04A8 - 0x0458)
class ATedPawnCommandPreview_DeployStructure : public ATedPawnCommandPreviewActor
{
public:
	class UTedStructureDeployPreviewComponent*    PlacementPreviewComponent;                         // 0x0458(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 SkeletalMesh;                                      // 0x0460(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedGridVisualizationComponent*         InfluenceArea;                                     // 0x0468(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATedPlayerState*                        CachedPS;                                          // 0x0470(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CachedDeployLoc;                                   // 0x0478(0x0018)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 CachedCommandActor;                                // 0x0490(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASquareNavGrid*                         CachedNavGrid;                                     // 0x0498(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedRangeDecalComponent*                RangeDecal;                                        // 0x04A0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void UpdateRangeDecalData(const TSubclassOf<class ATedStructureBase> StructureClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommandPreview_DeployStructure">();
	}
	static class ATedPawnCommandPreview_DeployStructure* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedPawnCommandPreview_DeployStructure>();
	}
};
static_assert(alignof(ATedPawnCommandPreview_DeployStructure) == 0x000008, "Wrong alignment on ATedPawnCommandPreview_DeployStructure");
static_assert(sizeof(ATedPawnCommandPreview_DeployStructure) == 0x0004A8, "Wrong size on ATedPawnCommandPreview_DeployStructure");
static_assert(offsetof(ATedPawnCommandPreview_DeployStructure, PlacementPreviewComponent) == 0x000458, "Member 'ATedPawnCommandPreview_DeployStructure::PlacementPreviewComponent' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_DeployStructure, SkeletalMesh) == 0x000460, "Member 'ATedPawnCommandPreview_DeployStructure::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_DeployStructure, InfluenceArea) == 0x000468, "Member 'ATedPawnCommandPreview_DeployStructure::InfluenceArea' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_DeployStructure, CachedPS) == 0x000470, "Member 'ATedPawnCommandPreview_DeployStructure::CachedPS' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_DeployStructure, CachedDeployLoc) == 0x000478, "Member 'ATedPawnCommandPreview_DeployStructure::CachedDeployLoc' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_DeployStructure, CachedCommandActor) == 0x000490, "Member 'ATedPawnCommandPreview_DeployStructure::CachedCommandActor' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_DeployStructure, CachedNavGrid) == 0x000498, "Member 'ATedPawnCommandPreview_DeployStructure::CachedNavGrid' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_DeployStructure, RangeDecal) == 0x0004A0, "Member 'ATedPawnCommandPreview_DeployStructure::RangeDecal' has a wrong offset!");

// Class Tempest.TedPawnCommandPreview_Patrol
// 0x0078 (0x04D0 - 0x0458)
class ATedPawnCommandPreview_Patrol : public ATedPawnCommandPreviewActor
{
public:
	class UFXSystemAsset*                         DefaultPatrolPointFX;                              // 0x0458(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemAsset*                         StartEndPatrolPointFX;                             // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemAsset*                         BothWayPatrolLinesFX;                              // 0x0468(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemAsset*                         OneWayPatrolLinesFX;                               // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemComponent*                     PatrolPointIndicator;                              // 0x0478(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FPatrolPointWrapper>            PatrolPointIndicators;                             // 0x0480(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class FName                                   LoopPointParamName;                                // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           LoopPointColor;                                    // 0x0498(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           NormalPointColor;                                  // 0x04A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ATedPlayerController>    CachedPC;                                          // 0x04B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartPatrolPointCursorHoverExtents;                // 0x04C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PatrolPointPulseScaleParamName;                    // 0x04C4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4CC[0x4];                                      // 0x04CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommandPreview_Patrol">();
	}
	static class ATedPawnCommandPreview_Patrol* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedPawnCommandPreview_Patrol>();
	}
};
static_assert(alignof(ATedPawnCommandPreview_Patrol) == 0x000008, "Wrong alignment on ATedPawnCommandPreview_Patrol");
static_assert(sizeof(ATedPawnCommandPreview_Patrol) == 0x0004D0, "Wrong size on ATedPawnCommandPreview_Patrol");
static_assert(offsetof(ATedPawnCommandPreview_Patrol, DefaultPatrolPointFX) == 0x000458, "Member 'ATedPawnCommandPreview_Patrol::DefaultPatrolPointFX' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_Patrol, StartEndPatrolPointFX) == 0x000460, "Member 'ATedPawnCommandPreview_Patrol::StartEndPatrolPointFX' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_Patrol, BothWayPatrolLinesFX) == 0x000468, "Member 'ATedPawnCommandPreview_Patrol::BothWayPatrolLinesFX' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_Patrol, OneWayPatrolLinesFX) == 0x000470, "Member 'ATedPawnCommandPreview_Patrol::OneWayPatrolLinesFX' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_Patrol, PatrolPointIndicator) == 0x000478, "Member 'ATedPawnCommandPreview_Patrol::PatrolPointIndicator' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_Patrol, PatrolPointIndicators) == 0x000480, "Member 'ATedPawnCommandPreview_Patrol::PatrolPointIndicators' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_Patrol, LoopPointParamName) == 0x000490, "Member 'ATedPawnCommandPreview_Patrol::LoopPointParamName' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_Patrol, LoopPointColor) == 0x000498, "Member 'ATedPawnCommandPreview_Patrol::LoopPointColor' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_Patrol, NormalPointColor) == 0x0004A8, "Member 'ATedPawnCommandPreview_Patrol::NormalPointColor' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_Patrol, CachedPC) == 0x0004B8, "Member 'ATedPawnCommandPreview_Patrol::CachedPC' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_Patrol, StartPatrolPointCursorHoverExtents) == 0x0004C0, "Member 'ATedPawnCommandPreview_Patrol::StartPatrolPointCursorHoverExtents' has a wrong offset!");
static_assert(offsetof(ATedPawnCommandPreview_Patrol, PatrolPointPulseScaleParamName) == 0x0004C4, "Member 'ATedPawnCommandPreview_Patrol::PatrolPointPulseScaleParamName' has a wrong offset!");

// Class Tempest.TedPawnCommandSlotBase
// 0x0010 (0x0440 - 0x0430)
class UTedPawnCommandSlotBase : public UTedContentPanelSlotButton
{
public:
	bool                                          bLastPressWasDoubleClick;                          // 0x0430(0x0001)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_431[0x7];                                      // 0x0431(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           ResetDoubleClick_TH;                               // 0x0438(0x0008)(Transient, DuplicateTransient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommandSlotBase">();
	}
	static class UTedPawnCommandSlotBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnCommandSlotBase>();
	}
};
static_assert(alignof(UTedPawnCommandSlotBase) == 0x000008, "Wrong alignment on UTedPawnCommandSlotBase");
static_assert(sizeof(UTedPawnCommandSlotBase) == 0x000440, "Wrong size on UTedPawnCommandSlotBase");
static_assert(offsetof(UTedPawnCommandSlotBase, bLastPressWasDoubleClick) == 0x000430, "Member 'UTedPawnCommandSlotBase::bLastPressWasDoubleClick' has a wrong offset!");
static_assert(offsetof(UTedPawnCommandSlotBase, ResetDoubleClick_TH) == 0x000438, "Member 'UTedPawnCommandSlotBase::ResetDoubleClick_TH' has a wrong offset!");

// Class Tempest.TedPawnCommandVisualActor
// 0x0010 (0x0360 - 0x0350)
class ATedPawnCommandVisualActor final : public ATedCommandVisualActor
{
public:
	TArray<class AActor*>                         ContextActors;                                     // 0x0350(0x0010)(Net, ZeroConstructor, Transient, DuplicateTransient, RepNotify, Protected, NativeAccessSpecifierProtected)

public:
	void K2_OnRep_ContextActors();
	void OnContextActorDestroyed(class AActor* ContextActor);
	void OnRep_ContextActors();

	TArray<class AActor*> GetContextActors() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommandVisualActor">();
	}
	static class ATedPawnCommandVisualActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedPawnCommandVisualActor>();
	}
};
static_assert(alignof(ATedPawnCommandVisualActor) == 0x000008, "Wrong alignment on ATedPawnCommandVisualActor");
static_assert(sizeof(ATedPawnCommandVisualActor) == 0x000360, "Wrong size on ATedPawnCommandVisualActor");
static_assert(offsetof(ATedPawnCommandVisualActor, ContextActors) == 0x000350, "Member 'ATedPawnCommandVisualActor::ContextActors' has a wrong offset!");

// Class Tempest.TedPawnCommand_ActivateAbility
// 0x0000 (0x0540 - 0x0540)
class UTedPawnCommand_ActivateAbility final : public UTedPawnCommand
{
public:
	static struct FGameplayCommandData CreateAbilityCommandDataWithClass(TSubclassOf<class UTedAbilityBase> InAbilityClass, bool bInUsePayload, const struct FGameplayEventData& InPayload);
	static struct FGameplayCommandData CreateAbilityCommandDataWithTags(const struct FGameplayTagContainer& InAbilityTags, bool bInUsePayload, const struct FGameplayEventData& InPayload);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommand_ActivateAbility">();
	}
	static class UTedPawnCommand_ActivateAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnCommand_ActivateAbility>();
	}
};
static_assert(alignof(UTedPawnCommand_ActivateAbility) == 0x000008, "Wrong alignment on UTedPawnCommand_ActivateAbility");
static_assert(sizeof(UTedPawnCommand_ActivateAbility) == 0x000540, "Wrong size on UTedPawnCommand_ActivateAbility");

// Class Tempest.TedPawnCommand_ApplyGameplayEffect
// 0x0028 (0x0568 - 0x0540)
class UTedPawnCommand_ApplyGameplayEffect : public UTedPawnCommand
{
public:
	TSoftClassPtr<class UClass>                   GEToApply;                                         // 0x0540(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommand_ApplyGameplayEffect">();
	}
	static class UTedPawnCommand_ApplyGameplayEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnCommand_ApplyGameplayEffect>();
	}
};
static_assert(alignof(UTedPawnCommand_ApplyGameplayEffect) == 0x000008, "Wrong alignment on UTedPawnCommand_ApplyGameplayEffect");
static_assert(sizeof(UTedPawnCommand_ApplyGameplayEffect) == 0x000568, "Wrong size on UTedPawnCommand_ApplyGameplayEffect");
static_assert(offsetof(UTedPawnCommand_ApplyGameplayEffect, GEToApply) == 0x000540, "Member 'UTedPawnCommand_ApplyGameplayEffect::GEToApply' has a wrong offset!");

// Class Tempest.TedPawnCommand_DroneBase
// 0x0000 (0x0570 - 0x0570)
class UTedPawnCommand_DroneBase : public UTedPawnCommandWithBehavior
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommand_DroneBase">();
	}
	static class UTedPawnCommand_DroneBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnCommand_DroneBase>();
	}
};
static_assert(alignof(UTedPawnCommand_DroneBase) == 0x000008, "Wrong alignment on UTedPawnCommand_DroneBase");
static_assert(sizeof(UTedPawnCommand_DroneBase) == 0x000570, "Wrong size on UTedPawnCommand_DroneBase");

// Class Tempest.TedPawnCommand_AttackWithDrone
// 0x0008 (0x0578 - 0x0570)
class UTedPawnCommand_AttackWithDrone final : public UTedPawnCommand_DroneBase
{
public:
	struct FGameplayTag                           DroneRemoteControlledTag;                          // 0x0570(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommand_AttackWithDrone">();
	}
	static class UTedPawnCommand_AttackWithDrone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnCommand_AttackWithDrone>();
	}
};
static_assert(alignof(UTedPawnCommand_AttackWithDrone) == 0x000008, "Wrong alignment on UTedPawnCommand_AttackWithDrone");
static_assert(sizeof(UTedPawnCommand_AttackWithDrone) == 0x000578, "Wrong size on UTedPawnCommand_AttackWithDrone");
static_assert(offsetof(UTedPawnCommand_AttackWithDrone, DroneRemoteControlledTag) == 0x000570, "Member 'UTedPawnCommand_AttackWithDrone::DroneRemoteControlledTag' has a wrong offset!");

// Class Tempest.TedPawnCommand_CancelAbility
// 0x0050 (0x0590 - 0x0540)
class UTedPawnCommand_CancelAbility : public UTedPawnCommand
{
public:
	uint8                                         bUseAbilityTags : 1;                               // 0x0540(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_541[0x7];                                      // 0x0541(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   AbilityClassToCancel;                              // 0x0548(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  AbilityTags;                                       // 0x0570(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommand_CancelAbility">();
	}
	static class UTedPawnCommand_CancelAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnCommand_CancelAbility>();
	}
};
static_assert(alignof(UTedPawnCommand_CancelAbility) == 0x000008, "Wrong alignment on UTedPawnCommand_CancelAbility");
static_assert(sizeof(UTedPawnCommand_CancelAbility) == 0x000590, "Wrong size on UTedPawnCommand_CancelAbility");
static_assert(offsetof(UTedPawnCommand_CancelAbility, AbilityClassToCancel) == 0x000548, "Member 'UTedPawnCommand_CancelAbility::AbilityClassToCancel' has a wrong offset!");
static_assert(offsetof(UTedPawnCommand_CancelAbility, AbilityTags) == 0x000570, "Member 'UTedPawnCommand_CancelAbility::AbilityTags' has a wrong offset!");

// Class Tempest.TedPawnCommand_Drone_Move
// 0x0000 (0x0570 - 0x0570)
class UTedPawnCommand_Drone_Move final : public UTedPawnCommand_DroneBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommand_Drone_Move">();
	}
	static class UTedPawnCommand_Drone_Move* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnCommand_Drone_Move>();
	}
};
static_assert(alignof(UTedPawnCommand_Drone_Move) == 0x000008, "Wrong alignment on UTedPawnCommand_Drone_Move");
static_assert(sizeof(UTedPawnCommand_Drone_Move) == 0x000570, "Wrong size on UTedPawnCommand_Drone_Move");

// Class Tempest.TedPawnCommand_Enqueue
// 0x0000 (0x0570 - 0x0570)
class UTedPawnCommand_Enqueue : public UTedPawnCommandWithBehavior
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommand_Enqueue">();
	}
	static class UTedPawnCommand_Enqueue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnCommand_Enqueue>();
	}
};
static_assert(alignof(UTedPawnCommand_Enqueue) == 0x000008, "Wrong alignment on UTedPawnCommand_Enqueue");
static_assert(sizeof(UTedPawnCommand_Enqueue) == 0x000570, "Wrong size on UTedPawnCommand_Enqueue");

// Class Tempest.TedPawnCommand_LandOnAirfield
// 0x0000 (0x0570 - 0x0570)
class UTedPawnCommand_LandOnAirfield : public UTedPawnCommandWithBehavior
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommand_LandOnAirfield">();
	}
	static class UTedPawnCommand_LandOnAirfield* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnCommand_LandOnAirfield>();
	}
};
static_assert(alignof(UTedPawnCommand_LandOnAirfield) == 0x000008, "Wrong alignment on UTedPawnCommand_LandOnAirfield");
static_assert(sizeof(UTedPawnCommand_LandOnAirfield) == 0x000570, "Wrong size on UTedPawnCommand_LandOnAirfield");

// Class Tempest.TedPawnCommand_RecallAircraft
// 0x0000 (0x0540 - 0x0540)
class UTedPawnCommand_RecallAircraft : public UTedPawnCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommand_RecallAircraft">();
	}
	static class UTedPawnCommand_RecallAircraft* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnCommand_RecallAircraft>();
	}
};
static_assert(alignof(UTedPawnCommand_RecallAircraft) == 0x000008, "Wrong alignment on UTedPawnCommand_RecallAircraft");
static_assert(sizeof(UTedPawnCommand_RecallAircraft) == 0x000540, "Wrong size on UTedPawnCommand_RecallAircraft");

// Class Tempest.TedPawnCommand_RedirectCommand
// 0x0018 (0x0558 - 0x0540)
class UTedPawnCommand_RedirectCommand : public UTedPawnCommand
{
public:
	bool                                          bUseCommandClass;                                  // 0x0540(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_541[0x7];                                      // 0x0541(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UTedCommand>                CommandClassToRedirect;                            // 0x0548(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           CommandTypeToRedirect;                             // 0x0550(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommand_RedirectCommand">();
	}
	static class UTedPawnCommand_RedirectCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnCommand_RedirectCommand>();
	}
};
static_assert(alignof(UTedPawnCommand_RedirectCommand) == 0x000008, "Wrong alignment on UTedPawnCommand_RedirectCommand");
static_assert(sizeof(UTedPawnCommand_RedirectCommand) == 0x000558, "Wrong size on UTedPawnCommand_RedirectCommand");
static_assert(offsetof(UTedPawnCommand_RedirectCommand, bUseCommandClass) == 0x000540, "Member 'UTedPawnCommand_RedirectCommand::bUseCommandClass' has a wrong offset!");
static_assert(offsetof(UTedPawnCommand_RedirectCommand, CommandClassToRedirect) == 0x000548, "Member 'UTedPawnCommand_RedirectCommand::CommandClassToRedirect' has a wrong offset!");
static_assert(offsetof(UTedPawnCommand_RedirectCommand, CommandTypeToRedirect) == 0x000550, "Member 'UTedPawnCommand_RedirectCommand::CommandTypeToRedirect' has a wrong offset!");

// Class Tempest.TedPawnCommand_RemoveGameplayEffect
// 0x0070 (0x05B0 - 0x0540)
class UTedPawnCommand_RemoveGameplayEffect : public UTedPawnCommand
{
public:
	struct FGameplayTagContainer                  RemoveByGEGrantedTags;                             // 0x0540(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  RemoveByGEAssetTags;                               // 0x0560(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   RemoveByGEClass;                                   // 0x0580(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StacksToRemove;                                    // 0x05A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5AC[0x4];                                      // 0x05AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommand_RemoveGameplayEffect">();
	}
	static class UTedPawnCommand_RemoveGameplayEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnCommand_RemoveGameplayEffect>();
	}
};
static_assert(alignof(UTedPawnCommand_RemoveGameplayEffect) == 0x000008, "Wrong alignment on UTedPawnCommand_RemoveGameplayEffect");
static_assert(sizeof(UTedPawnCommand_RemoveGameplayEffect) == 0x0005B0, "Wrong size on UTedPawnCommand_RemoveGameplayEffect");
static_assert(offsetof(UTedPawnCommand_RemoveGameplayEffect, RemoveByGEGrantedTags) == 0x000540, "Member 'UTedPawnCommand_RemoveGameplayEffect::RemoveByGEGrantedTags' has a wrong offset!");
static_assert(offsetof(UTedPawnCommand_RemoveGameplayEffect, RemoveByGEAssetTags) == 0x000560, "Member 'UTedPawnCommand_RemoveGameplayEffect::RemoveByGEAssetTags' has a wrong offset!");
static_assert(offsetof(UTedPawnCommand_RemoveGameplayEffect, RemoveByGEClass) == 0x000580, "Member 'UTedPawnCommand_RemoveGameplayEffect::RemoveByGEClass' has a wrong offset!");
static_assert(offsetof(UTedPawnCommand_RemoveGameplayEffect, StacksToRemove) == 0x0005A8, "Member 'UTedPawnCommand_RemoveGameplayEffect::StacksToRemove' has a wrong offset!");

// Class Tempest.TedPawnCommand_PauseUpgradeResearch
// 0x0008 (0x0548 - 0x0540)
class UTedPawnCommand_PauseUpgradeResearch : public UTedPawnCommand
{
public:
	bool                                          bPause;                                            // 0x0540(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_541[0x7];                                      // 0x0541(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommand_PauseUpgradeResearch">();
	}
	static class UTedPawnCommand_PauseUpgradeResearch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnCommand_PauseUpgradeResearch>();
	}
};
static_assert(alignof(UTedPawnCommand_PauseUpgradeResearch) == 0x000008, "Wrong alignment on UTedPawnCommand_PauseUpgradeResearch");
static_assert(sizeof(UTedPawnCommand_PauseUpgradeResearch) == 0x000548, "Wrong size on UTedPawnCommand_PauseUpgradeResearch");
static_assert(offsetof(UTedPawnCommand_PauseUpgradeResearch, bPause) == 0x000540, "Member 'UTedPawnCommand_PauseUpgradeResearch::bPause' has a wrong offset!");

// Class Tempest.TedPawnCommand_CancelUpgradeResearch
// 0x0000 (0x0540 - 0x0540)
class UTedPawnCommand_CancelUpgradeResearch : public UTedPawnCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommand_CancelUpgradeResearch">();
	}
	static class UTedPawnCommand_CancelUpgradeResearch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnCommand_CancelUpgradeResearch>();
	}
};
static_assert(alignof(UTedPawnCommand_CancelUpgradeResearch) == 0x000008, "Wrong alignment on UTedPawnCommand_CancelUpgradeResearch");
static_assert(sizeof(UTedPawnCommand_CancelUpgradeResearch) == 0x000540, "Wrong size on UTedPawnCommand_CancelUpgradeResearch");

// Class Tempest.TedPawnCommand_SacrificeDrone
// 0x0000 (0x0558 - 0x0558)
class UTedPawnCommand_SacrificeDrone : public UTedPawnCommand_RedirectCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommand_SacrificeDrone">();
	}
	static class UTedPawnCommand_SacrificeDrone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnCommand_SacrificeDrone>();
	}
};
static_assert(alignof(UTedPawnCommand_SacrificeDrone) == 0x000008, "Wrong alignment on UTedPawnCommand_SacrificeDrone");
static_assert(sizeof(UTedPawnCommand_SacrificeDrone) == 0x000558, "Wrong size on UTedPawnCommand_SacrificeDrone");

// Class Tempest.TedPawnCommand_SendGameplayEvent
// 0x0020 (0x0560 - 0x0540)
class UTedPawnCommand_SendGameplayEvent : public UTedPawnCommand
{
public:
	struct FGameplayTagContainer                  GameplayEventTags;                                 // 0x0540(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommand_SendGameplayEvent">();
	}
	static class UTedPawnCommand_SendGameplayEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnCommand_SendGameplayEvent>();
	}
};
static_assert(alignof(UTedPawnCommand_SendGameplayEvent) == 0x000008, "Wrong alignment on UTedPawnCommand_SendGameplayEvent");
static_assert(sizeof(UTedPawnCommand_SendGameplayEvent) == 0x000560, "Wrong size on UTedPawnCommand_SendGameplayEvent");
static_assert(offsetof(UTedPawnCommand_SendGameplayEvent, GameplayEventTags) == 0x000540, "Member 'UTedPawnCommand_SendGameplayEvent::GameplayEventTags' has a wrong offset!");

// Class Tempest.TedPawnCommand_Stop
// 0x0000 (0x0540 - 0x0540)
class UTedPawnCommand_Stop : public UTedPawnCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommand_Stop">();
	}
	static class UTedPawnCommand_Stop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnCommand_Stop>();
	}
};
static_assert(alignof(UTedPawnCommand_Stop) == 0x000008, "Wrong alignment on UTedPawnCommand_Stop");
static_assert(sizeof(UTedPawnCommand_Stop) == 0x000540, "Wrong size on UTedPawnCommand_Stop");

// Class Tempest.TedPawnCommand_ToggleAbility
// 0x0050 (0x0590 - 0x0540)
class UTedPawnCommand_ToggleAbility : public UTedPawnCommand
{
public:
	uint8                                         bUseAbilityTags : 1;                               // 0x0540(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_541[0x7];                                      // 0x0541(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   AbilityClassToActivate;                            // 0x0548(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  AbilityTags;                                       // 0x0570(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommand_ToggleAbility">();
	}
	static class UTedPawnCommand_ToggleAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnCommand_ToggleAbility>();
	}
};
static_assert(alignof(UTedPawnCommand_ToggleAbility) == 0x000008, "Wrong alignment on UTedPawnCommand_ToggleAbility");
static_assert(sizeof(UTedPawnCommand_ToggleAbility) == 0x000590, "Wrong size on UTedPawnCommand_ToggleAbility");
static_assert(offsetof(UTedPawnCommand_ToggleAbility, AbilityClassToActivate) == 0x000548, "Member 'UTedPawnCommand_ToggleAbility::AbilityClassToActivate' has a wrong offset!");
static_assert(offsetof(UTedPawnCommand_ToggleAbility, AbilityTags) == 0x000570, "Member 'UTedPawnCommand_ToggleAbility::AbilityTags' has a wrong offset!");

// Class Tempest.TedPawnCommand_UnloadGivenPawns
// 0x0000 (0x0540 - 0x0540)
class UTedPawnCommand_UnloadGivenPawns : public UTedPawnCommand
{
public:
	static struct FGameplayCommandData CreateCommandData_UnloadGivenPawns(const TArray<class ATedPawn*>& Pawns, TSubclassOf<class UTedCommand> CommandOverride);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnCommand_UnloadGivenPawns">();
	}
	static class UTedPawnCommand_UnloadGivenPawns* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnCommand_UnloadGivenPawns>();
	}
};
static_assert(alignof(UTedPawnCommand_UnloadGivenPawns) == 0x000008, "Wrong alignment on UTedPawnCommand_UnloadGivenPawns");
static_assert(sizeof(UTedPawnCommand_UnloadGivenPawns) == 0x000540, "Wrong size on UTedPawnCommand_UnloadGivenPawns");

// Class Tempest.TedPawnContainerCommand_Attack
// 0x0008 (0x0578 - 0x0570)
class UTedPawnContainerCommand_Attack : public UTedPawnCommandWithBehavior
{
public:
	bool                                          bSkipDistanceCheck;                                // 0x0570(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_571[0x7];                                      // 0x0571(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnContainerCommand_Attack">();
	}
	static class UTedPawnContainerCommand_Attack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnContainerCommand_Attack>();
	}
};
static_assert(alignof(UTedPawnContainerCommand_Attack) == 0x000008, "Wrong alignment on UTedPawnContainerCommand_Attack");
static_assert(sizeof(UTedPawnContainerCommand_Attack) == 0x000578, "Wrong size on UTedPawnContainerCommand_Attack");
static_assert(offsetof(UTedPawnContainerCommand_Attack, bSkipDistanceCheck) == 0x000570, "Member 'UTedPawnContainerCommand_Attack::bSkipDistanceCheck' has a wrong offset!");

// Class Tempest.TedPawnContainerComponent
// 0x01A8 (0x0258 - 0x00B0)
class UTedPawnContainerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ATedPawn* Pawn)> OnPawnLoadUnload;                           // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x30];                                      // 0x00C8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Slots;                                             // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FreeSlots;                                         // 0x00FC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  ContainableUnitTypes;                              // 0x0100(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bAllowNeutralUnits;                                // 0x0120(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TSubclassOf<class ATedUnitBase>, int32>  UnitsToSpawn;                                      // 0x0128(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bUnloadPawnsOnOwnerPlayerIDChange;                 // 0x0178(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_179[0x7];                                      // 0x0179(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   ActorTags;                                         // 0x0180(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bCanFireFromInside;                                // 0x0190(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanRepairFromInside;                              // 0x0191(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_192[0x6];                                      // 0x0192(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           PhysicalFireLocSocketNames;                        // 0x0198(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              RelativeUnloadLocationOffset;                      // 0x01A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ATedPawn*>                       PawnsInContainer;                                  // 0x01B8(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	TSet<class ATedPawn*>                         CachedPawnsInContainer;                            // 0x01C8(0x0050)(Protected, NativeAccessSpecifierProtected)
	bool                                          bCanSpawnOnBeginPlay;                              // 0x0218(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_219[0x7];                                      // 0x0219(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFiringSocketInfo>              CachedFiringSocketInfo;                            // 0x0220(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class ATedPawn*                               PawnOwner;                                         // 0x0230(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETedPlayerID                                  OwningPlayerID;                                    // 0x0238(0x0001)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        SpawnedSound;                                      // 0x0240(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UGameplayEffect>>    AppliedEffects;                                    // 0x0248(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	bool HasPawnsInContainer();
	void OnOwnerTakeDamage(class AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser);
	void OnRep_PawnsInContainer();
	void OnStoredPawnDestroyed(class AActor* InActor);
	bool RequestStorePawn(class ATedPawn* InPawn);

	bool CanStorePawn(const class ATedPawn* InPawn) const;
	bool CanUnitsFireFromInside() const;
	int32 GetNumberOfFreeSlots() const;
	int32 GetNumberOfSlots() const;
	const TArray<class ATedPawn*> GetStoredPawns() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnContainerComponent">();
	}
	static class UTedPawnContainerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnContainerComponent>();
	}
};
static_assert(alignof(UTedPawnContainerComponent) == 0x000008, "Wrong alignment on UTedPawnContainerComponent");
static_assert(sizeof(UTedPawnContainerComponent) == 0x000258, "Wrong size on UTedPawnContainerComponent");
static_assert(offsetof(UTedPawnContainerComponent, OnPawnLoadUnload) == 0x0000B8, "Member 'UTedPawnContainerComponent::OnPawnLoadUnload' has a wrong offset!");
static_assert(offsetof(UTedPawnContainerComponent, Slots) == 0x0000F8, "Member 'UTedPawnContainerComponent::Slots' has a wrong offset!");
static_assert(offsetof(UTedPawnContainerComponent, FreeSlots) == 0x0000FC, "Member 'UTedPawnContainerComponent::FreeSlots' has a wrong offset!");
static_assert(offsetof(UTedPawnContainerComponent, ContainableUnitTypes) == 0x000100, "Member 'UTedPawnContainerComponent::ContainableUnitTypes' has a wrong offset!");
static_assert(offsetof(UTedPawnContainerComponent, bAllowNeutralUnits) == 0x000120, "Member 'UTedPawnContainerComponent::bAllowNeutralUnits' has a wrong offset!");
static_assert(offsetof(UTedPawnContainerComponent, UnitsToSpawn) == 0x000128, "Member 'UTedPawnContainerComponent::UnitsToSpawn' has a wrong offset!");
static_assert(offsetof(UTedPawnContainerComponent, bUnloadPawnsOnOwnerPlayerIDChange) == 0x000178, "Member 'UTedPawnContainerComponent::bUnloadPawnsOnOwnerPlayerIDChange' has a wrong offset!");
static_assert(offsetof(UTedPawnContainerComponent, ActorTags) == 0x000180, "Member 'UTedPawnContainerComponent::ActorTags' has a wrong offset!");
static_assert(offsetof(UTedPawnContainerComponent, bCanFireFromInside) == 0x000190, "Member 'UTedPawnContainerComponent::bCanFireFromInside' has a wrong offset!");
static_assert(offsetof(UTedPawnContainerComponent, bCanRepairFromInside) == 0x000191, "Member 'UTedPawnContainerComponent::bCanRepairFromInside' has a wrong offset!");
static_assert(offsetof(UTedPawnContainerComponent, PhysicalFireLocSocketNames) == 0x000198, "Member 'UTedPawnContainerComponent::PhysicalFireLocSocketNames' has a wrong offset!");
static_assert(offsetof(UTedPawnContainerComponent, RelativeUnloadLocationOffset) == 0x0001A8, "Member 'UTedPawnContainerComponent::RelativeUnloadLocationOffset' has a wrong offset!");
static_assert(offsetof(UTedPawnContainerComponent, PawnsInContainer) == 0x0001B8, "Member 'UTedPawnContainerComponent::PawnsInContainer' has a wrong offset!");
static_assert(offsetof(UTedPawnContainerComponent, CachedPawnsInContainer) == 0x0001C8, "Member 'UTedPawnContainerComponent::CachedPawnsInContainer' has a wrong offset!");
static_assert(offsetof(UTedPawnContainerComponent, bCanSpawnOnBeginPlay) == 0x000218, "Member 'UTedPawnContainerComponent::bCanSpawnOnBeginPlay' has a wrong offset!");
static_assert(offsetof(UTedPawnContainerComponent, CachedFiringSocketInfo) == 0x000220, "Member 'UTedPawnContainerComponent::CachedFiringSocketInfo' has a wrong offset!");
static_assert(offsetof(UTedPawnContainerComponent, PawnOwner) == 0x000230, "Member 'UTedPawnContainerComponent::PawnOwner' has a wrong offset!");
static_assert(offsetof(UTedPawnContainerComponent, OwningPlayerID) == 0x000238, "Member 'UTedPawnContainerComponent::OwningPlayerID' has a wrong offset!");
static_assert(offsetof(UTedPawnContainerComponent, SpawnedSound) == 0x000240, "Member 'UTedPawnContainerComponent::SpawnedSound' has a wrong offset!");
static_assert(offsetof(UTedPawnContainerComponent, AppliedEffects) == 0x000248, "Member 'UTedPawnContainerComponent::AppliedEffects' has a wrong offset!");

// Class Tempest.TedStructureDefinitionAsset
// 0x00E8 (0x07F8 - 0x0710)
class UTedStructureDefinitionAsset final : public UTedEntityDefinitionAsset
{
public:
	TArray<TSoftClassPtr<class UClass>>           ProducedStructures;                                // 0x0710(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ProducedStructuresIds;                             // 0x0720(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         bAllowMultiStructureQueue : 1;                     // 0x0740(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_741[0x7];                                      // 0x0741(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           ProducedUnits;                                     // 0x0748(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ProducedUnitsIds;                                  // 0x0758(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           ConstructionAutoSpawnUnits;                        // 0x0778(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           DestructionAutoSpawnUnits;                         // 0x0788(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         bUnique : 1;                                       // 0x0798(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_799[0x7];                                      // 0x0799(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ConstructionSite;                                  // 0x07A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConstructionSiteUpfrontCost;                       // 0x07C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SellValue;                                         // 0x07CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SellTime;                                          // 0x07D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SellIntelValue;                                    // 0x07D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CaptureIntelValue;                                 // 0x07D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CaptureTime;                                       // 0x07DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntelGeneration;                                   // 0x07E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CreditsGeneration;                                 // 0x07E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResourceGenerationInterval;                        // 0x07E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RepairCost;                                        // 0x07EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CreditsCapGain;                                    // 0x07F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7F4[0x4];                                      // 0x07F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedStructureDefinitionAsset">();
	}
	static class UTedStructureDefinitionAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedStructureDefinitionAsset>();
	}
};
static_assert(alignof(UTedStructureDefinitionAsset) == 0x000008, "Wrong alignment on UTedStructureDefinitionAsset");
static_assert(sizeof(UTedStructureDefinitionAsset) == 0x0007F8, "Wrong size on UTedStructureDefinitionAsset");
static_assert(offsetof(UTedStructureDefinitionAsset, ProducedStructures) == 0x000710, "Member 'UTedStructureDefinitionAsset::ProducedStructures' has a wrong offset!");
static_assert(offsetof(UTedStructureDefinitionAsset, ProducedStructuresIds) == 0x000720, "Member 'UTedStructureDefinitionAsset::ProducedStructuresIds' has a wrong offset!");
static_assert(offsetof(UTedStructureDefinitionAsset, ProducedUnits) == 0x000748, "Member 'UTedStructureDefinitionAsset::ProducedUnits' has a wrong offset!");
static_assert(offsetof(UTedStructureDefinitionAsset, ProducedUnitsIds) == 0x000758, "Member 'UTedStructureDefinitionAsset::ProducedUnitsIds' has a wrong offset!");
static_assert(offsetof(UTedStructureDefinitionAsset, ConstructionAutoSpawnUnits) == 0x000778, "Member 'UTedStructureDefinitionAsset::ConstructionAutoSpawnUnits' has a wrong offset!");
static_assert(offsetof(UTedStructureDefinitionAsset, DestructionAutoSpawnUnits) == 0x000788, "Member 'UTedStructureDefinitionAsset::DestructionAutoSpawnUnits' has a wrong offset!");
static_assert(offsetof(UTedStructureDefinitionAsset, ConstructionSite) == 0x0007A0, "Member 'UTedStructureDefinitionAsset::ConstructionSite' has a wrong offset!");
static_assert(offsetof(UTedStructureDefinitionAsset, ConstructionSiteUpfrontCost) == 0x0007C8, "Member 'UTedStructureDefinitionAsset::ConstructionSiteUpfrontCost' has a wrong offset!");
static_assert(offsetof(UTedStructureDefinitionAsset, SellValue) == 0x0007CC, "Member 'UTedStructureDefinitionAsset::SellValue' has a wrong offset!");
static_assert(offsetof(UTedStructureDefinitionAsset, SellTime) == 0x0007D0, "Member 'UTedStructureDefinitionAsset::SellTime' has a wrong offset!");
static_assert(offsetof(UTedStructureDefinitionAsset, SellIntelValue) == 0x0007D4, "Member 'UTedStructureDefinitionAsset::SellIntelValue' has a wrong offset!");
static_assert(offsetof(UTedStructureDefinitionAsset, CaptureIntelValue) == 0x0007D8, "Member 'UTedStructureDefinitionAsset::CaptureIntelValue' has a wrong offset!");
static_assert(offsetof(UTedStructureDefinitionAsset, CaptureTime) == 0x0007DC, "Member 'UTedStructureDefinitionAsset::CaptureTime' has a wrong offset!");
static_assert(offsetof(UTedStructureDefinitionAsset, IntelGeneration) == 0x0007E0, "Member 'UTedStructureDefinitionAsset::IntelGeneration' has a wrong offset!");
static_assert(offsetof(UTedStructureDefinitionAsset, CreditsGeneration) == 0x0007E4, "Member 'UTedStructureDefinitionAsset::CreditsGeneration' has a wrong offset!");
static_assert(offsetof(UTedStructureDefinitionAsset, ResourceGenerationInterval) == 0x0007E8, "Member 'UTedStructureDefinitionAsset::ResourceGenerationInterval' has a wrong offset!");
static_assert(offsetof(UTedStructureDefinitionAsset, RepairCost) == 0x0007EC, "Member 'UTedStructureDefinitionAsset::RepairCost' has a wrong offset!");
static_assert(offsetof(UTedStructureDefinitionAsset, CreditsCapGain) == 0x0007F0, "Member 'UTedStructureDefinitionAsset::CreditsCapGain' has a wrong offset!");

// Class Tempest.TedUnitDefinitionAsset
// 0x00A0 (0x07B0 - 0x0710)
class UTedUnitDefinitionAsset final : public UTedEntityDefinitionAsset
{
public:
	TSubclassOf<class UNavigationQueryFilter>     DefaultNavFilterClass;                             // 0x0710(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTedNavFilterSelector*                  NavFilterSelector;                                 // 0x0718(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionRadius;                                   // 0x0720(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETedUnitType                                  UnitType;                                          // 0x0724(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_725[0x3];                                      // 0x0725(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EvadeRange;                                        // 0x0728(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChaseRange;                                        // 0x072C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDefaultAiChaseRangeToVisionRange;                 // 0x0730(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_731[0x3];                                      // 0x0731(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AiChaseRangeOverride;                              // 0x0734(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementSpeed;                                     // 0x0738(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Acceleration;                                      // 0x073C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Deacceleration;                                    // 0x0740(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationSpeed;                                     // 0x0744(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGarrisonSlotSize                             GarrisonSize;                                      // 0x0748(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanCrushPawns;                                    // 0x0749(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74A[0x6];                                      // 0x074A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  WhitelistCrushPawnTypeTags;                        // 0x0750(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BlacklistCrushPawnTypeTags;                        // 0x0770(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BlacklistCrushEntityTags;                          // 0x0790(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	int32 GetGarrisonSlotCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitDefinitionAsset">();
	}
	static class UTedUnitDefinitionAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUnitDefinitionAsset>();
	}
};
static_assert(alignof(UTedUnitDefinitionAsset) == 0x000008, "Wrong alignment on UTedUnitDefinitionAsset");
static_assert(sizeof(UTedUnitDefinitionAsset) == 0x0007B0, "Wrong size on UTedUnitDefinitionAsset");
static_assert(offsetof(UTedUnitDefinitionAsset, DefaultNavFilterClass) == 0x000710, "Member 'UTedUnitDefinitionAsset::DefaultNavFilterClass' has a wrong offset!");
static_assert(offsetof(UTedUnitDefinitionAsset, NavFilterSelector) == 0x000718, "Member 'UTedUnitDefinitionAsset::NavFilterSelector' has a wrong offset!");
static_assert(offsetof(UTedUnitDefinitionAsset, CollisionRadius) == 0x000720, "Member 'UTedUnitDefinitionAsset::CollisionRadius' has a wrong offset!");
static_assert(offsetof(UTedUnitDefinitionAsset, UnitType) == 0x000724, "Member 'UTedUnitDefinitionAsset::UnitType' has a wrong offset!");
static_assert(offsetof(UTedUnitDefinitionAsset, EvadeRange) == 0x000728, "Member 'UTedUnitDefinitionAsset::EvadeRange' has a wrong offset!");
static_assert(offsetof(UTedUnitDefinitionAsset, ChaseRange) == 0x00072C, "Member 'UTedUnitDefinitionAsset::ChaseRange' has a wrong offset!");
static_assert(offsetof(UTedUnitDefinitionAsset, bDefaultAiChaseRangeToVisionRange) == 0x000730, "Member 'UTedUnitDefinitionAsset::bDefaultAiChaseRangeToVisionRange' has a wrong offset!");
static_assert(offsetof(UTedUnitDefinitionAsset, AiChaseRangeOverride) == 0x000734, "Member 'UTedUnitDefinitionAsset::AiChaseRangeOverride' has a wrong offset!");
static_assert(offsetof(UTedUnitDefinitionAsset, MovementSpeed) == 0x000738, "Member 'UTedUnitDefinitionAsset::MovementSpeed' has a wrong offset!");
static_assert(offsetof(UTedUnitDefinitionAsset, Acceleration) == 0x00073C, "Member 'UTedUnitDefinitionAsset::Acceleration' has a wrong offset!");
static_assert(offsetof(UTedUnitDefinitionAsset, Deacceleration) == 0x000740, "Member 'UTedUnitDefinitionAsset::Deacceleration' has a wrong offset!");
static_assert(offsetof(UTedUnitDefinitionAsset, RotationSpeed) == 0x000744, "Member 'UTedUnitDefinitionAsset::RotationSpeed' has a wrong offset!");
static_assert(offsetof(UTedUnitDefinitionAsset, GarrisonSize) == 0x000748, "Member 'UTedUnitDefinitionAsset::GarrisonSize' has a wrong offset!");
static_assert(offsetof(UTedUnitDefinitionAsset, bCanCrushPawns) == 0x000749, "Member 'UTedUnitDefinitionAsset::bCanCrushPawns' has a wrong offset!");
static_assert(offsetof(UTedUnitDefinitionAsset, WhitelistCrushPawnTypeTags) == 0x000750, "Member 'UTedUnitDefinitionAsset::WhitelistCrushPawnTypeTags' has a wrong offset!");
static_assert(offsetof(UTedUnitDefinitionAsset, BlacklistCrushPawnTypeTags) == 0x000770, "Member 'UTedUnitDefinitionAsset::BlacklistCrushPawnTypeTags' has a wrong offset!");
static_assert(offsetof(UTedUnitDefinitionAsset, BlacklistCrushEntityTags) == 0x000790, "Member 'UTedUnitDefinitionAsset::BlacklistCrushEntityTags' has a wrong offset!");

// Class Tempest.TedDestructibleDefinitionAsset
// 0x0050 (0x0760 - 0x0710)
class UTedDestructibleDefinitionAsset final : public UTedEntityDefinitionAsset
{
public:
	struct FVector2D                              DeathEventsDelay;                                  // 0x0710(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        DeathCue;                                          // 0x0720(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DeathCueDelayOffset;                               // 0x0728(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72C[0x4];                                      // 0x072C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UTedDamageType>             DeathDamageType;                                   // 0x0730(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            DeathDamageEffect;                                 // 0x0738(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDealDamageToFriendlies;                           // 0x0740(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyDeathDamageEffectToSelf;                     // 0x0741(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_742[0x2];                                      // 0x0742(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRadialDamageParams                    DeathDamageParams;                                 // 0x0744(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ExtraKeepAliveTime;                                // 0x0758(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75C[0x4];                                      // 0x075C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedDestructibleDefinitionAsset">();
	}
	static class UTedDestructibleDefinitionAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedDestructibleDefinitionAsset>();
	}
};
static_assert(alignof(UTedDestructibleDefinitionAsset) == 0x000008, "Wrong alignment on UTedDestructibleDefinitionAsset");
static_assert(sizeof(UTedDestructibleDefinitionAsset) == 0x000760, "Wrong size on UTedDestructibleDefinitionAsset");
static_assert(offsetof(UTedDestructibleDefinitionAsset, DeathEventsDelay) == 0x000710, "Member 'UTedDestructibleDefinitionAsset::DeathEventsDelay' has a wrong offset!");
static_assert(offsetof(UTedDestructibleDefinitionAsset, DeathCue) == 0x000720, "Member 'UTedDestructibleDefinitionAsset::DeathCue' has a wrong offset!");
static_assert(offsetof(UTedDestructibleDefinitionAsset, DeathCueDelayOffset) == 0x000728, "Member 'UTedDestructibleDefinitionAsset::DeathCueDelayOffset' has a wrong offset!");
static_assert(offsetof(UTedDestructibleDefinitionAsset, DeathDamageType) == 0x000730, "Member 'UTedDestructibleDefinitionAsset::DeathDamageType' has a wrong offset!");
static_assert(offsetof(UTedDestructibleDefinitionAsset, DeathDamageEffect) == 0x000738, "Member 'UTedDestructibleDefinitionAsset::DeathDamageEffect' has a wrong offset!");
static_assert(offsetof(UTedDestructibleDefinitionAsset, bDealDamageToFriendlies) == 0x000740, "Member 'UTedDestructibleDefinitionAsset::bDealDamageToFriendlies' has a wrong offset!");
static_assert(offsetof(UTedDestructibleDefinitionAsset, bApplyDeathDamageEffectToSelf) == 0x000741, "Member 'UTedDestructibleDefinitionAsset::bApplyDeathDamageEffectToSelf' has a wrong offset!");
static_assert(offsetof(UTedDestructibleDefinitionAsset, DeathDamageParams) == 0x000744, "Member 'UTedDestructibleDefinitionAsset::DeathDamageParams' has a wrong offset!");
static_assert(offsetof(UTedDestructibleDefinitionAsset, ExtraKeepAliveTime) == 0x000758, "Member 'UTedDestructibleDefinitionAsset::ExtraKeepAliveTime' has a wrong offset!");

// Class Tempest.TedPawnSoundManager
// 0x0050 (0x0078 - 0x0028)
class UTedPawnSoundManager final : public UObject
{
public:
	struct FPawnSoundHandle                       CurrentSound;                                      // 0x0028(0x0020)(Transient, DuplicateTransient, NoDestructor, NativeAccessSpecifierPrivate)
	struct FPawnSoundHandle                       NextSound;                                         // 0x0048(0x0020)(Transient, DuplicateTransient, NoDestructor, NativeAccessSpecifierPrivate)
	TSubclassOf<class UTedPawnSound>              SelectionSoundClass;                               // 0x0068(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        AudioComponent;                                    // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnSoundFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnSoundManager">();
	}
	static class UTedPawnSoundManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnSoundManager>();
	}
};
static_assert(alignof(UTedPawnSoundManager) == 0x000008, "Wrong alignment on UTedPawnSoundManager");
static_assert(sizeof(UTedPawnSoundManager) == 0x000078, "Wrong size on UTedPawnSoundManager");
static_assert(offsetof(UTedPawnSoundManager, CurrentSound) == 0x000028, "Member 'UTedPawnSoundManager::CurrentSound' has a wrong offset!");
static_assert(offsetof(UTedPawnSoundManager, NextSound) == 0x000048, "Member 'UTedPawnSoundManager::NextSound' has a wrong offset!");
static_assert(offsetof(UTedPawnSoundManager, SelectionSoundClass) == 0x000068, "Member 'UTedPawnSoundManager::SelectionSoundClass' has a wrong offset!");
static_assert(offsetof(UTedPawnSoundManager, AudioComponent) == 0x000070, "Member 'UTedPawnSoundManager::AudioComponent' has a wrong offset!");

// Class Tempest.TedPawnsPanelSlot
// 0x0008 (0x0438 - 0x0430)
class UTedPawnsPanelSlot : public UTedContentPanelSlotButton
{
public:
	uint8                                         Pad_430[0x8];                                      // 0x0430(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPawnDamaged(class AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser);

	class ATedPawn* GetContent() const;
	class UTexture2D* GetContentIcon() const;
	class UTedPawnsPanel* GetPawnsPanel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnsPanelSlot">();
	}
	static class UTedPawnsPanelSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnsPanelSlot>();
	}
};
static_assert(alignof(UTedPawnsPanelSlot) == 0x000008, "Wrong alignment on UTedPawnsPanelSlot");
static_assert(sizeof(UTedPawnsPanelSlot) == 0x000438, "Wrong size on UTedPawnsPanelSlot");

// Class Tempest.TedPawnVeterancyWidget
// 0x0010 (0x0410 - 0x0400)
class UTedPawnVeterancyWidget : public UTedUserWidget
{
public:
	ETedVeterancyLevel                            MinVeterancyToShow;                                // 0x0400(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bRefreshOnLevelChange : 1;                         // 0x0401(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bRefreshOnProgressChange : 1;                      // 0x0401(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_402[0x6];                                      // 0x0402(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ATedPawn*                               DisplayedPawn;                                     // 0x0408(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetDisplayedPawn(class ATedPawn* InPawn);

	bool DisplayPawnHasVeterancy() const;
	class ATedPawn* GetDisplayedPawn() const;
	int32 GetVeterancyLevel() const;
	float GetVeterancyProgress() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPawnVeterancyWidget">();
	}
	static class UTedPawnVeterancyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPawnVeterancyWidget>();
	}
};
static_assert(alignof(UTedPawnVeterancyWidget) == 0x000008, "Wrong alignment on UTedPawnVeterancyWidget");
static_assert(sizeof(UTedPawnVeterancyWidget) == 0x000410, "Wrong size on UTedPawnVeterancyWidget");
static_assert(offsetof(UTedPawnVeterancyWidget, MinVeterancyToShow) == 0x000400, "Member 'UTedPawnVeterancyWidget::MinVeterancyToShow' has a wrong offset!");
static_assert(offsetof(UTedPawnVeterancyWidget, DisplayedPawn) == 0x000408, "Member 'UTedPawnVeterancyWidget::DisplayedPawn' has a wrong offset!");

// Class Tempest.TedPerformanceStatSubsystem
// 0x0010 (0x0040 - 0x0030)
class UTedPerformanceStatSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	double GetStatValue(const ETedDisplayablePerformanceStat Stat) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPerformanceStatSubsystem">();
	}
	static class UTedPerformanceStatSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPerformanceStatSubsystem>();
	}
};
static_assert(alignof(UTedPerformanceStatSubsystem) == 0x000008, "Wrong alignment on UTedPerformanceStatSubsystem");
static_assert(sizeof(UTedPerformanceStatSubsystem) == 0x000040, "Wrong size on UTedPerformanceStatSubsystem");

// Class Tempest.TedPerfStatOverlayWidget
// 0x0050 (0x0450 - 0x0400)
class UTedPerfStatOverlayWidget : public UTedUserWidget
{
public:
	TSet<ETedDisplayablePerformanceStat>          NetworkingStats;                                   // 0x0400(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	void UpdateVisibilityOfChildren();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPerfStatOverlayWidget">();
	}
	static class UTedPerfStatOverlayWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPerfStatOverlayWidget>();
	}
};
static_assert(alignof(UTedPerfStatOverlayWidget) == 0x000008, "Wrong alignment on UTedPerfStatOverlayWidget");
static_assert(sizeof(UTedPerfStatOverlayWidget) == 0x000450, "Wrong size on UTedPerfStatOverlayWidget");
static_assert(offsetof(UTedPerfStatOverlayWidget, NetworkingStats) == 0x000400, "Member 'UTedPerfStatOverlayWidget::NetworkingStats' has a wrong offset!");

// Class Tempest.TedPickupActor
// 0x0050 (0x02E8 - 0x0298)
class ATedPickupActor : public AEcsActor
{
public:
	TMulticastInlineDelegate<void(class ATedUnitBase* PickedUpBy, class ATedPickupActor* PickupActor)> OnPickedUp; // 0x0298(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UBoxComponent*                          NavModifier;                                       // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bEnabled : 1;                                      // 0x02B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, DuplicateTransient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAutoEnabled : 1;                                  // 0x02B0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDestroyOnPickUp : 1;                              // 0x02B0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RespawnTime;                                       // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DestroyDelay;                                      // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PickupRadius;                                      // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EditorSphereZOffset;                               // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           InitActorTag;                                      // 0x02C4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ATedStructureBase>       BlockingStructure;                                 // 0x02CC(0x0008)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLoadedFromSave;                                   // 0x02D4(0x0001)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D5[0x3];                                      // 0x02D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           DestroyTimerHandle;                                // 0x02D8(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           RespawnTimerHandle;                                // 0x02E0(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void NetMulticast_PickedUp(class ATedUnitBase* PickedUpBy);
	void OnBlockingStructureEndPlay(class AActor* InActor, EEndPlayReason InEndPlayReason);
	void OnRep_IsEnabled();
	void PickUp(class ATedUnitBase* PickUpBy);
	void ReceiveDisabled();
	void ReceiveEnabled();
	void ReceivePickedUp(class ATedUnitBase* PikedUpBy);
	void SetEnabled(bool bInEnabled);

	bool CanPickUp(class ATedUnitBase* PickUpBy) const;
	bool IsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPickupActor">();
	}
	static class ATedPickupActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedPickupActor>();
	}
};
static_assert(alignof(ATedPickupActor) == 0x000008, "Wrong alignment on ATedPickupActor");
static_assert(sizeof(ATedPickupActor) == 0x0002E8, "Wrong size on ATedPickupActor");
static_assert(offsetof(ATedPickupActor, OnPickedUp) == 0x000298, "Member 'ATedPickupActor::OnPickedUp' has a wrong offset!");
static_assert(offsetof(ATedPickupActor, NavModifier) == 0x0002A8, "Member 'ATedPickupActor::NavModifier' has a wrong offset!");
static_assert(offsetof(ATedPickupActor, RespawnTime) == 0x0002B4, "Member 'ATedPickupActor::RespawnTime' has a wrong offset!");
static_assert(offsetof(ATedPickupActor, DestroyDelay) == 0x0002B8, "Member 'ATedPickupActor::DestroyDelay' has a wrong offset!");
static_assert(offsetof(ATedPickupActor, PickupRadius) == 0x0002BC, "Member 'ATedPickupActor::PickupRadius' has a wrong offset!");
static_assert(offsetof(ATedPickupActor, EditorSphereZOffset) == 0x0002C0, "Member 'ATedPickupActor::EditorSphereZOffset' has a wrong offset!");
static_assert(offsetof(ATedPickupActor, InitActorTag) == 0x0002C4, "Member 'ATedPickupActor::InitActorTag' has a wrong offset!");
static_assert(offsetof(ATedPickupActor, BlockingStructure) == 0x0002CC, "Member 'ATedPickupActor::BlockingStructure' has a wrong offset!");
static_assert(offsetof(ATedPickupActor, bLoadedFromSave) == 0x0002D4, "Member 'ATedPickupActor::bLoadedFromSave' has a wrong offset!");
static_assert(offsetof(ATedPickupActor, DestroyTimerHandle) == 0x0002D8, "Member 'ATedPickupActor::DestroyTimerHandle' has a wrong offset!");
static_assert(offsetof(ATedPickupActor, RespawnTimerHandle) == 0x0002E0, "Member 'ATedPickupActor::RespawnTimerHandle' has a wrong offset!");

// Class Tempest.TedPickupActor_Cash
// 0x0010 (0x02F8 - 0x02E8)
class ATedPickupActor_Cash : public ATedPickupActor
{
public:
	class UStaticMeshComponent*                   PickupMesh;                                        // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Amount;                                            // 0x02F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverflow;                                         // 0x02F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F5[0x3];                                      // 0x02F5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPickupActor_Cash">();
	}
	static class ATedPickupActor_Cash* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedPickupActor_Cash>();
	}
};
static_assert(alignof(ATedPickupActor_Cash) == 0x000008, "Wrong alignment on ATedPickupActor_Cash");
static_assert(sizeof(ATedPickupActor_Cash) == 0x0002F8, "Wrong size on ATedPickupActor_Cash");
static_assert(offsetof(ATedPickupActor_Cash, PickupMesh) == 0x0002E8, "Member 'ATedPickupActor_Cash::PickupMesh' has a wrong offset!");
static_assert(offsetof(ATedPickupActor_Cash, Amount) == 0x0002F0, "Member 'ATedPickupActor_Cash::Amount' has a wrong offset!");
static_assert(offsetof(ATedPickupActor_Cash, bOverflow) == 0x0002F4, "Member 'ATedPickupActor_Cash::bOverflow' has a wrong offset!");

// Class Tempest.TedPingActor
// 0x0040 (0x02D0 - 0x0290)
class ATedPingActor : public AActor
{
public:
	struct FPingData                              PingData;                                          // 0x0290(0x0020)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UTedAnnouncement>           AnnouncementClass;                                 // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTedMarkerConfig*                       Marker;                                            // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETedTeamID                                    OwningTeam;                                        // 0x02C0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedMarkerHandle                       MarkerHandle;                                      // 0x02C4(0x0004)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocalPredicted;                                   // 0x02C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_InStorage();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPingActor">();
	}
	static class ATedPingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedPingActor>();
	}
};
static_assert(alignof(ATedPingActor) == 0x000008, "Wrong alignment on ATedPingActor");
static_assert(sizeof(ATedPingActor) == 0x0002D0, "Wrong size on ATedPingActor");
static_assert(offsetof(ATedPingActor, PingData) == 0x000290, "Member 'ATedPingActor::PingData' has a wrong offset!");
static_assert(offsetof(ATedPingActor, AnnouncementClass) == 0x0002B0, "Member 'ATedPingActor::AnnouncementClass' has a wrong offset!");
static_assert(offsetof(ATedPingActor, Marker) == 0x0002B8, "Member 'ATedPingActor::Marker' has a wrong offset!");
static_assert(offsetof(ATedPingActor, OwningTeam) == 0x0002C0, "Member 'ATedPingActor::OwningTeam' has a wrong offset!");
static_assert(offsetof(ATedPingActor, MarkerHandle) == 0x0002C4, "Member 'ATedPingActor::MarkerHandle' has a wrong offset!");
static_assert(offsetof(ATedPingActor, bLocalPredicted) == 0x0002C8, "Member 'ATedPingActor::bLocalPredicted' has a wrong offset!");

// Class Tempest.TedPlayerCameraComponent
// 0x0110 (0x0B00 - 0x09F0)
class UTedPlayerCameraComponent final : public UCameraComponent
{
public:
	float                                         FixedCameraYaw;                                    // 0x09F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9F4[0x4];                                      // 0x09F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              CameraPitchRange;                                  // 0x09F8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinCameraOffset;                                   // 0x0A08(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxCameraOffset;                                   // 0x0A0C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraStartingZoomPct;                             // 0x0A10(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraZoomStep;                                    // 0x0A14(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraZoomRate;                                    // 0x0A18(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraZoomIterpSpeed;                              // 0x0A1C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraRotationSpeed;                               // 0x0A20(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraFreeLookSpeed;                               // 0x0A24(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraBorderPanningSpeed;                          // 0x0A28(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraPanningSpeedZoomedInPct;                     // 0x0A2C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CameraActiveBorder;                                // 0x0A30(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BoundsLimit;                                       // 0x0A34(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndGameInterpTime;                                 // 0x0A38(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndGameLockTime;                                   // 0x0A3C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAllowForDiagonalCameraBorderPanning : 1;          // 0x0A40(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_A41[0xBF];                                     // 0x0A41(0x00BF)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float InterpolateCameraToLocation(const struct FVector& TargetLocation, const float InterpTime, const float InterpExponent, const float OverrideZoomPct, const float LockTargetLocationTime, const bool bReturnToStartLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerCameraComponent">();
	}
	static class UTedPlayerCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerCameraComponent>();
	}
};
static_assert(alignof(UTedPlayerCameraComponent) == 0x000010, "Wrong alignment on UTedPlayerCameraComponent");
static_assert(sizeof(UTedPlayerCameraComponent) == 0x000B00, "Wrong size on UTedPlayerCameraComponent");
static_assert(offsetof(UTedPlayerCameraComponent, FixedCameraYaw) == 0x0009F0, "Member 'UTedPlayerCameraComponent::FixedCameraYaw' has a wrong offset!");
static_assert(offsetof(UTedPlayerCameraComponent, CameraPitchRange) == 0x0009F8, "Member 'UTedPlayerCameraComponent::CameraPitchRange' has a wrong offset!");
static_assert(offsetof(UTedPlayerCameraComponent, MinCameraOffset) == 0x000A08, "Member 'UTedPlayerCameraComponent::MinCameraOffset' has a wrong offset!");
static_assert(offsetof(UTedPlayerCameraComponent, MaxCameraOffset) == 0x000A0C, "Member 'UTedPlayerCameraComponent::MaxCameraOffset' has a wrong offset!");
static_assert(offsetof(UTedPlayerCameraComponent, CameraStartingZoomPct) == 0x000A10, "Member 'UTedPlayerCameraComponent::CameraStartingZoomPct' has a wrong offset!");
static_assert(offsetof(UTedPlayerCameraComponent, CameraZoomStep) == 0x000A14, "Member 'UTedPlayerCameraComponent::CameraZoomStep' has a wrong offset!");
static_assert(offsetof(UTedPlayerCameraComponent, CameraZoomRate) == 0x000A18, "Member 'UTedPlayerCameraComponent::CameraZoomRate' has a wrong offset!");
static_assert(offsetof(UTedPlayerCameraComponent, CameraZoomIterpSpeed) == 0x000A1C, "Member 'UTedPlayerCameraComponent::CameraZoomIterpSpeed' has a wrong offset!");
static_assert(offsetof(UTedPlayerCameraComponent, CameraRotationSpeed) == 0x000A20, "Member 'UTedPlayerCameraComponent::CameraRotationSpeed' has a wrong offset!");
static_assert(offsetof(UTedPlayerCameraComponent, CameraFreeLookSpeed) == 0x000A24, "Member 'UTedPlayerCameraComponent::CameraFreeLookSpeed' has a wrong offset!");
static_assert(offsetof(UTedPlayerCameraComponent, CameraBorderPanningSpeed) == 0x000A28, "Member 'UTedPlayerCameraComponent::CameraBorderPanningSpeed' has a wrong offset!");
static_assert(offsetof(UTedPlayerCameraComponent, CameraPanningSpeedZoomedInPct) == 0x000A2C, "Member 'UTedPlayerCameraComponent::CameraPanningSpeedZoomedInPct' has a wrong offset!");
static_assert(offsetof(UTedPlayerCameraComponent, CameraActiveBorder) == 0x000A30, "Member 'UTedPlayerCameraComponent::CameraActiveBorder' has a wrong offset!");
static_assert(offsetof(UTedPlayerCameraComponent, BoundsLimit) == 0x000A34, "Member 'UTedPlayerCameraComponent::BoundsLimit' has a wrong offset!");
static_assert(offsetof(UTedPlayerCameraComponent, EndGameInterpTime) == 0x000A38, "Member 'UTedPlayerCameraComponent::EndGameInterpTime' has a wrong offset!");
static_assert(offsetof(UTedPlayerCameraComponent, EndGameLockTime) == 0x000A3C, "Member 'UTedPlayerCameraComponent::EndGameLockTime' has a wrong offset!");

// Class Tempest.TedPlayerCameraManager
// 0x0030 (0x24F0 - 0x24C0)
class ATedPlayerCameraManager final : public APlayerCameraManager
{
public:
	uint8                                         Pad_24C0[0x30];                                    // 0x24C0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerCameraManager">();
	}
	static class ATedPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedPlayerCameraManager>();
	}
};
static_assert(alignof(ATedPlayerCameraManager) == 0x000010, "Wrong alignment on ATedPlayerCameraManager");
static_assert(sizeof(ATedPlayerCameraManager) == 0x0024F0, "Wrong size on ATedPlayerCameraManager");

// Class Tempest.TedPlayerCommandsWidget
// 0x0020 (0x0430 - 0x0410)
class UTedPlayerCommandsWidget : public UTedPlayerDataWidget
{
public:
	class UImage*                                 Image_Frame;                                       // 0x0410(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedCommandsPanel*                      CommandsPanel;                                     // 0x0418(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       WidgetAnim_Collapse;                               // 0x0420(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedContentPanelBase*                   CollapseButtonPanel;                               // 0x0428(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnCollapseButtonAcivateState(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotState InState, bool bInActivated);
	void OnCollapseButtonPanelTriggerAction(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction);
	void OnCommandsPanelContentChange(class UTedContentPanelDynamic* InContentPanel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerCommandsWidget">();
	}
	static class UTedPlayerCommandsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerCommandsWidget>();
	}
};
static_assert(alignof(UTedPlayerCommandsWidget) == 0x000008, "Wrong alignment on UTedPlayerCommandsWidget");
static_assert(sizeof(UTedPlayerCommandsWidget) == 0x000430, "Wrong size on UTedPlayerCommandsWidget");
static_assert(offsetof(UTedPlayerCommandsWidget, Image_Frame) == 0x000410, "Member 'UTedPlayerCommandsWidget::Image_Frame' has a wrong offset!");
static_assert(offsetof(UTedPlayerCommandsWidget, CommandsPanel) == 0x000418, "Member 'UTedPlayerCommandsWidget::CommandsPanel' has a wrong offset!");
static_assert(offsetof(UTedPlayerCommandsWidget, WidgetAnim_Collapse) == 0x000420, "Member 'UTedPlayerCommandsWidget::WidgetAnim_Collapse' has a wrong offset!");
static_assert(offsetof(UTedPlayerCommandsWidget, CollapseButtonPanel) == 0x000428, "Member 'UTedPlayerCommandsWidget::CollapseButtonPanel' has a wrong offset!");

// Class Tempest.TedPlayerCommand_Airstrike
// 0x0020 (0x0618 - 0x05F8)
class UTedPlayerCommand_Airstrike : public UTedPlayerCommand_AirMission_Base
{
public:
	struct FVector2D                              ProjectileXOffsetRange;                            // 0x05F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              ProjectileYOffsetRange;                            // 0x0608(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static struct FGameplayCommandData CreateAirstrikeCommandData(TSubclassOf<class UTedPlayerCommand_Airstrike> CommandClass, const struct FGameplayCommandDataPayload_Airstrike& Payload);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerCommand_Airstrike">();
	}
	static class UTedPlayerCommand_Airstrike* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerCommand_Airstrike>();
	}
};
static_assert(alignof(UTedPlayerCommand_Airstrike) == 0x000008, "Wrong alignment on UTedPlayerCommand_Airstrike");
static_assert(sizeof(UTedPlayerCommand_Airstrike) == 0x000618, "Wrong size on UTedPlayerCommand_Airstrike");
static_assert(offsetof(UTedPlayerCommand_Airstrike, ProjectileXOffsetRange) == 0x0005F8, "Member 'UTedPlayerCommand_Airstrike::ProjectileXOffsetRange' has a wrong offset!");
static_assert(offsetof(UTedPlayerCommand_Airstrike, ProjectileYOffsetRange) == 0x000608, "Member 'UTedPlayerCommand_Airstrike::ProjectileYOffsetRange' has a wrong offset!");

// Class Tempest.TedPlayerCommand_ApplyGameplayEffect
// 0x0058 (0x05C8 - 0x0570)
class UTedPlayerCommand_ApplyGameplayEffect : public UTedPlayerCommand
{
public:
	TSoftClassPtr<class UClass>                   EffectClass;                                       // 0x0570(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   CommandVisualActorClass;                           // 0x0598(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAISenseAffiliationFilter              AttitudeFilter;                                    // 0x05C0(0x0004)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C4[0x4];                                      // 0x05C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerCommand_ApplyGameplayEffect">();
	}
	static class UTedPlayerCommand_ApplyGameplayEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerCommand_ApplyGameplayEffect>();
	}
};
static_assert(alignof(UTedPlayerCommand_ApplyGameplayEffect) == 0x000008, "Wrong alignment on UTedPlayerCommand_ApplyGameplayEffect");
static_assert(sizeof(UTedPlayerCommand_ApplyGameplayEffect) == 0x0005C8, "Wrong size on UTedPlayerCommand_ApplyGameplayEffect");
static_assert(offsetof(UTedPlayerCommand_ApplyGameplayEffect, EffectClass) == 0x000570, "Member 'UTedPlayerCommand_ApplyGameplayEffect::EffectClass' has a wrong offset!");
static_assert(offsetof(UTedPlayerCommand_ApplyGameplayEffect, CommandVisualActorClass) == 0x000598, "Member 'UTedPlayerCommand_ApplyGameplayEffect::CommandVisualActorClass' has a wrong offset!");
static_assert(offsetof(UTedPlayerCommand_ApplyGameplayEffect, AttitudeFilter) == 0x0005C0, "Member 'UTedPlayerCommand_ApplyGameplayEffect::AttitudeFilter' has a wrong offset!");

// Class Tempest.TedPlayerCommand_ClusterMine
// 0x0000 (0x0618 - 0x0618)
class UTedPlayerCommand_ClusterMine : public UTedPlayerCommand_Airstrike
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerCommand_ClusterMine">();
	}
	static class UTedPlayerCommand_ClusterMine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerCommand_ClusterMine>();
	}
};
static_assert(alignof(UTedPlayerCommand_ClusterMine) == 0x000008, "Wrong alignment on UTedPlayerCommand_ClusterMine");
static_assert(sizeof(UTedPlayerCommand_ClusterMine) == 0x000618, "Wrong size on UTedPlayerCommand_ClusterMine");

// Class Tempest.TedPlayerCommand_StructureBase
// 0x0000 (0x0570 - 0x0570)
class UTedPlayerCommand_StructureBase : public UTedPlayerCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerCommand_StructureBase">();
	}
	static class UTedPlayerCommand_StructureBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerCommand_StructureBase>();
	}
};
static_assert(alignof(UTedPlayerCommand_StructureBase) == 0x000008, "Wrong alignment on UTedPlayerCommand_StructureBase");
static_assert(sizeof(UTedPlayerCommand_StructureBase) == 0x000570, "Wrong size on UTedPlayerCommand_StructureBase");

// Class Tempest.TedPlayerCommand_ConstructionQueue
// 0x0008 (0x0578 - 0x0570)
class UTedPlayerCommand_ConstructionQueue : public UTedPlayerCommand_StructureBase
{
public:
	int32                                         Amount;                                            // 0x0570(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_574[0x4];                                      // 0x0574(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FGameplayCommandData CreateCommandData_ConstructionQueue(TSubclassOf<class UTedCommand> InCommand, class ATedStructureBase* InFactory, const struct FGameplayTag& InConstructionElementId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerCommand_ConstructionQueue">();
	}
	static class UTedPlayerCommand_ConstructionQueue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerCommand_ConstructionQueue>();
	}
};
static_assert(alignof(UTedPlayerCommand_ConstructionQueue) == 0x000008, "Wrong alignment on UTedPlayerCommand_ConstructionQueue");
static_assert(sizeof(UTedPlayerCommand_ConstructionQueue) == 0x000578, "Wrong size on UTedPlayerCommand_ConstructionQueue");
static_assert(offsetof(UTedPlayerCommand_ConstructionQueue, Amount) == 0x000570, "Member 'UTedPlayerCommand_ConstructionQueue::Amount' has a wrong offset!");

// Class Tempest.TedPlayerCommand_PauseDoctrineResearch
// 0x0008 (0x0578 - 0x0570)
class UTedPlayerCommand_PauseDoctrineResearch : public UTedPlayerCommand_DoctrineBase
{
public:
	bool                                          bPause;                                            // 0x0570(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_571[0x7];                                      // 0x0571(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerCommand_PauseDoctrineResearch">();
	}
	static class UTedPlayerCommand_PauseDoctrineResearch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerCommand_PauseDoctrineResearch>();
	}
};
static_assert(alignof(UTedPlayerCommand_PauseDoctrineResearch) == 0x000008, "Wrong alignment on UTedPlayerCommand_PauseDoctrineResearch");
static_assert(sizeof(UTedPlayerCommand_PauseDoctrineResearch) == 0x000578, "Wrong size on UTedPlayerCommand_PauseDoctrineResearch");
static_assert(offsetof(UTedPlayerCommand_PauseDoctrineResearch, bPause) == 0x000570, "Member 'UTedPlayerCommand_PauseDoctrineResearch::bPause' has a wrong offset!");

// Class Tempest.TedPlayerCommand_SellDoctrine
// 0x0000 (0x0570 - 0x0570)
class UTedPlayerCommand_SellDoctrine : public UTedPlayerCommand_DoctrineBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerCommand_SellDoctrine">();
	}
	static class UTedPlayerCommand_SellDoctrine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerCommand_SellDoctrine>();
	}
};
static_assert(alignof(UTedPlayerCommand_SellDoctrine) == 0x000008, "Wrong alignment on UTedPlayerCommand_SellDoctrine");
static_assert(sizeof(UTedPlayerCommand_SellDoctrine) == 0x000570, "Wrong size on UTedPlayerCommand_SellDoctrine");

// Class Tempest.TedPlayerCommand_LockDown
// 0x0008 (0x05D0 - 0x05C8)
class UTedPlayerCommand_LockDown final : public UTedPlayerCommand_ApplyGameplayEffect
{
public:
	float                                         PowerConsumption;                                  // 0x05C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PowerConsumptionDuration;                          // 0x05CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerCommand_LockDown">();
	}
	static class UTedPlayerCommand_LockDown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerCommand_LockDown>();
	}
};
static_assert(alignof(UTedPlayerCommand_LockDown) == 0x000008, "Wrong alignment on UTedPlayerCommand_LockDown");
static_assert(sizeof(UTedPlayerCommand_LockDown) == 0x0005D0, "Wrong size on UTedPlayerCommand_LockDown");
static_assert(offsetof(UTedPlayerCommand_LockDown, PowerConsumption) == 0x0005C8, "Member 'UTedPlayerCommand_LockDown::PowerConsumption' has a wrong offset!");
static_assert(offsetof(UTedPlayerCommand_LockDown, PowerConsumptionDuration) == 0x0005CC, "Member 'UTedPlayerCommand_LockDown::PowerConsumptionDuration' has a wrong offset!");

// Class Tempest.TedPlayerCommand_PauseConstruction
// 0x0008 (0x0578 - 0x0570)
class UTedPlayerCommand_PauseConstruction : public UTedPlayerCommand_StructureBase
{
public:
	bool                                          bPause;                                            // 0x0570(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_571[0x7];                                      // 0x0571(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FGameplayCommandData CreateCommandData_PauseConstruction(TSubclassOf<class UTedCommand> InCommand, class ATedStructureBase* InFactory, const struct FGameplayTag& InConstructionElementId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerCommand_PauseConstruction">();
	}
	static class UTedPlayerCommand_PauseConstruction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerCommand_PauseConstruction>();
	}
};
static_assert(alignof(UTedPlayerCommand_PauseConstruction) == 0x000008, "Wrong alignment on UTedPlayerCommand_PauseConstruction");
static_assert(sizeof(UTedPlayerCommand_PauseConstruction) == 0x000578, "Wrong size on UTedPlayerCommand_PauseConstruction");
static_assert(offsetof(UTedPlayerCommand_PauseConstruction, bPause) == 0x000570, "Member 'UTedPlayerCommand_PauseConstruction::bPause' has a wrong offset!");

// Class Tempest.TedPlayerCommand_PlaceStructure
// 0x0000 (0x0570 - 0x0570)
class UTedPlayerCommand_PlaceStructure : public UTedPlayerCommand
{
public:
	static struct FGameplayCommandData CreateCommandData_PlaceStructure(const struct FVector& InLocation, TSubclassOf<class ATedStructureBase> InStructureClass, class ATedStructureBase* InFactory, TSubclassOf<class UTedCommand> InCommandOverride);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerCommand_PlaceStructure">();
	}
	static class UTedPlayerCommand_PlaceStructure* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerCommand_PlaceStructure>();
	}
};
static_assert(alignof(UTedPlayerCommand_PlaceStructure) == 0x000008, "Wrong alignment on UTedPlayerCommand_PlaceStructure");
static_assert(sizeof(UTedPlayerCommand_PlaceStructure) == 0x000570, "Wrong size on UTedPlayerCommand_PlaceStructure");

// Class Tempest.TedPlayerCommand_PlaceConstructionSite
// 0x0000 (0x0570 - 0x0570)
class UTedPlayerCommand_PlaceConstructionSite : public UTedPlayerCommand_PlaceStructure
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerCommand_PlaceConstructionSite">();
	}
	static class UTedPlayerCommand_PlaceConstructionSite* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerCommand_PlaceConstructionSite>();
	}
};
static_assert(alignof(UTedPlayerCommand_PlaceConstructionSite) == 0x000008, "Wrong alignment on UTedPlayerCommand_PlaceConstructionSite");
static_assert(sizeof(UTedPlayerCommand_PlaceConstructionSite) == 0x000570, "Wrong size on UTedPlayerCommand_PlaceConstructionSite");

// Class Tempest.TedPlayerCommand_PlaceStructure_SupportPower
// 0x0028 (0x0598 - 0x0570)
class UTedPlayerCommand_PlaceStructure_SupportPower : public UTedPlayerCommand
{
public:
	TSoftClassPtr<class UClass>                   StructureClass;                                    // 0x0570(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerCommand_PlaceStructure_SupportPower">();
	}
	static class UTedPlayerCommand_PlaceStructure_SupportPower* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerCommand_PlaceStructure_SupportPower>();
	}
};
static_assert(alignof(UTedPlayerCommand_PlaceStructure_SupportPower) == 0x000008, "Wrong alignment on UTedPlayerCommand_PlaceStructure_SupportPower");
static_assert(sizeof(UTedPlayerCommand_PlaceStructure_SupportPower) == 0x000598, "Wrong size on UTedPlayerCommand_PlaceStructure_SupportPower");
static_assert(offsetof(UTedPlayerCommand_PlaceStructure_SupportPower, StructureClass) == 0x000570, "Member 'UTedPlayerCommand_PlaceStructure_SupportPower::StructureClass' has a wrong offset!");

// Class Tempest.TedPlayerCommand_RepairStructure
// 0x0000 (0x0570 - 0x0570)
class UTedPlayerCommand_RepairStructure : public UTedPlayerCommand_StructureBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerCommand_RepairStructure">();
	}
	static class UTedPlayerCommand_RepairStructure* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerCommand_RepairStructure>();
	}
};
static_assert(alignof(UTedPlayerCommand_RepairStructure) == 0x000008, "Wrong alignment on UTedPlayerCommand_RepairStructure");
static_assert(sizeof(UTedPlayerCommand_RepairStructure) == 0x000570, "Wrong size on UTedPlayerCommand_RepairStructure");

// Class Tempest.TedPlayerCommand_SellStructure
// 0x0000 (0x0570 - 0x0570)
class UTedPlayerCommand_SellStructure : public UTedPlayerCommand_StructureBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerCommand_SellStructure">();
	}
	static class UTedPlayerCommand_SellStructure* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerCommand_SellStructure>();
	}
};
static_assert(alignof(UTedPlayerCommand_SellStructure) == 0x000008, "Wrong alignment on UTedPlayerCommand_SellStructure");
static_assert(sizeof(UTedPlayerCommand_SellStructure) == 0x000570, "Wrong size on UTedPlayerCommand_SellStructure");

// Class Tempest.TedPlayerCommand_SpawnProjectile
// 0x0128 (0x0698 - 0x0570)
class UTedPlayerCommand_SpawnProjectile : public UTedPlayerCommand
{
public:
	TSoftClassPtr<class UClass>                   ProjectileClass;                                   // 0x0570(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTedDamageType>             DamageType;                                        // 0x0598(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRadialDamageParams                    RadialDamageParams;                                // 0x05A0(0x0014)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B4[0x4];                                      // 0x05B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedUtilsPawnFilter                    PawnFilter;                                        // 0x05B8(0x00D0)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            EffectToApplyOnDamage;                             // 0x0688(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDealsFullDamageToTarget;                          // 0x0690(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_691[0x7];                                      // 0x0691(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerCommand_SpawnProjectile">();
	}
	static class UTedPlayerCommand_SpawnProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerCommand_SpawnProjectile>();
	}
};
static_assert(alignof(UTedPlayerCommand_SpawnProjectile) == 0x000008, "Wrong alignment on UTedPlayerCommand_SpawnProjectile");
static_assert(sizeof(UTedPlayerCommand_SpawnProjectile) == 0x000698, "Wrong size on UTedPlayerCommand_SpawnProjectile");
static_assert(offsetof(UTedPlayerCommand_SpawnProjectile, ProjectileClass) == 0x000570, "Member 'UTedPlayerCommand_SpawnProjectile::ProjectileClass' has a wrong offset!");
static_assert(offsetof(UTedPlayerCommand_SpawnProjectile, DamageType) == 0x000598, "Member 'UTedPlayerCommand_SpawnProjectile::DamageType' has a wrong offset!");
static_assert(offsetof(UTedPlayerCommand_SpawnProjectile, RadialDamageParams) == 0x0005A0, "Member 'UTedPlayerCommand_SpawnProjectile::RadialDamageParams' has a wrong offset!");
static_assert(offsetof(UTedPlayerCommand_SpawnProjectile, PawnFilter) == 0x0005B8, "Member 'UTedPlayerCommand_SpawnProjectile::PawnFilter' has a wrong offset!");
static_assert(offsetof(UTedPlayerCommand_SpawnProjectile, EffectToApplyOnDamage) == 0x000688, "Member 'UTedPlayerCommand_SpawnProjectile::EffectToApplyOnDamage' has a wrong offset!");
static_assert(offsetof(UTedPlayerCommand_SpawnProjectile, bDealsFullDamageToTarget) == 0x000690, "Member 'UTedPlayerCommand_SpawnProjectile::bDealsFullDamageToTarget' has a wrong offset!");

// Class Tempest.TedPlayerCommand_SpawnUnitsForPawns
// 0x0038 (0x05B8 - 0x0580)
class UTedPlayerCommand_SpawnUnitsForPawns : public UTedPlayerCommand_SpawnUnits
{
public:
	int32                                         PawnLimit;                                         // 0x0580(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_584[0x4];                                      // 0x0584(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  PriorityTags;                                      // 0x0588(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FPawnDefinitionFilter>          PawnFilters;                                       // 0x05A8(0x0010)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, NoClear, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerCommand_SpawnUnitsForPawns">();
	}
	static class UTedPlayerCommand_SpawnUnitsForPawns* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerCommand_SpawnUnitsForPawns>();
	}
};
static_assert(alignof(UTedPlayerCommand_SpawnUnitsForPawns) == 0x000008, "Wrong alignment on UTedPlayerCommand_SpawnUnitsForPawns");
static_assert(sizeof(UTedPlayerCommand_SpawnUnitsForPawns) == 0x0005B8, "Wrong size on UTedPlayerCommand_SpawnUnitsForPawns");
static_assert(offsetof(UTedPlayerCommand_SpawnUnitsForPawns, PawnLimit) == 0x000580, "Member 'UTedPlayerCommand_SpawnUnitsForPawns::PawnLimit' has a wrong offset!");
static_assert(offsetof(UTedPlayerCommand_SpawnUnitsForPawns, PriorityTags) == 0x000588, "Member 'UTedPlayerCommand_SpawnUnitsForPawns::PriorityTags' has a wrong offset!");
static_assert(offsetof(UTedPlayerCommand_SpawnUnitsForPawns, PawnFilters) == 0x0005A8, "Member 'UTedPlayerCommand_SpawnUnitsForPawns::PawnFilters' has a wrong offset!");

// Class Tempest.TedPlayerCommand_ToggleStructurePower
// 0x0000 (0x0570 - 0x0570)
class UTedPlayerCommand_ToggleStructurePower : public UTedPlayerCommand_StructureBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerCommand_ToggleStructurePower">();
	}
	static class UTedPlayerCommand_ToggleStructurePower* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerCommand_ToggleStructurePower>();
	}
};
static_assert(alignof(UTedPlayerCommand_ToggleStructurePower) == 0x000008, "Wrong alignment on UTedPlayerCommand_ToggleStructurePower");
static_assert(sizeof(UTedPlayerCommand_ToggleStructurePower) == 0x000570, "Wrong size on UTedPlayerCommand_ToggleStructurePower");

// Class Tempest.TedPlayerController_CC
// 0x0170 (0x0A30 - 0x08C0)
class ATedPlayerController_CC final : public ATedPlayerControllerBase
{
public:
	TMap<ETedCCCameraType, class FName>           CameraTags;                                        // 0x08C0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         bCameraTransitions : 1;                            // 0x0910(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_911[0x3];                                      // 0x0911(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraTransitionDuration;                          // 0x0914(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EViewTargetBlendFunction                      CameraTransitionFunction;                          // 0x0918(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_919[0x3];                                      // 0x0919(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraTransitionBlendExp;                          // 0x091C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSequenceActive;                                 // 0x0920(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_921[0x7];                                      // 0x0921(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraModifier*                        CamModifier;                                       // 0x0928(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraModifier>            CamModifierClass;                                  // 0x0930(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            CamModifierCurve;                                  // 0x0938(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_940[0x30];                                     // 0x0940(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedMapInfo*                            CurrentBriefingMap;                                // 0x0970(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class UObject*>                          CurrentBriefingLoadedAssets;                       // 0x0978(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	class ALevelSequenceActor*                    BriefingSequenceActor;                             // 0x09C8(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StreamingLevelLoadWait;                            // 0x09D0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StreamingTexturesLoadWait;                         // 0x09D4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9D8[0x58];                                     // 0x09D8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AtBriefingEnd();
	void AtBriefingSkip();
	void OnBriefingSequencePlayerFinished();
	void OnBriefingSequencePlayerPlayed();
	void OnBriefingSequencePlayerStopped();
	void SetViewTargetByCameraType(const ETedCCCameraType InCamera);
	void ShowMapScreen();
	void StartCameraTransition(const ETedCCCameraType InCamera);
	void UnloadLevels();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerController_CC">();
	}
	static class ATedPlayerController_CC* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedPlayerController_CC>();
	}
};
static_assert(alignof(ATedPlayerController_CC) == 0x000008, "Wrong alignment on ATedPlayerController_CC");
static_assert(sizeof(ATedPlayerController_CC) == 0x000A30, "Wrong size on ATedPlayerController_CC");
static_assert(offsetof(ATedPlayerController_CC, CameraTags) == 0x0008C0, "Member 'ATedPlayerController_CC::CameraTags' has a wrong offset!");
static_assert(offsetof(ATedPlayerController_CC, CameraTransitionDuration) == 0x000914, "Member 'ATedPlayerController_CC::CameraTransitionDuration' has a wrong offset!");
static_assert(offsetof(ATedPlayerController_CC, CameraTransitionFunction) == 0x000918, "Member 'ATedPlayerController_CC::CameraTransitionFunction' has a wrong offset!");
static_assert(offsetof(ATedPlayerController_CC, CameraTransitionBlendExp) == 0x00091C, "Member 'ATedPlayerController_CC::CameraTransitionBlendExp' has a wrong offset!");
static_assert(offsetof(ATedPlayerController_CC, bIsSequenceActive) == 0x000920, "Member 'ATedPlayerController_CC::bIsSequenceActive' has a wrong offset!");
static_assert(offsetof(ATedPlayerController_CC, CamModifier) == 0x000928, "Member 'ATedPlayerController_CC::CamModifier' has a wrong offset!");
static_assert(offsetof(ATedPlayerController_CC, CamModifierClass) == 0x000930, "Member 'ATedPlayerController_CC::CamModifierClass' has a wrong offset!");
static_assert(offsetof(ATedPlayerController_CC, CamModifierCurve) == 0x000938, "Member 'ATedPlayerController_CC::CamModifierCurve' has a wrong offset!");
static_assert(offsetof(ATedPlayerController_CC, CurrentBriefingMap) == 0x000970, "Member 'ATedPlayerController_CC::CurrentBriefingMap' has a wrong offset!");
static_assert(offsetof(ATedPlayerController_CC, CurrentBriefingLoadedAssets) == 0x000978, "Member 'ATedPlayerController_CC::CurrentBriefingLoadedAssets' has a wrong offset!");
static_assert(offsetof(ATedPlayerController_CC, BriefingSequenceActor) == 0x0009C8, "Member 'ATedPlayerController_CC::BriefingSequenceActor' has a wrong offset!");
static_assert(offsetof(ATedPlayerController_CC, StreamingLevelLoadWait) == 0x0009D0, "Member 'ATedPlayerController_CC::StreamingLevelLoadWait' has a wrong offset!");
static_assert(offsetof(ATedPlayerController_CC, StreamingTexturesLoadWait) == 0x0009D4, "Member 'ATedPlayerController_CC::StreamingTexturesLoadWait' has a wrong offset!");

// Class Tempest.TedPlayerData
// 0x0A90 (0x0B40 - 0x00B0)
class UTedPlayerData final : public UActorComponent
{
public:
	struct FTedPlayerDataResources                Resources;                                         // 0x00B0(0x0020)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x20];                                      // 0x00D0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ATedStructureBase*, struct FTimerHandle> IntelGenerationHandles;                      // 0x00F0(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TMap<struct FTedUpcomingPopulationSourceHandle, int32> UpcomingPopulationSources;                // 0x0140(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TMap<struct FTedUpcomingPopulationSourceHandle, int32> AlwaysCountToUpcomingPopulationSources;   // 0x0190(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UTedPlayerData* InPlayerData, const struct FTedPlayerDataResources& InPrevious, const struct FTedPlayerDataResources& InCurrent)> OnResourcesChangeEvent; // 0x01E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F0[0x18];                                     // 0x01F0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UTedPlayerData* InPlayerData, const struct FTedPlayerLockedTechData& InPrevious, const struct FTedPlayerLockedTechData& InCurrent)> OnLockedTechDataChange; // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_218[0x18];                                     // 0x0218(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedPlayerLockedTechData               LockedTechData;                                    // 0x0230(0x0028)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_258[0x28];                                     // 0x0258(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HarvesterCredits;                                  // 0x0280(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UTedPlayerData* InPlayerData)> OnOwnedTagsChange;            // 0x0288(0x0010)(ZeroConstructor, InstancedReference, SaveGame, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_298[0x158];                                    // 0x0298(0x0158)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedGameplayTagReplicationContainer    OwnedReplicationTags;                              // 0x03F0(0x0060)(Net, Transient, SaveGame, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_450[0x50];                                     // 0x0450(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLockOwnedTags;                                    // 0x04A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A1[0x7];                                      // 0x04A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATedStructureBase*>              OwnedStructures;                                   // 0x04A8(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	TSet<class ATedStructureBase*>                LastOwnedStructures;                               // 0x04B8(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UTedPlayerData* InPlayerData)> OnStructuresChange;           // 0x0508(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_518[0x18];                                     // 0x0518(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UTedPlayerData* InPlayerData)> OnInfluenceAreaChange;        // 0x0530(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_540[0x18];                                     // 0x0540(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATedPawn*>                       AdditionalInfluenceAreaProviders;                  // 0x0558(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	TSet<struct FOffsetCoords>                    InfluenceArea;                                     // 0x0568(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TArray<class ATedUnitBase*>                   OwnedUnits;                                        // 0x05B8(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	TSet<class ATedUnitBase*>                     LastOwnedUnits;                                    // 0x05C8(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	struct FTedSpecialistLimitSettings            SpecialistLimitSettings;                           // 0x0618(0x000C)(Net, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_624[0x4];                                      // 0x0624(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATedUnitBase*>                   SpecialistRefs;                                    // 0x0628(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class ATedUnitBase*>                   CommandoRefs;                                      // 0x0638(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         SpecialistsQueued;                                 // 0x0648(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CommandosQueued;                                   // 0x064C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UTedPlayerData* InPlayerData)> OnUnitsChange;                // 0x0650(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_660[0x18];                                     // 0x0660(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UTedPlayerData* InPlayerData)> OnOtherPawnsChange;           // 0x0678(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_688[0x18];                                     // 0x0688(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATedPawn*>                       OwnedOtherPawns;                                   // 0x06A0(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	TSet<class ATedPawn*>                         LastOwnedOtherPawns;                               // 0x06B0(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	struct FTedPlayerDataConstructionQueues       ConstructionQueues;                                // 0x0700(0x0018)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_718[0x18];                                     // 0x0718(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UTedPlayerData* InPlayerData, const struct FTedPlayerDataConstructionQueues& InPrevious, const struct FTedPlayerDataConstructionQueues& InCurrent)> OnConstructionQueuesChange; // 0x0730(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_740[0x18];                                     // 0x0740(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTedUpgrade*>                    UnlockedUpgrades;                                  // 0x0758(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TSet<class UTedUpgrade*>                      LastUnlockedUpgrades;                              // 0x0768(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UTedPlayerData* InPlayerData)> OnUnlockedUpgradesChange;     // 0x07B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C8[0x18];                                     // 0x07C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedDoctrineResearchQueue              DoctrineResearchQueue;                             // 0x07E0(0x0020)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_800[0x20];                                     // 0x0800(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTedDoctrineDefinition*>         ResearchedDoctrines;                               // 0x0820(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TSet<class UTedDoctrineDefinition*>           LastResearchedDoctrines;                           // 0x0830(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UTedPlayerData* InPlayerData, const struct FTedDoctrineResearchQueue& InPrevious, const struct FTedDoctrineResearchQueue& InCurrent)> OnDoctrineResearchQueueChange; // 0x0880(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_890[0x18];                                     // 0x0890(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UTedPlayerData* InPlayerData)> OnResearchedDoctrinesChange;  // 0x08A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B8[0x18];                                     // 0x08B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UObject*>                          AlreadyLoadedObjectsCache;                         // 0x08D0(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_920[0xA8];                                     // 0x0920(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTedPlayerDataPendingAnnouncement> PendingAnnouncements;                           // 0x09C8(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FPendingBuildCompletedNotify>   PendingBuildCompletedNotify;                       // 0x09D8(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, int32>              BuildNotifiesSent;                                 // 0x09E8(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	int32                                         MaxBuildNotifiesToSend;                            // 0x0A38(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTedPlayerIncomeCalculator             IncomeCalculator;                                  // 0x0A3C(0x00FC)(SaveGame, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bMovingData : 1;                                   // 0x0B38(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, DuplicateTransient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_B39[0x7];                                      // 0x0B39(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTedPlayerData* Get(const class APlayerState* InPlayerState);
	static class UTedPlayerData* GetByPlayerID(const class UObject* InWorldContext, const ETedPlayerID InPlayer);
	static class UTedPlayerData* GetByPlayerIndex(const class UObject* InWorldContext, const int32 InPlayerIndex);

	void AddCredits(const int32 InValue, const bool bInOverflow);
	void AddCreditsCap(const int32 InValue);
	void AddIntel(const int32 InValue);
	void AddPower(const int32 InValue);
	void AddPowerConsumption(const int32 InValue);
	void Client_ProductionCompleted(const class UTedEntityDefinitionAsset* InProducedPawnDefinitionAsset, const float InCreditsSpent, const ETedTelemetryCreditsSource InCreditsSource);
	void Client_ResourceChanged(const ETedResourceType InResourceType, const float InResourceDelta, const ETedResourceChangeReason InReason);
	void Client_SellStructure(class ATedStructureBase* InStructure);
	void ClientNotifyStructuresBuild(const TArray<struct FPendingBuildCompletedNotify>& DefinitionIds);
	void ClientOnIntelMarked(const class FString& UnitID);
	void ClientPlayAnnouncements(const TArray<struct FTedPlayerDataPendingAnnouncement>& InAnnouncements);
	void OnOtherPawnDestroyed_Handler(class AActor* InActor);
	void OnOtherPawnEndPlay_Handler(class AActor* InActor, EEndPlayReason InEndPlayReason);
	void OnRep_AdditionalInfluenceAreaProviders();
	void OnRep_ConstructionQueues(struct FTedPlayerDataConstructionQueues* OldConstructionQueues);
	void OnRep_DoctrineResearchQueue();
	void OnRep_HarvesterCredits();
	void OnRep_LockedTechData();
	void OnRep_OwnedOtherPawns();
	void OnRep_OwnedStructures();
	void OnRep_OwnedTags();
	void OnRep_OwnedUnits();
	void OnRep_Resources();
	void OnStructureDestroyed_Handler(class AActor* InActor);
	void OnStructureEndPlay_Handler(class AActor* InActor, EEndPlayReason InEndPlayReason);
	void OnUnitDestroyed_Handler(class AActor* InActor);
	void OnUnitEndPlay_Handler(class AActor* InActor, EEndPlayReason InEndPlayReason);
	void RegisterInfluenceAreaProvider(class ATedPawn* InPawnProvider);
	void ServerDebugAddCredits(const int32 InValue);
	void ServerDebugAddCreditsCap(const int32 InValue);
	void ServerDebugAddIntel(const int32 InValue);
	void ServerDebugAddPower(const int32 InValue);
	void UnregisterInfluenceAreaProvider(class ATedPawn* InPawnProvider);

	bool AllowPlayerCommands() const;
	int32 GetCommandoLimit() const;
	void GetCommandoRefs(TArray<class ATedUnitBase*>* OutCommandoRefs) const;
	int32 GetCredits() const;
	int32 GetCreditsCap() const;
	float GetCreditsPct() const;
	int32 GetIntel() const;
	const struct FTedPlayerLockedTechData GetLockedTechData() const;
	class ATedStructureBase* GetOwnedStructure_ByDefinition(const TSoftObjectPtr<class UTedEntityDefinitionAsset>& InDefinition) const;
	class ATedStructureBase* GetOwnedStructure_ByTag(const struct FGameplayTag& InTag) const;
	bool GetOwnedStructures(TArray<class ATedStructureBase*>* OutStructures) const;
	bool GetOwnedStructures_ByDefinition(const TSoftObjectPtr<class UTedEntityDefinitionAsset>& InDefinition, TArray<class ATedStructureBase*>* OutStructures) const;
	bool GetOwnedStructures_ByTag(const struct FGameplayTag& InTag, TArray<class ATedStructureBase*>* OutStructures) const;
	const struct FGameplayTagContainer GetOwnedTags() const;
	class ATedUnitBase* GetOwnedUnit_ByDefinition(const TSoftObjectPtr<class UTedEntityDefinitionAsset>& InDefinition) const;
	class ATedUnitBase* GetOwnedUnit_ByTag(const struct FGameplayTag& InTag) const;
	bool GetOwnedUnits(TArray<class ATedUnitBase*>* OutUnits) const;
	bool GetOwnedUnits_ByDefinition(const TSoftObjectPtr<class UTedEntityDefinitionAsset>& InDefinition, TArray<class ATedUnitBase*>* OutUnits) const;
	bool GetOwnedUnits_ByTag(const struct FGameplayTag& InTag, TArray<class ATedUnitBase*>* OutUnits) const;
	class ATedPlayerState* GetOwningPlayerState() const;
	class FText GetPlayerName() const;
	int32 GetPopulation() const;
	int32 GetPopulationCap() const;
	int32 GetPower() const;
	int32 GetPowerConsumption() const;
	const struct FTedPlayerDataResources GetResources() const;
	int32 GetSparePopulation(const bool bInIgnoreUpcomingPopulation, const bool bUseAlwaysCountPopulation) const;
	int32 GetSpecialistLimit() const;
	void GetSpecialistRefs(TArray<class ATedUnitBase*>* OutSpecialistRefs) const;
	void GetSpecialistsQueued(int32* OutAmountSpecialists, int32* OutAmountCommandos) const;
	int32 GetUnusedPower() const;
	int32 GetUnusedPowerTillPlentyPowerThreshold() const;
	int32 GetUpcomingPopulation() const;
	bool HasCredits() const;
	bool HasPower() const;
	bool HasPowerConsumption() const;
	bool HasStructure(const class ATedStructureBase* InStructure) const;
	bool HasUnit(const class ATedUnitBase* InUnit) const;
	bool IsBotPlayerData() const;
	bool IsDoctrineResearched(const class UTedDoctrineDefinition* InDoctrine) const;
	bool IsHumanPlayerData() const;
	bool IsImmuneToLowPower() const;
	bool IsInLowPowerMode() const;
	bool IsIntelRelevant() const;
	bool IsPowerLow() const;
	bool IsPowerPlenty() const;
	bool IsRegisteredInfluenceAreaProvider(const class ATedPawn* InPawn) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerData">();
	}
	static class UTedPlayerData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerData>();
	}
};
static_assert(alignof(UTedPlayerData) == 0x000008, "Wrong alignment on UTedPlayerData");
static_assert(sizeof(UTedPlayerData) == 0x000B40, "Wrong size on UTedPlayerData");
static_assert(offsetof(UTedPlayerData, Resources) == 0x0000B0, "Member 'UTedPlayerData::Resources' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, IntelGenerationHandles) == 0x0000F0, "Member 'UTedPlayerData::IntelGenerationHandles' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, UpcomingPopulationSources) == 0x000140, "Member 'UTedPlayerData::UpcomingPopulationSources' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, AlwaysCountToUpcomingPopulationSources) == 0x000190, "Member 'UTedPlayerData::AlwaysCountToUpcomingPopulationSources' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, OnResourcesChangeEvent) == 0x0001E0, "Member 'UTedPlayerData::OnResourcesChangeEvent' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, OnLockedTechDataChange) == 0x000208, "Member 'UTedPlayerData::OnLockedTechDataChange' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, LockedTechData) == 0x000230, "Member 'UTedPlayerData::LockedTechData' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, HarvesterCredits) == 0x000280, "Member 'UTedPlayerData::HarvesterCredits' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, OnOwnedTagsChange) == 0x000288, "Member 'UTedPlayerData::OnOwnedTagsChange' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, OwnedReplicationTags) == 0x0003F0, "Member 'UTedPlayerData::OwnedReplicationTags' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, bLockOwnedTags) == 0x0004A0, "Member 'UTedPlayerData::bLockOwnedTags' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, OwnedStructures) == 0x0004A8, "Member 'UTedPlayerData::OwnedStructures' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, LastOwnedStructures) == 0x0004B8, "Member 'UTedPlayerData::LastOwnedStructures' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, OnStructuresChange) == 0x000508, "Member 'UTedPlayerData::OnStructuresChange' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, OnInfluenceAreaChange) == 0x000530, "Member 'UTedPlayerData::OnInfluenceAreaChange' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, AdditionalInfluenceAreaProviders) == 0x000558, "Member 'UTedPlayerData::AdditionalInfluenceAreaProviders' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, InfluenceArea) == 0x000568, "Member 'UTedPlayerData::InfluenceArea' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, OwnedUnits) == 0x0005B8, "Member 'UTedPlayerData::OwnedUnits' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, LastOwnedUnits) == 0x0005C8, "Member 'UTedPlayerData::LastOwnedUnits' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, SpecialistLimitSettings) == 0x000618, "Member 'UTedPlayerData::SpecialistLimitSettings' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, SpecialistRefs) == 0x000628, "Member 'UTedPlayerData::SpecialistRefs' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, CommandoRefs) == 0x000638, "Member 'UTedPlayerData::CommandoRefs' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, SpecialistsQueued) == 0x000648, "Member 'UTedPlayerData::SpecialistsQueued' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, CommandosQueued) == 0x00064C, "Member 'UTedPlayerData::CommandosQueued' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, OnUnitsChange) == 0x000650, "Member 'UTedPlayerData::OnUnitsChange' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, OnOtherPawnsChange) == 0x000678, "Member 'UTedPlayerData::OnOtherPawnsChange' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, OwnedOtherPawns) == 0x0006A0, "Member 'UTedPlayerData::OwnedOtherPawns' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, LastOwnedOtherPawns) == 0x0006B0, "Member 'UTedPlayerData::LastOwnedOtherPawns' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, ConstructionQueues) == 0x000700, "Member 'UTedPlayerData::ConstructionQueues' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, OnConstructionQueuesChange) == 0x000730, "Member 'UTedPlayerData::OnConstructionQueuesChange' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, UnlockedUpgrades) == 0x000758, "Member 'UTedPlayerData::UnlockedUpgrades' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, LastUnlockedUpgrades) == 0x000768, "Member 'UTedPlayerData::LastUnlockedUpgrades' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, OnUnlockedUpgradesChange) == 0x0007B8, "Member 'UTedPlayerData::OnUnlockedUpgradesChange' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, DoctrineResearchQueue) == 0x0007E0, "Member 'UTedPlayerData::DoctrineResearchQueue' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, ResearchedDoctrines) == 0x000820, "Member 'UTedPlayerData::ResearchedDoctrines' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, LastResearchedDoctrines) == 0x000830, "Member 'UTedPlayerData::LastResearchedDoctrines' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, OnDoctrineResearchQueueChange) == 0x000880, "Member 'UTedPlayerData::OnDoctrineResearchQueueChange' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, OnResearchedDoctrinesChange) == 0x0008A8, "Member 'UTedPlayerData::OnResearchedDoctrinesChange' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, AlreadyLoadedObjectsCache) == 0x0008D0, "Member 'UTedPlayerData::AlreadyLoadedObjectsCache' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, PendingAnnouncements) == 0x0009C8, "Member 'UTedPlayerData::PendingAnnouncements' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, PendingBuildCompletedNotify) == 0x0009D8, "Member 'UTedPlayerData::PendingBuildCompletedNotify' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, BuildNotifiesSent) == 0x0009E8, "Member 'UTedPlayerData::BuildNotifiesSent' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, MaxBuildNotifiesToSend) == 0x000A38, "Member 'UTedPlayerData::MaxBuildNotifiesToSend' has a wrong offset!");
static_assert(offsetof(UTedPlayerData, IncomeCalculator) == 0x000A3C, "Member 'UTedPlayerData::IncomeCalculator' has a wrong offset!");

// Class Tempest.TedPlayerDataFunctionsLibrary
// 0x0000 (0x0028 - 0x0028)
class UTedPlayerDataFunctionsLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddLockedTech_ByDefinitions(const class UObject* InWorldContext, const ETedPlayerID InPlayer, const TArray<TSoftObjectPtr<class UTedEntityDefinitionAsset>>& InDefinitions);
	static void AddLockedTech_ByTags(const class UObject* InWorldContext, const ETedPlayerID InPlayer, const struct FGameplayTagContainer& InList);
	static void AddPlayerCredits(const class UObject* InWorldContext, const ETedPlayerID InPlayer, const int32 InValue, const bool bInOverflow);
	static void AddPlayerIntel(const class UObject* InWorldContext, const ETedPlayerID InPlayer, const int32 InValue);
	static bool HasAllOwnedTags(const class UObject* InWorldContext, const ETedPlayerID InPlayer, const struct FGameplayTagContainer& InTags);
	static bool HasAnyOwnedTags(const class UObject* InWorldContext, const ETedPlayerID InPlayer, const struct FGameplayTagContainer& InTags);
	static bool HasOwnedTag(const class UObject* InWorldContext, const ETedPlayerID InPlayer, const struct FGameplayTag& InTag);
	static bool IsTechLocked(const class UObject* InWorldContext, const ETedPlayerID InPlayer, const struct FGameplayTag& InTech);
	static bool IsTechLockedMultiple(const class UObject* InWorldContext, const ETedPlayerID InPlayer, const struct FGameplayTagContainer& InTech, const bool bInAny);
	static void RemoveLockedTech_ByDefinitions(const class UObject* InWorldContext, const ETedPlayerID InPlayer, const TArray<TSoftObjectPtr<class UTedEntityDefinitionAsset>>& InDefinitions);
	static void RemoveLockedTech_ByTags(const class UObject* InWorldContext, const ETedPlayerID InPlayer, const struct FGameplayTagContainer& InList);
	static void SetAllowPlayerCommands(const class UObject* InWorldContext, const ETedPlayerID InPlayer, const bool bInAllow);
	static void SetAllPawnsOwner(const class UObject* InWorldContext, const ETedPlayerID InSourcePlayer, const ETedPlayerID InTargetPlayer);
	static void SetLockedSupportPowers(const class UObject* InWorldContext, const ETedPlayerID InPlayer, const bool bLock, const struct FGameplayTagContainer& InCommandTypeTags);
	static void SetLockedTechData_ByDefinitions(const class UObject* InWorldContext, const ETedPlayerID InPlayer, const ETedPlayerLockedTechMode InMode, const TArray<TSoftObjectPtr<class UTedEntityDefinitionAsset>>& InDefinitions);
	static void SetLockedTechData_ByTags(const class UObject* InWorldContext, const ETedPlayerID InPlayer, const ETedPlayerLockedTechMode InMode, const struct FGameplayTagContainer& InList);
	static void SetPawnOwner(const class UObject* InWorldContext, class ATedPawn* InPawn, const ETedPlayerID InPlayer);
	static void SetPawnsOwner(const class UObject* InWorldContext, const TArray<class ATedPawn*>& InPawns, const ETedPlayerID InPlayer);
	static void SetPawnsOwner_ActorTag(const class UObject* InWorldContext, const struct FGameplayTagContainer& InActorTags, const ETedPlayerID InPlayer);
	static void SetPlayerTeam(const class UObject* InWorldContext, const ETedPlayerID InPlayer, const ETedTeamID InTeam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerDataFunctionsLibrary">();
	}
	static class UTedPlayerDataFunctionsLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerDataFunctionsLibrary>();
	}
};
static_assert(alignof(UTedPlayerDataFunctionsLibrary) == 0x000008, "Wrong alignment on UTedPlayerDataFunctionsLibrary");
static_assert(sizeof(UTedPlayerDataFunctionsLibrary) == 0x000028, "Wrong size on UTedPlayerDataFunctionsLibrary");

// Class Tempest.TedPlayerDataSettings
// 0x0298 (0x02D0 - 0x0038)
class UTedPlayerDataSettings final : public UDeveloperSettings
{
public:
	struct FGameplayTag                           FactoryType_Buildings;                             // 0x0038(0x0008)(Edit, Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           FactoryType_Defenses;                              // 0x0040(0x0008)(Edit, Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           FactoryType_Infantry;                              // 0x0048(0x0008)(Edit, Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           FactoryType_Vehicles;                              // 0x0050(0x0008)(Edit, Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           FactoryType_AirAndSea;                             // 0x0058(0x0008)(Edit, Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           FactoryType_PawnSpecific_Refinery;                 // 0x0060(0x0008)(Edit, Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           AllowInsufficientPowerTag;                         // 0x0068(0x0008)(Edit, Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTedPlayerDataTagDislpayName>   TagsDisplayNames;                                  // 0x0070(0x0010)(Edit, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TMap<ETedFaction, struct FAnnouncementForwardMap> EntityOwnedTagsTechAnnouncements;              // 0x0080(0x0050)(Edit, Config, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTedPlayerDataAnnouncementConfig> AnnouncementsMap;                                // 0x00D0(0x0010)(Edit, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	float                                         SilosNeededAnnouncementThreshold;                  // 0x00E0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTedSpecialistLimitSettings            MultiplayerRules;                                  // 0x00E4(0x000C)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FTedSpecialistLimitSettings            CampaignRules;                                     // 0x00F0(0x000C)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FTedSpecialistLimitSettings            SkirmishRules;                                     // 0x00FC(0x000C)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CreditPerResourceUnit;                             // 0x0108(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         IntelCap;                                          // 0x010C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PopulationCap;                                     // 0x0110(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTedDoctrineTreesArray>         AvailableDoctrines;                                // 0x0118(0x0010)(Edit, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	int32                                         DoctrinesLimit;                                    // 0x0128(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCheckCurrentOwnerFaction;                         // 0x012C(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12D[0x3];                                      // 0x012D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETedFaction, struct FTedConstructionQueueLimit> QueueLimitPerFaction;                       // 0x0130(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, int32>              QueueLimitPerFactory;                              // 0x0180(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, int32>              QueueLimitPerElement;                              // 0x01D0(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	struct FTedConfigRuntimeFloatCurve            PowerEfficiencyCurve;                              // 0x0220(0x00A8)(Edit, Config, Protected, NativeAccessSpecifierProtected)
	uint8                                         bScaleRepairCost : 1;                              // 0x02C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bScaleSellValue : 1;                               // 0x02C8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTedPlayerDataSettings* K2_GetPlayerDataSettings();

	const class FText GetPlayerDataTagDisplayName(const struct FGameplayTag& InTag);

	float CalculatePowerEfficiency(const int32 InPower, const int32 InPowerConsumption) const;
	const struct FGameplayTag GetAllowInsufficientPowerTag() const;
	TSoftClassPtr<class UClass> GetAnnouncement(const ETedPlayerDataAnnouncement InType, const bool bInUnit) const;
	float GetCreditPerResourceUnit() const;
	const struct FGameplayTag GetFactoryType_AirAndSea() const;
	const struct FGameplayTag GetFactoryType_Buildings() const;
	const struct FGameplayTag GetFactoryType_Defenses() const;
	const struct FGameplayTag GetFactoryType_Infantry() const;
	const struct FGameplayTag GetFactoryType_PawnSpecific_Refinery() const;
	const struct FGameplayTag GetFactoryType_Vehicles() const;
	int32 GetIntelCap() const;
	int32 GetPopulationCap() const;
	float GetSilosNeededAnnouncementThreshold() const;
	const class FText GetTagDisplayName(const struct FGameplayTag& InTag) const;
	bool ShouldScaleRepairCost() const;
	bool ShouldScaleSellValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerDataSettings">();
	}
	static class UTedPlayerDataSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerDataSettings>();
	}
};
static_assert(alignof(UTedPlayerDataSettings) == 0x000008, "Wrong alignment on UTedPlayerDataSettings");
static_assert(sizeof(UTedPlayerDataSettings) == 0x0002D0, "Wrong size on UTedPlayerDataSettings");
static_assert(offsetof(UTedPlayerDataSettings, FactoryType_Buildings) == 0x000038, "Member 'UTedPlayerDataSettings::FactoryType_Buildings' has a wrong offset!");
static_assert(offsetof(UTedPlayerDataSettings, FactoryType_Defenses) == 0x000040, "Member 'UTedPlayerDataSettings::FactoryType_Defenses' has a wrong offset!");
static_assert(offsetof(UTedPlayerDataSettings, FactoryType_Infantry) == 0x000048, "Member 'UTedPlayerDataSettings::FactoryType_Infantry' has a wrong offset!");
static_assert(offsetof(UTedPlayerDataSettings, FactoryType_Vehicles) == 0x000050, "Member 'UTedPlayerDataSettings::FactoryType_Vehicles' has a wrong offset!");
static_assert(offsetof(UTedPlayerDataSettings, FactoryType_AirAndSea) == 0x000058, "Member 'UTedPlayerDataSettings::FactoryType_AirAndSea' has a wrong offset!");
static_assert(offsetof(UTedPlayerDataSettings, FactoryType_PawnSpecific_Refinery) == 0x000060, "Member 'UTedPlayerDataSettings::FactoryType_PawnSpecific_Refinery' has a wrong offset!");
static_assert(offsetof(UTedPlayerDataSettings, AllowInsufficientPowerTag) == 0x000068, "Member 'UTedPlayerDataSettings::AllowInsufficientPowerTag' has a wrong offset!");
static_assert(offsetof(UTedPlayerDataSettings, TagsDisplayNames) == 0x000070, "Member 'UTedPlayerDataSettings::TagsDisplayNames' has a wrong offset!");
static_assert(offsetof(UTedPlayerDataSettings, EntityOwnedTagsTechAnnouncements) == 0x000080, "Member 'UTedPlayerDataSettings::EntityOwnedTagsTechAnnouncements' has a wrong offset!");
static_assert(offsetof(UTedPlayerDataSettings, AnnouncementsMap) == 0x0000D0, "Member 'UTedPlayerDataSettings::AnnouncementsMap' has a wrong offset!");
static_assert(offsetof(UTedPlayerDataSettings, SilosNeededAnnouncementThreshold) == 0x0000E0, "Member 'UTedPlayerDataSettings::SilosNeededAnnouncementThreshold' has a wrong offset!");
static_assert(offsetof(UTedPlayerDataSettings, MultiplayerRules) == 0x0000E4, "Member 'UTedPlayerDataSettings::MultiplayerRules' has a wrong offset!");
static_assert(offsetof(UTedPlayerDataSettings, CampaignRules) == 0x0000F0, "Member 'UTedPlayerDataSettings::CampaignRules' has a wrong offset!");
static_assert(offsetof(UTedPlayerDataSettings, SkirmishRules) == 0x0000FC, "Member 'UTedPlayerDataSettings::SkirmishRules' has a wrong offset!");
static_assert(offsetof(UTedPlayerDataSettings, CreditPerResourceUnit) == 0x000108, "Member 'UTedPlayerDataSettings::CreditPerResourceUnit' has a wrong offset!");
static_assert(offsetof(UTedPlayerDataSettings, IntelCap) == 0x00010C, "Member 'UTedPlayerDataSettings::IntelCap' has a wrong offset!");
static_assert(offsetof(UTedPlayerDataSettings, PopulationCap) == 0x000110, "Member 'UTedPlayerDataSettings::PopulationCap' has a wrong offset!");
static_assert(offsetof(UTedPlayerDataSettings, AvailableDoctrines) == 0x000118, "Member 'UTedPlayerDataSettings::AvailableDoctrines' has a wrong offset!");
static_assert(offsetof(UTedPlayerDataSettings, DoctrinesLimit) == 0x000128, "Member 'UTedPlayerDataSettings::DoctrinesLimit' has a wrong offset!");
static_assert(offsetof(UTedPlayerDataSettings, bCheckCurrentOwnerFaction) == 0x00012C, "Member 'UTedPlayerDataSettings::bCheckCurrentOwnerFaction' has a wrong offset!");
static_assert(offsetof(UTedPlayerDataSettings, QueueLimitPerFaction) == 0x000130, "Member 'UTedPlayerDataSettings::QueueLimitPerFaction' has a wrong offset!");
static_assert(offsetof(UTedPlayerDataSettings, QueueLimitPerFactory) == 0x000180, "Member 'UTedPlayerDataSettings::QueueLimitPerFactory' has a wrong offset!");
static_assert(offsetof(UTedPlayerDataSettings, QueueLimitPerElement) == 0x0001D0, "Member 'UTedPlayerDataSettings::QueueLimitPerElement' has a wrong offset!");
static_assert(offsetof(UTedPlayerDataSettings, PowerEfficiencyCurve) == 0x000220, "Member 'UTedPlayerDataSettings::PowerEfficiencyCurve' has a wrong offset!");

// Class Tempest.TedLinkedKeySettings
// 0x0008 (0x0080 - 0x0078)
class UTedLinkedKeySettings final : public UPlayerMappableKeySettings
{
public:
	class FName                                   LinkedMapping;                                     // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedLinkedKeySettings">();
	}
	static class UTedLinkedKeySettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedLinkedKeySettings>();
	}
};
static_assert(alignof(UTedLinkedKeySettings) == 0x000008, "Wrong alignment on UTedLinkedKeySettings");
static_assert(sizeof(UTedLinkedKeySettings) == 0x000080, "Wrong size on UTedLinkedKeySettings");
static_assert(offsetof(UTedLinkedKeySettings, LinkedMapping) == 0x000078, "Member 'UTedLinkedKeySettings::LinkedMapping' has a wrong offset!");

// Class Tempest.TedPlayerMovementComponent
// 0x0268 (0x03D0 - 0x0168)
class UTedPlayerMovementComponent final : public UPawnMovementComponent
{
public:
	uint8                                         bIgnoreTimeDilation : 1;                           // 0x0168(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_169[0x3];                                      // 0x0169(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultMaxSpeed;                                   // 0x016C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAdjustToFloor : 1;                                // 0x0170(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_171[0x7];                                      // 0x0171(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              FloorTraceRange;                                   // 0x0178(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              FloorSweepRange;                                   // 0x0188(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FloorSweepRadius;                                  // 0x0198(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             FloorTraceChannel;                                 // 0x019C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_19D[0x3];                                      // 0x019D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdjustmentToFloorInterpSpeed;                      // 0x01A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A4[0x22C];                                    // 0x01A4(0x022C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerMovementComponent">();
	}
	static class UTedPlayerMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerMovementComponent>();
	}
};
static_assert(alignof(UTedPlayerMovementComponent) == 0x000008, "Wrong alignment on UTedPlayerMovementComponent");
static_assert(sizeof(UTedPlayerMovementComponent) == 0x0003D0, "Wrong size on UTedPlayerMovementComponent");
static_assert(offsetof(UTedPlayerMovementComponent, DefaultMaxSpeed) == 0x00016C, "Member 'UTedPlayerMovementComponent::DefaultMaxSpeed' has a wrong offset!");
static_assert(offsetof(UTedPlayerMovementComponent, FloorTraceRange) == 0x000178, "Member 'UTedPlayerMovementComponent::FloorTraceRange' has a wrong offset!");
static_assert(offsetof(UTedPlayerMovementComponent, FloorSweepRange) == 0x000188, "Member 'UTedPlayerMovementComponent::FloorSweepRange' has a wrong offset!");
static_assert(offsetof(UTedPlayerMovementComponent, FloorSweepRadius) == 0x000198, "Member 'UTedPlayerMovementComponent::FloorSweepRadius' has a wrong offset!");
static_assert(offsetof(UTedPlayerMovementComponent, FloorTraceChannel) == 0x00019C, "Member 'UTedPlayerMovementComponent::FloorTraceChannel' has a wrong offset!");
static_assert(offsetof(UTedPlayerMovementComponent, AdjustmentToFloorInterpSpeed) == 0x0001A0, "Member 'UTedPlayerMovementComponent::AdjustmentToFloorInterpSpeed' has a wrong offset!");

// Class Tempest.TedPlayerPawn
// 0x0018 (0x0330 - 0x0318)
class ATedPlayerPawn : public APawn
{
public:
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedPlayerMovementComponent*            PlayerMovementComponent;                           // 0x0320(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTedPlayerCameraComponent*              PlayerCameraComponent;                             // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerPawn">();
	}
	static class ATedPlayerPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedPlayerPawn>();
	}
};
static_assert(alignof(ATedPlayerPawn) == 0x000008, "Wrong alignment on ATedPlayerPawn");
static_assert(sizeof(ATedPlayerPawn) == 0x000330, "Wrong size on ATedPlayerPawn");
static_assert(offsetof(ATedPlayerPawn, PlayerMovementComponent) == 0x000320, "Member 'ATedPlayerPawn::PlayerMovementComponent' has a wrong offset!");
static_assert(offsetof(ATedPlayerPawn, PlayerCameraComponent) == 0x000328, "Member 'ATedPlayerPawn::PlayerCameraComponent' has a wrong offset!");

// Class Tempest.TedPlayerProfileManager
// 0x0248 (0x0278 - 0x0030)
class UTedPlayerProfileManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x150];                                     // 0x0030(0x0150)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedStatistics                         PostponedProfile;                                  // 0x0180(0x0090)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_210[0x68];                                     // 0x0210(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDownloadPlayerProfileComplete(EProsdkErrorCodeAbstractData ResultCode, const TArray<struct FAbstractDataKeyRecord>& KeyRecords);
	void OnFriendStatusUpdateFromSteam(const uint64 InSteamId, const int32 InChangeFlags);
	void OnRequestPlayerProfileComplete(EProsdkErrorCodeAbstractData ResultCode, const TArray<struct FAbstractDataKeyRecord>& KeyRecords);
	void OnUploadPlayerProfileComplete(int32 LocalUserNum, EProsdkErrorCodeAbstractData ResultCode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerProfileManager">();
	}
	static class UTedPlayerProfileManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerProfileManager>();
	}
};
static_assert(alignof(UTedPlayerProfileManager) == 0x000008, "Wrong alignment on UTedPlayerProfileManager");
static_assert(sizeof(UTedPlayerProfileManager) == 0x000278, "Wrong size on UTedPlayerProfileManager");
static_assert(offsetof(UTedPlayerProfileManager, PostponedProfile) == 0x000180, "Member 'UTedPlayerProfileManager::PostponedProfile' has a wrong offset!");

// Class Tempest.TedPlayerProfileSeasonSelector
// 0x0048 (0x0448 - 0x0400)
class UTedPlayerProfileSeasonSelector final : public UTedUserWidget
{
public:
	uint8                                         Pad_400[0x20];                                     // 0x0400(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(int32 NewSeason)> OnSeasonChanged;                                 // 0x0420(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UTextBlock*                             SeasonText;                                        // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                DecreaseButton;                                    // 0x0438(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                IncreaseButton;                                    // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnDecreaseButtonClicked();
	void OnIncreaseButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerProfileSeasonSelector">();
	}
	static class UTedPlayerProfileSeasonSelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerProfileSeasonSelector>();
	}
};
static_assert(alignof(UTedPlayerProfileSeasonSelector) == 0x000008, "Wrong alignment on UTedPlayerProfileSeasonSelector");
static_assert(sizeof(UTedPlayerProfileSeasonSelector) == 0x000448, "Wrong size on UTedPlayerProfileSeasonSelector");
static_assert(offsetof(UTedPlayerProfileSeasonSelector, OnSeasonChanged) == 0x000420, "Member 'UTedPlayerProfileSeasonSelector::OnSeasonChanged' has a wrong offset!");
static_assert(offsetof(UTedPlayerProfileSeasonSelector, SeasonText) == 0x000430, "Member 'UTedPlayerProfileSeasonSelector::SeasonText' has a wrong offset!");
static_assert(offsetof(UTedPlayerProfileSeasonSelector, DecreaseButton) == 0x000438, "Member 'UTedPlayerProfileSeasonSelector::DecreaseButton' has a wrong offset!");
static_assert(offsetof(UTedPlayerProfileSeasonSelector, IncreaseButton) == 0x000440, "Member 'UTedPlayerProfileSeasonSelector::IncreaseButton' has a wrong offset!");

// Class Tempest.TedPlayerProfileStatisticsOverview
// 0x00F8 (0x04F8 - 0x0400)
class UTedPlayerProfileStatisticsOverview final : public UTedUserWidget
{
public:
	class UTextBlock*                             PlayerName;                                        // 0x0400(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PlayerPortrait;                                    // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedPlayerProfileLeaderboardPositionsPanel* LeaderboardPositionsPanel;                     // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedPlayerProfileStatsPanel*            QuickStats;                                        // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedPlayerProfileStatsPanel*            FullStats_Match;                                   // 0x0420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedPlayerProfileStatsPanel*            FullStats_Units;                                   // 0x0428(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedPlayerProfileStatsPanel*            FullStats_Buildings;                               // 0x0430(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedPlayerProfileStatsPanel*            FullStats_Resources;                               // 0x0438(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedPlayerProfileStatsPanel*            FullStats_Damage;                                  // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedPlayerProfileSeasonSelector*        SeasonSelector;                                    // 0x0448(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_450[0xA8];                                     // 0x0450(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UTedOnlinePlayerProfileWidget* GetPlayerProfile() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerProfileStatisticsOverview">();
	}
	static class UTedPlayerProfileStatisticsOverview* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerProfileStatisticsOverview>();
	}
};
static_assert(alignof(UTedPlayerProfileStatisticsOverview) == 0x000008, "Wrong alignment on UTedPlayerProfileStatisticsOverview");
static_assert(sizeof(UTedPlayerProfileStatisticsOverview) == 0x0004F8, "Wrong size on UTedPlayerProfileStatisticsOverview");
static_assert(offsetof(UTedPlayerProfileStatisticsOverview, PlayerName) == 0x000400, "Member 'UTedPlayerProfileStatisticsOverview::PlayerName' has a wrong offset!");
static_assert(offsetof(UTedPlayerProfileStatisticsOverview, PlayerPortrait) == 0x000408, "Member 'UTedPlayerProfileStatisticsOverview::PlayerPortrait' has a wrong offset!");
static_assert(offsetof(UTedPlayerProfileStatisticsOverview, LeaderboardPositionsPanel) == 0x000410, "Member 'UTedPlayerProfileStatisticsOverview::LeaderboardPositionsPanel' has a wrong offset!");
static_assert(offsetof(UTedPlayerProfileStatisticsOverview, QuickStats) == 0x000418, "Member 'UTedPlayerProfileStatisticsOverview::QuickStats' has a wrong offset!");
static_assert(offsetof(UTedPlayerProfileStatisticsOverview, FullStats_Match) == 0x000420, "Member 'UTedPlayerProfileStatisticsOverview::FullStats_Match' has a wrong offset!");
static_assert(offsetof(UTedPlayerProfileStatisticsOverview, FullStats_Units) == 0x000428, "Member 'UTedPlayerProfileStatisticsOverview::FullStats_Units' has a wrong offset!");
static_assert(offsetof(UTedPlayerProfileStatisticsOverview, FullStats_Buildings) == 0x000430, "Member 'UTedPlayerProfileStatisticsOverview::FullStats_Buildings' has a wrong offset!");
static_assert(offsetof(UTedPlayerProfileStatisticsOverview, FullStats_Resources) == 0x000438, "Member 'UTedPlayerProfileStatisticsOverview::FullStats_Resources' has a wrong offset!");
static_assert(offsetof(UTedPlayerProfileStatisticsOverview, FullStats_Damage) == 0x000440, "Member 'UTedPlayerProfileStatisticsOverview::FullStats_Damage' has a wrong offset!");
static_assert(offsetof(UTedPlayerProfileStatisticsOverview, SeasonSelector) == 0x000448, "Member 'UTedPlayerProfileStatisticsOverview::SeasonSelector' has a wrong offset!");

// Class Tempest.TedPlayerProfileStatsPanel_Slot
// 0x0000 (0x0430 - 0x0430)
class UTedPlayerProfileStatsPanel_Slot final : public UTedContentPanelSlotButton
{
public:
	void K2_DescribeQuickStatBrush(const struct FSlateBrush& InBrush);
	void K2_DescribeTitle(const class FText& InTitle);
	void K2_DescribeValue(const class FText& InVal);

	class FText GetStatTitle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerProfileStatsPanel_Slot">();
	}
	static class UTedPlayerProfileStatsPanel_Slot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerProfileStatsPanel_Slot>();
	}
};
static_assert(alignof(UTedPlayerProfileStatsPanel_Slot) == 0x000008, "Wrong alignment on UTedPlayerProfileStatsPanel_Slot");
static_assert(sizeof(UTedPlayerProfileStatsPanel_Slot) == 0x000430, "Wrong size on UTedPlayerProfileStatsPanel_Slot");

// Class Tempest.TedPlayerProfileStatTooltip
// 0x0000 (0x04A0 - 0x04A0)
class UTedPlayerProfileStatTooltip final : public UTedTooltipWidget
{
public:
	void K2_DescribeCombined(const class FText& TotalValue, const class FText& AverageValue, const class FName StatID, const bool bShouldShowAverage);
	void K2_DescribeFactionSpecific(const ETedRankedFaction Faction, const class FText& TotalValue, const class FText& AverageValue, const class FName StatID, const bool bShouldShowAverage);
	void K2_DescribeTitle(const class FText& Title);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerProfileStatTooltip">();
	}
	static class UTedPlayerProfileStatTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerProfileStatTooltip>();
	}
};
static_assert(alignof(UTedPlayerProfileStatTooltip) == 0x000008, "Wrong alignment on UTedPlayerProfileStatTooltip");
static_assert(sizeof(UTedPlayerProfileStatTooltip) == 0x0004A0, "Wrong size on UTedPlayerProfileStatTooltip");

// Class Tempest.TedPlayerStart
// 0x0018 (0x02D8 - 0x02C0)
class ATedPlayerStart final : public APlayerStart
{
public:
	uint8                                         bSnapToGrid : 1;                                   // 0x02C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnLocationsRadius;                              // 0x02C4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        UnitSpawnLocations;                                // 0x02C8(0x0010)(Edit, ZeroConstructor, Transient, EditConst, DuplicateTransient, Protected, NativeAccessSpecifierProtected)

public:
	void ResetSpawnLocations();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerStart">();
	}
	static class ATedPlayerStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedPlayerStart>();
	}
};
static_assert(alignof(ATedPlayerStart) == 0x000008, "Wrong alignment on ATedPlayerStart");
static_assert(sizeof(ATedPlayerStart) == 0x0002D8, "Wrong size on ATedPlayerStart");
static_assert(offsetof(ATedPlayerStart, SpawnLocationsRadius) == 0x0002C4, "Member 'ATedPlayerStart::SpawnLocationsRadius' has a wrong offset!");
static_assert(offsetof(ATedPlayerStart, UnitSpawnLocations) == 0x0002C8, "Member 'ATedPlayerStart::UnitSpawnLocations' has a wrong offset!");

// Class Tempest.TedPlayerState
// 0x0108 (0x0450 - 0x0348)
class ATedPlayerState final : public ATedPlayerStateBase
{
public:
	uint8                                         Pad_348[0x8];                                      // 0x0348(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGenericTeamId                         TeamID;                                            // 0x0350(0x0001)(Net, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGenericTeamId                         PreviousTeamID;                                    // 0x0351(0x0001)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETedPlayerID                                  InitialPlayerID;                                   // 0x0352(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsStartupBot;                                      // 0x0353(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_354[0x4];                                      // 0x0354(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedPlayerData*                         PlayerData;                                        // 0x0358(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETedPlayerID                                  TedPlayerID;                                       // 0x0360(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERTSColor                                     PlayerColor;                                       // 0x0361(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETedFaction                                   PlayerFaction;                                     // 0x0362(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_363[0x5];                                      // 0x0363(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedRankedRow                          RankedRow;                                         // 0x0368(0x0070)(Transient, NativeAccessSpecifierPrivate)
	class FString                                 HydraId;                                           // 0x03D8(0x0010)(Net, ZeroConstructor, Transient, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bIsDefeated : 1;                                   // 0x03E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bIsSurrendered : 1;                                // 0x03E8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bIsDeliDisc : 1;                                   // 0x03E8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_3E9[0x7];                                      // 0x03E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize10                  CameraLocation;                                    // 0x03F0(0x0018)(Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETedServerType                                ServerType;                                        // 0x0408(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bAllowSpectatorsSeeAll : 1;                        // 0x0409(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_40A[0x6];                                      // 0x040A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTedPawnSkinOverride>           SkinOverrides;                                     // 0x0410(0x0010)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	ETedBotDifficulty                             BotDifficulty;                                     // 0x0420(0x0001)(Net, ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_421[0x1F];                                     // 0x0421(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTedWeapon*>                     CachedWeaponInstances;                             // 0x0440(0x0010)(ZeroConstructor, Transient, DuplicateTransient, NativeAccessSpecifierPrivate)

public:
	static class ATedPlayerState* Get(const class UObject* InWorldContext, const ETedPlayerID InPlayerID, bool Silent);

	void OnRep_HydraId();
	void OnRep_PlayerColor();
	void OnRep_TeamID(const struct FGenericTeamId& OldTeamID);
	void OnRep_TedPlayerID();
	void Server_R_SetCameraLocation(const struct FVector_NetQuantize10& InCameraLocation);

	bool AllowSpectatorsSeeAll() const;
	void ClientRequestHydraInfo() const;
	ETedBotDifficulty GetBotDifficulty() const;
	struct FVector GetCameraLocation() const;
	class FString GetHydraId() const;
	bool GetIsStartupBot() const;
	ETedPawnSkinIndex GetPawnSkinOverride(const struct FGameplayTag& PawnTag) const;
	ERTSColor GetPlayerColor() const;
	class UTedPlayerData* GetPlayerData() const;
	ETedFaction GetPlayerFaction() const;
	ETedTeamID GetPreviousTeamID() const;
	const struct FTedRankedRow GetRankedRow() const;
	ETedRankedTeam GetRankedTeam() const;
	ETedServerType GetServerType() const;
	ETedTeamID GetTeamID() const;
	ETedPlayerID GetTedPlayerID() const;
	bool IsDefeated() const;
	bool IsDeliDisc() const;
	bool IsSurrendered() const;
	void ServerAcceptHydraInfo(const struct FPlayerHydraInfo& PlayerHydraInfo) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerState">();
	}
	static class ATedPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedPlayerState>();
	}
};
static_assert(alignof(ATedPlayerState) == 0x000008, "Wrong alignment on ATedPlayerState");
static_assert(sizeof(ATedPlayerState) == 0x000450, "Wrong size on ATedPlayerState");
static_assert(offsetof(ATedPlayerState, TeamID) == 0x000350, "Member 'ATedPlayerState::TeamID' has a wrong offset!");
static_assert(offsetof(ATedPlayerState, PreviousTeamID) == 0x000351, "Member 'ATedPlayerState::PreviousTeamID' has a wrong offset!");
static_assert(offsetof(ATedPlayerState, InitialPlayerID) == 0x000352, "Member 'ATedPlayerState::InitialPlayerID' has a wrong offset!");
static_assert(offsetof(ATedPlayerState, IsStartupBot) == 0x000353, "Member 'ATedPlayerState::IsStartupBot' has a wrong offset!");
static_assert(offsetof(ATedPlayerState, PlayerData) == 0x000358, "Member 'ATedPlayerState::PlayerData' has a wrong offset!");
static_assert(offsetof(ATedPlayerState, TedPlayerID) == 0x000360, "Member 'ATedPlayerState::TedPlayerID' has a wrong offset!");
static_assert(offsetof(ATedPlayerState, PlayerColor) == 0x000361, "Member 'ATedPlayerState::PlayerColor' has a wrong offset!");
static_assert(offsetof(ATedPlayerState, PlayerFaction) == 0x000362, "Member 'ATedPlayerState::PlayerFaction' has a wrong offset!");
static_assert(offsetof(ATedPlayerState, RankedRow) == 0x000368, "Member 'ATedPlayerState::RankedRow' has a wrong offset!");
static_assert(offsetof(ATedPlayerState, HydraId) == 0x0003D8, "Member 'ATedPlayerState::HydraId' has a wrong offset!");
static_assert(offsetof(ATedPlayerState, CameraLocation) == 0x0003F0, "Member 'ATedPlayerState::CameraLocation' has a wrong offset!");
static_assert(offsetof(ATedPlayerState, ServerType) == 0x000408, "Member 'ATedPlayerState::ServerType' has a wrong offset!");
static_assert(offsetof(ATedPlayerState, SkinOverrides) == 0x000410, "Member 'ATedPlayerState::SkinOverrides' has a wrong offset!");
static_assert(offsetof(ATedPlayerState, BotDifficulty) == 0x000420, "Member 'ATedPlayerState::BotDifficulty' has a wrong offset!");
static_assert(offsetof(ATedPlayerState, CachedWeaponInstances) == 0x000440, "Member 'ATedPlayerState::CachedWeaponInstances' has a wrong offset!");

// Class Tempest.TedPlayerStatePanel
// 0x0098 (0x0848 - 0x07B0)
class UTedPlayerStatePanel final : public UTedContentPanelDynamic
{
public:
	TMulticastInlineDelegate<void(class ATedPlayerState* InPlayerState, const struct FTedUserInfo& UserInfo)> OnUserInfoReceivedForPlayer; // 0x07B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	bool                                          bIncludeNeutralAndHostile;                         // 0x07C0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C1[0x27];                                     // 0x07C1(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATedPlayerState*>                content;                                           // 0x07E8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7F8[0x50];                                     // 0x07F8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class ATedPlayerState*> GetAllContent();
	class ATedPlayerState* GetContent(const int32 SlotIndex);
	void OnAllPlayersStarted(const TArray<class APlayerState*>& PlayerState);
	void SetContent(const TArray<class ATedPlayerState*>& InNewContent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlayerStatePanel">();
	}
	static class UTedPlayerStatePanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlayerStatePanel>();
	}
};
static_assert(alignof(UTedPlayerStatePanel) == 0x000008, "Wrong alignment on UTedPlayerStatePanel");
static_assert(sizeof(UTedPlayerStatePanel) == 0x000848, "Wrong size on UTedPlayerStatePanel");
static_assert(offsetof(UTedPlayerStatePanel, OnUserInfoReceivedForPlayer) == 0x0007B0, "Member 'UTedPlayerStatePanel::OnUserInfoReceivedForPlayer' has a wrong offset!");
static_assert(offsetof(UTedPlayerStatePanel, bIncludeNeutralAndHostile) == 0x0007C0, "Member 'UTedPlayerStatePanel::bIncludeNeutralAndHostile' has a wrong offset!");
static_assert(offsetof(UTedPlayerStatePanel, content) == 0x0007E8, "Member 'UTedPlayerStatePanel::content' has a wrong offset!");

// Class Tempest.TedPlaySoundCondition
// 0x0000 (0x0028 - 0x0028)
class UTedPlaySoundCondition final : public UPlaySoundCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPlaySoundCondition">();
	}
	static class UTedPlaySoundCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPlaySoundCondition>();
	}
};
static_assert(alignof(UTedPlaySoundCondition) == 0x000008, "Wrong alignment on UTedPlaySoundCondition");
static_assert(sizeof(UTedPlaySoundCondition) == 0x000028, "Wrong size on UTedPlaySoundCondition");

// Class Tempest.TedHudPopup2Buttons
// 0x0000 (0x0400 - 0x0400)
class UTedHudPopup2Buttons : public UTedUserWidget
{
public:
	void K2_OnHide();
	void K2_OnShow();
	void No();
	void Yes();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedHudPopup2Buttons">();
	}
	static class UTedHudPopup2Buttons* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedHudPopup2Buttons>();
	}
};
static_assert(alignof(UTedHudPopup2Buttons) == 0x000008, "Wrong alignment on UTedHudPopup2Buttons");
static_assert(sizeof(UTedHudPopup2Buttons) == 0x000400, "Wrong size on UTedHudPopup2Buttons");

// Class Tempest.TedHudPopup1Button
// 0x0000 (0x0400 - 0x0400)
class UTedHudPopup1Button final : public UTedUserWidget
{
public:
	void K2_OnHide();
	void K2_OnShow();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedHudPopup1Button">();
	}
	static class UTedHudPopup1Button* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedHudPopup1Button>();
	}
};
static_assert(alignof(UTedHudPopup1Button) == 0x000008, "Wrong alignment on UTedHudPopup1Button");
static_assert(sizeof(UTedHudPopup1Button) == 0x000400, "Wrong size on UTedHudPopup1Button");

// Class Tempest.TedPopupButtonsPanel
// 0x0010 (0x07C0 - 0x07B0)
class UTedPopupButtonsPanel : public UTedContentPanelDynamic
{
public:
	TArray<struct FTedPopupButton>                content;                                           // 0x07B0(0x0010)(ZeroConstructor, Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void SetContent(const TArray<struct FTedPopupButton>& InContent);

	const TArray<struct FTedPopupButton> GetContentAll() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPopupButtonsPanel">();
	}
	static class UTedPopupButtonsPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPopupButtonsPanel>();
	}
};
static_assert(alignof(UTedPopupButtonsPanel) == 0x000008, "Wrong alignment on UTedPopupButtonsPanel");
static_assert(sizeof(UTedPopupButtonsPanel) == 0x0007C0, "Wrong size on UTedPopupButtonsPanel");
static_assert(offsetof(UTedPopupButtonsPanel, content) == 0x0007B0, "Member 'UTedPopupButtonsPanel::content' has a wrong offset!");

// Class Tempest.TedPowerBarWidget
// 0x0108 (0x0518 - 0x0410)
class UTedPowerBarWidget : public UTedPlayerDataWidget
{
public:
	class FName                                   FillPctParamName;                                  // 0x0410(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RulerCountParamName;                               // 0x0418(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DisplayWidthParamName;                             // 0x0420(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PowerModeParamName;                                // 0x0428(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PowerMode_LowPower;                                // 0x0430(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PowerMode_MidPower;                                // 0x0434(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PowerMode_HighPower;                               // 0x0438(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableDynamicCapacity : 1;                        // 0x043C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_43D[0x3];                                      // 0x043D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DynamicCapacityStep;                               // 0x0440(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bForceInstantUpdate : 1;                           // 0x0444(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_445[0x3];                                      // 0x0445(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PowerProductionArgName;                            // 0x0448(0x0010)(Edit, ZeroConstructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 PowerConsumptionArgName;                           // 0x0458(0x0010)(Edit, ZeroConstructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 PowerEfficiencyArgName;                            // 0x0468(0x0010)(Edit, ZeroConstructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTedPowerBarData                       Data_PP;                                           // 0x0478(0x0048)(Edit, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UImage*                                 Image_ProgressBar_PP;                              // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTedPowerBarData                       Data_PC;                                           // 0x04C8(0x0048)(Edit, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UWidget*                                Indicator_PC;                                      // 0x0510(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnDisplayPowerConsumption(const struct FTedPowerBarData& InData);
	void OnDisplayPowerProduction(const struct FTedPowerBarData& InData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPowerBarWidget">();
	}
	static class UTedPowerBarWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPowerBarWidget>();
	}
};
static_assert(alignof(UTedPowerBarWidget) == 0x000008, "Wrong alignment on UTedPowerBarWidget");
static_assert(sizeof(UTedPowerBarWidget) == 0x000518, "Wrong size on UTedPowerBarWidget");
static_assert(offsetof(UTedPowerBarWidget, FillPctParamName) == 0x000410, "Member 'UTedPowerBarWidget::FillPctParamName' has a wrong offset!");
static_assert(offsetof(UTedPowerBarWidget, RulerCountParamName) == 0x000418, "Member 'UTedPowerBarWidget::RulerCountParamName' has a wrong offset!");
static_assert(offsetof(UTedPowerBarWidget, DisplayWidthParamName) == 0x000420, "Member 'UTedPowerBarWidget::DisplayWidthParamName' has a wrong offset!");
static_assert(offsetof(UTedPowerBarWidget, PowerModeParamName) == 0x000428, "Member 'UTedPowerBarWidget::PowerModeParamName' has a wrong offset!");
static_assert(offsetof(UTedPowerBarWidget, PowerMode_LowPower) == 0x000430, "Member 'UTedPowerBarWidget::PowerMode_LowPower' has a wrong offset!");
static_assert(offsetof(UTedPowerBarWidget, PowerMode_MidPower) == 0x000434, "Member 'UTedPowerBarWidget::PowerMode_MidPower' has a wrong offset!");
static_assert(offsetof(UTedPowerBarWidget, PowerMode_HighPower) == 0x000438, "Member 'UTedPowerBarWidget::PowerMode_HighPower' has a wrong offset!");
static_assert(offsetof(UTedPowerBarWidget, DynamicCapacityStep) == 0x000440, "Member 'UTedPowerBarWidget::DynamicCapacityStep' has a wrong offset!");
static_assert(offsetof(UTedPowerBarWidget, PowerProductionArgName) == 0x000448, "Member 'UTedPowerBarWidget::PowerProductionArgName' has a wrong offset!");
static_assert(offsetof(UTedPowerBarWidget, PowerConsumptionArgName) == 0x000458, "Member 'UTedPowerBarWidget::PowerConsumptionArgName' has a wrong offset!");
static_assert(offsetof(UTedPowerBarWidget, PowerEfficiencyArgName) == 0x000468, "Member 'UTedPowerBarWidget::PowerEfficiencyArgName' has a wrong offset!");
static_assert(offsetof(UTedPowerBarWidget, Data_PP) == 0x000478, "Member 'UTedPowerBarWidget::Data_PP' has a wrong offset!");
static_assert(offsetof(UTedPowerBarWidget, Image_ProgressBar_PP) == 0x0004C0, "Member 'UTedPowerBarWidget::Image_ProgressBar_PP' has a wrong offset!");
static_assert(offsetof(UTedPowerBarWidget, Data_PC) == 0x0004C8, "Member 'UTedPowerBarWidget::Data_PC' has a wrong offset!");
static_assert(offsetof(UTedPowerBarWidget, Indicator_PC) == 0x000510, "Member 'UTedPowerBarWidget::Indicator_PC' has a wrong offset!");

// Class Tempest.TedPrerequisiteSettings
// 0x0010 (0x0048 - 0x0038)
class UTedPrerequisiteSettings final : public UDeveloperSettings
{
public:
	TArray<struct FTedPrerequisiteSettings_TransferMap> DeprecatedTagToPrerequisites;                // 0x0038(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPrerequisiteSettings">();
	}
	static class UTedPrerequisiteSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPrerequisiteSettings>();
	}
};
static_assert(alignof(UTedPrerequisiteSettings) == 0x000008, "Wrong alignment on UTedPrerequisiteSettings");
static_assert(sizeof(UTedPrerequisiteSettings) == 0x000048, "Wrong size on UTedPrerequisiteSettings");
static_assert(offsetof(UTedPrerequisiteSettings, DeprecatedTagToPrerequisites) == 0x000038, "Member 'UTedPrerequisiteSettings::DeprecatedTagToPrerequisites' has a wrong offset!");

// Class Tempest.TedProceduralMeshWidget
// 0x0060 (0x01F0 - 0x0190)
class UTedProceduralMeshWidget final : public UNativeWidgetHost
{
public:
	TMap<uint32, class UObject*>                  CachedResourceObjects;                             // 0x0190(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E0[0x10];                                     // 0x01E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedProceduralMeshWidget">();
	}
	static class UTedProceduralMeshWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedProceduralMeshWidget>();
	}
};
static_assert(alignof(UTedProceduralMeshWidget) == 0x000008, "Wrong alignment on UTedProceduralMeshWidget");
static_assert(sizeof(UTedProceduralMeshWidget) == 0x0001F0, "Wrong size on UTedProceduralMeshWidget");
static_assert(offsetof(UTedProceduralMeshWidget, CachedResourceObjects) == 0x000190, "Member 'UTedProceduralMeshWidget::CachedResourceObjects' has a wrong offset!");

// Class Tempest.TedProjectileMovementComponent
// 0x0010 (0x0280 - 0x0270)
class UTedProjectileMovementComponent final : public UProjectileMovementComponent
{
public:
	float                                         HomingDistanceThreshold;                           // 0x0268(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bUseHomingDot : 1;                                 // 0x026C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_26D[0x3];                                      // 0x026D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HomingDotThreshold;                                // 0x0270(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HomingDotPower;                                    // 0x0274(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HomingLocationTimeToPredict;                       // 0x0278(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bHomigSteerWithYawOnly : 1;                        // 0x027C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDrawHomingDebug : 1;                              // 0x027C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_27D[0x3];                                      // 0x027D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedProjectileMovementComponent">();
	}
	static class UTedProjectileMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedProjectileMovementComponent>();
	}
};
static_assert(alignof(UTedProjectileMovementComponent) == 0x000010, "Wrong alignment on UTedProjectileMovementComponent");
static_assert(sizeof(UTedProjectileMovementComponent) == 0x000280, "Wrong size on UTedProjectileMovementComponent");
static_assert(offsetof(UTedProjectileMovementComponent, HomingDistanceThreshold) == 0x000268, "Member 'UTedProjectileMovementComponent::HomingDistanceThreshold' has a wrong offset!");
static_assert(offsetof(UTedProjectileMovementComponent, HomingDotThreshold) == 0x000270, "Member 'UTedProjectileMovementComponent::HomingDotThreshold' has a wrong offset!");
static_assert(offsetof(UTedProjectileMovementComponent, HomingDotPower) == 0x000274, "Member 'UTedProjectileMovementComponent::HomingDotPower' has a wrong offset!");
static_assert(offsetof(UTedProjectileMovementComponent, HomingLocationTimeToPredict) == 0x000278, "Member 'UTedProjectileMovementComponent::HomingLocationTimeToPredict' has a wrong offset!");

// Class Tempest.TedProjectilePool
// 0x0058 (0x0088 - 0x0030)
class UTedProjectilePool final : public UWorldSubsystem
{
public:
	TMap<TSubclassOf<class ATedProjectile>, struct FTPPool> ProjectilePools;                         // 0x0030(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedProjectilePool">();
	}
	static class UTedProjectilePool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedProjectilePool>();
	}
};
static_assert(alignof(UTedProjectilePool) == 0x000008, "Wrong alignment on UTedProjectilePool");
static_assert(sizeof(UTedProjectilePool) == 0x000088, "Wrong size on UTedProjectilePool");
static_assert(offsetof(UTedProjectilePool, ProjectilePools) == 0x000030, "Member 'UTedProjectilePool::ProjectilePools' has a wrong offset!");

// Class Tempest.TedProjectile_ClusterMine
// 0x0010 (0x0470 - 0x0460)
class ATedProjectile_ClusterMine : public ATedProjectile
{
public:
	TSubclassOf<class UTedMinefieldProxy>         MinefieldProxy;                                    // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATedPlayerState*                        CachedPS;                                          // 0x0468(0x0008)(ZeroConstructor, SaveGame, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedProjectile_ClusterMine">();
	}
	static class ATedProjectile_ClusterMine* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedProjectile_ClusterMine>();
	}
};
static_assert(alignof(ATedProjectile_ClusterMine) == 0x000008, "Wrong alignment on ATedProjectile_ClusterMine");
static_assert(sizeof(ATedProjectile_ClusterMine) == 0x000470, "Wrong size on ATedProjectile_ClusterMine");
static_assert(offsetof(ATedProjectile_ClusterMine, MinefieldProxy) == 0x000460, "Member 'ATedProjectile_ClusterMine::MinefieldProxy' has a wrong offset!");
static_assert(offsetof(ATedProjectile_ClusterMine, CachedPS) == 0x000468, "Member 'ATedProjectile_ClusterMine::CachedPS' has a wrong offset!");

// Class Tempest.TedProjectSettings
// 0x03B8 (0x03F0 - 0x0038)
class UTedProjectSettings final : public UDeveloperSettings
{
public:
	TArray<struct FTedAudioProjectSetting>        DefaultAudioSettings;                              // 0x0038(0x0010)(Edit, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USoundBase>              DefaultHintSFX;                                    // 0x0048(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGCueTranslation>               ImpactGCueTranslations;                            // 0x0070(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FGCueTranslationOverride>       ImpactGCueTranslationsOverrides;                   // 0x0080(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	struct FTedScalingConfig                      UIScalingConfig;                                   // 0x0090(0x000C)(Edit, Config, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTedScalingConfig                      UIStatusEffectScalingConfig;                       // 0x009C(0x000C)(Edit, Config, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTedLoadingScreenSetup>         LoadingScreens;                                    // 0x00A8(0x0010)(Edit, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	bool                                          bEnableUnitOutline;                                // 0x00B8(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedScalingConfig                      ResolutionScaleConfig;                             // 0x00BC(0x000C)(Edit, Config, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTedDemoWatermarkConfig                DemoWatermarkConfig;                               // 0x00C8(0x00D0)(Edit, Config, NativeAccessSpecifierPublic)
	bool                                          bAllowSpectators;                                  // 0x0198(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_199[0x3];                                      // 0x0199(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpectatorsLimit;                                   // 0x019C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETedPingType                                  ClientPingType;                                    // 0x01A0(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x3];                                      // 0x01A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TedUDPPingPort;                                    // 0x01A4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWhitelistEnabled;                                 // 0x01A8(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UTedMapInfo>>     WhitelistedMaps;                                   // 0x01B0(0x0010)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         StartingCredits;                                   // 0x01C0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETedStartingArmySize                          StartingArmy;                                      // 0x01C4(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowLargerMapsForLowPlayerCount;                 // 0x01C5(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAchievements;                               // 0x01C6(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C7[0x1];                                      // 0x01C7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  StructureBuildAchievementNotify;                   // 0x01C8(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTedAchievementsDefinition> AchievementsDefinition;                         // 0x01E8(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PlatformInterfaceClass;                            // 0x0210(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnlockAchievementsFromSavedCampaignProgress;      // 0x0238(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETedFaction, TSoftObjectPtr<class UDataTable>> RankedMedals;                                // 0x0240(0x0050)(Edit, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class FString>                         SkirmishBotNames;                                  // 0x0290(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              ChatEmoteTable;                                    // 0x02A0(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UTedUserWidget>             ChatBadge;                                         // 0x02C8(0x0008)(Edit, ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   LoadingPlayerProfilePopup;                         // 0x02D0(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DefaultPlayerProfileWidget;                        // 0x02F8(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PreorderPlayerProfileWidget;                       // 0x0320(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              DefaultAvatarTexture;                              // 0x0348(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlobalAttackGraceRange;                            // 0x0370(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_374[0x4];                                      // 0x0374(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TSoftObjectPtr<class UTedMapInfo>, struct FTriggerIgnores> TriggerIgnores;                  // 0x0378(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   GenericPopup;                                      // 0x03C8(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedProjectSettings">();
	}
	static class UTedProjectSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedProjectSettings>();
	}
};
static_assert(alignof(UTedProjectSettings) == 0x000008, "Wrong alignment on UTedProjectSettings");
static_assert(sizeof(UTedProjectSettings) == 0x0003F0, "Wrong size on UTedProjectSettings");
static_assert(offsetof(UTedProjectSettings, DefaultAudioSettings) == 0x000038, "Member 'UTedProjectSettings::DefaultAudioSettings' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, DefaultHintSFX) == 0x000048, "Member 'UTedProjectSettings::DefaultHintSFX' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, ImpactGCueTranslations) == 0x000070, "Member 'UTedProjectSettings::ImpactGCueTranslations' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, ImpactGCueTranslationsOverrides) == 0x000080, "Member 'UTedProjectSettings::ImpactGCueTranslationsOverrides' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, UIScalingConfig) == 0x000090, "Member 'UTedProjectSettings::UIScalingConfig' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, UIStatusEffectScalingConfig) == 0x00009C, "Member 'UTedProjectSettings::UIStatusEffectScalingConfig' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, LoadingScreens) == 0x0000A8, "Member 'UTedProjectSettings::LoadingScreens' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, bEnableUnitOutline) == 0x0000B8, "Member 'UTedProjectSettings::bEnableUnitOutline' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, ResolutionScaleConfig) == 0x0000BC, "Member 'UTedProjectSettings::ResolutionScaleConfig' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, DemoWatermarkConfig) == 0x0000C8, "Member 'UTedProjectSettings::DemoWatermarkConfig' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, bAllowSpectators) == 0x000198, "Member 'UTedProjectSettings::bAllowSpectators' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, SpectatorsLimit) == 0x00019C, "Member 'UTedProjectSettings::SpectatorsLimit' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, ClientPingType) == 0x0001A0, "Member 'UTedProjectSettings::ClientPingType' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, TedUDPPingPort) == 0x0001A4, "Member 'UTedProjectSettings::TedUDPPingPort' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, bWhitelistEnabled) == 0x0001A8, "Member 'UTedProjectSettings::bWhitelistEnabled' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, WhitelistedMaps) == 0x0001B0, "Member 'UTedProjectSettings::WhitelistedMaps' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, StartingCredits) == 0x0001C0, "Member 'UTedProjectSettings::StartingCredits' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, StartingArmy) == 0x0001C4, "Member 'UTedProjectSettings::StartingArmy' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, bAllowLargerMapsForLowPlayerCount) == 0x0001C5, "Member 'UTedProjectSettings::bAllowLargerMapsForLowPlayerCount' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, bEnableAchievements) == 0x0001C6, "Member 'UTedProjectSettings::bEnableAchievements' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, StructureBuildAchievementNotify) == 0x0001C8, "Member 'UTedProjectSettings::StructureBuildAchievementNotify' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, AchievementsDefinition) == 0x0001E8, "Member 'UTedProjectSettings::AchievementsDefinition' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, PlatformInterfaceClass) == 0x000210, "Member 'UTedProjectSettings::PlatformInterfaceClass' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, bUnlockAchievementsFromSavedCampaignProgress) == 0x000238, "Member 'UTedProjectSettings::bUnlockAchievementsFromSavedCampaignProgress' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, RankedMedals) == 0x000240, "Member 'UTedProjectSettings::RankedMedals' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, SkirmishBotNames) == 0x000290, "Member 'UTedProjectSettings::SkirmishBotNames' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, ChatEmoteTable) == 0x0002A0, "Member 'UTedProjectSettings::ChatEmoteTable' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, ChatBadge) == 0x0002C8, "Member 'UTedProjectSettings::ChatBadge' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, LoadingPlayerProfilePopup) == 0x0002D0, "Member 'UTedProjectSettings::LoadingPlayerProfilePopup' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, DefaultPlayerProfileWidget) == 0x0002F8, "Member 'UTedProjectSettings::DefaultPlayerProfileWidget' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, PreorderPlayerProfileWidget) == 0x000320, "Member 'UTedProjectSettings::PreorderPlayerProfileWidget' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, DefaultAvatarTexture) == 0x000348, "Member 'UTedProjectSettings::DefaultAvatarTexture' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, GlobalAttackGraceRange) == 0x000370, "Member 'UTedProjectSettings::GlobalAttackGraceRange' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, TriggerIgnores) == 0x000378, "Member 'UTedProjectSettings::TriggerIgnores' has a wrong offset!");
static_assert(offsetof(UTedProjectSettings, GenericPopup) == 0x0003C8, "Member 'UTedProjectSettings::GenericPopup' has a wrong offset!");

// Class Tempest.TedQrCodeWidget
// 0x0018 (0x0418 - 0x0400)
class UTedQrCodeWidget final : public UTedUserWidget
{
public:
	class UImage*                                 Image_QrCode;                                      // 0x0400(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_408[0x10];                                     // 0x0408(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnQrCodeReceived(const struct FProsQrCodeState& QrCodeState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedQrCodeWidget">();
	}
	static class UTedQrCodeWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedQrCodeWidget>();
	}
};
static_assert(alignof(UTedQrCodeWidget) == 0x000008, "Wrong alignment on UTedQrCodeWidget");
static_assert(sizeof(UTedQrCodeWidget) == 0x000418, "Wrong size on UTedQrCodeWidget");
static_assert(offsetof(UTedQrCodeWidget, Image_QrCode) == 0x000400, "Member 'UTedQrCodeWidget::Image_QrCode' has a wrong offset!");

// Class Tempest.TedQueueOverlay
// 0x0028 (0x0428 - 0x0400)
class UTedQueueOverlay final : public UTedUserWidget
{
public:
	class UTextBlock*                             TextBlock_GameQueueType;                           // 0x0400(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock_ElapsedTime_Stopwatch;                   // 0x0408(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                Button_Cancel;                                     // 0x0410(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedOnlineSessionsControllerWidget*     OnlineSessionsController;                          // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_420[0x8];                                      // 0x0420(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Hide();
	void LeaveQueue();
	void Reveal(const ETedServerType ServerType);
	void SetOnlineSessionsController(class UTedOnlineSessionsControllerWidget* SessionsController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedQueueOverlay">();
	}
	static class UTedQueueOverlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedQueueOverlay>();
	}
};
static_assert(alignof(UTedQueueOverlay) == 0x000008, "Wrong alignment on UTedQueueOverlay");
static_assert(sizeof(UTedQueueOverlay) == 0x000428, "Wrong size on UTedQueueOverlay");
static_assert(offsetof(UTedQueueOverlay, TextBlock_GameQueueType) == 0x000400, "Member 'UTedQueueOverlay::TextBlock_GameQueueType' has a wrong offset!");
static_assert(offsetof(UTedQueueOverlay, TextBlock_ElapsedTime_Stopwatch) == 0x000408, "Member 'UTedQueueOverlay::TextBlock_ElapsedTime_Stopwatch' has a wrong offset!");
static_assert(offsetof(UTedQueueOverlay, Button_Cancel) == 0x000410, "Member 'UTedQueueOverlay::Button_Cancel' has a wrong offset!");
static_assert(offsetof(UTedQueueOverlay, OnlineSessionsController) == 0x000418, "Member 'UTedQueueOverlay::OnlineSessionsController' has a wrong offset!");

// Class Tempest.TedRangeDecalComponent
// 0x0040 (0x02F0 - 0x02B0)
class UTedRangeDecalComponent final : public UDecalComponent
{
public:
	TMulticastInlineDelegate<void()>              OnRangeDisplayedDelegate;                          // 0x02A8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnShouldDisplayPreviewChanged;                     // 0x02B8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnShouldDisplayPerkChanged;                        // 0x02C8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         AbilityIndex;                                      // 0x02D8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DC[0x14];                                     // 0x02DC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisplayRange();
	void SetIsCommandSelected(bool bInIsCommandSelected);
	void SetRadius(float Radius);
	void SetShouldDisplayPerkRange(bool bInIsPerkPreviewed);
	void SetShouldDisplayPreviewRange(bool bInShouldDisplayUpgradeRange);
	void StopDisplayRange();
	float TryFindMaxAbilityRange(const class UTedEntityDefinitionAsset* EntityDefinition);
	float TryFindPostUpdateRange(const class UTedStructureDefinitionAsset* SructureDef);

	bool GetIsCommandSelected() const;
	bool GetShouldDisplayPerkRange() const;
	bool GetShouldDisplayPreviewRange() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedRangeDecalComponent">();
	}
	static class UTedRangeDecalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedRangeDecalComponent>();
	}
};
static_assert(alignof(UTedRangeDecalComponent) == 0x000010, "Wrong alignment on UTedRangeDecalComponent");
static_assert(sizeof(UTedRangeDecalComponent) == 0x0002F0, "Wrong size on UTedRangeDecalComponent");
static_assert(offsetof(UTedRangeDecalComponent, OnRangeDisplayedDelegate) == 0x0002A8, "Member 'UTedRangeDecalComponent::OnRangeDisplayedDelegate' has a wrong offset!");
static_assert(offsetof(UTedRangeDecalComponent, OnShouldDisplayPreviewChanged) == 0x0002B8, "Member 'UTedRangeDecalComponent::OnShouldDisplayPreviewChanged' has a wrong offset!");
static_assert(offsetof(UTedRangeDecalComponent, OnShouldDisplayPerkChanged) == 0x0002C8, "Member 'UTedRangeDecalComponent::OnShouldDisplayPerkChanged' has a wrong offset!");
static_assert(offsetof(UTedRangeDecalComponent, AbilityIndex) == 0x0002D8, "Member 'UTedRangeDecalComponent::AbilityIndex' has a wrong offset!");

// Class Tempest.TedRankingProgressionWidget
// 0x0020 (0x0420 - 0x0400)
class UTedRankingProgressionWidget final : public UTedUserWidget
{
public:
	class UTextBlock*                             CurrentRating;                                     // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedContentPanelInstanced*              RankedTeamPanel;                                   // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedContentPanelInstanced*              RankedFactionTierPanel;                            // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CachedCurrentRating;                               // 0x0418(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedRankedTeam                                SelectedRankedTeam;                                // 0x041C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedRankedFaction                             SelectedRankedFaction;                             // 0x041D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41E[0x2];                                      // 0x041E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DescribeCurrentSelection(const class FText& SelectionText);
	void DescribeTierProgress(const int32 InCurrentRating, const struct FTedMedalTableRow_Ranked& InCurrentMedalTierRow, const struct FTedMedalTableRow_Ranked& InNextMedalTierRow);
	void OnRankedFactionTierPanelSlotAction(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction);
	void OnRankedFactionTierPanelSlotActivatedState(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotState InState, bool bInActivated);
	void OnRankedTeamPanelSlotAction(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction);
	void OnRankedTeamPanelSlotActivatedState(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotState InState, bool bInActivated);

	class UTedOnlinePlayerProfileWidget* GetPlayerProfile() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedRankingProgressionWidget">();
	}
	static class UTedRankingProgressionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedRankingProgressionWidget>();
	}
};
static_assert(alignof(UTedRankingProgressionWidget) == 0x000008, "Wrong alignment on UTedRankingProgressionWidget");
static_assert(sizeof(UTedRankingProgressionWidget) == 0x000420, "Wrong size on UTedRankingProgressionWidget");
static_assert(offsetof(UTedRankingProgressionWidget, CurrentRating) == 0x000400, "Member 'UTedRankingProgressionWidget::CurrentRating' has a wrong offset!");
static_assert(offsetof(UTedRankingProgressionWidget, RankedTeamPanel) == 0x000408, "Member 'UTedRankingProgressionWidget::RankedTeamPanel' has a wrong offset!");
static_assert(offsetof(UTedRankingProgressionWidget, RankedFactionTierPanel) == 0x000410, "Member 'UTedRankingProgressionWidget::RankedFactionTierPanel' has a wrong offset!");
static_assert(offsetof(UTedRankingProgressionWidget, CachedCurrentRating) == 0x000418, "Member 'UTedRankingProgressionWidget::CachedCurrentRating' has a wrong offset!");
static_assert(offsetof(UTedRankingProgressionWidget, SelectedRankedTeam) == 0x00041C, "Member 'UTedRankingProgressionWidget::SelectedRankedTeam' has a wrong offset!");
static_assert(offsetof(UTedRankingProgressionWidget, SelectedRankedFaction) == 0x00041D, "Member 'UTedRankingProgressionWidget::SelectedRankedFaction' has a wrong offset!");

// Class Tempest.TedRepCurveFunctions
// 0x0000 (0x0028 - 0x0028)
class UTedRepCurveFunctions final : public UBlueprintFunctionLibrary
{
public:
	static void CurrentTime(struct FTedServerTime* OutTime);
	static void CustomTime(float InTime, struct FTedServerTime* OutTime);
	static bool GetValueAtTime_Bool(const struct FRepCurve_Bool& InCurve, const struct FTedServerTime& InTime, const bool InValueIfEmpty);
	static float GetValueAtTime_Float(const struct FRepCurve_Float& InCurve, const struct FTedServerTime& InTime, const float InValueIfEmpty);
	static void GetValueAtTimeAdvanced_Bool(const struct FRepCurve_Bool& InCurve, const struct FTedServerTime& InTime, const bool InValueIfEmpty, bool* OutFromValue, bool* OutToValue, bool* OutCurrentValue, float* OutProgress);
	static void GetValueAtTimeAdvanced_Float(const struct FRepCurve_Float& InCurve, const struct FTedServerTime& InTime, const float InValueIfEmpty, float* OutFromValue, float* OutToValue, float* OutCurrentValue, float* OutProgress);
	static bool IsEmpty_Bool(const struct FRepCurve_Bool& InCurve);
	static bool IsEmpty_Float(const struct FRepCurve_Float& InCurve);
	static void SetValue_Bool(struct FRepCurve_Bool& InCurve, const struct FTedServerTime& InTime, const bool InValue);
	static void SetValue_Float(struct FRepCurve_Float& InCurve, const struct FTedServerTime& InTime, const float InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedRepCurveFunctions">();
	}
	static class UTedRepCurveFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedRepCurveFunctions>();
	}
};
static_assert(alignof(UTedRepCurveFunctions) == 0x000008, "Wrong alignment on UTedRepCurveFunctions");
static_assert(sizeof(UTedRepCurveFunctions) == 0x000028, "Wrong size on UTedRepCurveFunctions");

// Class Tempest.TedReplicationGraphNode_AlwaysRelevant_ForConnection
// 0x0240 (0x0290 - 0x0050)
class UTedReplicationGraphNode_AlwaysRelevant_ForConnection final : public UReplicationGraphNode
{
public:
	uint8                                         Pad_50[0x220];                                     // 0x0050(0x0220)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 LastPawn;                                          // 0x0270(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FTedAlwaysRelevantActorInfo>    PastRelevantActors;                                // 0x0278(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedReplicationGraphNode_AlwaysRelevant_ForConnection">();
	}
	static class UTedReplicationGraphNode_AlwaysRelevant_ForConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedReplicationGraphNode_AlwaysRelevant_ForConnection>();
	}
};
static_assert(alignof(UTedReplicationGraphNode_AlwaysRelevant_ForConnection) == 0x000008, "Wrong alignment on UTedReplicationGraphNode_AlwaysRelevant_ForConnection");
static_assert(sizeof(UTedReplicationGraphNode_AlwaysRelevant_ForConnection) == 0x000290, "Wrong size on UTedReplicationGraphNode_AlwaysRelevant_ForConnection");
static_assert(offsetof(UTedReplicationGraphNode_AlwaysRelevant_ForConnection, LastPawn) == 0x000270, "Member 'UTedReplicationGraphNode_AlwaysRelevant_ForConnection::LastPawn' has a wrong offset!");
static_assert(offsetof(UTedReplicationGraphNode_AlwaysRelevant_ForConnection, PastRelevantActors) == 0x000278, "Member 'UTedReplicationGraphNode_AlwaysRelevant_ForConnection::PastRelevantActors' has a wrong offset!");

// Class Tempest.TedReplicationGraphNode_PlayerStateFrequencyLimiter
// 0x0028 (0x0078 - 0x0050)
class UTedReplicationGraphNode_PlayerStateFrequencyLimiter final : public UReplicationGraphNode
{
public:
	uint8                                         Pad_50[0x28];                                      // 0x0050(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedReplicationGraphNode_PlayerStateFrequencyLimiter">();
	}
	static class UTedReplicationGraphNode_PlayerStateFrequencyLimiter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedReplicationGraphNode_PlayerStateFrequencyLimiter>();
	}
};
static_assert(alignof(UTedReplicationGraphNode_PlayerStateFrequencyLimiter) == 0x000008, "Wrong alignment on UTedReplicationGraphNode_PlayerStateFrequencyLimiter");
static_assert(sizeof(UTedReplicationGraphNode_PlayerStateFrequencyLimiter) == 0x000078, "Wrong size on UTedReplicationGraphNode_PlayerStateFrequencyLimiter");

// Class Tempest.TedReplicationGraphConnection
// 0x0018 (0x0390 - 0x0378)
class UTedReplicationGraphConnection final : public UNetReplicationGraphConnection
{
public:
	class UTedNewReplicationGraphNode_PlayerState_ForConnection* PlayerStateRelevancyConnectionNode; // 0x0378(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReplicationGraphNode_AlwaysRelevant_ForConnection* AlwaysRelevantConnectionNode;          // 0x0380(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTedReplicationGraphNode_FogOfWar*      FogOfWarConnectionNode;                            // 0x0388(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedReplicationGraphConnection">();
	}
	static class UTedReplicationGraphConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedReplicationGraphConnection>();
	}
};
static_assert(alignof(UTedReplicationGraphConnection) == 0x000008, "Wrong alignment on UTedReplicationGraphConnection");
static_assert(sizeof(UTedReplicationGraphConnection) == 0x000390, "Wrong size on UTedReplicationGraphConnection");
static_assert(offsetof(UTedReplicationGraphConnection, PlayerStateRelevancyConnectionNode) == 0x000378, "Member 'UTedReplicationGraphConnection::PlayerStateRelevancyConnectionNode' has a wrong offset!");
static_assert(offsetof(UTedReplicationGraphConnection, AlwaysRelevantConnectionNode) == 0x000380, "Member 'UTedReplicationGraphConnection::AlwaysRelevantConnectionNode' has a wrong offset!");
static_assert(offsetof(UTedReplicationGraphConnection, FogOfWarConnectionNode) == 0x000388, "Member 'UTedReplicationGraphConnection::FogOfWarConnectionNode' has a wrong offset!");

// Class Tempest.TedNewReplicationGraphNode_PlayerStateFrequencyLimiter
// 0x0028 (0x0078 - 0x0050)
class UTedNewReplicationGraphNode_PlayerStateFrequencyLimiter final : public UReplicationGraphNode
{
public:
	uint8                                         Pad_50[0x28];                                      // 0x0050(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedNewReplicationGraphNode_PlayerStateFrequencyLimiter">();
	}
	static class UTedNewReplicationGraphNode_PlayerStateFrequencyLimiter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedNewReplicationGraphNode_PlayerStateFrequencyLimiter>();
	}
};
static_assert(alignof(UTedNewReplicationGraphNode_PlayerStateFrequencyLimiter) == 0x000008, "Wrong alignment on UTedNewReplicationGraphNode_PlayerStateFrequencyLimiter");
static_assert(sizeof(UTedNewReplicationGraphNode_PlayerStateFrequencyLimiter) == 0x000078, "Wrong size on UTedNewReplicationGraphNode_PlayerStateFrequencyLimiter");

// Class Tempest.TedNewReplicationGraphNode_PlayerState_ForConnection
// 0x0268 (0x03A8 - 0x0140)
class UTedNewReplicationGraphNode_PlayerState_ForConnection final : public UReplicationGraphNode_AlwaysRelevant_ForConnection
{
public:
	uint8                                         Pad_140[0x268];                                    // 0x0140(0x0268)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedNewReplicationGraphNode_PlayerState_ForConnection">();
	}
	static class UTedNewReplicationGraphNode_PlayerState_ForConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedNewReplicationGraphNode_PlayerState_ForConnection>();
	}
};
static_assert(alignof(UTedNewReplicationGraphNode_PlayerState_ForConnection) == 0x000008, "Wrong alignment on UTedNewReplicationGraphNode_PlayerState_ForConnection");
static_assert(sizeof(UTedNewReplicationGraphNode_PlayerState_ForConnection) == 0x0003A8, "Wrong size on UTedNewReplicationGraphNode_PlayerState_ForConnection");

// Class Tempest.TedReplicationGraphPreloader
// 0x0078 (0x00A8 - 0x0030)
class UTedReplicationGraphPreloader final : public UGameInstanceSubsystem
{
public:
	TArray<class UObject*>                        GlobalGameObjectMap;                               // 0x0030(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FTedSpawnSettingsCache                 TedSpawnSettingsCache;                             // 0x0040(0x0030)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UObject*>                        LevelBoundGameObjectMap;                           // 0x0070(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<TSoftClassPtr<class UClass>>           ClassQueue;                                        // 0x0080(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bWorldIsTearingDown;                               // 0x0090(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInitialized;                                      // 0x0091(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_92[0x16];                                      // 0x0092(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedReplicationGraphPreloader">();
	}
	static class UTedReplicationGraphPreloader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedReplicationGraphPreloader>();
	}
};
static_assert(alignof(UTedReplicationGraphPreloader) == 0x000008, "Wrong alignment on UTedReplicationGraphPreloader");
static_assert(sizeof(UTedReplicationGraphPreloader) == 0x0000A8, "Wrong size on UTedReplicationGraphPreloader");
static_assert(offsetof(UTedReplicationGraphPreloader, GlobalGameObjectMap) == 0x000030, "Member 'UTedReplicationGraphPreloader::GlobalGameObjectMap' has a wrong offset!");
static_assert(offsetof(UTedReplicationGraphPreloader, TedSpawnSettingsCache) == 0x000040, "Member 'UTedReplicationGraphPreloader::TedSpawnSettingsCache' has a wrong offset!");
static_assert(offsetof(UTedReplicationGraphPreloader, LevelBoundGameObjectMap) == 0x000070, "Member 'UTedReplicationGraphPreloader::LevelBoundGameObjectMap' has a wrong offset!");
static_assert(offsetof(UTedReplicationGraphPreloader, ClassQueue) == 0x000080, "Member 'UTedReplicationGraphPreloader::ClassQueue' has a wrong offset!");
static_assert(offsetof(UTedReplicationGraphPreloader, bWorldIsTearingDown) == 0x000090, "Member 'UTedReplicationGraphPreloader::bWorldIsTearingDown' has a wrong offset!");
static_assert(offsetof(UTedReplicationGraphPreloader, bInitialized) == 0x000091, "Member 'UTedReplicationGraphPreloader::bInitialized' has a wrong offset!");

// Class Tempest.TedResizableBoxControl
// 0x0130 (0x0530 - 0x0400)
class UTedResizableBoxControl final : public UTedUserWidget
{
public:
	uint8                                         Pad_400[0x60];                                     // 0x0400(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            ControlBrush;                                      // 0x0460(0x00D0)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedResizableBoxControl">();
	}
	static class UTedResizableBoxControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedResizableBoxControl>();
	}
};
static_assert(alignof(UTedResizableBoxControl) == 0x000010, "Wrong alignment on UTedResizableBoxControl");
static_assert(sizeof(UTedResizableBoxControl) == 0x000530, "Wrong size on UTedResizableBoxControl");
static_assert(offsetof(UTedResizableBoxControl, ControlBrush) == 0x000460, "Member 'UTedResizableBoxControl::ControlBrush' has a wrong offset!");

// Class Tempest.TedRipenFieldConfig
// 0x0058 (0x0088 - 0x0030)
class UTedRipenFieldConfig final : public UDataAsset
{
public:
	struct FRipenFieldConfig                      RipenFieldConfig;                                  // 0x0030(0x0058)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedRipenFieldConfig">();
	}
	static class UTedRipenFieldConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedRipenFieldConfig>();
	}
};
static_assert(alignof(UTedRipenFieldConfig) == 0x000008, "Wrong alignment on UTedRipenFieldConfig");
static_assert(sizeof(UTedRipenFieldConfig) == 0x000088, "Wrong size on UTedRipenFieldConfig");
static_assert(offsetof(UTedRipenFieldConfig, RipenFieldConfig) == 0x000030, "Member 'UTedRipenFieldConfig::RipenFieldConfig' has a wrong offset!");

// Class Tempest.TedSavedGameProfileInfo
// 0x0028 (0x0080 - 0x0058)
class UTedSavedGameProfileInfo final : public USavedGameProfileInfo
{
public:
	int32                                         Version;                                           // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedCampaignProgressContainerData      LatestProgressSnapshot;                            // 0x0060(0x0020)(SaveGame, Protected, NativeAccessSpecifierProtected)

public:
	static void ContinueCampaignFromCurrentProfile(const class UObject* WorldContextObject);
	static class UTedSavedGameProfileInfo* GetCurrentProfile(const class UObject* WorldContextObject);

	ETedGameDifficulty GetCampaignDifficulty() const;
	ETedFaction GetCampaignFaction() const;
	int32 GetCampaignProgressInPercentage() const;
	const class UTedCampaignInfo* GetCurrentCampaign() const;
	const class UTedMapInfo* GetCurrentMap() const;
	int32 GetCurrentMapIndex(bool bZeroBased) const;
	const class UTedMapInfo* GetLastUnlockedPlayableMap() const;
	int32 GetMapIndex(const class UTedMapInfo* InMapInfo, bool bZeroBased) const;
	const class UTedMapInfo* GetNextMap() const;
	int32 GetNextMapIndex(bool bZeroBased) const;
	const class UTedMapInfo* GetPreviousMap() const;
	bool HasAnyProgress() const;
	bool IsCompatible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSavedGameProfileInfo">();
	}
	static class UTedSavedGameProfileInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSavedGameProfileInfo>();
	}
};
static_assert(alignof(UTedSavedGameProfileInfo) == 0x000008, "Wrong alignment on UTedSavedGameProfileInfo");
static_assert(sizeof(UTedSavedGameProfileInfo) == 0x000080, "Wrong size on UTedSavedGameProfileInfo");
static_assert(offsetof(UTedSavedGameProfileInfo, Version) == 0x000058, "Member 'UTedSavedGameProfileInfo::Version' has a wrong offset!");
static_assert(offsetof(UTedSavedGameProfileInfo, LatestProgressSnapshot) == 0x000060, "Member 'UTedSavedGameProfileInfo::LatestProgressSnapshot' has a wrong offset!");

// Class Tempest.TedSavedGameSlotInfo
// 0x0098 (0x0180 - 0x00E8)
class UTedSavedGameSlotInfo final : public USavedGameSlotInfo
{
public:
	class FName                                   MapInfoName;                                       // 0x00E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class UTedObjectiveObj*>                 CurrentObjectivesCompleted;                        // 0x00F0(0x0050)(BlueprintVisible, BlueprintReadOnly, SaveGame, NativeAccessSpecifierPublic)
	struct FTedCampaignTimestamp                  SaveTimestamp;                                     // 0x0140(0x0010)(BlueprintVisible, BlueprintReadOnly, SaveGame, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsCommandCompoundSave;                            // 0x0150(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETedSavedSlotGamemodeType                     SavedSlotGamemodeType;                             // 0x0151(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_152[0x2];                                      // 0x0152(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VersionRelease;                                    // 0x0154(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VersionPatch;                                      // 0x0158(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedCampaignProgressContainerData      SavedGameProgress;                                 // 0x0160(0x0020)(SaveGame, Deprecated, Protected, NativeAccessSpecifierProtected)

public:
	class FText GetSaveDisplayName(class USavedGameSlotInfo* GameSlotInfo);

	bool IsCompatible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSavedGameSlotInfo">();
	}
	static class UTedSavedGameSlotInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSavedGameSlotInfo>();
	}
};
static_assert(alignof(UTedSavedGameSlotInfo) == 0x000008, "Wrong alignment on UTedSavedGameSlotInfo");
static_assert(sizeof(UTedSavedGameSlotInfo) == 0x000180, "Wrong size on UTedSavedGameSlotInfo");
static_assert(offsetof(UTedSavedGameSlotInfo, MapInfoName) == 0x0000E8, "Member 'UTedSavedGameSlotInfo::MapInfoName' has a wrong offset!");
static_assert(offsetof(UTedSavedGameSlotInfo, CurrentObjectivesCompleted) == 0x0000F0, "Member 'UTedSavedGameSlotInfo::CurrentObjectivesCompleted' has a wrong offset!");
static_assert(offsetof(UTedSavedGameSlotInfo, SaveTimestamp) == 0x000140, "Member 'UTedSavedGameSlotInfo::SaveTimestamp' has a wrong offset!");
static_assert(offsetof(UTedSavedGameSlotInfo, bIsCommandCompoundSave) == 0x000150, "Member 'UTedSavedGameSlotInfo::bIsCommandCompoundSave' has a wrong offset!");
static_assert(offsetof(UTedSavedGameSlotInfo, SavedSlotGamemodeType) == 0x000151, "Member 'UTedSavedGameSlotInfo::SavedSlotGamemodeType' has a wrong offset!");
static_assert(offsetof(UTedSavedGameSlotInfo, VersionRelease) == 0x000154, "Member 'UTedSavedGameSlotInfo::VersionRelease' has a wrong offset!");
static_assert(offsetof(UTedSavedGameSlotInfo, VersionPatch) == 0x000158, "Member 'UTedSavedGameSlotInfo::VersionPatch' has a wrong offset!");
static_assert(offsetof(UTedSavedGameSlotInfo, SavedGameProgress) == 0x000160, "Member 'UTedSavedGameSlotInfo::SavedGameProgress' has a wrong offset!");

// Class Tempest.TedSavedGameSubsystem
// 0x0018 (0x0290 - 0x0278)
class UTedSavedGameSubsystem final : public USavedGameSubsystem
{
public:
	TMulticastInlineDelegate<void(class UTedSavedGameProfileInfo* NewProfile)> OnNewProfileCreated;  // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USavedGameSlotInfo*                     LastUsedManualSave;                                // 0x0288(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void K2_CreateNewProfile(const class FString& ProfileName, bool bSetAsCurrent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSavedGameSubsystem">();
	}
	static class UTedSavedGameSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSavedGameSubsystem>();
	}
};
static_assert(alignof(UTedSavedGameSubsystem) == 0x000008, "Wrong alignment on UTedSavedGameSubsystem");
static_assert(sizeof(UTedSavedGameSubsystem) == 0x000290, "Wrong size on UTedSavedGameSubsystem");
static_assert(offsetof(UTedSavedGameSubsystem, OnNewProfileCreated) == 0x000278, "Member 'UTedSavedGameSubsystem::OnNewProfileCreated' has a wrong offset!");
static_assert(offsetof(UTedSavedGameSubsystem, LastUsedManualSave) == 0x000288, "Member 'UTedSavedGameSubsystem::LastUsedManualSave' has a wrong offset!");

// Class Tempest.TedSaveLoadContentPanel
// 0x0058 (0x0808 - 0x07B0)
class UTedSaveLoadContentPanel : public UTedContentPanelDynamic
{
public:
	TMulticastInlineDelegate<void(class USavedGameSlotInfo* SlotInfoToDelete)> OnDeleteSaveSlotRequested; // 0x07B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USavedGameSlotInfo*                     DeleteSaveSlotInfo;                                // 0x07C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTedFactionCampaignWidget*              CachedFactionWidget;                               // 0x07C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D0[0x10];                                     // 0x07D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShowBriefingShortcuts;                            // 0x07E0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7E1[0x7];                                      // 0x07E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedSavedGameSubsystem*                 CachedSaveSubsystem;                               // 0x07E8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETedSavedSlotGamemodeType                     GamemodeToShowSlotsFor;                            // 0x07F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7F1[0x17];                                     // 0x07F1(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttemptDeleteSaveSlot(class USavedGameSlotInfo* SaveSlotInfo);
	void GenerateNewSaveName(class FString* NewSaveName);
	void SetGamemodeToShowSlotsFor(const ETedSavedSlotGamemodeType InType, bool bRefresh);

	int32 GetBriefingDisplayNumberForSlot(const int32 SlotIndex) const;
	const class UTedSavedGameSlotInfo* GetContent(const int32 InSlotIndex) const;
	const class USavedGameSlotInfo* GetContentByState(const ETedContentSlotState InState, const int32 InIndex) const;
	const class UTedMapInfo* GetMapInfoBySlotIndex(const int32 SlotIndex) const;
	const class USavedGameSlotInfo* GetSelectedContent() const;
	const ETedSavedSlotGamemodeType GetSelectedGamemodeType() const;
	const class UTedMapInfo* GetSelectedMapInfo() const;
	bool HasAnySaveSlots() const;
	const bool HasSaveFileWithName(const class FName& SlotName) const;
	bool SlotIsBriefingCheckpoint(const int32 SlotIndex) const;
	bool SlotIsSaveGame(const int32 SlotIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSaveLoadContentPanel">();
	}
	static class UTedSaveLoadContentPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSaveLoadContentPanel>();
	}
};
static_assert(alignof(UTedSaveLoadContentPanel) == 0x000008, "Wrong alignment on UTedSaveLoadContentPanel");
static_assert(sizeof(UTedSaveLoadContentPanel) == 0x000808, "Wrong size on UTedSaveLoadContentPanel");
static_assert(offsetof(UTedSaveLoadContentPanel, OnDeleteSaveSlotRequested) == 0x0007B0, "Member 'UTedSaveLoadContentPanel::OnDeleteSaveSlotRequested' has a wrong offset!");
static_assert(offsetof(UTedSaveLoadContentPanel, DeleteSaveSlotInfo) == 0x0007C0, "Member 'UTedSaveLoadContentPanel::DeleteSaveSlotInfo' has a wrong offset!");
static_assert(offsetof(UTedSaveLoadContentPanel, CachedFactionWidget) == 0x0007C8, "Member 'UTedSaveLoadContentPanel::CachedFactionWidget' has a wrong offset!");
static_assert(offsetof(UTedSaveLoadContentPanel, bShowBriefingShortcuts) == 0x0007E0, "Member 'UTedSaveLoadContentPanel::bShowBriefingShortcuts' has a wrong offset!");
static_assert(offsetof(UTedSaveLoadContentPanel, CachedSaveSubsystem) == 0x0007E8, "Member 'UTedSaveLoadContentPanel::CachedSaveSubsystem' has a wrong offset!");
static_assert(offsetof(UTedSaveLoadContentPanel, GamemodeToShowSlotsFor) == 0x0007F0, "Member 'UTedSaveLoadContentPanel::GamemodeToShowSlotsFor' has a wrong offset!");

// Class Tempest.TedScoreMenuScreenContextObject
// 0x0008 (0x0030 - 0x0028)
class UTedScoreMenuScreenContextObject final : public UObject
{
public:
	uint8                                         bVictory : 1;                                      // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTedScoreMenuScreenContextObject* New(const bool bInVictory);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedScoreMenuScreenContextObject">();
	}
	static class UTedScoreMenuScreenContextObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedScoreMenuScreenContextObject>();
	}
};
static_assert(alignof(UTedScoreMenuScreenContextObject) == 0x000008, "Wrong alignment on UTedScoreMenuScreenContextObject");
static_assert(sizeof(UTedScoreMenuScreenContextObject) == 0x000030, "Wrong size on UTedScoreMenuScreenContextObject");

// Class Tempest.TedScoreScreenGraphParticipantsPanel
// 0x0000 (0x0808 - 0x0808)
class UTedScoreScreenGraphParticipantsPanel : public UTedGenericDataContentPanel
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedScoreScreenGraphParticipantsPanel">();
	}
	static class UTedScoreScreenGraphParticipantsPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedScoreScreenGraphParticipantsPanel>();
	}
};
static_assert(alignof(UTedScoreScreenGraphParticipantsPanel) == 0x000008, "Wrong alignment on UTedScoreScreenGraphParticipantsPanel");
static_assert(sizeof(UTedScoreScreenGraphParticipantsPanel) == 0x000808, "Wrong size on UTedScoreScreenGraphParticipantsPanel");

// Class Tempest.TedScoreScreenGraphTab
// 0x0190 (0x0590 - 0x0400)
class UTedScoreScreenGraphTab : public UTedUserWidget
{
public:
	uint8                                         bSuppressCallbacks : 1;                            // 0x0400(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_401[0x17];                                     // 0x0401(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTedScoreScreenMatchParticipant> Participants;                                     // 0x0418(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTedScoreScreenGraphParticipantCharts> ParticipantsCharts;                         // 0x0428(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	class UTedGenericDataContentPanel*            ParticipantsPanel;                                 // 0x0438(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bShowOnlyOwningParticipant : 1;                    // 0x0440(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_441[0x7];                                      // 0x0441(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedDropDown*                           ChartSelector;                                     // 0x0448(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<ETedPlayerDataStat>                    CachedDisplayedStats;                              // 0x0450(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_460[0x8];                                      // 0x0460(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETedPlayerDataStat, struct FGameplayTag> RelevantCharts;                                    // 0x0468(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         bShowEndOfMatchMarker : 1;                         // 0x04B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_4B9[0x7];                                      // 0x04B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedChartMarkerMinimal                 EndOfMatchMarker;                                  // 0x04C0(0x00B8)(Edit, Protected, NativeAccessSpecifierProtected)
	class UTedChartWidgetBase*                    Chart_Background;                                  // 0x0578(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedChartWidgetBase*                    Chart_Content;                                     // 0x0580(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedChartWidgetBase*                    Chart_Foreground;                                  // 0x0588(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void K2_OnUserInfoReceived(const struct FTedUserInfo& InUserInfo, const class FString& InHydraId);
	void OnActivateParticipantPanelSlotState(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotState InState, bool bInActivated);
	void OnParticipantsPanelContentChange(class UTedContentPanelDynamic* InContentPanel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedScoreScreenGraphTab">();
	}
	static class UTedScoreScreenGraphTab* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedScoreScreenGraphTab>();
	}
};
static_assert(alignof(UTedScoreScreenGraphTab) == 0x000008, "Wrong alignment on UTedScoreScreenGraphTab");
static_assert(sizeof(UTedScoreScreenGraphTab) == 0x000590, "Wrong size on UTedScoreScreenGraphTab");
static_assert(offsetof(UTedScoreScreenGraphTab, Participants) == 0x000418, "Member 'UTedScoreScreenGraphTab::Participants' has a wrong offset!");
static_assert(offsetof(UTedScoreScreenGraphTab, ParticipantsCharts) == 0x000428, "Member 'UTedScoreScreenGraphTab::ParticipantsCharts' has a wrong offset!");
static_assert(offsetof(UTedScoreScreenGraphTab, ParticipantsPanel) == 0x000438, "Member 'UTedScoreScreenGraphTab::ParticipantsPanel' has a wrong offset!");
static_assert(offsetof(UTedScoreScreenGraphTab, ChartSelector) == 0x000448, "Member 'UTedScoreScreenGraphTab::ChartSelector' has a wrong offset!");
static_assert(offsetof(UTedScoreScreenGraphTab, CachedDisplayedStats) == 0x000450, "Member 'UTedScoreScreenGraphTab::CachedDisplayedStats' has a wrong offset!");
static_assert(offsetof(UTedScoreScreenGraphTab, RelevantCharts) == 0x000468, "Member 'UTedScoreScreenGraphTab::RelevantCharts' has a wrong offset!");
static_assert(offsetof(UTedScoreScreenGraphTab, EndOfMatchMarker) == 0x0004C0, "Member 'UTedScoreScreenGraphTab::EndOfMatchMarker' has a wrong offset!");
static_assert(offsetof(UTedScoreScreenGraphTab, Chart_Background) == 0x000578, "Member 'UTedScoreScreenGraphTab::Chart_Background' has a wrong offset!");
static_assert(offsetof(UTedScoreScreenGraphTab, Chart_Content) == 0x000580, "Member 'UTedScoreScreenGraphTab::Chart_Content' has a wrong offset!");
static_assert(offsetof(UTedScoreScreenGraphTab, Chart_Foreground) == 0x000588, "Member 'UTedScoreScreenGraphTab::Chart_Foreground' has a wrong offset!");

// Class Tempest.TedScoreScreenOnlinePlayersPanel
// 0x0060 (0x0868 - 0x0808)
class UTedScoreScreenOnlinePlayersPanel final : public UTedGenericDataContentPanel
{
public:
	int32                                         SlotOptions;                                       // 0x0808(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bToggleVictoriousPlayers;                          // 0x080C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_80D[0x3];                                      // 0x080D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETedFaction, struct FSlateBrush>         FactionIcons;                                      // 0x0810(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     AvatarMaterial;                                    // 0x0860(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	TArray<class FName> GetSlotIDs();
	bool PlayerDefeatOrVictoryFilter(const class UTedGenericDataContentPanel* InPanel, const struct FTedGenericDataContainer& InGenericDataContainer, const int32 InIndex);

	void OnPlayerDetailSlotRegistered(class UTedUI_InstancedContent* SlotContent, class UTedContentPanelInstanced* Panel, const int32 InIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedScoreScreenOnlinePlayersPanel">();
	}
	static class UTedScoreScreenOnlinePlayersPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedScoreScreenOnlinePlayersPanel>();
	}
};
static_assert(alignof(UTedScoreScreenOnlinePlayersPanel) == 0x000008, "Wrong alignment on UTedScoreScreenOnlinePlayersPanel");
static_assert(sizeof(UTedScoreScreenOnlinePlayersPanel) == 0x000868, "Wrong size on UTedScoreScreenOnlinePlayersPanel");
static_assert(offsetof(UTedScoreScreenOnlinePlayersPanel, SlotOptions) == 0x000808, "Member 'UTedScoreScreenOnlinePlayersPanel::SlotOptions' has a wrong offset!");
static_assert(offsetof(UTedScoreScreenOnlinePlayersPanel, bToggleVictoriousPlayers) == 0x00080C, "Member 'UTedScoreScreenOnlinePlayersPanel::bToggleVictoriousPlayers' has a wrong offset!");
static_assert(offsetof(UTedScoreScreenOnlinePlayersPanel, FactionIcons) == 0x000810, "Member 'UTedScoreScreenOnlinePlayersPanel::FactionIcons' has a wrong offset!");
static_assert(offsetof(UTedScoreScreenOnlinePlayersPanel, AvatarMaterial) == 0x000860, "Member 'UTedScoreScreenOnlinePlayersPanel::AvatarMaterial' has a wrong offset!");

// Class Tempest.TedScorescreenProgressbar
// 0x0008 (0x0408 - 0x0400)
class UTedScorescreenProgressbar final : public UTedUserWidget
{
public:
	float                                         MaxValue;                                          // 0x0400(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GainedValue;                                       // 0x0404(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	float RecalculateMaxValue();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedScorescreenProgressbar">();
	}
	static class UTedScorescreenProgressbar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedScorescreenProgressbar>();
	}
};
static_assert(alignof(UTedScorescreenProgressbar) == 0x000008, "Wrong alignment on UTedScorescreenProgressbar");
static_assert(sizeof(UTedScorescreenProgressbar) == 0x000408, "Wrong size on UTedScorescreenProgressbar");
static_assert(offsetof(UTedScorescreenProgressbar, MaxValue) == 0x000400, "Member 'UTedScorescreenProgressbar::MaxValue' has a wrong offset!");
static_assert(offsetof(UTedScorescreenProgressbar, GainedValue) == 0x000404, "Member 'UTedScorescreenProgressbar::GainedValue' has a wrong offset!");

// Class Tempest.TedScoreScreenRewardValueWidget
// 0x0060 (0x0460 - 0x0400)
class UTedScoreScreenRewardValueWidget : public UTedUserWidget
{
public:
	class FText                                   Title;                                             // 0x0400(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   ValueFormat;                                       // 0x0410(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   ValueFormatNoMax;                                  // 0x0420(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	int32                                         Value;                                             // 0x0430(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         max_0;                                             // 0x0434(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FScoreScreenRewardValueWidgetVisibility ConditionalVisibility;                            // 0x0438(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bUseConditionalVisibility : 1;                     // 0x0444(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_445[0x3];                                      // 0x0445(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             TitleTextBlock;                                    // 0x0448(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                TitleTextWidget;                                   // 0x0450(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                ValueTextWidget;                                   // 0x0458(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetTitle(const class FText& InTitle);
	void SetValue(const int32 InValue, const int32 InMax);

	ESlateVisibility GetConditionalVisibility() const;
	int32 GetMax() const;
	const class FText GetTitle() const;
	int32 GetValue() const;
	float GetValueAlpha() const;
	class FText GetValueText() const;
	bool HasMax() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedScoreScreenRewardValueWidget">();
	}
	static class UTedScoreScreenRewardValueWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedScoreScreenRewardValueWidget>();
	}
};
static_assert(alignof(UTedScoreScreenRewardValueWidget) == 0x000008, "Wrong alignment on UTedScoreScreenRewardValueWidget");
static_assert(sizeof(UTedScoreScreenRewardValueWidget) == 0x000460, "Wrong size on UTedScoreScreenRewardValueWidget");
static_assert(offsetof(UTedScoreScreenRewardValueWidget, Title) == 0x000400, "Member 'UTedScoreScreenRewardValueWidget::Title' has a wrong offset!");
static_assert(offsetof(UTedScoreScreenRewardValueWidget, ValueFormat) == 0x000410, "Member 'UTedScoreScreenRewardValueWidget::ValueFormat' has a wrong offset!");
static_assert(offsetof(UTedScoreScreenRewardValueWidget, ValueFormatNoMax) == 0x000420, "Member 'UTedScoreScreenRewardValueWidget::ValueFormatNoMax' has a wrong offset!");
static_assert(offsetof(UTedScoreScreenRewardValueWidget, Value) == 0x000430, "Member 'UTedScoreScreenRewardValueWidget::Value' has a wrong offset!");
static_assert(offsetof(UTedScoreScreenRewardValueWidget, max_0) == 0x000434, "Member 'UTedScoreScreenRewardValueWidget::max_0' has a wrong offset!");
static_assert(offsetof(UTedScoreScreenRewardValueWidget, ConditionalVisibility) == 0x000438, "Member 'UTedScoreScreenRewardValueWidget::ConditionalVisibility' has a wrong offset!");
static_assert(offsetof(UTedScoreScreenRewardValueWidget, TitleTextBlock) == 0x000448, "Member 'UTedScoreScreenRewardValueWidget::TitleTextBlock' has a wrong offset!");
static_assert(offsetof(UTedScoreScreenRewardValueWidget, TitleTextWidget) == 0x000450, "Member 'UTedScoreScreenRewardValueWidget::TitleTextWidget' has a wrong offset!");
static_assert(offsetof(UTedScoreScreenRewardValueWidget, ValueTextWidget) == 0x000458, "Member 'UTedScoreScreenRewardValueWidget::ValueTextWidget' has a wrong offset!");

// Class Tempest.TedScoreScreenStatsTableTab
// 0x0100 (0x0500 - 0x0400)
class UTedScoreScreenStatsTableTab : public UTedUserWidget
{
public:
	class UTedScoreScreenHeadersPanel*            SummaryHeaders;                                    // 0x0400(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedGenericDataContentPanel*            SummaryPanel;                                      // 0x0408(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTedScoreScreenMatchParticipant> Participants;                                     // 0x0410(0x0010)(Edit, ZeroConstructor, Transient, EditConst, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	uint8                                         bShowOnlyOwningParticipant : 1;                    // 0x0420(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_421[0x7];                                      // 0x0421(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedDropDown*                           ParticipantSelector;                               // 0x0428(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SelectedParticipant;                               // 0x0430(0x0004)(Edit, ZeroConstructor, Transient, EditConst, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_434[0x4];                                      // 0x0434(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETedPlayerDataStat, struct FGameplayTag> ParticipantStatToGenericValueMap;                  // 0x0438(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TMap<ETedPlayerDataStat, struct FGameplayTag> PawnStatToGenericValueMap;                         // 0x0488(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	ETedScoreScreenRelevantPawns                  RelevantPawns;                                     // 0x04D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D9[0x7];                                      // 0x04D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedScoreScreenHeadersPanel*            PawnStatHeadersPanel;                              // 0x04E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedGenericDataContentPanel*            PawnStatsPanel;                                    // 0x04E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTedGenericDataContainer>       SelectedParticipantPawnStats;                      // 0x04F0(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)

public:
	void K2_OnUserInfoReceived(const struct FTedUserInfo& InUserInfo, const class FString& InHydraId);
	void OnActivatePawnStatHeaderSlotState(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotState InState, bool bInActivated);
	void OnActivateSummaryHeaderSlotState(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotState InState, bool bInActivated);
	void OnOpenTab();
	void OnSelectedParticipantChange();
	void OnSummaryPanelContentChange(class UTedContentPanelDynamic* InContentPanel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedScoreScreenStatsTableTab">();
	}
	static class UTedScoreScreenStatsTableTab* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedScoreScreenStatsTableTab>();
	}
};
static_assert(alignof(UTedScoreScreenStatsTableTab) == 0x000008, "Wrong alignment on UTedScoreScreenStatsTableTab");
static_assert(sizeof(UTedScoreScreenStatsTableTab) == 0x000500, "Wrong size on UTedScoreScreenStatsTableTab");
static_assert(offsetof(UTedScoreScreenStatsTableTab, SummaryHeaders) == 0x000400, "Member 'UTedScoreScreenStatsTableTab::SummaryHeaders' has a wrong offset!");
static_assert(offsetof(UTedScoreScreenStatsTableTab, SummaryPanel) == 0x000408, "Member 'UTedScoreScreenStatsTableTab::SummaryPanel' has a wrong offset!");
static_assert(offsetof(UTedScoreScreenStatsTableTab, Participants) == 0x000410, "Member 'UTedScoreScreenStatsTableTab::Participants' has a wrong offset!");
static_assert(offsetof(UTedScoreScreenStatsTableTab, ParticipantSelector) == 0x000428, "Member 'UTedScoreScreenStatsTableTab::ParticipantSelector' has a wrong offset!");
static_assert(offsetof(UTedScoreScreenStatsTableTab, SelectedParticipant) == 0x000430, "Member 'UTedScoreScreenStatsTableTab::SelectedParticipant' has a wrong offset!");
static_assert(offsetof(UTedScoreScreenStatsTableTab, ParticipantStatToGenericValueMap) == 0x000438, "Member 'UTedScoreScreenStatsTableTab::ParticipantStatToGenericValueMap' has a wrong offset!");
static_assert(offsetof(UTedScoreScreenStatsTableTab, PawnStatToGenericValueMap) == 0x000488, "Member 'UTedScoreScreenStatsTableTab::PawnStatToGenericValueMap' has a wrong offset!");
static_assert(offsetof(UTedScoreScreenStatsTableTab, RelevantPawns) == 0x0004D8, "Member 'UTedScoreScreenStatsTableTab::RelevantPawns' has a wrong offset!");
static_assert(offsetof(UTedScoreScreenStatsTableTab, PawnStatHeadersPanel) == 0x0004E0, "Member 'UTedScoreScreenStatsTableTab::PawnStatHeadersPanel' has a wrong offset!");
static_assert(offsetof(UTedScoreScreenStatsTableTab, PawnStatsPanel) == 0x0004E8, "Member 'UTedScoreScreenStatsTableTab::PawnStatsPanel' has a wrong offset!");
static_assert(offsetof(UTedScoreScreenStatsTableTab, SelectedParticipantPawnStats) == 0x0004F0, "Member 'UTedScoreScreenStatsTableTab::SelectedParticipantPawnStats' has a wrong offset!");

// Class Tempest.TedScrollBox
// 0x0000 (0x0D00 - 0x0D00)
class UTedScrollBox final : public UScrollBox
{
public:
	class USlateWidgetStyleAsset*                 BarStyle;                                          // 0x0CF8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetBarStyle(const class USlateWidgetStyleAsset* InStyle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedScrollBox">();
	}
	static class UTedScrollBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedScrollBox>();
	}
};
static_assert(alignof(UTedScrollBox) == 0x000010, "Wrong alignment on UTedScrollBox");
static_assert(sizeof(UTedScrollBox) == 0x000D00, "Wrong size on UTedScrollBox");
static_assert(offsetof(UTedScrollBox, BarStyle) == 0x000CF8, "Member 'UTedScrollBox::BarStyle' has a wrong offset!");

// Class Tempest.TedSelectionDetailsGarrisonedPawnsPanel
// 0x00B0 (0x0888 - 0x07D8)
class UTedSelectionDetailsGarrisonedPawnsPanel : public UTedPawnsPanel
{
public:
	struct FMargin                                SlotPadding;                                       // 0x07D8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTedShortcutUI                         UnloadPawnShortcut;                                // 0x07E8(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTedShortcutUI                         UnloadPawnsByTypeShortcut;                         // 0x0808(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTedShortcutUI                         UnloadAllPawnsShortcut;                            // 0x0828(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTedShortcutUI                         UnloadAllPawnsButOneShortcut;                      // 0x0848(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTedShortcutUI                         UnloadAllPawnsButTypeShortcut;                     // 0x0868(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	bool DoesContentTakeOneSlot(const int32 InSlotIndex) const;
	const struct FMargin GetSlotPadding() const;
	const struct FTedShortcutUI GetUnloadAllPawnsButOneShortcut() const;
	const struct FTedShortcutUI GetUnloadAllPawnsButTypeShortcut() const;
	const struct FTedShortcutUI GetUnloadAllPawnsShortcut() const;
	const struct FTedShortcutUI GetUnloadPawnsByTypeShortcut() const;
	const struct FTedShortcutUI GetUnloadPawnShortcut() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSelectionDetailsGarrisonedPawnsPanel">();
	}
	static class UTedSelectionDetailsGarrisonedPawnsPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSelectionDetailsGarrisonedPawnsPanel>();
	}
};
static_assert(alignof(UTedSelectionDetailsGarrisonedPawnsPanel) == 0x000008, "Wrong alignment on UTedSelectionDetailsGarrisonedPawnsPanel");
static_assert(sizeof(UTedSelectionDetailsGarrisonedPawnsPanel) == 0x000888, "Wrong size on UTedSelectionDetailsGarrisonedPawnsPanel");
static_assert(offsetof(UTedSelectionDetailsGarrisonedPawnsPanel, SlotPadding) == 0x0007D8, "Member 'UTedSelectionDetailsGarrisonedPawnsPanel::SlotPadding' has a wrong offset!");
static_assert(offsetof(UTedSelectionDetailsGarrisonedPawnsPanel, UnloadPawnShortcut) == 0x0007E8, "Member 'UTedSelectionDetailsGarrisonedPawnsPanel::UnloadPawnShortcut' has a wrong offset!");
static_assert(offsetof(UTedSelectionDetailsGarrisonedPawnsPanel, UnloadPawnsByTypeShortcut) == 0x000808, "Member 'UTedSelectionDetailsGarrisonedPawnsPanel::UnloadPawnsByTypeShortcut' has a wrong offset!");
static_assert(offsetof(UTedSelectionDetailsGarrisonedPawnsPanel, UnloadAllPawnsShortcut) == 0x000828, "Member 'UTedSelectionDetailsGarrisonedPawnsPanel::UnloadAllPawnsShortcut' has a wrong offset!");
static_assert(offsetof(UTedSelectionDetailsGarrisonedPawnsPanel, UnloadAllPawnsButOneShortcut) == 0x000848, "Member 'UTedSelectionDetailsGarrisonedPawnsPanel::UnloadAllPawnsButOneShortcut' has a wrong offset!");
static_assert(offsetof(UTedSelectionDetailsGarrisonedPawnsPanel, UnloadAllPawnsButTypeShortcut) == 0x000868, "Member 'UTedSelectionDetailsGarrisonedPawnsPanel::UnloadAllPawnsButTypeShortcut' has a wrong offset!");

// Class Tempest.TedSelectionDetailsGarrisonedPawnsWidget
// 0x0030 (0x0430 - 0x0400)
class UTedSelectionDetailsGarrisonedPawnsWidget : public UTedUserWidget
{
public:
	TArray<struct FTedSelectionDetailsGarrisonedPawnsBackground> Backgrounds;                        // 0x0400(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UTedPawnCommand_UnloadGivenPawns> UnloadPawnsCommand;                          // 0x0410(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedSelectionDetailsGarrisonedPawnsPanel* PawnsPanel;                                      // 0x0418(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_Background;                                  // 0x0420(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedPawnContainerComponent*             PawnContainer;                                     // 0x0428(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPlayersPawnContentChange(class UTedContentPanelDynamic* InContentPanel);
	void OnPlayersPawnTriggerSlotAction(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction);
	void RefreshPawnsPanel();
	void SetPawnContainer(class UTedPawnContainerComponent* InContainer);
	void SetPawnContainerByPawn(class ATedPawn* InContainerOwner);
	void UnloadAllPawns();
	void UnloadAllPawnsButOne(const int32 InSlotIndex);
	void UnloadPawn(const int32 InSlotIndex);
	void UnloadPawns(const TArray<class ATedPawn*>& InPawns);
	void UnloadPawnsByType(const int32 InSlotIndex, const bool bInKeepMatching);

	class UTedPawnContainerComponent* GetPawnContainer() const;
	class ATedPawn* GetPawnContainerOwner() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSelectionDetailsGarrisonedPawnsWidget">();
	}
	static class UTedSelectionDetailsGarrisonedPawnsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSelectionDetailsGarrisonedPawnsWidget>();
	}
};
static_assert(alignof(UTedSelectionDetailsGarrisonedPawnsWidget) == 0x000008, "Wrong alignment on UTedSelectionDetailsGarrisonedPawnsWidget");
static_assert(sizeof(UTedSelectionDetailsGarrisonedPawnsWidget) == 0x000430, "Wrong size on UTedSelectionDetailsGarrisonedPawnsWidget");
static_assert(offsetof(UTedSelectionDetailsGarrisonedPawnsWidget, Backgrounds) == 0x000400, "Member 'UTedSelectionDetailsGarrisonedPawnsWidget::Backgrounds' has a wrong offset!");
static_assert(offsetof(UTedSelectionDetailsGarrisonedPawnsWidget, UnloadPawnsCommand) == 0x000410, "Member 'UTedSelectionDetailsGarrisonedPawnsWidget::UnloadPawnsCommand' has a wrong offset!");
static_assert(offsetof(UTedSelectionDetailsGarrisonedPawnsWidget, PawnsPanel) == 0x000418, "Member 'UTedSelectionDetailsGarrisonedPawnsWidget::PawnsPanel' has a wrong offset!");
static_assert(offsetof(UTedSelectionDetailsGarrisonedPawnsWidget, Image_Background) == 0x000420, "Member 'UTedSelectionDetailsGarrisonedPawnsWidget::Image_Background' has a wrong offset!");
static_assert(offsetof(UTedSelectionDetailsGarrisonedPawnsWidget, PawnContainer) == 0x000428, "Member 'UTedSelectionDetailsGarrisonedPawnsWidget::PawnContainer' has a wrong offset!");

// Class Tempest.TedSelectionDetails_InfoSlots_Slot_Perks
// 0x0000 (0x0410 - 0x0410)
class UTedSelectionDetails_InfoSlots_Slot_Perks : public UTedContentPanelSlotBase
{
public:
	void OnContextChange(class UTedContentPanelStatic* InContentPanel, class UObject* InPrevContext, class UObject* InNewContext);
	void RefreshDisabledState();

	class ATedPawn* GetContextPawn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSelectionDetails_InfoSlots_Slot_Perks">();
	}
	static class UTedSelectionDetails_InfoSlots_Slot_Perks* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSelectionDetails_InfoSlots_Slot_Perks>();
	}
};
static_assert(alignof(UTedSelectionDetails_InfoSlots_Slot_Perks) == 0x000008, "Wrong alignment on UTedSelectionDetails_InfoSlots_Slot_Perks");
static_assert(sizeof(UTedSelectionDetails_InfoSlots_Slot_Perks) == 0x000410, "Wrong size on UTedSelectionDetails_InfoSlots_Slot_Perks");

// Class Tempest.TedSelectionDetails_InfoSlots_Tooltip_Attack
// 0x0008 (0x04A8 - 0x04A0)
class UTedSelectionDetails_InfoSlots_Tooltip_Attack : public UTedTooltipWidget
{
public:
	class UTedDefinitionPanel_Weapon*             Weapons;                                           // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSelectionDetails_InfoSlots_Tooltip_Attack">();
	}
	static class UTedSelectionDetails_InfoSlots_Tooltip_Attack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSelectionDetails_InfoSlots_Tooltip_Attack>();
	}
};
static_assert(alignof(UTedSelectionDetails_InfoSlots_Tooltip_Attack) == 0x000008, "Wrong alignment on UTedSelectionDetails_InfoSlots_Tooltip_Attack");
static_assert(sizeof(UTedSelectionDetails_InfoSlots_Tooltip_Attack) == 0x0004A8, "Wrong size on UTedSelectionDetails_InfoSlots_Tooltip_Attack");
static_assert(offsetof(UTedSelectionDetails_InfoSlots_Tooltip_Attack, Weapons) == 0x0004A0, "Member 'UTedSelectionDetails_InfoSlots_Tooltip_Attack::Weapons' has a wrong offset!");

// Class Tempest.TedSelectionGroupPanel
// 0x0008 (0x07B8 - 0x07B0)
class UTedSelectionGroupPanel : public UTedContentPanelDynamic
{
public:
	uint8                                         DisplaySlots;                                      // 0x07B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7B1[0x7];                                      // 0x07B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FocusCameraOnGroup(const int32 InSlotIndex);
	void ReceiveUpdateGroupSize(const int32 InSlotIndex, const int32 InGroupIndex, const int32 InGroupSize);

	int32 GetGroupIndex(const int32 InSlotIndex) const;
	int32 GetSlotGroupSize(const int32 InSlotIndex) const;
	bool IsSlotEmpty(const int32 InSlotIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSelectionGroupPanel">();
	}
	static class UTedSelectionGroupPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSelectionGroupPanel>();
	}
};
static_assert(alignof(UTedSelectionGroupPanel) == 0x000008, "Wrong alignment on UTedSelectionGroupPanel");
static_assert(sizeof(UTedSelectionGroupPanel) == 0x0007B8, "Wrong size on UTedSelectionGroupPanel");
static_assert(offsetof(UTedSelectionGroupPanel, DisplaySlots) == 0x0007B0, "Member 'UTedSelectionGroupPanel::DisplaySlots' has a wrong offset!");

// Class Tempest.TedSelectionInterface
// 0x0000 (0x0000 - 0x0000)
class ITedSelectionInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSelectionInterface">();
	}
	static class ITedSelectionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITedSelectionInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITedSelectionInterface) == 0x000001, "Wrong alignment on ITedSelectionInterface");
static_assert(sizeof(ITedSelectionInterface) == 0x000001, "Wrong size on ITedSelectionInterface");

// Class Tempest.TedSettingsScreen_GameSettings
// 0x02C8 (0x0700 - 0x0438)
class UTedSettingsScreen_GameSettings : public UTedSettingsScreen
{
public:
	class UTedUserSettings*                       UserSettings;                                      // 0x0438(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_440[0xF8];                                     // 0x0440(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedSettingsPanel*                      Settings_Graphics;                                 // 0x0538(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedSettingsPanel*                      Settings_Audio;                                    // 0x0540(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_548[0xA0];                                     // 0x0548(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedSettingsPanel*                      Settings_General;                                  // 0x05E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTedSettingsSlot_DropDown*>      PlayerColorSlots;                                  // 0x05F0(0x0010)(ExportObject, ZeroConstructor, Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UTedSettingsSlot_DropDown*>      PlayerColorBlindSlots;                             // 0x0600(0x0010)(ExportObject, ZeroConstructor, Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UTedSettingsSlot_DropDown*>      SelectionColorSlots;                               // 0x0610(0x0010)(ExportObject, ZeroConstructor, Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UTedSettingsSlot_DropDown*>      SelectionColorBlindSlots;                          // 0x0620(0x0010)(ExportObject, ZeroConstructor, Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         bUseControlSectionsOrder : 1;                      // 0x0630(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_631[0x7];                                      // 0x0631(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FKey>                             UnBindableKeys;                                    // 0x0638(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	class UTedSettingsPanel*                      Settings_Controls;                                 // 0x0688(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedInputMappingPicker*                 Controls_InputMappingPicker;                       // 0x0690(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEnhancedInputLocalPlayerSubsystem*     Controls_EISubsystem;                              // 0x0698(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedEnhancedInputSettings*              Controls_EISettings;                               // 0x06A0(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEnhancedPlayerMappableKeyProfile*      Controls_EIProfile;                                // 0x06A8(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedSettingsPanel*                      Settings_PreOrder;                                 // 0x06B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6B8[0x30];                                     // 0x06B8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedPopup*                              Popup_Default;                                     // 0x06E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedPopup*                              Popup_Working;                                     // 0x06F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedContentPanelInstanced*              ButtonsPanel;                                      // 0x06F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnTriggerButtonSlotAction(class UTedContentPanelBase* InContentPanel, class UTedContentPanelSlotBase* InContentSlot, ETedContentSlotAction InAction);
	void ResetBindingsToDefaults();
	bool RunAutoBenchmark(float InDeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSettingsScreen_GameSettings">();
	}
	static class UTedSettingsScreen_GameSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSettingsScreen_GameSettings>();
	}
};
static_assert(alignof(UTedSettingsScreen_GameSettings) == 0x000008, "Wrong alignment on UTedSettingsScreen_GameSettings");
static_assert(sizeof(UTedSettingsScreen_GameSettings) == 0x000700, "Wrong size on UTedSettingsScreen_GameSettings");
static_assert(offsetof(UTedSettingsScreen_GameSettings, UserSettings) == 0x000438, "Member 'UTedSettingsScreen_GameSettings::UserSettings' has a wrong offset!");
static_assert(offsetof(UTedSettingsScreen_GameSettings, Settings_Graphics) == 0x000538, "Member 'UTedSettingsScreen_GameSettings::Settings_Graphics' has a wrong offset!");
static_assert(offsetof(UTedSettingsScreen_GameSettings, Settings_Audio) == 0x000540, "Member 'UTedSettingsScreen_GameSettings::Settings_Audio' has a wrong offset!");
static_assert(offsetof(UTedSettingsScreen_GameSettings, Settings_General) == 0x0005E8, "Member 'UTedSettingsScreen_GameSettings::Settings_General' has a wrong offset!");
static_assert(offsetof(UTedSettingsScreen_GameSettings, PlayerColorSlots) == 0x0005F0, "Member 'UTedSettingsScreen_GameSettings::PlayerColorSlots' has a wrong offset!");
static_assert(offsetof(UTedSettingsScreen_GameSettings, PlayerColorBlindSlots) == 0x000600, "Member 'UTedSettingsScreen_GameSettings::PlayerColorBlindSlots' has a wrong offset!");
static_assert(offsetof(UTedSettingsScreen_GameSettings, SelectionColorSlots) == 0x000610, "Member 'UTedSettingsScreen_GameSettings::SelectionColorSlots' has a wrong offset!");
static_assert(offsetof(UTedSettingsScreen_GameSettings, SelectionColorBlindSlots) == 0x000620, "Member 'UTedSettingsScreen_GameSettings::SelectionColorBlindSlots' has a wrong offset!");
static_assert(offsetof(UTedSettingsScreen_GameSettings, UnBindableKeys) == 0x000638, "Member 'UTedSettingsScreen_GameSettings::UnBindableKeys' has a wrong offset!");
static_assert(offsetof(UTedSettingsScreen_GameSettings, Settings_Controls) == 0x000688, "Member 'UTedSettingsScreen_GameSettings::Settings_Controls' has a wrong offset!");
static_assert(offsetof(UTedSettingsScreen_GameSettings, Controls_InputMappingPicker) == 0x000690, "Member 'UTedSettingsScreen_GameSettings::Controls_InputMappingPicker' has a wrong offset!");
static_assert(offsetof(UTedSettingsScreen_GameSettings, Controls_EISubsystem) == 0x000698, "Member 'UTedSettingsScreen_GameSettings::Controls_EISubsystem' has a wrong offset!");
static_assert(offsetof(UTedSettingsScreen_GameSettings, Controls_EISettings) == 0x0006A0, "Member 'UTedSettingsScreen_GameSettings::Controls_EISettings' has a wrong offset!");
static_assert(offsetof(UTedSettingsScreen_GameSettings, Controls_EIProfile) == 0x0006A8, "Member 'UTedSettingsScreen_GameSettings::Controls_EIProfile' has a wrong offset!");
static_assert(offsetof(UTedSettingsScreen_GameSettings, Settings_PreOrder) == 0x0006B0, "Member 'UTedSettingsScreen_GameSettings::Settings_PreOrder' has a wrong offset!");
static_assert(offsetof(UTedSettingsScreen_GameSettings, Popup_Default) == 0x0006E8, "Member 'UTedSettingsScreen_GameSettings::Popup_Default' has a wrong offset!");
static_assert(offsetof(UTedSettingsScreen_GameSettings, Popup_Working) == 0x0006F0, "Member 'UTedSettingsScreen_GameSettings::Popup_Working' has a wrong offset!");
static_assert(offsetof(UTedSettingsScreen_GameSettings, ButtonsPanel) == 0x0006F8, "Member 'UTedSettingsScreen_GameSettings::ButtonsPanel' has a wrong offset!");

// Class Tempest.TedSettingsSlotClasses
// 0x0010 (0x0040 - 0x0030)
class UTedSettingsSlotClasses final : public UPrimaryDataAsset
{
public:
	TArray<TSubclassOf<class UTedSettingsSlot>>   Classes;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSettingsSlotClasses">();
	}
	static class UTedSettingsSlotClasses* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSettingsSlotClasses>();
	}
};
static_assert(alignof(UTedSettingsSlotClasses) == 0x000008, "Wrong alignment on UTedSettingsSlotClasses");
static_assert(sizeof(UTedSettingsSlotClasses) == 0x000040, "Wrong size on UTedSettingsSlotClasses");
static_assert(offsetof(UTedSettingsSlotClasses, Classes) == 0x000030, "Member 'UTedSettingsSlotClasses::Classes' has a wrong offset!");

// Class Tempest.TedSettingsSlot_CheckBox
// 0x0028 (0x04B8 - 0x0490)
class UTedSettingsSlot_CheckBox : public UTedSettingsSlot
{
public:
	uint8                                         Pad_490[0x20];                                     // 0x0490(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UCheckBox*                              Value_CheckBox;                                    // 0x04B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetSourceValue(bool bInIsChecked);

	bool GetSourceValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSettingsSlot_CheckBox">();
	}
	static class UTedSettingsSlot_CheckBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSettingsSlot_CheckBox>();
	}
};
static_assert(alignof(UTedSettingsSlot_CheckBox) == 0x000008, "Wrong alignment on UTedSettingsSlot_CheckBox");
static_assert(sizeof(UTedSettingsSlot_CheckBox) == 0x0004B8, "Wrong size on UTedSettingsSlot_CheckBox");
static_assert(offsetof(UTedSettingsSlot_CheckBox, Value_CheckBox) == 0x0004B0, "Member 'UTedSettingsSlot_CheckBox::Value_CheckBox' has a wrong offset!");

// Class Tempest.TedSettingsSlot_DropDown
// 0x0090 (0x0520 - 0x0490)
class UTedSettingsSlot_DropDown : public UTedSettingsSlot
{
public:
	uint8                                         Pad_490[0x60];                                     // 0x0490(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedDropDown*                           Value_DropDown;                                    // 0x04F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Value_TextBlock;                                   // 0x04F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 Options;                                           // 0x0500(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class FText>                           Descriptions;                                      // 0x0510(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSettingsSlot_DropDown">();
	}
	static class UTedSettingsSlot_DropDown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSettingsSlot_DropDown>();
	}
};
static_assert(alignof(UTedSettingsSlot_DropDown) == 0x000008, "Wrong alignment on UTedSettingsSlot_DropDown");
static_assert(sizeof(UTedSettingsSlot_DropDown) == 0x000520, "Wrong size on UTedSettingsSlot_DropDown");
static_assert(offsetof(UTedSettingsSlot_DropDown, Value_DropDown) == 0x0004F0, "Member 'UTedSettingsSlot_DropDown::Value_DropDown' has a wrong offset!");
static_assert(offsetof(UTedSettingsSlot_DropDown, Value_TextBlock) == 0x0004F8, "Member 'UTedSettingsSlot_DropDown::Value_TextBlock' has a wrong offset!");
static_assert(offsetof(UTedSettingsSlot_DropDown, Options) == 0x000500, "Member 'UTedSettingsSlot_DropDown::Options' has a wrong offset!");
static_assert(offsetof(UTedSettingsSlot_DropDown, Descriptions) == 0x000510, "Member 'UTedSettingsSlot_DropDown::Descriptions' has a wrong offset!");

// Class Tempest.TedSettingsSlot_DropDown_PlayerColor
// 0x01C0 (0x06E0 - 0x0520)
class UTedSettingsSlot_DropDown_PlayerColor : public UTedSettingsSlot_DropDown
{
public:
	uint8                                         Pad_520[0x10];                                     // 0x0520(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            ColorPreviewBrush;                                 // 0x0530(0x00D0)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            ColorPreviewFrameBrush;                            // 0x0600(0x00D0)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<struct FRTSColorUIData>                AvailableColors;                                   // 0x06D0(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSettingsSlot_DropDown_PlayerColor">();
	}
	static class UTedSettingsSlot_DropDown_PlayerColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSettingsSlot_DropDown_PlayerColor>();
	}
};
static_assert(alignof(UTedSettingsSlot_DropDown_PlayerColor) == 0x000010, "Wrong alignment on UTedSettingsSlot_DropDown_PlayerColor");
static_assert(sizeof(UTedSettingsSlot_DropDown_PlayerColor) == 0x0006E0, "Wrong size on UTedSettingsSlot_DropDown_PlayerColor");
static_assert(offsetof(UTedSettingsSlot_DropDown_PlayerColor, ColorPreviewBrush) == 0x000530, "Member 'UTedSettingsSlot_DropDown_PlayerColor::ColorPreviewBrush' has a wrong offset!");
static_assert(offsetof(UTedSettingsSlot_DropDown_PlayerColor, ColorPreviewFrameBrush) == 0x000600, "Member 'UTedSettingsSlot_DropDown_PlayerColor::ColorPreviewFrameBrush' has a wrong offset!");
static_assert(offsetof(UTedSettingsSlot_DropDown_PlayerColor, AvailableColors) == 0x0006D0, "Member 'UTedSettingsSlot_DropDown_PlayerColor::AvailableColors' has a wrong offset!");

// Class Tempest.TedSettingsSlot_InputAxis
// 0x0088 (0x0518 - 0x0490)
class UTedSettingsSlot_InputAxis : public UTedSettingsSlot
{
public:
	class FName                                   InputName;                                         // 0x0490(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InputScale;                                        // 0x0498(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49C[0x44];                                     // 0x049C(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedInputMappingPanel*                  Value_MappingPanel;                                // 0x04E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E8[0x30];                                     // 0x04E8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearSourceValue(const struct FInputAxisKeyMapping& InValue);
	void OnTriggerMappingSlotAction(class UTedContentPanelBase* InPanel, class UTedContentPanelSlotBase* InSlot, const ETedContentSlotAction InAction);
	void SetSourceValue(const struct FInputAxisKeyMapping& InValue);

	struct FInputAxisKeyMapping GetSourceValue(const int32 InMappingIndex) const;
	bool IsPositive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSettingsSlot_InputAxis">();
	}
	static class UTedSettingsSlot_InputAxis* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSettingsSlot_InputAxis>();
	}
};
static_assert(alignof(UTedSettingsSlot_InputAxis) == 0x000008, "Wrong alignment on UTedSettingsSlot_InputAxis");
static_assert(sizeof(UTedSettingsSlot_InputAxis) == 0x000518, "Wrong size on UTedSettingsSlot_InputAxis");
static_assert(offsetof(UTedSettingsSlot_InputAxis, InputName) == 0x000490, "Member 'UTedSettingsSlot_InputAxis::InputName' has a wrong offset!");
static_assert(offsetof(UTedSettingsSlot_InputAxis, InputScale) == 0x000498, "Member 'UTedSettingsSlot_InputAxis::InputScale' has a wrong offset!");
static_assert(offsetof(UTedSettingsSlot_InputAxis, Value_MappingPanel) == 0x0004E0, "Member 'UTedSettingsSlot_InputAxis::Value_MappingPanel' has a wrong offset!");

// Class Tempest.TedSettingsSlot_Readonly
// 0x0080 (0x0510 - 0x0490)
class UTedSettingsSlot_Readonly : public UTedSettingsSlot
{
public:
	struct FTedInputDisplay                       CachedInput;                                       // 0x0490(0x0070)(NativeAccessSpecifierPublic)
	uint8                                         Pad_500[0x10];                                     // 0x0500(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBinds();

	void SetKeyBinds(const TArray<struct FKey>& Binds) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSettingsSlot_Readonly">();
	}
	static class UTedSettingsSlot_Readonly* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSettingsSlot_Readonly>();
	}
};
static_assert(alignof(UTedSettingsSlot_Readonly) == 0x000008, "Wrong alignment on UTedSettingsSlot_Readonly");
static_assert(sizeof(UTedSettingsSlot_Readonly) == 0x000510, "Wrong size on UTedSettingsSlot_Readonly");
static_assert(offsetof(UTedSettingsSlot_Readonly, CachedInput) == 0x000490, "Member 'UTedSettingsSlot_Readonly::CachedInput' has a wrong offset!");

// Class Tempest.TedSettingsSlot_Section
// 0x0018 (0x04A8 - 0x0490)
class UTedSettingsSlot_Section : public UTedSettingsSlot
{
public:
	uint8                                         bAnimatedCollapsing : 1;                           // 0x0490(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_491[0x7];                                      // 0x0491(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedSettingsPanel*                      InnerSettingsPanel;                                // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UExpandableArea*                        ExpandableArea;                                    // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnExpansionChanged(class UExpandableArea* InArea, bool bInIsExpanded);

	class UTedSettingsPanel* GetInnerSettingsPanel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSettingsSlot_Section">();
	}
	static class UTedSettingsSlot_Section* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSettingsSlot_Section>();
	}
};
static_assert(alignof(UTedSettingsSlot_Section) == 0x000008, "Wrong alignment on UTedSettingsSlot_Section");
static_assert(sizeof(UTedSettingsSlot_Section) == 0x0004A8, "Wrong size on UTedSettingsSlot_Section");
static_assert(offsetof(UTedSettingsSlot_Section, InnerSettingsPanel) == 0x000498, "Member 'UTedSettingsSlot_Section::InnerSettingsPanel' has a wrong offset!");
static_assert(offsetof(UTedSettingsSlot_Section, ExpandableArea) == 0x0004A0, "Member 'UTedSettingsSlot_Section::ExpandableArea' has a wrong offset!");

// Class Tempest.TedShortcutsPanel
// 0x0028 (0x07D8 - 0x07B0)
class UTedShortcutsPanel : public UTedContentPanelDynamic
{
public:
	TArray<struct FTedShortcutChordUI>            content;                                           // 0x07B0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTedShortcutUI>                 ContentShortcuts;                                  // 0x07C0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	ESlateVisibility                              EmptyVisibility;                                   // 0x07D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESlateVisibility                              NonEmptyVisibility;                                // 0x07D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7D2[0x6];                                      // 0x07D2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetContent(const TArray<struct FTedShortcutChordUI>& InContent, const bool bInRefreshContent);
	void SetContentShortcuts(const TArray<struct FTedShortcutUI>& InContent, const bool bInRefreshContent);

	bool GetContent(const int32 InSlotIndex, struct FTedShortcutChordUI* OutContent) const;
	ESlateVisibility GetEmptyVisibility() const;
	ESlateVisibility GetNonEmptyVisibility() const;
	bool IsEmpty() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedShortcutsPanel">();
	}
	static class UTedShortcutsPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedShortcutsPanel>();
	}
};
static_assert(alignof(UTedShortcutsPanel) == 0x000008, "Wrong alignment on UTedShortcutsPanel");
static_assert(sizeof(UTedShortcutsPanel) == 0x0007D8, "Wrong size on UTedShortcutsPanel");
static_assert(offsetof(UTedShortcutsPanel, content) == 0x0007B0, "Member 'UTedShortcutsPanel::content' has a wrong offset!");
static_assert(offsetof(UTedShortcutsPanel, ContentShortcuts) == 0x0007C0, "Member 'UTedShortcutsPanel::ContentShortcuts' has a wrong offset!");
static_assert(offsetof(UTedShortcutsPanel, EmptyVisibility) == 0x0007D0, "Member 'UTedShortcutsPanel::EmptyVisibility' has a wrong offset!");
static_assert(offsetof(UTedShortcutsPanel, NonEmptyVisibility) == 0x0007D1, "Member 'UTedShortcutsPanel::NonEmptyVisibility' has a wrong offset!");

// Class Tempest.TedShortcutsSlot
// 0x0000 (0x0410 - 0x0410)
class UTedShortcutsSlot : public UTedContentPanelSlotBase
{
public:
	bool GetContent(struct FTedShortcutChordUI* OutContent) const;
	class UTedShortcutsPanel* GetContentPanel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedShortcutsSlot">();
	}
	static class UTedShortcutsSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedShortcutsSlot>();
	}
};
static_assert(alignof(UTedShortcutsSlot) == 0x000008, "Wrong alignment on UTedShortcutsSlot");
static_assert(sizeof(UTedShortcutsSlot) == 0x000410, "Wrong size on UTedShortcutsSlot");

// Class Tempest.TedSkipUIWidget
// 0x0068 (0x0468 - 0x0400)
class UTedSkipUIWidget : public UTedUserWidget
{
public:
	struct FTedShortcutUI                         SkipUIBinding;                                     // 0x0400(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            SkippingProgressCurve;                             // 0x0420(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SkipDuration;                                      // 0x0428(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecoverDuration;                                   // 0x042C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShowingDuration;                                   // 0x0430(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_434[0x4];                                      // 0x0434(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            ShowingCurve;                                      // 0x0438(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HidingDuration;                                    // 0x0440(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_444[0x4];                                      // 0x0444(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            HidingCurve;                                       // 0x0448(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SkippingProgress;                                  // 0x0450(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShowingProgress;                                   // 0x0454(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bSkipping : 1;                                     // 0x0458(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bShowing : 1;                                      // 0x0458(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_459[0x3];                                      // 0x0459(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           SkippingSequence;                                  // 0x045C(0x0008)(Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_464[0x4];                                      // 0x0464(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FText GetSkippableSequenceText() const;
	float GetSkippingProgress() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSkipUIWidget">();
	}
	static class UTedSkipUIWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSkipUIWidget>();
	}
};
static_assert(alignof(UTedSkipUIWidget) == 0x000008, "Wrong alignment on UTedSkipUIWidget");
static_assert(sizeof(UTedSkipUIWidget) == 0x000468, "Wrong size on UTedSkipUIWidget");
static_assert(offsetof(UTedSkipUIWidget, SkipUIBinding) == 0x000400, "Member 'UTedSkipUIWidget::SkipUIBinding' has a wrong offset!");
static_assert(offsetof(UTedSkipUIWidget, SkippingProgressCurve) == 0x000420, "Member 'UTedSkipUIWidget::SkippingProgressCurve' has a wrong offset!");
static_assert(offsetof(UTedSkipUIWidget, SkipDuration) == 0x000428, "Member 'UTedSkipUIWidget::SkipDuration' has a wrong offset!");
static_assert(offsetof(UTedSkipUIWidget, RecoverDuration) == 0x00042C, "Member 'UTedSkipUIWidget::RecoverDuration' has a wrong offset!");
static_assert(offsetof(UTedSkipUIWidget, ShowingDuration) == 0x000430, "Member 'UTedSkipUIWidget::ShowingDuration' has a wrong offset!");
static_assert(offsetof(UTedSkipUIWidget, ShowingCurve) == 0x000438, "Member 'UTedSkipUIWidget::ShowingCurve' has a wrong offset!");
static_assert(offsetof(UTedSkipUIWidget, HidingDuration) == 0x000440, "Member 'UTedSkipUIWidget::HidingDuration' has a wrong offset!");
static_assert(offsetof(UTedSkipUIWidget, HidingCurve) == 0x000448, "Member 'UTedSkipUIWidget::HidingCurve' has a wrong offset!");
static_assert(offsetof(UTedSkipUIWidget, SkippingProgress) == 0x000450, "Member 'UTedSkipUIWidget::SkippingProgress' has a wrong offset!");
static_assert(offsetof(UTedSkipUIWidget, ShowingProgress) == 0x000454, "Member 'UTedSkipUIWidget::ShowingProgress' has a wrong offset!");
static_assert(offsetof(UTedSkipUIWidget, SkippingSequence) == 0x00045C, "Member 'UTedSkipUIWidget::SkippingSequence' has a wrong offset!");

// Class Tempest.TedSpectatorPlayer
// 0x0008 (0x0338 - 0x0330)
class ATedSpectatorPlayer : public ATedPlayerPawn
{
public:
	uint8                                         Pad_330[0x8];                                      // 0x0330(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSpectatorPlayer">();
	}
	static class ATedSpectatorPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedSpectatorPlayer>();
	}
};
static_assert(alignof(ATedSpectatorPlayer) == 0x000008, "Wrong alignment on ATedSpectatorPlayer");
static_assert(sizeof(ATedSpectatorPlayer) == 0x000338, "Wrong size on ATedSpectatorPlayer");

// Class Tempest.TedStatusDefinition
// 0x0090 (0x00C8 - 0x0038)
class UTedStatusDefinition final : public USmartDataAsset
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           AssetIdentifier;                                   // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTedFormattedText                      Description;                                       // 0x0060(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	ETedStatusType                                Type;                                              // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowOnUnitCard;                                   // 0x00C1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyOwningPlayerSee;                              // 0x00C2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopFollowingUnit;                                // 0x00C3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedStatusDefinition">();
	}
	static class UTedStatusDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedStatusDefinition>();
	}
};
static_assert(alignof(UTedStatusDefinition) == 0x000008, "Wrong alignment on UTedStatusDefinition");
static_assert(sizeof(UTedStatusDefinition) == 0x0000C8, "Wrong size on UTedStatusDefinition");
static_assert(offsetof(UTedStatusDefinition, AssetIdentifier) == 0x000040, "Member 'UTedStatusDefinition::AssetIdentifier' has a wrong offset!");
static_assert(offsetof(UTedStatusDefinition, Icon) == 0x000048, "Member 'UTedStatusDefinition::Icon' has a wrong offset!");
static_assert(offsetof(UTedStatusDefinition, DisplayName) == 0x000050, "Member 'UTedStatusDefinition::DisplayName' has a wrong offset!");
static_assert(offsetof(UTedStatusDefinition, Description) == 0x000060, "Member 'UTedStatusDefinition::Description' has a wrong offset!");
static_assert(offsetof(UTedStatusDefinition, Type) == 0x0000C0, "Member 'UTedStatusDefinition::Type' has a wrong offset!");
static_assert(offsetof(UTedStatusDefinition, bShowOnUnitCard) == 0x0000C1, "Member 'UTedStatusDefinition::bShowOnUnitCard' has a wrong offset!");
static_assert(offsetof(UTedStatusDefinition, bOnlyOwningPlayerSee) == 0x0000C2, "Member 'UTedStatusDefinition::bOnlyOwningPlayerSee' has a wrong offset!");
static_assert(offsetof(UTedStatusDefinition, bStopFollowingUnit) == 0x0000C3, "Member 'UTedStatusDefinition::bStopFollowingUnit' has a wrong offset!");

// Class Tempest.TedStatusPanel
// 0x0040 (0x07F0 - 0x07B0)
class UTedStatusPanel : public UTedContentPanelDynamic
{
public:
	class USmartDataCollection*                   StatusCollection;                                  // 0x07B0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<ETedStatusType>                        TypeSortOrder;                                     // 0x07B8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         InlinedSlotsNum;                                   // 0x07C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7CC[0x4];                                      // 0x07CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTedStatusDefinition*>           content;                                           // 0x07D0(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	class ATedPawn*                               ContentSourcePawn;                                 // 0x07E0(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinSlots;                                          // 0x07E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7EC[0x4];                                      // 0x07EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetContentSourcePawn(class ATedPawn* InPawn);

	const class UTedStatusDefinition* GetContent(const int32 InSlotIndex) const;
	class UTedAbilityComponent* GetContentSourceAbilityComponent() const;
	class ATedPawn* GetContentSourcePawn() const;
	int32 GetInlinedSlotsNum() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedStatusPanel">();
	}
	static class UTedStatusPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedStatusPanel>();
	}
};
static_assert(alignof(UTedStatusPanel) == 0x000008, "Wrong alignment on UTedStatusPanel");
static_assert(sizeof(UTedStatusPanel) == 0x0007F0, "Wrong size on UTedStatusPanel");
static_assert(offsetof(UTedStatusPanel, StatusCollection) == 0x0007B0, "Member 'UTedStatusPanel::StatusCollection' has a wrong offset!");
static_assert(offsetof(UTedStatusPanel, TypeSortOrder) == 0x0007B8, "Member 'UTedStatusPanel::TypeSortOrder' has a wrong offset!");
static_assert(offsetof(UTedStatusPanel, InlinedSlotsNum) == 0x0007C8, "Member 'UTedStatusPanel::InlinedSlotsNum' has a wrong offset!");
static_assert(offsetof(UTedStatusPanel, content) == 0x0007D0, "Member 'UTedStatusPanel::content' has a wrong offset!");
static_assert(offsetof(UTedStatusPanel, ContentSourcePawn) == 0x0007E0, "Member 'UTedStatusPanel::ContentSourcePawn' has a wrong offset!");
static_assert(offsetof(UTedStatusPanel, MinSlots) == 0x0007E8, "Member 'UTedStatusPanel::MinSlots' has a wrong offset!");

// Class Tempest.TedStatusSlot
// 0x0050 (0x0460 - 0x0410)
class UTedStatusSlot : public UTedContentPanelSlotBase
{
public:
	bool                                          bIsEmpty;                                          // 0x0410(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_411[0x3];                                      // 0x0411(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   IconParamName;                                     // 0x0414(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BuffParamName;                                     // 0x041C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DisableParamName;                                  // 0x0424(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_42C[0x4];                                      // 0x042C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 Image_Icon_Texture;                                // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_Icon_Material;                               // 0x0438(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_DisplayName;                                  // 0x0440(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Description;                                  // 0x0448(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     StatusMaterial;                                    // 0x0450(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     EmptyStatusMaterial;                               // 0x0458(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	const class UTedStatusDefinition* GetContent() const;
	class FText GetDescription() const;
	const class FText GetDisplayName() const;
	class UTexture2D* GetIcon() const;
	class UMaterialInstanceDynamic* GetIconMID() const;
	class UTedStatusPanel* GetParentPanel() const;
	ETedStatusType GetType() const;
	bool IsInlined() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedStatusSlot">();
	}
	static class UTedStatusSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedStatusSlot>();
	}
};
static_assert(alignof(UTedStatusSlot) == 0x000008, "Wrong alignment on UTedStatusSlot");
static_assert(sizeof(UTedStatusSlot) == 0x000460, "Wrong size on UTedStatusSlot");
static_assert(offsetof(UTedStatusSlot, bIsEmpty) == 0x000410, "Member 'UTedStatusSlot::bIsEmpty' has a wrong offset!");
static_assert(offsetof(UTedStatusSlot, IconParamName) == 0x000414, "Member 'UTedStatusSlot::IconParamName' has a wrong offset!");
static_assert(offsetof(UTedStatusSlot, BuffParamName) == 0x00041C, "Member 'UTedStatusSlot::BuffParamName' has a wrong offset!");
static_assert(offsetof(UTedStatusSlot, DisableParamName) == 0x000424, "Member 'UTedStatusSlot::DisableParamName' has a wrong offset!");
static_assert(offsetof(UTedStatusSlot, Image_Icon_Texture) == 0x000430, "Member 'UTedStatusSlot::Image_Icon_Texture' has a wrong offset!");
static_assert(offsetof(UTedStatusSlot, Image_Icon_Material) == 0x000438, "Member 'UTedStatusSlot::Image_Icon_Material' has a wrong offset!");
static_assert(offsetof(UTedStatusSlot, Text_DisplayName) == 0x000440, "Member 'UTedStatusSlot::Text_DisplayName' has a wrong offset!");
static_assert(offsetof(UTedStatusSlot, Text_Description) == 0x000448, "Member 'UTedStatusSlot::Text_Description' has a wrong offset!");
static_assert(offsetof(UTedStatusSlot, StatusMaterial) == 0x000450, "Member 'UTedStatusSlot::StatusMaterial' has a wrong offset!");
static_assert(offsetof(UTedStatusSlot, EmptyStatusMaterial) == 0x000458, "Member 'UTedStatusSlot::EmptyStatusMaterial' has a wrong offset!");

// Class Tempest.TedStructureAirfield
// 0x0060 (0x1A60 - 0x1A00)
class ATedStructureAirfield : public ATedStructureUnitFactory
{
public:
	uint8                                         Pad_1A00[0x10];                                    // 0x1A00(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            AirpadEffect;                                      // 0x1A10(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           AirpadSocketNames;                                 // 0x1A18(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   HTOLSplineTag;                                     // 0x1A28(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceToLandingTolerance;                        // 0x1A30(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A34[0x4];                                     // 0x1A34(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTedAircraftSlot>               AircraftSlots;                                     // 0x1A38(0x0010)(Net, ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A48[0x18];                                    // 0x1A48(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedStructureAirfield">();
	}
	static class ATedStructureAirfield* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedStructureAirfield>();
	}
};
static_assert(alignof(ATedStructureAirfield) == 0x000010, "Wrong alignment on ATedStructureAirfield");
static_assert(sizeof(ATedStructureAirfield) == 0x001A60, "Wrong size on ATedStructureAirfield");
static_assert(offsetof(ATedStructureAirfield, AirpadEffect) == 0x001A10, "Member 'ATedStructureAirfield::AirpadEffect' has a wrong offset!");
static_assert(offsetof(ATedStructureAirfield, AirpadSocketNames) == 0x001A18, "Member 'ATedStructureAirfield::AirpadSocketNames' has a wrong offset!");
static_assert(offsetof(ATedStructureAirfield, HTOLSplineTag) == 0x001A28, "Member 'ATedStructureAirfield::HTOLSplineTag' has a wrong offset!");
static_assert(offsetof(ATedStructureAirfield, DistanceToLandingTolerance) == 0x001A30, "Member 'ATedStructureAirfield::DistanceToLandingTolerance' has a wrong offset!");
static_assert(offsetof(ATedStructureAirfield, AircraftSlots) == 0x001A38, "Member 'ATedStructureAirfield::AircraftSlots' has a wrong offset!");

// Class Tempest.TedStructureCommandButton
// 0x0018 (0x0448 - 0x0430)
class UTedStructureCommandButton : public UTedContentPanelSlotButton
{
public:
	TSubclassOf<class UTedPlayerCommand_StructureBase> Command;                                      // 0x0430(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bKeepSelectedAfterExecution : 1;                   // 0x0438(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bWasPreviouslySelected : 1;                        // 0x0438(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_439[0x7];                                      // 0x0439(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             TextBlock_Shortcut;                                // 0x0440(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SelectCommand(const bool bInDeselectIfAlreadySelected);

	bool GetCommandShortcut(struct FInputChord* OutShortcut) const;
	bool GetCommandUIData(class UTexture2D** OutIcon, class UTexture2D** OutCursor, class FText* OutName, class FText* OutDescription) const;
	bool GetKeyCommandShortcut(struct FKey* OutShortcut) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedStructureCommandButton">();
	}
	static class UTedStructureCommandButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedStructureCommandButton>();
	}
};
static_assert(alignof(UTedStructureCommandButton) == 0x000008, "Wrong alignment on UTedStructureCommandButton");
static_assert(sizeof(UTedStructureCommandButton) == 0x000448, "Wrong size on UTedStructureCommandButton");
static_assert(offsetof(UTedStructureCommandButton, Command) == 0x000430, "Member 'UTedStructureCommandButton::Command' has a wrong offset!");
static_assert(offsetof(UTedStructureCommandButton, TextBlock_Shortcut) == 0x000440, "Member 'UTedStructureCommandButton::TextBlock_Shortcut' has a wrong offset!");

// Class Tempest.TedStructureCommand_ActivatePlan
// 0x0000 (0x0590 - 0x0590)
class UTedStructureCommand_ActivatePlan : public UTedPawnCommand_AbilityBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedStructureCommand_ActivatePlan">();
	}
	static class UTedStructureCommand_ActivatePlan* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedStructureCommand_ActivatePlan>();
	}
};
static_assert(alignof(UTedStructureCommand_ActivatePlan) == 0x000008, "Wrong alignment on UTedStructureCommand_ActivatePlan");
static_assert(sizeof(UTedStructureCommand_ActivatePlan) == 0x000590, "Wrong size on UTedStructureCommand_ActivatePlan");

// Class Tempest.TedStructureCommand_HarvestResource_Refinery
// 0x0008 (0x0548 - 0x0540)
class UTedStructureCommand_HarvestResource_Refinery : public UTedPawnCommand
{
public:
	TSubclassOf<class UTedUnitCommand_HarvestResource> HarvestCmdClassToPush;                        // 0x0540(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedStructureCommand_HarvestResource_Refinery">();
	}
	static class UTedStructureCommand_HarvestResource_Refinery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedStructureCommand_HarvestResource_Refinery>();
	}
};
static_assert(alignof(UTedStructureCommand_HarvestResource_Refinery) == 0x000008, "Wrong alignment on UTedStructureCommand_HarvestResource_Refinery");
static_assert(sizeof(UTedStructureCommand_HarvestResource_Refinery) == 0x000548, "Wrong size on UTedStructureCommand_HarvestResource_Refinery");
static_assert(offsetof(UTedStructureCommand_HarvestResource_Refinery, HarvestCmdClassToPush) == 0x000540, "Member 'UTedStructureCommand_HarvestResource_Refinery::HarvestCmdClassToPush' has a wrong offset!");

// Class Tempest.TedStructureCommand_SetRallyPoint
// 0x0050 (0x0590 - 0x0540)
class UTedStructureCommand_SetRallyPoint : public UTedPawnCommand
{
public:
	TSet<TSoftClassPtr<class UClass>>             AllowedTargetClasses;                              // 0x0540(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedStructureCommand_SetRallyPoint">();
	}
	static class UTedStructureCommand_SetRallyPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedStructureCommand_SetRallyPoint>();
	}
};
static_assert(alignof(UTedStructureCommand_SetRallyPoint) == 0x000008, "Wrong alignment on UTedStructureCommand_SetRallyPoint");
static_assert(sizeof(UTedStructureCommand_SetRallyPoint) == 0x000590, "Wrong size on UTedStructureCommand_SetRallyPoint");
static_assert(offsetof(UTedStructureCommand_SetRallyPoint, AllowedTargetClasses) == 0x000540, "Member 'UTedStructureCommand_SetRallyPoint::AllowedTargetClasses' has a wrong offset!");

// Class Tempest.TedStructurePlacementPreviewComponent
// 0x0148 (0x01F8 - 0x00B0)
class UTedStructurePlacementPreviewComponent : public UActorComponent
{
public:
	TSubclassOf<class ATedStructureBase>          Structure;                                         // 0x00B0(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         PreviewAreaSize;                                   // 0x00B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     PreviewMaterial;                                   // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MeshPreviewMaterialValidParam;                     // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class FName>                             TextureParamsToCopy;                               // 0x00D0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSet<class FName>                             ScalarParamsToCopy;                                // 0x0120(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSet<class FName>                             VectorParamsToCopy;                                // 0x0170(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	ETedStructureSpawnOption                      AccumulatedStructureSpawnOptions;                  // 0x01C0(0x0001)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInstanceDynamic*>       MIDs;                                              // 0x01C8(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TArray<class UStaticMeshComponent*>           ExtraStaticMeshes;                                 // 0x01D8(0x0010)(ExportObject, ZeroConstructor, Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UTedGridOutlineComponent*               InfluenceAreaBorderPtr;                            // 0x01E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedStructureAlignment                        Alignment;                                         // 0x01F0(0x0001)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F1[0x7];                                      // 0x01F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSetupMaterial(class UMaterialInstanceDynamic* InMyMID, const class UMaterialInstance* InStructureMID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedStructurePlacementPreviewComponent">();
	}
	static class UTedStructurePlacementPreviewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedStructurePlacementPreviewComponent>();
	}
};
static_assert(alignof(UTedStructurePlacementPreviewComponent) == 0x000008, "Wrong alignment on UTedStructurePlacementPreviewComponent");
static_assert(sizeof(UTedStructurePlacementPreviewComponent) == 0x0001F8, "Wrong size on UTedStructurePlacementPreviewComponent");
static_assert(offsetof(UTedStructurePlacementPreviewComponent, Structure) == 0x0000B0, "Member 'UTedStructurePlacementPreviewComponent::Structure' has a wrong offset!");
static_assert(offsetof(UTedStructurePlacementPreviewComponent, PreviewAreaSize) == 0x0000B8, "Member 'UTedStructurePlacementPreviewComponent::PreviewAreaSize' has a wrong offset!");
static_assert(offsetof(UTedStructurePlacementPreviewComponent, PreviewMaterial) == 0x0000C0, "Member 'UTedStructurePlacementPreviewComponent::PreviewMaterial' has a wrong offset!");
static_assert(offsetof(UTedStructurePlacementPreviewComponent, MeshPreviewMaterialValidParam) == 0x0000C8, "Member 'UTedStructurePlacementPreviewComponent::MeshPreviewMaterialValidParam' has a wrong offset!");
static_assert(offsetof(UTedStructurePlacementPreviewComponent, TextureParamsToCopy) == 0x0000D0, "Member 'UTedStructurePlacementPreviewComponent::TextureParamsToCopy' has a wrong offset!");
static_assert(offsetof(UTedStructurePlacementPreviewComponent, ScalarParamsToCopy) == 0x000120, "Member 'UTedStructurePlacementPreviewComponent::ScalarParamsToCopy' has a wrong offset!");
static_assert(offsetof(UTedStructurePlacementPreviewComponent, VectorParamsToCopy) == 0x000170, "Member 'UTedStructurePlacementPreviewComponent::VectorParamsToCopy' has a wrong offset!");
static_assert(offsetof(UTedStructurePlacementPreviewComponent, AccumulatedStructureSpawnOptions) == 0x0001C0, "Member 'UTedStructurePlacementPreviewComponent::AccumulatedStructureSpawnOptions' has a wrong offset!");
static_assert(offsetof(UTedStructurePlacementPreviewComponent, MIDs) == 0x0001C8, "Member 'UTedStructurePlacementPreviewComponent::MIDs' has a wrong offset!");
static_assert(offsetof(UTedStructurePlacementPreviewComponent, ExtraStaticMeshes) == 0x0001D8, "Member 'UTedStructurePlacementPreviewComponent::ExtraStaticMeshes' has a wrong offset!");
static_assert(offsetof(UTedStructurePlacementPreviewComponent, InfluenceAreaBorderPtr) == 0x0001E8, "Member 'UTedStructurePlacementPreviewComponent::InfluenceAreaBorderPtr' has a wrong offset!");
static_assert(offsetof(UTedStructurePlacementPreviewComponent, Alignment) == 0x0001F0, "Member 'UTedStructurePlacementPreviewComponent::Alignment' has a wrong offset!");

// Class Tempest.TedStructureDeployPreviewComponent
// 0x0008 (0x0200 - 0x01F8)
class UTedStructureDeployPreviewComponent final : public UTedStructurePlacementPreviewComponent
{
public:
	bool                                          bHideInfluenceArea;                                // 0x01F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedStructureDeployPreviewComponent">();
	}
	static class UTedStructureDeployPreviewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedStructureDeployPreviewComponent>();
	}
};
static_assert(alignof(UTedStructureDeployPreviewComponent) == 0x000008, "Wrong alignment on UTedStructureDeployPreviewComponent");
static_assert(sizeof(UTedStructureDeployPreviewComponent) == 0x000200, "Wrong size on UTedStructureDeployPreviewComponent");
static_assert(offsetof(UTedStructureDeployPreviewComponent, bHideInfluenceArea) == 0x0001F8, "Member 'UTedStructureDeployPreviewComponent::bHideInfluenceArea' has a wrong offset!");

// Class Tempest.TedStructureGateNavLink
// 0x0010 (0x0200 - 0x01F0)
class UTedStructureGateNavLink final : public UNavLinkCustomComponent
{
public:
	float                                         AgentRadius;                                       // 0x01F0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LinkIndex;                                         // 0x01F4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LinksCount;                                        // 0x01F8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FC[0x4];                                      // 0x01FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedStructureGateNavLink">();
	}
	static class UTedStructureGateNavLink* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedStructureGateNavLink>();
	}
};
static_assert(alignof(UTedStructureGateNavLink) == 0x000008, "Wrong alignment on UTedStructureGateNavLink");
static_assert(sizeof(UTedStructureGateNavLink) == 0x000200, "Wrong size on UTedStructureGateNavLink");
static_assert(offsetof(UTedStructureGateNavLink, AgentRadius) == 0x0001F0, "Member 'UTedStructureGateNavLink::AgentRadius' has a wrong offset!");
static_assert(offsetof(UTedStructureGateNavLink, LinkIndex) == 0x0001F4, "Member 'UTedStructureGateNavLink::LinkIndex' has a wrong offset!");
static_assert(offsetof(UTedStructureGateNavLink, LinksCount) == 0x0001F8, "Member 'UTedStructureGateNavLink::LinksCount' has a wrong offset!");

// Class Tempest.TedStructureGate
// 0x0050 (0x1AE0 - 0x1A90)
class ATedStructureGate : public ATedStructureNeighborBase
{
public:
	uint8                                         bRotated : 1;                                      // 0x1A90(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, EditConst, SaveGame, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1A91[0x7];                                     // 0x1A91(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   TempMovableGateMesh;                               // 0x1A98(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            DeathFrameMesh;                                    // 0x1AA0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            DeathGateMesh;                                     // 0x1AA8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTedStructureGateNavLink*>       NavLinks;                                          // 0x1AB0(0x0010)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         AutoCloseTime;                                     // 0x1AC0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AC4[0x4];                                     // 0x1AC4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           TH_ClosingGate;                                    // 0x1AC8(0x0008)(Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bOpened : 1;                                       // 0x1AD0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, DuplicateTransient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1AD1[0xF];                                     // 0x1AD1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Opened();
	void OnSetOpenedCosmetic(const bool bInOpened);
	void SetOpened(const bool bInOpened);

	bool IsOpened() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedStructureGate">();
	}
	static class ATedStructureGate* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedStructureGate>();
	}
};
static_assert(alignof(ATedStructureGate) == 0x000010, "Wrong alignment on ATedStructureGate");
static_assert(sizeof(ATedStructureGate) == 0x001AE0, "Wrong size on ATedStructureGate");
static_assert(offsetof(ATedStructureGate, TempMovableGateMesh) == 0x001A98, "Member 'ATedStructureGate::TempMovableGateMesh' has a wrong offset!");
static_assert(offsetof(ATedStructureGate, DeathFrameMesh) == 0x001AA0, "Member 'ATedStructureGate::DeathFrameMesh' has a wrong offset!");
static_assert(offsetof(ATedStructureGate, DeathGateMesh) == 0x001AA8, "Member 'ATedStructureGate::DeathGateMesh' has a wrong offset!");
static_assert(offsetof(ATedStructureGate, NavLinks) == 0x001AB0, "Member 'ATedStructureGate::NavLinks' has a wrong offset!");
static_assert(offsetof(ATedStructureGate, AutoCloseTime) == 0x001AC0, "Member 'ATedStructureGate::AutoCloseTime' has a wrong offset!");
static_assert(offsetof(ATedStructureGate, TH_ClosingGate) == 0x001AC8, "Member 'ATedStructureGate::TH_ClosingGate' has a wrong offset!");

// Class Tempest.TedStructureModeProxyWidget
// 0x0350 (0x0750 - 0x0400)
class UTedStructureModeProxyWidget : public UTedUserWidget
{
public:
	struct FSlateBrush                            RepairingIcon;                                     // 0x0400(0x00D0)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            LowPowerFunctionalIcon;                            // 0x04D0(0x00D0)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            LowPowerNonFunctionalIcon;                         // 0x05A0(0x00D0)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            PowerOffIcon;                                      // 0x0670(0x00D0)(Edit, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            ScaleCurve;                                        // 0x0740(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CachedScale;                                       // 0x0748(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74C[0x4];                                      // 0x074C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedStructureModeProxyWidget">();
	}
	static class UTedStructureModeProxyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedStructureModeProxyWidget>();
	}
};
static_assert(alignof(UTedStructureModeProxyWidget) == 0x000010, "Wrong alignment on UTedStructureModeProxyWidget");
static_assert(sizeof(UTedStructureModeProxyWidget) == 0x000750, "Wrong size on UTedStructureModeProxyWidget");
static_assert(offsetof(UTedStructureModeProxyWidget, RepairingIcon) == 0x000400, "Member 'UTedStructureModeProxyWidget::RepairingIcon' has a wrong offset!");
static_assert(offsetof(UTedStructureModeProxyWidget, LowPowerFunctionalIcon) == 0x0004D0, "Member 'UTedStructureModeProxyWidget::LowPowerFunctionalIcon' has a wrong offset!");
static_assert(offsetof(UTedStructureModeProxyWidget, LowPowerNonFunctionalIcon) == 0x0005A0, "Member 'UTedStructureModeProxyWidget::LowPowerNonFunctionalIcon' has a wrong offset!");
static_assert(offsetof(UTedStructureModeProxyWidget, PowerOffIcon) == 0x000670, "Member 'UTedStructureModeProxyWidget::PowerOffIcon' has a wrong offset!");
static_assert(offsetof(UTedStructureModeProxyWidget, ScaleCurve) == 0x000740, "Member 'UTedStructureModeProxyWidget::ScaleCurve' has a wrong offset!");
static_assert(offsetof(UTedStructureModeProxyWidget, CachedScale) == 0x000748, "Member 'UTedStructureModeProxyWidget::CachedScale' has a wrong offset!");

// Class Tempest.TedStructurePlacementVolume
// 0x0030 (0x03D8 - 0x03A8)
class ATedStructurePlacementVolume final : public ANavGridTriggerVolume
{
public:
	struct FGameplayTagContainer                  RelevantTech_OLD;                                  // 0x03A8(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UTedEntityDefinitionAsset>> RelevantDefinitions;                     // 0x03C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void K2_SetRelevantDefinitions(const TArray<TSoftObjectPtr<class UTedEntityDefinitionAsset>>& InDefinitions);
	void K2_SetRelevantTech(const struct FGameplayTagContainer& InTech);

	const struct FGameplayTagContainer GetRelevantTech() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedStructurePlacementVolume">();
	}
	static class ATedStructurePlacementVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedStructurePlacementVolume>();
	}
};
static_assert(alignof(ATedStructurePlacementVolume) == 0x000008, "Wrong alignment on ATedStructurePlacementVolume");
static_assert(sizeof(ATedStructurePlacementVolume) == 0x0003D8, "Wrong size on ATedStructurePlacementVolume");
static_assert(offsetof(ATedStructurePlacementVolume, RelevantTech_OLD) == 0x0003A8, "Member 'ATedStructurePlacementVolume::RelevantTech_OLD' has a wrong offset!");
static_assert(offsetof(ATedStructurePlacementVolume, RelevantDefinitions) == 0x0003C8, "Member 'ATedStructurePlacementVolume::RelevantDefinitions' has a wrong offset!");

// Class Tempest.TedStructureRefinery_DYN_V2
// 0x0020 (0x1C10 - 0x1BF0)
class ATedStructureRefinery_DYN_V2 : public ATedStructureRefinery_DYN
{
public:
	TArray<class FName>                           DepositSocketNames;                                // 0x1BF0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UTedUnitSpawnerComponent*               UnitSpawnerComponent;                              // 0x1C00(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C08[0x8];                                     // 0x1C08(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedStructureRefinery_DYN_V2">();
	}
	static class ATedStructureRefinery_DYN_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedStructureRefinery_DYN_V2>();
	}
};
static_assert(alignof(ATedStructureRefinery_DYN_V2) == 0x000010, "Wrong alignment on ATedStructureRefinery_DYN_V2");
static_assert(sizeof(ATedStructureRefinery_DYN_V2) == 0x001C10, "Wrong size on ATedStructureRefinery_DYN_V2");
static_assert(offsetof(ATedStructureRefinery_DYN_V2, DepositSocketNames) == 0x001BF0, "Member 'ATedStructureRefinery_DYN_V2::DepositSocketNames' has a wrong offset!");
static_assert(offsetof(ATedStructureRefinery_DYN_V2, UnitSpawnerComponent) == 0x001C00, "Member 'ATedStructureRefinery_DYN_V2::UnitSpawnerComponent' has a wrong offset!");

// Class Tempest.TedStructureRefinery_GDF
// 0x0030 (0x1B40 - 0x1B10)
class ATedStructureRefinery_GDF : public ATedStructureRefinery
{
public:
	class FName                                   SplineSlotComponentTag;                            // 0x1B10(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InsideDistanceTolerance;                           // 0x1B18(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OutsideDistanceTolerance;                          // 0x1B1C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DepositSocketName;                                 // 0x1B20(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USplineComponent*>               SlotSplines;                                       // 0x1B28(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B38[0x8];                                     // 0x1B38(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedStructureRefinery_GDF">();
	}
	static class ATedStructureRefinery_GDF* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedStructureRefinery_GDF>();
	}
};
static_assert(alignof(ATedStructureRefinery_GDF) == 0x000010, "Wrong alignment on ATedStructureRefinery_GDF");
static_assert(sizeof(ATedStructureRefinery_GDF) == 0x001B40, "Wrong size on ATedStructureRefinery_GDF");
static_assert(offsetof(ATedStructureRefinery_GDF, SplineSlotComponentTag) == 0x001B10, "Member 'ATedStructureRefinery_GDF::SplineSlotComponentTag' has a wrong offset!");
static_assert(offsetof(ATedStructureRefinery_GDF, InsideDistanceTolerance) == 0x001B18, "Member 'ATedStructureRefinery_GDF::InsideDistanceTolerance' has a wrong offset!");
static_assert(offsetof(ATedStructureRefinery_GDF, OutsideDistanceTolerance) == 0x001B1C, "Member 'ATedStructureRefinery_GDF::OutsideDistanceTolerance' has a wrong offset!");
static_assert(offsetof(ATedStructureRefinery_GDF, DepositSocketName) == 0x001B20, "Member 'ATedStructureRefinery_GDF::DepositSocketName' has a wrong offset!");
static_assert(offsetof(ATedStructureRefinery_GDF, SlotSplines) == 0x001B28, "Member 'ATedStructureRefinery_GDF::SlotSplines' has a wrong offset!");

// Class Tempest.TedStructureRepairBay
// 0x0100 (0x1B00 - 0x1A00)
class ATedStructureRepairBay final : public ATedStructureUnitFactory
{
public:
	uint8                                         Pad_1A00[0x8];                                     // 0x1A00(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(int32 SlotID, bool bOccupied)> ReceiveRepairSlotUpdated;           // 0x1A08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BigSlotTechTags;                                   // 0x1A18(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            RepairGE;                                          // 0x1A38(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USplineComponent*                       QueueSpline;                                       // 0x1A40(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RepairSlotSplineComponentTag;                      // 0x1A48(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BigRepairSlotSplineComponentTag;                   // 0x1A50(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RepairSlotSplinePtIdx;                             // 0x1A58(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ExitSlotSplinePtIdx;                               // 0x1A5C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InterpolationRate;                                 // 0x1A60(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InterpolationStep;                                 // 0x1A64(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ATedUnitBase*>                   UnitQueue;                                         // 0x1A68(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class ATedUnitBase*>                   RepairSlots;                                       // 0x1A78(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<class ATedUnitBase*>                   PreviousRepairSlots;                               // 0x1A88(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class USplineComponent*>               RepairSlotSplines;                                 // 0x1A98(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class USplineComponent*                       BigRepairSlotSpline;                               // 0x1AA8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TWeakObjectPtr<class ATedUnitBase>, struct FInterpolationInfo> InterpolatedUnits;           // 0x1AB0(0x0050)(Transient, DuplicateTransient, NativeAccessSpecifierPrivate)

public:
	void OnRep_RepairSlots();

	int32 GetOccupiedSlotsNum() const;
	bool IsRepairingVehicle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedStructureRepairBay">();
	}
	static class ATedStructureRepairBay* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedStructureRepairBay>();
	}
};
static_assert(alignof(ATedStructureRepairBay) == 0x000010, "Wrong alignment on ATedStructureRepairBay");
static_assert(sizeof(ATedStructureRepairBay) == 0x001B00, "Wrong size on ATedStructureRepairBay");
static_assert(offsetof(ATedStructureRepairBay, ReceiveRepairSlotUpdated) == 0x001A08, "Member 'ATedStructureRepairBay::ReceiveRepairSlotUpdated' has a wrong offset!");
static_assert(offsetof(ATedStructureRepairBay, BigSlotTechTags) == 0x001A18, "Member 'ATedStructureRepairBay::BigSlotTechTags' has a wrong offset!");
static_assert(offsetof(ATedStructureRepairBay, RepairGE) == 0x001A38, "Member 'ATedStructureRepairBay::RepairGE' has a wrong offset!");
static_assert(offsetof(ATedStructureRepairBay, QueueSpline) == 0x001A40, "Member 'ATedStructureRepairBay::QueueSpline' has a wrong offset!");
static_assert(offsetof(ATedStructureRepairBay, RepairSlotSplineComponentTag) == 0x001A48, "Member 'ATedStructureRepairBay::RepairSlotSplineComponentTag' has a wrong offset!");
static_assert(offsetof(ATedStructureRepairBay, BigRepairSlotSplineComponentTag) == 0x001A50, "Member 'ATedStructureRepairBay::BigRepairSlotSplineComponentTag' has a wrong offset!");
static_assert(offsetof(ATedStructureRepairBay, RepairSlotSplinePtIdx) == 0x001A58, "Member 'ATedStructureRepairBay::RepairSlotSplinePtIdx' has a wrong offset!");
static_assert(offsetof(ATedStructureRepairBay, ExitSlotSplinePtIdx) == 0x001A5C, "Member 'ATedStructureRepairBay::ExitSlotSplinePtIdx' has a wrong offset!");
static_assert(offsetof(ATedStructureRepairBay, InterpolationRate) == 0x001A60, "Member 'ATedStructureRepairBay::InterpolationRate' has a wrong offset!");
static_assert(offsetof(ATedStructureRepairBay, InterpolationStep) == 0x001A64, "Member 'ATedStructureRepairBay::InterpolationStep' has a wrong offset!");
static_assert(offsetof(ATedStructureRepairBay, UnitQueue) == 0x001A68, "Member 'ATedStructureRepairBay::UnitQueue' has a wrong offset!");
static_assert(offsetof(ATedStructureRepairBay, RepairSlots) == 0x001A78, "Member 'ATedStructureRepairBay::RepairSlots' has a wrong offset!");
static_assert(offsetof(ATedStructureRepairBay, PreviousRepairSlots) == 0x001A88, "Member 'ATedStructureRepairBay::PreviousRepairSlots' has a wrong offset!");
static_assert(offsetof(ATedStructureRepairBay, RepairSlotSplines) == 0x001A98, "Member 'ATedStructureRepairBay::RepairSlotSplines' has a wrong offset!");
static_assert(offsetof(ATedStructureRepairBay, BigRepairSlotSpline) == 0x001AA8, "Member 'ATedStructureRepairBay::BigRepairSlotSpline' has a wrong offset!");
static_assert(offsetof(ATedStructureRepairBay, InterpolatedUnits) == 0x001AB0, "Member 'ATedStructureRepairBay::InterpolatedUnits' has a wrong offset!");

// Class Tempest.TedStructuresPanel
// 0x0030 (0x07E0 - 0x07B0)
class UTedStructuresPanel : public UTedContentPanelDynamic
{
public:
	uint8                                         AmountOfSlots;                                     // 0x07B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7B1[0x7];                                      // 0x07B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATedStructureBase*>              content;                                           // 0x07B8(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	int32                                         PageNumber;                                        // 0x07C8(0x0004)(BlueprintVisible, ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7CC[0x14];                                     // 0x07CC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateSlotStateByContent(const class ATedStructureBase* InContent, const ETedContentSlotState InState, const bool bInActivate);
	void SetContent(const TArray<class ATedStructureBase*>& InContent, const bool bInRefreshContent);
	void SetUniqueContent(const TSet<class ATedStructureBase*>& InContent, const bool bInRefreshContent);
	void SwitchPage(bool bForwards);

	bool GetContent(TArray<class ATedStructureBase*>* OutContent) const;
	class ATedStructureBase* GetSelectedContent() const;
	class ATedStructureBase* GetSlotContent(const int32 InSlotIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedStructuresPanel">();
	}
	static class UTedStructuresPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedStructuresPanel>();
	}
};
static_assert(alignof(UTedStructuresPanel) == 0x000008, "Wrong alignment on UTedStructuresPanel");
static_assert(sizeof(UTedStructuresPanel) == 0x0007E0, "Wrong size on UTedStructuresPanel");
static_assert(offsetof(UTedStructuresPanel, AmountOfSlots) == 0x0007B0, "Member 'UTedStructuresPanel::AmountOfSlots' has a wrong offset!");
static_assert(offsetof(UTedStructuresPanel, content) == 0x0007B8, "Member 'UTedStructuresPanel::content' has a wrong offset!");
static_assert(offsetof(UTedStructuresPanel, PageNumber) == 0x0007C8, "Member 'UTedStructuresPanel::PageNumber' has a wrong offset!");

// Class Tempest.TedStructureTower
// 0x0010 (0x1AA0 - 0x1A90)
class ATedStructureTower : public ATedStructureNeighborBase
{
public:
	class UTedRangeDecalComponent*                RangeDecal;                                        // 0x1A90(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A98[0x8];                                     // 0x1A98(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleSelectionChanged(const bool bSelectionStateChanged, const bool bHoveredStateChanged);
	void UpdateRangeDecalData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedStructureTower">();
	}
	static class ATedStructureTower* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedStructureTower>();
	}
};
static_assert(alignof(ATedStructureTower) == 0x000010, "Wrong alignment on ATedStructureTower");
static_assert(sizeof(ATedStructureTower) == 0x001AA0, "Wrong size on ATedStructureTower");
static_assert(offsetof(ATedStructureTower, RangeDecal) == 0x001A90, "Member 'ATedStructureTower::RangeDecal' has a wrong offset!");

// Class Tempest.TedStructureWall
// 0x0080 (0x1B10 - 0x1A90)
class ATedStructureWall : public ATedStructureNeighborBase
{
public:
	class UBoxComponent*                          SecondaryNavModifier;                              // 0x1A90(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NavModifierWidth;                                  // 0x1A98(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NavModifierHeight;                                 // 0x1A9C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          PrimaryHitBox;                                     // 0x1AA0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          SecondaryHitBox;                                   // 0x1AA8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitBoxWidth;                                       // 0x1AB0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitBoxHeight;                                      // 0x1AB4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTedStructureWallMeshSetup_Temp        MeshSetup_Temp;                                    // 0x1AB8(0x0028)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTedStructureWallMeshSetup_Temp        DeathMeshes;                                       // 0x1AE0(0x0028)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         ConnectionRange;                                   // 0x1B08(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bUseUniqueMaterials : 1;                           // 0x1B09(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1B0A[0x6];                                     // 0x1B0A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedStructureWall">();
	}
	static class ATedStructureWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedStructureWall>();
	}
};
static_assert(alignof(ATedStructureWall) == 0x000010, "Wrong alignment on ATedStructureWall");
static_assert(sizeof(ATedStructureWall) == 0x001B10, "Wrong size on ATedStructureWall");
static_assert(offsetof(ATedStructureWall, SecondaryNavModifier) == 0x001A90, "Member 'ATedStructureWall::SecondaryNavModifier' has a wrong offset!");
static_assert(offsetof(ATedStructureWall, NavModifierWidth) == 0x001A98, "Member 'ATedStructureWall::NavModifierWidth' has a wrong offset!");
static_assert(offsetof(ATedStructureWall, NavModifierHeight) == 0x001A9C, "Member 'ATedStructureWall::NavModifierHeight' has a wrong offset!");
static_assert(offsetof(ATedStructureWall, PrimaryHitBox) == 0x001AA0, "Member 'ATedStructureWall::PrimaryHitBox' has a wrong offset!");
static_assert(offsetof(ATedStructureWall, SecondaryHitBox) == 0x001AA8, "Member 'ATedStructureWall::SecondaryHitBox' has a wrong offset!");
static_assert(offsetof(ATedStructureWall, HitBoxWidth) == 0x001AB0, "Member 'ATedStructureWall::HitBoxWidth' has a wrong offset!");
static_assert(offsetof(ATedStructureWall, HitBoxHeight) == 0x001AB4, "Member 'ATedStructureWall::HitBoxHeight' has a wrong offset!");
static_assert(offsetof(ATedStructureWall, MeshSetup_Temp) == 0x001AB8, "Member 'ATedStructureWall::MeshSetup_Temp' has a wrong offset!");
static_assert(offsetof(ATedStructureWall, DeathMeshes) == 0x001AE0, "Member 'ATedStructureWall::DeathMeshes' has a wrong offset!");
static_assert(offsetof(ATedStructureWall, ConnectionRange) == 0x001B08, "Member 'ATedStructureWall::ConnectionRange' has a wrong offset!");

// Class Tempest.TedSubtitleWidget
// 0x0030 (0x0430 - 0x0400)
class UTedSubtitleWidget : public UTedUserWidget
{
public:
	TArray<ETedMovieType>                         ValidMovies;                                       // 0x0400(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bAlwaysShowIfNonEmpty : 1;                         // 0x0410(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_411[0x7];                                      // 0x0411(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayedText;                                     // 0x0418(0x0010)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	class UTextBlock*                             Subtitle;                                          // 0x0428(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static float GetSubtitlesScale();

	void K2_DisplaySubtitle(const class FText& InText);
	void OnSkippableSequenceEnded(const struct FGameplayTag& InSequence);

	ESlateVisibility EvaluateVisibility() const;
	const class FText GetDisplayedText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSubtitleWidget">();
	}
	static class UTedSubtitleWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSubtitleWidget>();
	}
};
static_assert(alignof(UTedSubtitleWidget) == 0x000008, "Wrong alignment on UTedSubtitleWidget");
static_assert(sizeof(UTedSubtitleWidget) == 0x000430, "Wrong size on UTedSubtitleWidget");
static_assert(offsetof(UTedSubtitleWidget, ValidMovies) == 0x000400, "Member 'UTedSubtitleWidget::ValidMovies' has a wrong offset!");
static_assert(offsetof(UTedSubtitleWidget, DisplayedText) == 0x000418, "Member 'UTedSubtitleWidget::DisplayedText' has a wrong offset!");
static_assert(offsetof(UTedSubtitleWidget, Subtitle) == 0x000428, "Member 'UTedSubtitleWidget::Subtitle' has a wrong offset!");

// Class Tempest.TedTelemetryManager
// 0x0290 (0x02C0 - 0x0030)
class UTedTelemetryManager final : public UGameInstanceSubsystem
{
public:
	class UTedOnlineHydraAPI*                     HydraAPI;                                          // 0x0030(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FMatchmakeDatacenterPingInfo>   DatacenterInfos;                                   // 0x0038(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	float                                         PeriodicDataSendRate;                              // 0x0048(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CollectDurationsRate;                              // 0x004C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x20];                                      // 0x0050(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedTelemetryMatchDetails              MatchDetails;                                      // 0x0070(0x0060)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FMissionDetails                        CampaignMissionDetails;                            // 0x00D0(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<ETedPlayerID, struct FTedTelemetryPlayerData> PlayerTelemetryData;                          // 0x00F8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_148[0x4C];                                     // 0x0148(0x004C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntPoint                              QuadrantsAmount;                                   // 0x0194(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_19C[0x4];                                      // 0x019C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              QuadrantSize;                                      // 0x01A0(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              QuadrantOffset;                                    // 0x01B0(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBox                                   CachedWorldBounds;                                 // 0x01C0(0x0038)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bQuadrantsValid;                                   // 0x01F8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F9[0xAF];                                     // 0x01F9(0x00AF)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLogIntoFile;                                      // 0x02A8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LogFilePath;                                       // 0x02B0(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static void OnCutsceneFinished(const class UObject* InWorldContextObject, const ETedPlayerID InPlayerID, const class FString& InCutsceneName);
	static void OnCutsceneStarted(const class UObject* InWorldContextObject, const ETedPlayerID InPlayerID, const class FString& InCutsceneName);
	static void OnPawnChangedOwner(const class ATedPawn* InPawn, const class ATedPlayerState* InNewOwner, const class ATedPlayerState* InPreviousOwner);
	static void OnPawnDied(const class ATedPawn* InPawn, const class AActor* InKillerActor);
	static void OnPawnHealthChanged(const class ATedPawn* InPawn, const float InHealthChange, const class AActor* InSourceActor);
	static void OnPawnProduced(const class UObject* InWorldContextObject, const class UTedEntityDefinitionAsset* InPawnDefinition, const ETedPlayerID InOwnerId, const int32 InCreditsCost);
	static void OnPawnReplaced(const class ATedPawn* InReplacingPawn, const class ATedPawn* InReplacedPawn);
	static void OnPlayerResourceChanged(const class UObject* InWorldContextObject, const ETedPlayerID InPlayerID, const ETedResourceType InResourceType, const float InResourceDelta, const ETedResourceChangeReason InChangeReason);
	static void OnPlayerSettingsChanged(const class UObject* InWorldContextObject, const class FString& InSettingName, const class FString& InNewState, const class FString& InPreviousState);
	static void OnStructureConstructionChanged(const class UObject* InWorldContextObject, const class UTedStructureDefinitionAsset* InStructureDefinition, const ETedPlayerID InOwnerId, const struct FVector& InConstructionLocation, const ETedTelemetryConstructionStatus InConstructionStatus);
	static void OnStructureSold(const class ATedStructureBase* InSoldStructure, const ETedPlayerID InPlayerID);
	static void OnSupportPowerBeginTracking(const class UObject* InWorldContextObject, const class AActor* InOwner, const struct FGameplayTag& InSupportPowerTag, const struct FVector& InSupportPowerLocation, const TArray<class AActor*>& InAssociatedActors, const struct FTedTelemetrySupportPowerTrackingOptions& InOptions);
	static void OnSupportPowerEndTracking(const class UObject* InWorldContextObject, const class AActor* InOwner, const struct FGameplayTag& InSupportPowerTag, const ETedTelemetryTrackedSupportPowerResult InResult);
	static void OnSupportPowerPawnShotProjectile(const class UObject* InWorldContextObject, class ATedPawn* InShooter, class AActor* InTarget, class ATedProjectile* InShotProjectile, const struct FGameplayTag& InSupportPowerTag);
	static void OnSupportPowerProjectileDealtDamage(const class UObject* InWorldContextObject, const class AActor* InOwner, const struct FGameplayTag& InSupportPowerTag, const class ATedProjectile* InProjectile, const TArray<class ATedPawn*>& InDamagedPawns);

	void HandleSupportPowerActorEndPlay(class AActor* InActor, EEndPlayReason InEndPlayReason);
	void OnLobbyUpdate(class ATedLobbyBeaconState* InLobbyState);
	void OnLocalPlayerStateReplicated(class ATedPlayerController* PlayerController);
	void SendClientBannerClickEvent(const struct FProsBanner& InBanner);
	void SendClientBannerImpressionEvent(const struct FProsBanner& InBanner);

	void SendClientBannerCloseWindowEvent(const struct FProsBanner& InBanner) const;
	void SendClientBannerOpenWindowEvent(const struct FProsBanner& InBanner) const;
	void SendClientBannerSettingsEvent(const bool bInShowing) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedTelemetryManager">();
	}
	static class UTedTelemetryManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedTelemetryManager>();
	}
};
static_assert(alignof(UTedTelemetryManager) == 0x000008, "Wrong alignment on UTedTelemetryManager");
static_assert(sizeof(UTedTelemetryManager) == 0x0002C0, "Wrong size on UTedTelemetryManager");
static_assert(offsetof(UTedTelemetryManager, HydraAPI) == 0x000030, "Member 'UTedTelemetryManager::HydraAPI' has a wrong offset!");
static_assert(offsetof(UTedTelemetryManager, DatacenterInfos) == 0x000038, "Member 'UTedTelemetryManager::DatacenterInfos' has a wrong offset!");
static_assert(offsetof(UTedTelemetryManager, PeriodicDataSendRate) == 0x000048, "Member 'UTedTelemetryManager::PeriodicDataSendRate' has a wrong offset!");
static_assert(offsetof(UTedTelemetryManager, CollectDurationsRate) == 0x00004C, "Member 'UTedTelemetryManager::CollectDurationsRate' has a wrong offset!");
static_assert(offsetof(UTedTelemetryManager, MatchDetails) == 0x000070, "Member 'UTedTelemetryManager::MatchDetails' has a wrong offset!");
static_assert(offsetof(UTedTelemetryManager, CampaignMissionDetails) == 0x0000D0, "Member 'UTedTelemetryManager::CampaignMissionDetails' has a wrong offset!");
static_assert(offsetof(UTedTelemetryManager, PlayerTelemetryData) == 0x0000F8, "Member 'UTedTelemetryManager::PlayerTelemetryData' has a wrong offset!");
static_assert(offsetof(UTedTelemetryManager, QuadrantsAmount) == 0x000194, "Member 'UTedTelemetryManager::QuadrantsAmount' has a wrong offset!");
static_assert(offsetof(UTedTelemetryManager, QuadrantSize) == 0x0001A0, "Member 'UTedTelemetryManager::QuadrantSize' has a wrong offset!");
static_assert(offsetof(UTedTelemetryManager, QuadrantOffset) == 0x0001B0, "Member 'UTedTelemetryManager::QuadrantOffset' has a wrong offset!");
static_assert(offsetof(UTedTelemetryManager, CachedWorldBounds) == 0x0001C0, "Member 'UTedTelemetryManager::CachedWorldBounds' has a wrong offset!");
static_assert(offsetof(UTedTelemetryManager, bQuadrantsValid) == 0x0001F8, "Member 'UTedTelemetryManager::bQuadrantsValid' has a wrong offset!");
static_assert(offsetof(UTedTelemetryManager, bLogIntoFile) == 0x0002A8, "Member 'UTedTelemetryManager::bLogIntoFile' has a wrong offset!");
static_assert(offsetof(UTedTelemetryManager, LogFilePath) == 0x0002B0, "Member 'UTedTelemetryManager::LogFilePath' has a wrong offset!");

// Class Tempest.TedTextWidgetInterfaceFunctions
// 0x0000 (0x0028 - 0x0028)
class UTedTextWidgetInterfaceFunctions final : public UBlueprintFunctionLibrary
{
public:
	static void SetData(TScriptInterface<class ITedTextWidgetInterface> Widget, const struct FTedTextWidgetConfig& Data);
	static void SetPrimaryColorr(TScriptInterface<class ITedTextWidgetInterface> Widget, const struct FLinearColor& Color);
	static void SetSecondaryColor(TScriptInterface<class ITedTextWidgetInterface> Widget, const struct FLinearColor& Color);
	static void SetText(TScriptInterface<class ITedTextWidgetInterface> Widget, const class FText& Text);
	static void SetThemedData(TScriptInterface<class ITedTextWidgetInterface> Widget, const struct FTedTextWidgetThemedConfig& Data, const ETedFaction CurrentTheme);
	static void SetUseSecondaryColor(TScriptInterface<class ITedTextWidgetInterface> Widget, const bool bInUseSecondaryColor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedTextWidgetInterfaceFunctions">();
	}
	static class UTedTextWidgetInterfaceFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedTextWidgetInterfaceFunctions>();
	}
};
static_assert(alignof(UTedTextWidgetInterfaceFunctions) == 0x000008, "Wrong alignment on UTedTextWidgetInterfaceFunctions");
static_assert(sizeof(UTedTextWidgetInterfaceFunctions) == 0x000028, "Wrong size on UTedTextWidgetInterfaceFunctions");

// Class Tempest.TedTextWidgetInterface
// 0x0000 (0x0000 - 0x0000)
class ITedTextWidgetInterface final
{
public:
	void K2_OnTextWidgetSetPrimaryColor(const struct FLinearColor& InColor);
	void K2_OnTextWidgetSetSecondaryColor(const struct FLinearColor& InColor);
	void K2_OnTextWidgetSetText(const class FText& InText);
	void K2_OnTextWidgetSetUseSecondaryColor(const bool bInUseSecondaryColor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedTextWidgetInterface">();
	}
	static class ITedTextWidgetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITedTextWidgetInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITedTextWidgetInterface) == 0x000001, "Wrong alignment on ITedTextWidgetInterface");
static_assert(sizeof(ITedTextWidgetInterface) == 0x000001, "Wrong size on ITedTextWidgetInterface");

// Class Tempest.TedTriggerVolume
// 0x0070 (0x0338 - 0x02C8)
class ATedTriggerVolume final : public AVolume
{
public:
	EComponentMobility                            Mobility;                                          // 0x02C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoEnabled;                                      // 0x02C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CA[0x2];                                      // 0x02CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           InitActorTag;                                      // 0x02CC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TriggerThickness;                                  // 0x02D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 TriggerColor;                                      // 0x02D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOpacityFill;                                      // 0x02DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnabled;                                          // 0x02DD(0x0001)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DE[0x2];                                      // 0x02DE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UEcsActorComponent*                     EcsActor;                                          // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class AActor*>                           OverlappingActors;                                 // 0x02E8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	void SetEnabled(bool bInEnabled);

	bool IsEnabled() const;
	TArray<class AActor*> K2_GetFilteredOverlappingActors(const struct FTedPawnFilter& InFilter) const;
	TArray<class AActor*> K2_GetOverlappingActors() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedTriggerVolume">();
	}
	static class ATedTriggerVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedTriggerVolume>();
	}
};
static_assert(alignof(ATedTriggerVolume) == 0x000008, "Wrong alignment on ATedTriggerVolume");
static_assert(sizeof(ATedTriggerVolume) == 0x000338, "Wrong size on ATedTriggerVolume");
static_assert(offsetof(ATedTriggerVolume, Mobility) == 0x0002C8, "Member 'ATedTriggerVolume::Mobility' has a wrong offset!");
static_assert(offsetof(ATedTriggerVolume, bAutoEnabled) == 0x0002C9, "Member 'ATedTriggerVolume::bAutoEnabled' has a wrong offset!");
static_assert(offsetof(ATedTriggerVolume, InitActorTag) == 0x0002CC, "Member 'ATedTriggerVolume::InitActorTag' has a wrong offset!");
static_assert(offsetof(ATedTriggerVolume, TriggerThickness) == 0x0002D4, "Member 'ATedTriggerVolume::TriggerThickness' has a wrong offset!");
static_assert(offsetof(ATedTriggerVolume, TriggerColor) == 0x0002D8, "Member 'ATedTriggerVolume::TriggerColor' has a wrong offset!");
static_assert(offsetof(ATedTriggerVolume, bOpacityFill) == 0x0002DC, "Member 'ATedTriggerVolume::bOpacityFill' has a wrong offset!");
static_assert(offsetof(ATedTriggerVolume, bEnabled) == 0x0002DD, "Member 'ATedTriggerVolume::bEnabled' has a wrong offset!");
static_assert(offsetof(ATedTriggerVolume, EcsActor) == 0x0002E0, "Member 'ATedTriggerVolume::EcsActor' has a wrong offset!");
static_assert(offsetof(ATedTriggerVolume, OverlappingActors) == 0x0002E8, "Member 'ATedTriggerVolume::OverlappingActors' has a wrong offset!");

// Class Tempest.TedUIPresenceAgent
// 0x0000 (0x0000 - 0x0000)
class ITedUIPresenceAgent final
{
public:
	class FText GetDisplayDescription() const;
	const class FText GetDisplayName() const;
	class UTexture2D* GetDisplayTexture() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUIPresenceAgent">();
	}
	static class ITedUIPresenceAgent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITedUIPresenceAgent>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITedUIPresenceAgent) == 0x000001, "Wrong alignment on ITedUIPresenceAgent");
static_assert(sizeof(ITedUIPresenceAgent) == 0x000001, "Wrong size on ITedUIPresenceAgent");

// Class Tempest.TedUnitCommand_AirDrop
// 0x0018 (0x0590 - 0x0578)
class UTedUnitCommand_AirDrop : public UTedUnitCommand_AirMission
{
public:
	TArray<struct FAirDropUnitData>               UnitsToSpawnData;                                  // 0x0578(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         DistanceBetweenUnits;                              // 0x0588(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IgnoreUpcomingPopulation;                          // 0x058C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58D[0x3];                                      // 0x058D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitCommand_AirDrop">();
	}
	static class UTedUnitCommand_AirDrop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUnitCommand_AirDrop>();
	}
};
static_assert(alignof(UTedUnitCommand_AirDrop) == 0x000008, "Wrong alignment on UTedUnitCommand_AirDrop");
static_assert(sizeof(UTedUnitCommand_AirDrop) == 0x000590, "Wrong size on UTedUnitCommand_AirDrop");
static_assert(offsetof(UTedUnitCommand_AirDrop, UnitsToSpawnData) == 0x000578, "Member 'UTedUnitCommand_AirDrop::UnitsToSpawnData' has a wrong offset!");
static_assert(offsetof(UTedUnitCommand_AirDrop, DistanceBetweenUnits) == 0x000588, "Member 'UTedUnitCommand_AirDrop::DistanceBetweenUnits' has a wrong offset!");
static_assert(offsetof(UTedUnitCommand_AirDrop, IgnoreUpcomingPopulation) == 0x00058C, "Member 'UTedUnitCommand_AirDrop::IgnoreUpcomingPopulation' has a wrong offset!");

// Class Tempest.TedUnitCommand_AttackMove
// 0x0000 (0x0580 - 0x0580)
class UTedUnitCommand_AttackMove : public UTedPawnCommand_AttackBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitCommand_AttackMove">();
	}
	static class UTedUnitCommand_AttackMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUnitCommand_AttackMove>();
	}
};
static_assert(alignof(UTedUnitCommand_AttackMove) == 0x000008, "Wrong alignment on UTedUnitCommand_AttackMove");
static_assert(sizeof(UTedUnitCommand_AttackMove) == 0x000580, "Wrong size on UTedUnitCommand_AttackMove");

// Class Tempest.TedUnitCommand_CaptureStructure
// 0x0000 (0x05C0 - 0x05C0)
class UTedUnitCommand_CaptureStructure : public UTedPawnCommandWithBehavior_Ability
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitCommand_CaptureStructure">();
	}
	static class UTedUnitCommand_CaptureStructure* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUnitCommand_CaptureStructure>();
	}
};
static_assert(alignof(UTedUnitCommand_CaptureStructure) == 0x000008, "Wrong alignment on UTedUnitCommand_CaptureStructure");
static_assert(sizeof(UTedUnitCommand_CaptureStructure) == 0x0005C0, "Wrong size on UTedUnitCommand_CaptureStructure");

// Class Tempest.TedUnitCommand_ChangeConformationState
// 0x0010 (0x0580 - 0x0570)
class UTedUnitCommand_ChangeConformationState : public UTedPawnCommandWithBehavior
{
public:
	struct FGameplayTag                           State;                                             // 0x0570(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DesiredStateValue;                                 // 0x0578(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_57C[0x4];                                      // 0x057C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitCommand_ChangeConformationState">();
	}
	static class UTedUnitCommand_ChangeConformationState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUnitCommand_ChangeConformationState>();
	}
};
static_assert(alignof(UTedUnitCommand_ChangeConformationState) == 0x000008, "Wrong alignment on UTedUnitCommand_ChangeConformationState");
static_assert(sizeof(UTedUnitCommand_ChangeConformationState) == 0x000580, "Wrong size on UTedUnitCommand_ChangeConformationState");
static_assert(offsetof(UTedUnitCommand_ChangeConformationState, State) == 0x000570, "Member 'UTedUnitCommand_ChangeConformationState::State' has a wrong offset!");
static_assert(offsetof(UTedUnitCommand_ChangeConformationState, DesiredStateValue) == 0x000578, "Member 'UTedUnitCommand_ChangeConformationState::DesiredStateValue' has a wrong offset!");

// Class Tempest.TedUnitCommand_DeployStructure_StructureHarvester
// 0x0000 (0x05C8 - 0x05C8)
class UTedUnitCommand_DeployStructure_StructureHarvester : public UTedUnitCommand_DeployStructure
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitCommand_DeployStructure_StructureHarvester">();
	}
	static class UTedUnitCommand_DeployStructure_StructureHarvester* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUnitCommand_DeployStructure_StructureHarvester>();
	}
};
static_assert(alignof(UTedUnitCommand_DeployStructure_StructureHarvester) == 0x000008, "Wrong alignment on UTedUnitCommand_DeployStructure_StructureHarvester");
static_assert(sizeof(UTedUnitCommand_DeployStructure_StructureHarvester) == 0x0005C8, "Wrong size on UTedUnitCommand_DeployStructure_StructureHarvester");

// Class Tempest.TedUnitCommand_DisarmMine
// 0x0000 (0x0570 - 0x0570)
class UTedUnitCommand_DisarmMine : public UTedPawnCommandWithBehavior
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitCommand_DisarmMine">();
	}
	static class UTedUnitCommand_DisarmMine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUnitCommand_DisarmMine>();
	}
};
static_assert(alignof(UTedUnitCommand_DisarmMine) == 0x000008, "Wrong alignment on UTedUnitCommand_DisarmMine");
static_assert(sizeof(UTedUnitCommand_DisarmMine) == 0x000570, "Wrong size on UTedUnitCommand_DisarmMine");

// Class Tempest.TedUnitCommand_EnterContainer
// 0x0000 (0x0570 - 0x0570)
class UTedUnitCommand_EnterContainer : public UTedPawnCommandWithBehavior
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitCommand_EnterContainer">();
	}
	static class UTedUnitCommand_EnterContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUnitCommand_EnterContainer>();
	}
};
static_assert(alignof(UTedUnitCommand_EnterContainer) == 0x000008, "Wrong alignment on UTedUnitCommand_EnterContainer");
static_assert(sizeof(UTedUnitCommand_EnterContainer) == 0x000570, "Wrong size on UTedUnitCommand_EnterContainer");

// Class Tempest.TedUnitCommand_Escort
// 0x0000 (0x0570 - 0x0570)
class UTedUnitCommand_Escort : public UTedPawnCommandWithBehavior
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitCommand_Escort">();
	}
	static class UTedUnitCommand_Escort* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUnitCommand_Escort>();
	}
};
static_assert(alignof(UTedUnitCommand_Escort) == 0x000008, "Wrong alignment on UTedUnitCommand_Escort");
static_assert(sizeof(UTedUnitCommand_Escort) == 0x000570, "Wrong size on UTedUnitCommand_Escort");

// Class Tempest.TedUnitCommand_Follow
// 0x0000 (0x0570 - 0x0570)
class UTedUnitCommand_Follow : public UTedPawnCommandWithBehavior
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitCommand_Follow">();
	}
	static class UTedUnitCommand_Follow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUnitCommand_Follow>();
	}
};
static_assert(alignof(UTedUnitCommand_Follow) == 0x000008, "Wrong alignment on UTedUnitCommand_Follow");
static_assert(sizeof(UTedUnitCommand_Follow) == 0x000570, "Wrong size on UTedUnitCommand_Follow");

// Class Tempest.TedUnitCommand_HoldPosition
// 0x0000 (0x0570 - 0x0570)
class UTedUnitCommand_HoldPosition : public UTedPawnCommandWithBehavior
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitCommand_HoldPosition">();
	}
	static class UTedUnitCommand_HoldPosition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUnitCommand_HoldPosition>();
	}
};
static_assert(alignof(UTedUnitCommand_HoldPosition) == 0x000008, "Wrong alignment on UTedUnitCommand_HoldPosition");
static_assert(sizeof(UTedUnitCommand_HoldPosition) == 0x000570, "Wrong size on UTedUnitCommand_HoldPosition");

// Class Tempest.TedUnitCommand_Land
// 0x0000 (0x0570 - 0x0570)
class UTedUnitCommand_Land : public UTedPawnCommandWithBehavior
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitCommand_Land">();
	}
	static class UTedUnitCommand_Land* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUnitCommand_Land>();
	}
};
static_assert(alignof(UTedUnitCommand_Land) == 0x000008, "Wrong alignment on UTedUnitCommand_Land");
static_assert(sizeof(UTedUnitCommand_Land) == 0x000570, "Wrong size on UTedUnitCommand_Land");

// Class Tempest.TedUnitCommand_Unload
// 0x0000 (0x0570 - 0x0570)
class UTedUnitCommand_Unload : public UTedPawnCommandWithBehavior
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitCommand_Unload">();
	}
	static class UTedUnitCommand_Unload* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUnitCommand_Unload>();
	}
};
static_assert(alignof(UTedUnitCommand_Unload) == 0x000008, "Wrong alignment on UTedUnitCommand_Unload");
static_assert(sizeof(UTedUnitCommand_Unload) == 0x000570, "Wrong size on UTedUnitCommand_Unload");

// Class Tempest.TedUnitMovementComponentManager
// 0x0060 (0x02F0 - 0x0290)
class ATedUnitMovementComponentManager final : public AActor
{
public:
	uint8                                         Pad_290[0x60];                                     // 0x0290(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitMovementComponentManager">();
	}
	static class ATedUnitMovementComponentManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedUnitMovementComponentManager>();
	}
};
static_assert(alignof(ATedUnitMovementComponentManager) == 0x000008, "Wrong alignment on ATedUnitMovementComponentManager");
static_assert(sizeof(ATedUnitMovementComponentManager) == 0x0002F0, "Wrong size on ATedUnitMovementComponentManager");

// Class Tempest.TedPreviewSkeletalMeshComponent
// 0x0000 (0x0F80 - 0x0F80)
class UTedPreviewSkeletalMeshComponent final : public USkeletalMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedPreviewSkeletalMeshComponent">();
	}
	static class UTedPreviewSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedPreviewSkeletalMeshComponent>();
	}
};
static_assert(alignof(UTedPreviewSkeletalMeshComponent) == 0x000010, "Wrong alignment on UTedPreviewSkeletalMeshComponent");
static_assert(sizeof(UTedPreviewSkeletalMeshComponent) == 0x000F80, "Wrong size on UTedPreviewSkeletalMeshComponent");

// Class Tempest.TedUnitSpawner
// 0x00F8 (0x03B0 - 0x02B8)
class ATedUnitSpawner final : public ANavigationObjectBase
{
public:
	TSubclassOf<class ATedUnitBase>               UnitClass;                                         // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedPlayerID                                  PlayerID;                                          // 0x02C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESpawnMode                                    SpawnMode;                                         // 0x02C1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C2[0x2];                                      // 0x02C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ActorTag;                                          // 0x02C4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseSplineOnSpawn;                                 // 0x02CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESpawnerMoveMode                              MoveMode;                                          // 0x02CD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CE[0x2];                                      // 0x02CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 MoveTargetActor;                                   // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                MoveTargetLocation;                                // 0x02D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class ATedUnitBase>, int32>  UnitsToSpawnForContainerOverride;                  // 0x02F0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTag>                   ActorTags;                                         // 0x0340(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class USplineComponent*                       SpawnSpline;                                       // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedPawnUpgradeTypeFlags                      InitialUpgradeFlags;                               // 0x0358(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_359[0x7];                                      // 0x0359(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DeveloperText;                                     // 0x0360(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 DebugColor;                                        // 0x0370(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 TextColor;                                         // 0x0374(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_378[0x18];                                     // 0x0378(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ATedUnitSpawner* SpawnerActor)> OnSpawnFailed;               // 0x0390(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A0[0x8];                                      // 0x03A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ATedUnitBase*                           SpawnedUnit;                                       // 0x03A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ReceiveSpawnCompleted();
	void ReceiveSpawnFailed();
	bool RequestSpawn(const bool bForce);

	class ATedUnitBase* GetSpawnedUnit() const;
	bool HasSpawnedUnit() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitSpawner">();
	}
	static class ATedUnitSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedUnitSpawner>();
	}
};
static_assert(alignof(ATedUnitSpawner) == 0x000008, "Wrong alignment on ATedUnitSpawner");
static_assert(sizeof(ATedUnitSpawner) == 0x0003B0, "Wrong size on ATedUnitSpawner");
static_assert(offsetof(ATedUnitSpawner, UnitClass) == 0x0002B8, "Member 'ATedUnitSpawner::UnitClass' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner, PlayerID) == 0x0002C0, "Member 'ATedUnitSpawner::PlayerID' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner, SpawnMode) == 0x0002C1, "Member 'ATedUnitSpawner::SpawnMode' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner, ActorTag) == 0x0002C4, "Member 'ATedUnitSpawner::ActorTag' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner, bUseSplineOnSpawn) == 0x0002CC, "Member 'ATedUnitSpawner::bUseSplineOnSpawn' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner, MoveMode) == 0x0002CD, "Member 'ATedUnitSpawner::MoveMode' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner, MoveTargetActor) == 0x0002D0, "Member 'ATedUnitSpawner::MoveTargetActor' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner, MoveTargetLocation) == 0x0002D8, "Member 'ATedUnitSpawner::MoveTargetLocation' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner, UnitsToSpawnForContainerOverride) == 0x0002F0, "Member 'ATedUnitSpawner::UnitsToSpawnForContainerOverride' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner, ActorTags) == 0x000340, "Member 'ATedUnitSpawner::ActorTags' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner, SpawnSpline) == 0x000350, "Member 'ATedUnitSpawner::SpawnSpline' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner, InitialUpgradeFlags) == 0x000358, "Member 'ATedUnitSpawner::InitialUpgradeFlags' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner, DeveloperText) == 0x000360, "Member 'ATedUnitSpawner::DeveloperText' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner, DebugColor) == 0x000370, "Member 'ATedUnitSpawner::DebugColor' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner, TextColor) == 0x000374, "Member 'ATedUnitSpawner::TextColor' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner, OnSpawnFailed) == 0x000390, "Member 'ATedUnitSpawner::OnSpawnFailed' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner, SpawnedUnit) == 0x0003A8, "Member 'ATedUnitSpawner::SpawnedUnit' has a wrong offset!");

// Class Tempest.TedUnitSpawnerComponent
// 0x0120 (0x01D0 - 0x00B0)
class UTedUnitSpawnerComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(class ATedUnitBase* SpawnedUnit)> OnUnitSpawned;                   // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bStarted)> OnSpawnTimerUpdated;                               // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x30];                                      // 0x00D0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUnitSpawnerComponentData              UnitSpawnerComponentData;                          // 0x0100(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         bUnitSpawnEnabled : 1;                             // 0x0160(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bInitialUnitSpawnEnabled : 1;                      // 0x0160(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_161[0x7];                                      // 0x0161(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATedUnitBase*>                   SpawnedUnits;                                      // 0x0168(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	TSet<class ATedUnitBase*>                     CachedRepPawnSet;                                  // 0x0178(0x0050)(NativeAccessSpecifierPrivate)
	struct FTimerHandle                           SpawnUnitTimerHandle;                              // 0x01C8(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnOwnerDestroyed(class AActor* Owner);
	void OnRep_Units();
	void SetInitialUnitSpawnEnabled(bool bEnable);
	void SetMaxAliveUnits(const int32 InMaxAliveUnits);
	void SetUnitRespawnTime(const float InUnitRespawnTime);
	void SetUnitSpawnEnabled(bool bEnable);

	int32 GetMaxAliveUnits() const;
	TArray<class ATedUnitBase*> GetSpawnedUnits() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitSpawnerComponent">();
	}
	static class UTedUnitSpawnerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUnitSpawnerComponent>();
	}
};
static_assert(alignof(UTedUnitSpawnerComponent) == 0x000008, "Wrong alignment on UTedUnitSpawnerComponent");
static_assert(sizeof(UTedUnitSpawnerComponent) == 0x0001D0, "Wrong size on UTedUnitSpawnerComponent");
static_assert(offsetof(UTedUnitSpawnerComponent, OnUnitSpawned) == 0x0000B0, "Member 'UTedUnitSpawnerComponent::OnUnitSpawned' has a wrong offset!");
static_assert(offsetof(UTedUnitSpawnerComponent, OnSpawnTimerUpdated) == 0x0000C0, "Member 'UTedUnitSpawnerComponent::OnSpawnTimerUpdated' has a wrong offset!");
static_assert(offsetof(UTedUnitSpawnerComponent, UnitSpawnerComponentData) == 0x000100, "Member 'UTedUnitSpawnerComponent::UnitSpawnerComponentData' has a wrong offset!");
static_assert(offsetof(UTedUnitSpawnerComponent, SpawnedUnits) == 0x000168, "Member 'UTedUnitSpawnerComponent::SpawnedUnits' has a wrong offset!");
static_assert(offsetof(UTedUnitSpawnerComponent, CachedRepPawnSet) == 0x000178, "Member 'UTedUnitSpawnerComponent::CachedRepPawnSet' has a wrong offset!");
static_assert(offsetof(UTedUnitSpawnerComponent, SpawnUnitTimerHandle) == 0x0001C8, "Member 'UTedUnitSpawnerComponent::SpawnUnitTimerHandle' has a wrong offset!");

// Class Tempest.TedUnitSpawner_Volume
// 0x0280 (0x0510 - 0x0290)
class ATedUnitSpawner_Volume final : public AActor
{
public:
	uint8                                         Pad_290[0x18];                                     // 0x0290(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          BoxComponent;                                      // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOpacityFill;                                      // 0x02B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BoxExtent;                                         // 0x02B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETedPlayerID                                  PlayerID;                                          // 0x02D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpawnMode                                    SpawnMode;                                         // 0x02D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D2[0x6];                                      // 0x02D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVolumeSpawnPayload                    SpawnPayload;                                      // 0x02D8(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         GridSpacing;                                       // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSnapLocationsToTerrain;                           // 0x02EC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ED[0x3];                                      // 0x02ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnTraceLength;                                  // 0x02F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        AirDropMovementLocations;                          // 0x02F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bOffsetSpawning;                                   // 0x0308(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_309[0x7];                                      // 0x0309(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OffsetSpawnCenter;                                 // 0x0310(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSnapOffsetLocationsToTerrain;                     // 0x0328(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_329[0x3];                                      // 0x0329(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SplineZOffset;                                     // 0x032C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnVFX;                                         // 0x0330(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_331[0xF];                                      // 0x0331(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnVfxTransformInfantry;                         // 0x0340(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             SpawnVfxTransformVehicle;                          // 0x03A0(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             SpawnVfxTransformAir;                              // 0x0400(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreSpawnDelay;                                     // 0x0460(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_464[0x4];                                      // 0x0464(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             MultipliersDataTable;                              // 0x0468(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_470[0x18];                                     // 0x0470(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVolumeSpawnInstance>           SpawnInstances;                                    // 0x0488(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FVolumeSpawnInstance>           SpawnInstancesDifficultyFiltered;                  // 0x0498(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class ATedUnitBase*>                   SpawnedUnits;                                      // 0x04A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class ATedUnitBase*>                   OffsetSpawnedUnits;                                // 0x04B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C8[0x28];                                     // 0x04C8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USplineComponent*>               SpawnSplineComponents;                             // 0x04F0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_500[0x10];                                     // 0x0500(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BuildSpawnInstances();
	void OnSaveGameLoaded(class USavedGameSlotInfo* Slot);
	TArray<class ATedUnitBase*> RequestSpawn(const bool bForce);

	void GetSpawnedUnits(TArray<class ATedUnitBase*>* OutSpawnedUnits) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUnitSpawner_Volume">();
	}
	static class ATedUnitSpawner_Volume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedUnitSpawner_Volume>();
	}
};
static_assert(alignof(ATedUnitSpawner_Volume) == 0x000010, "Wrong alignment on ATedUnitSpawner_Volume");
static_assert(sizeof(ATedUnitSpawner_Volume) == 0x000510, "Wrong size on ATedUnitSpawner_Volume");
static_assert(offsetof(ATedUnitSpawner_Volume, BoxComponent) == 0x0002A8, "Member 'ATedUnitSpawner_Volume::BoxComponent' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner_Volume, bOpacityFill) == 0x0002B0, "Member 'ATedUnitSpawner_Volume::bOpacityFill' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner_Volume, BoxExtent) == 0x0002B8, "Member 'ATedUnitSpawner_Volume::BoxExtent' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner_Volume, PlayerID) == 0x0002D0, "Member 'ATedUnitSpawner_Volume::PlayerID' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner_Volume, SpawnMode) == 0x0002D1, "Member 'ATedUnitSpawner_Volume::SpawnMode' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner_Volume, SpawnPayload) == 0x0002D8, "Member 'ATedUnitSpawner_Volume::SpawnPayload' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner_Volume, GridSpacing) == 0x0002E8, "Member 'ATedUnitSpawner_Volume::GridSpacing' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner_Volume, bSnapLocationsToTerrain) == 0x0002EC, "Member 'ATedUnitSpawner_Volume::bSnapLocationsToTerrain' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner_Volume, SpawnTraceLength) == 0x0002F0, "Member 'ATedUnitSpawner_Volume::SpawnTraceLength' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner_Volume, AirDropMovementLocations) == 0x0002F8, "Member 'ATedUnitSpawner_Volume::AirDropMovementLocations' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner_Volume, bOffsetSpawning) == 0x000308, "Member 'ATedUnitSpawner_Volume::bOffsetSpawning' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner_Volume, OffsetSpawnCenter) == 0x000310, "Member 'ATedUnitSpawner_Volume::OffsetSpawnCenter' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner_Volume, bSnapOffsetLocationsToTerrain) == 0x000328, "Member 'ATedUnitSpawner_Volume::bSnapOffsetLocationsToTerrain' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner_Volume, SplineZOffset) == 0x00032C, "Member 'ATedUnitSpawner_Volume::SplineZOffset' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner_Volume, bSpawnVFX) == 0x000330, "Member 'ATedUnitSpawner_Volume::bSpawnVFX' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner_Volume, SpawnVfxTransformInfantry) == 0x000340, "Member 'ATedUnitSpawner_Volume::SpawnVfxTransformInfantry' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner_Volume, SpawnVfxTransformVehicle) == 0x0003A0, "Member 'ATedUnitSpawner_Volume::SpawnVfxTransformVehicle' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner_Volume, SpawnVfxTransformAir) == 0x000400, "Member 'ATedUnitSpawner_Volume::SpawnVfxTransformAir' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner_Volume, PreSpawnDelay) == 0x000460, "Member 'ATedUnitSpawner_Volume::PreSpawnDelay' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner_Volume, MultipliersDataTable) == 0x000468, "Member 'ATedUnitSpawner_Volume::MultipliersDataTable' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner_Volume, SpawnInstances) == 0x000488, "Member 'ATedUnitSpawner_Volume::SpawnInstances' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner_Volume, SpawnInstancesDifficultyFiltered) == 0x000498, "Member 'ATedUnitSpawner_Volume::SpawnInstancesDifficultyFiltered' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner_Volume, SpawnedUnits) == 0x0004A8, "Member 'ATedUnitSpawner_Volume::SpawnedUnits' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner_Volume, OffsetSpawnedUnits) == 0x0004B8, "Member 'ATedUnitSpawner_Volume::OffsetSpawnedUnits' has a wrong offset!");
static_assert(offsetof(ATedUnitSpawner_Volume, SpawnSplineComponents) == 0x0004F0, "Member 'ATedUnitSpawner_Volume::SpawnSplineComponents' has a wrong offset!");

// Class Tempest.TedSpawnSettings
// 0x00F0 (0x0128 - 0x0038)
class UTedSpawnSettings final : public UDeveloperSettings
{
public:
	TSoftObjectPtr<class UNiagaraSystem>          PortalNiagaraSystemWorking;                        // 0x0038(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNiagaraSystem>          PortalNiagaraSystemCompleted;                      // 0x0060(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              PortalSpawnSound;                                  // 0x0088(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   AirDropCommandClass;                               // 0x00B0(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   AirDropInVolumeCommandClass;                       // 0x00D8(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   AirDropInVolumeFadeCommandClass;                   // 0x0100(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedSpawnSettings">();
	}
	static class UTedSpawnSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedSpawnSettings>();
	}
};
static_assert(alignof(UTedSpawnSettings) == 0x000008, "Wrong alignment on UTedSpawnSettings");
static_assert(sizeof(UTedSpawnSettings) == 0x000128, "Wrong size on UTedSpawnSettings");
static_assert(offsetof(UTedSpawnSettings, PortalNiagaraSystemWorking) == 0x000038, "Member 'UTedSpawnSettings::PortalNiagaraSystemWorking' has a wrong offset!");
static_assert(offsetof(UTedSpawnSettings, PortalNiagaraSystemCompleted) == 0x000060, "Member 'UTedSpawnSettings::PortalNiagaraSystemCompleted' has a wrong offset!");
static_assert(offsetof(UTedSpawnSettings, PortalSpawnSound) == 0x000088, "Member 'UTedSpawnSettings::PortalSpawnSound' has a wrong offset!");
static_assert(offsetof(UTedSpawnSettings, AirDropCommandClass) == 0x0000B0, "Member 'UTedSpawnSettings::AirDropCommandClass' has a wrong offset!");
static_assert(offsetof(UTedSpawnSettings, AirDropInVolumeCommandClass) == 0x0000D8, "Member 'UTedSpawnSettings::AirDropInVolumeCommandClass' has a wrong offset!");
static_assert(offsetof(UTedSpawnSettings, AirDropInVolumeFadeCommandClass) == 0x000100, "Member 'UTedSpawnSettings::AirDropInVolumeFadeCommandClass' has a wrong offset!");

// Class Tempest.TedUpgradeManager
// 0x0678 (0x06A8 - 0x0030)
class UTedUpgradeManager final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTedPlayerUpgradeData                  PlayerUpgradeData[0xA];                            // 0x0050(0x00A0)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<bool>                                  InitializedPlayers;                                // 0x0690(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class ATedUpgradeReplicationManager*          ReplicationManager;                                // 0x06A0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static void K2_ActivateUpgrade(const class UObject* WorldContextObject, const class UTedUpgrade* InUpgrade, const class ATedPlayerState* InPlayerState);
	static void K2_DeactivateUpgrade(const class UObject* WorldContextObject, const class UTedUpgrade* InUpgrade, const class ATedPlayerState* InPlayerState);
	static bool K2_IsUpgradeActive(const class UObject* WorldContextObject, const class UTedUpgrade* InUpgrade, const ETedPlayerID InPlayerID);

	void HandlePawnEndPlay(class AActor* InActor, EEndPlayReason InEndPlayReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUpgradeManager">();
	}
	static class UTedUpgradeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUpgradeManager>();
	}
};
static_assert(alignof(UTedUpgradeManager) == 0x000008, "Wrong alignment on UTedUpgradeManager");
static_assert(sizeof(UTedUpgradeManager) == 0x0006A8, "Wrong size on UTedUpgradeManager");
static_assert(offsetof(UTedUpgradeManager, PlayerUpgradeData) == 0x000050, "Member 'UTedUpgradeManager::PlayerUpgradeData' has a wrong offset!");
static_assert(offsetof(UTedUpgradeManager, InitializedPlayers) == 0x000690, "Member 'UTedUpgradeManager::InitializedPlayers' has a wrong offset!");
static_assert(offsetof(UTedUpgradeManager, ReplicationManager) == 0x0006A0, "Member 'UTedUpgradeManager::ReplicationManager' has a wrong offset!");

// Class Tempest.TedUpgradeReplicationManager
// 0x0018 (0x02A8 - 0x0290)
class ATedUpgradeReplicationManager final : public AActor
{
public:
	class UTedUpgradeManager*                     CachedUpgradeManager;                              // 0x0290(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTedReplicatedUpgradeInfo>      ReplicatedUpgradeInfo;                             // 0x0298(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)

public:
	void OnRep_ReplicatedUpgradeInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUpgradeReplicationManager">();
	}
	static class ATedUpgradeReplicationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedUpgradeReplicationManager>();
	}
};
static_assert(alignof(ATedUpgradeReplicationManager) == 0x000008, "Wrong alignment on ATedUpgradeReplicationManager");
static_assert(sizeof(ATedUpgradeReplicationManager) == 0x0002A8, "Wrong size on ATedUpgradeReplicationManager");
static_assert(offsetof(ATedUpgradeReplicationManager, CachedUpgradeManager) == 0x000290, "Member 'ATedUpgradeReplicationManager::CachedUpgradeManager' has a wrong offset!");
static_assert(offsetof(ATedUpgradeReplicationManager, ReplicatedUpgradeInfo) == 0x000298, "Member 'ATedUpgradeReplicationManager::ReplicatedUpgradeInfo' has a wrong offset!");

// Class Tempest.TedEquipment
// 0x0020 (0x00F8 - 0x00D8)
class UTedEquipment final : public UTedUpgrade
{
public:
	int32                                         RequisitionPointsCost;                             // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         EquipWeight;                                       // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedFaction                                   Faction;                                           // 0x00E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AssetRegistrySearchable, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UTedEquipment>>   IncompatibleEquipment;                             // 0x00E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedEquipment">();
	}
	static class UTedEquipment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedEquipment>();
	}
};
static_assert(alignof(UTedEquipment) == 0x000008, "Wrong alignment on UTedEquipment");
static_assert(sizeof(UTedEquipment) == 0x0000F8, "Wrong size on UTedEquipment");
static_assert(offsetof(UTedEquipment, RequisitionPointsCost) == 0x0000D8, "Member 'UTedEquipment::RequisitionPointsCost' has a wrong offset!");
static_assert(offsetof(UTedEquipment, EquipWeight) == 0x0000DC, "Member 'UTedEquipment::EquipWeight' has a wrong offset!");
static_assert(offsetof(UTedEquipment, Faction) == 0x0000E0, "Member 'UTedEquipment::Faction' has a wrong offset!");
static_assert(offsetof(UTedEquipment, IncompatibleEquipment) == 0x0000E8, "Member 'UTedEquipment::IncompatibleEquipment' has a wrong offset!");

// Class Tempest.TedUserInfoLatentFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UTedUserInfoLatentFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void RequestUserInfo(class UObject* InWorldContext, const struct FLatentActionInfo& LatentInfo, const struct FLatentActionSaveGameData& SaveInfo, const class FString& InHydraId, bool* bOutDownloadUserInfoSucceeded, bool* bOutDownloadUserAvatarSucceeded, bool* bOutDownloadUserPreferencesSucceeded, struct FTedUserInfo* OutDownloadedUserInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUserInfoLatentFunctionLibrary">();
	}
	static class UTedUserInfoLatentFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUserInfoLatentFunctionLibrary>();
	}
};
static_assert(alignof(UTedUserInfoLatentFunctionLibrary) == 0x000008, "Wrong alignment on UTedUserInfoLatentFunctionLibrary");
static_assert(sizeof(UTedUserInfoLatentFunctionLibrary) == 0x000028, "Wrong size on UTedUserInfoLatentFunctionLibrary");

// Class Tempest.TedUserInfoSubsystem
// 0x00A0 (0x00D0 - 0x0030)
class UTedUserInfoSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UTexture2D>>      UserAvatars;                                       // 0x0050(0x0010)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UTexture2D*>                     CachedAvatars;                                     // 0x0060(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x60];                                      // 0x0070(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHydraLogin(const bool bLoginSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUserInfoSubsystem">();
	}
	static class UTedUserInfoSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUserInfoSubsystem>();
	}
};
static_assert(alignof(UTedUserInfoSubsystem) == 0x000008, "Wrong alignment on UTedUserInfoSubsystem");
static_assert(sizeof(UTedUserInfoSubsystem) == 0x0000D0, "Wrong size on UTedUserInfoSubsystem");
static_assert(offsetof(UTedUserInfoSubsystem, UserAvatars) == 0x000050, "Member 'UTedUserInfoSubsystem::UserAvatars' has a wrong offset!");
static_assert(offsetof(UTedUserInfoSubsystem, CachedAvatars) == 0x000060, "Member 'UTedUserInfoSubsystem::CachedAvatars' has a wrong offset!");

// Class Tempest.TedUserSettings
// 0x0170 (0x02B8 - 0x0148)
class UTedUserSettings final : public UGameUserSettings
{
public:
	TMulticastInlineDelegate<void(const class FName& SettingName)> OnPreorderSettingChanged;         // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TOptional<class UTedUserSettings_UpscalerSettingsExtension*> UpscalerSettingsExtension;          // 0x0158(0x0010)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETedUpscaler                                  Upscaler;                                          // 0x0168(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETedUpscalerPreset                            UpscalerPreset;                                    // 0x0169(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFrameGenerationEnabled;                           // 0x016A(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_16B[0x1];                                      // 0x016B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DisplayGamma;                                      // 0x016C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EColorVisionDeficiency                        ColorVisionType;                                   // 0x0170(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_171[0x3];                                      // 0x0171(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ColorVisionStrength;                               // 0x0174(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UIScale;                                           // 0x0178(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UIStatusEffectScale;                               // 0x017C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUIStatusEffectEnabled;                            // 0x0180(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHealthBarsDisplayMode                        HealthBarsDisplayMode;                             // 0x0181(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPerfStatsOverlayEnabled;                          // 0x0182(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_183[0x1D];                                     // 0x0183(0x001D)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUnitsOutlineEnabled;                              // 0x01A0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCameraShakeEnabled;                               // 0x01A1(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAreHintsEnabled;                                  // 0x01A2(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSubtitlesEnabled;                                 // 0x01A3(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SubtitlesScale;                                    // 0x01A4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAreMapPingEnabled;                                // 0x01A8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMouseCaptureEnabled;                              // 0x01A9(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSoftwareCursorEnabled;                            // 0x01AA(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPauseOutOfFocus;                                  // 0x01AB(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AC[0x2];                                      // 0x01AC(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPreOrderContentEnabled;                           // 0x01AE(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreOrderChatIconEnabled;                          // 0x01AF(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreOrderMenuBackdropEnabled;                      // 0x01B0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreOrderConstructionYardEnabled;                  // 0x01B1(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreOrderNeutralBuildingsEnabled;                  // 0x01B2(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreOrderMarqueeSelectionEnabled;                  // 0x01B3(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreOrderUnitSelectionShapeEnabled;                // 0x01B4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreOrderProfileSkinEnabled;                       // 0x01B5(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETedPreOrderPlayerAvatar                      PreOrderPlayerAvatar;                              // 0x01B6(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETedPreOrderMouseCursorSkin                   PreOrderMouseCursorSkin;                           // 0x01B7(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETedDefaultMoveBehavior                       DefaultMoveBehavior;                               // 0x01B8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedDefaultAttackBehavior                     DefaultAttackBehavior;                             // 0x01B9(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETedAbilityCyclingBehavior                    AbilityCyclingBehavior;                            // 0x01BA(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1BB[0x1];                                      // 0x01BB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMultiplayerScreenSavedData            MultiplayerScreenSavedData;                        // 0x01BC(0x001C)(Config, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTedRankedMapState>             SavedMaps_Ranked_1v1;                              // 0x01D8(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTedRankedMapState>             SavedMaps_Ranked_2v2;                              // 0x01E8(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTedRankedMapState>             SavedMaps_Unranked_1v1;                            // 0x01F8(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTedRankedMapState>             SavedMaps_Unranked_2v2;                            // 0x0208(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	bool                                          bShouldShowEULA;                                   // 0x0218(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int8                                          TeamColorIntensity;                                // 0x0219(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAttitudePlayerColors;                             // 0x021A(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21B[0x5];                                      // 0x021B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ERTSColor>                             AttitudePlayerColors;                              // 0x0220(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TArray<ERTSColor>                             ColorBlindAttitudePlayerColors;                    // 0x0230(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TArray<ERTSColor>                             SelectionColors;                                   // 0x0240(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TArray<ERTSColor>                             ColorBlindSelectionColors;                         // 0x0250(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	bool                                          bColorBlindMode;                                   // 0x0260(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_261[0x7];                                      // 0x0261(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class URTSColorSubsystem*                     CachedRTSColorSubsystem;                           // 0x0268(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_270[0x18];                                     // 0x0270(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTedAudioSetting>               AudioVolumes;                                      // 0x0288(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	float                                         CameraEdgeScrollSpeedMultiplier;                   // 0x0298(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraKeyboardScrollSpeedMultiplier;               // 0x029C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraDragScrollSpeedMultiplier;                   // 0x02A0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraZoomSpeedMultiplier;                         // 0x02A4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInvertCameraDragScroll;                           // 0x02A8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsingClassicMouseControls;                        // 0x02A9(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsingSmartDragSelect;                             // 0x02AA(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AB[0x1];                                      // 0x02AB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ControlsPreset;                                    // 0x02AC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisablePointerSounds;                             // 0x02B0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTelemetryEnabled;                                 // 0x02B1(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B2[0x6];                                      // 0x02B2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTedUserSettings* Get();
	static void SetSlotToDefaults(ETedSettingSlot InSettingSlot);

	bool IsPreOrderMenuBackdropEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUserSettings">();
	}
	static class UTedUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUserSettings>();
	}
};
static_assert(alignof(UTedUserSettings) == 0x000008, "Wrong alignment on UTedUserSettings");
static_assert(sizeof(UTedUserSettings) == 0x0002B8, "Wrong size on UTedUserSettings");
static_assert(offsetof(UTedUserSettings, OnPreorderSettingChanged) == 0x000148, "Member 'UTedUserSettings::OnPreorderSettingChanged' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, UpscalerSettingsExtension) == 0x000158, "Member 'UTedUserSettings::UpscalerSettingsExtension' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, Upscaler) == 0x000168, "Member 'UTedUserSettings::Upscaler' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, UpscalerPreset) == 0x000169, "Member 'UTedUserSettings::UpscalerPreset' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, bFrameGenerationEnabled) == 0x00016A, "Member 'UTedUserSettings::bFrameGenerationEnabled' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, DisplayGamma) == 0x00016C, "Member 'UTedUserSettings::DisplayGamma' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, ColorVisionType) == 0x000170, "Member 'UTedUserSettings::ColorVisionType' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, ColorVisionStrength) == 0x000174, "Member 'UTedUserSettings::ColorVisionStrength' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, UIScale) == 0x000178, "Member 'UTedUserSettings::UIScale' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, UIStatusEffectScale) == 0x00017C, "Member 'UTedUserSettings::UIStatusEffectScale' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, bUIStatusEffectEnabled) == 0x000180, "Member 'UTedUserSettings::bUIStatusEffectEnabled' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, HealthBarsDisplayMode) == 0x000181, "Member 'UTedUserSettings::HealthBarsDisplayMode' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, bPerfStatsOverlayEnabled) == 0x000182, "Member 'UTedUserSettings::bPerfStatsOverlayEnabled' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, bUnitsOutlineEnabled) == 0x0001A0, "Member 'UTedUserSettings::bUnitsOutlineEnabled' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, bCameraShakeEnabled) == 0x0001A1, "Member 'UTedUserSettings::bCameraShakeEnabled' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, bAreHintsEnabled) == 0x0001A2, "Member 'UTedUserSettings::bAreHintsEnabled' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, bSubtitlesEnabled) == 0x0001A3, "Member 'UTedUserSettings::bSubtitlesEnabled' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, SubtitlesScale) == 0x0001A4, "Member 'UTedUserSettings::SubtitlesScale' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, bAreMapPingEnabled) == 0x0001A8, "Member 'UTedUserSettings::bAreMapPingEnabled' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, bMouseCaptureEnabled) == 0x0001A9, "Member 'UTedUserSettings::bMouseCaptureEnabled' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, bSoftwareCursorEnabled) == 0x0001AA, "Member 'UTedUserSettings::bSoftwareCursorEnabled' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, bPauseOutOfFocus) == 0x0001AB, "Member 'UTedUserSettings::bPauseOutOfFocus' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, bPreOrderContentEnabled) == 0x0001AE, "Member 'UTedUserSettings::bPreOrderContentEnabled' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, bPreOrderChatIconEnabled) == 0x0001AF, "Member 'UTedUserSettings::bPreOrderChatIconEnabled' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, bPreOrderMenuBackdropEnabled) == 0x0001B0, "Member 'UTedUserSettings::bPreOrderMenuBackdropEnabled' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, bPreOrderConstructionYardEnabled) == 0x0001B1, "Member 'UTedUserSettings::bPreOrderConstructionYardEnabled' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, bPreOrderNeutralBuildingsEnabled) == 0x0001B2, "Member 'UTedUserSettings::bPreOrderNeutralBuildingsEnabled' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, bPreOrderMarqueeSelectionEnabled) == 0x0001B3, "Member 'UTedUserSettings::bPreOrderMarqueeSelectionEnabled' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, bPreOrderUnitSelectionShapeEnabled) == 0x0001B4, "Member 'UTedUserSettings::bPreOrderUnitSelectionShapeEnabled' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, bPreOrderProfileSkinEnabled) == 0x0001B5, "Member 'UTedUserSettings::bPreOrderProfileSkinEnabled' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, PreOrderPlayerAvatar) == 0x0001B6, "Member 'UTedUserSettings::PreOrderPlayerAvatar' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, PreOrderMouseCursorSkin) == 0x0001B7, "Member 'UTedUserSettings::PreOrderMouseCursorSkin' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, DefaultMoveBehavior) == 0x0001B8, "Member 'UTedUserSettings::DefaultMoveBehavior' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, DefaultAttackBehavior) == 0x0001B9, "Member 'UTedUserSettings::DefaultAttackBehavior' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, AbilityCyclingBehavior) == 0x0001BA, "Member 'UTedUserSettings::AbilityCyclingBehavior' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, MultiplayerScreenSavedData) == 0x0001BC, "Member 'UTedUserSettings::MultiplayerScreenSavedData' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, SavedMaps_Ranked_1v1) == 0x0001D8, "Member 'UTedUserSettings::SavedMaps_Ranked_1v1' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, SavedMaps_Ranked_2v2) == 0x0001E8, "Member 'UTedUserSettings::SavedMaps_Ranked_2v2' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, SavedMaps_Unranked_1v1) == 0x0001F8, "Member 'UTedUserSettings::SavedMaps_Unranked_1v1' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, SavedMaps_Unranked_2v2) == 0x000208, "Member 'UTedUserSettings::SavedMaps_Unranked_2v2' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, bShouldShowEULA) == 0x000218, "Member 'UTedUserSettings::bShouldShowEULA' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, TeamColorIntensity) == 0x000219, "Member 'UTedUserSettings::TeamColorIntensity' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, bAttitudePlayerColors) == 0x00021A, "Member 'UTedUserSettings::bAttitudePlayerColors' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, AttitudePlayerColors) == 0x000220, "Member 'UTedUserSettings::AttitudePlayerColors' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, ColorBlindAttitudePlayerColors) == 0x000230, "Member 'UTedUserSettings::ColorBlindAttitudePlayerColors' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, SelectionColors) == 0x000240, "Member 'UTedUserSettings::SelectionColors' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, ColorBlindSelectionColors) == 0x000250, "Member 'UTedUserSettings::ColorBlindSelectionColors' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, bColorBlindMode) == 0x000260, "Member 'UTedUserSettings::bColorBlindMode' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, CachedRTSColorSubsystem) == 0x000268, "Member 'UTedUserSettings::CachedRTSColorSubsystem' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, AudioVolumes) == 0x000288, "Member 'UTedUserSettings::AudioVolumes' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, CameraEdgeScrollSpeedMultiplier) == 0x000298, "Member 'UTedUserSettings::CameraEdgeScrollSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, CameraKeyboardScrollSpeedMultiplier) == 0x00029C, "Member 'UTedUserSettings::CameraKeyboardScrollSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, CameraDragScrollSpeedMultiplier) == 0x0002A0, "Member 'UTedUserSettings::CameraDragScrollSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, CameraZoomSpeedMultiplier) == 0x0002A4, "Member 'UTedUserSettings::CameraZoomSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, bInvertCameraDragScroll) == 0x0002A8, "Member 'UTedUserSettings::bInvertCameraDragScroll' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, bUsingClassicMouseControls) == 0x0002A9, "Member 'UTedUserSettings::bUsingClassicMouseControls' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, bUsingSmartDragSelect) == 0x0002AA, "Member 'UTedUserSettings::bUsingSmartDragSelect' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, ControlsPreset) == 0x0002AC, "Member 'UTedUserSettings::ControlsPreset' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, bDisablePointerSounds) == 0x0002B0, "Member 'UTedUserSettings::bDisablePointerSounds' has a wrong offset!");
static_assert(offsetof(UTedUserSettings, bTelemetryEnabled) == 0x0002B1, "Member 'UTedUserSettings::bTelemetryEnabled' has a wrong offset!");

// Class Tempest.TedUserSettings_UpscalerSettingsExtension
// 0x0000 (0x0028 - 0x0028)
class UTedUserSettings_UpscalerSettingsExtension : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUserSettings_UpscalerSettingsExtension">();
	}
	static class UTedUserSettings_UpscalerSettingsExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUserSettings_UpscalerSettingsExtension>();
	}
};
static_assert(alignof(UTedUserSettings_UpscalerSettingsExtension) == 0x000008, "Wrong alignment on UTedUserSettings_UpscalerSettingsExtension");
static_assert(sizeof(UTedUserSettings_UpscalerSettingsExtension) == 0x000028, "Wrong size on UTedUserSettings_UpscalerSettingsExtension");

// Class Tempest.TedUserSettingsProjectConfiguration
// 0x0028 (0x0050 - 0x0028)
class UTedUserSettingsProjectConfiguration final : public UObject
{
public:
	struct FSoftClassPath                         GameUserSettingsUpscalersExtensionClassName;       // 0x0028(0x0020)(Edit, ZeroConstructor, Config, GlobalConfig, NoClear, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UTedUserSettings_UpscalerSettingsExtension> GameUserSettingsUpscalersExtensionClass; // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUserSettingsProjectConfiguration">();
	}
	static class UTedUserSettingsProjectConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUserSettingsProjectConfiguration>();
	}
};
static_assert(alignof(UTedUserSettingsProjectConfiguration) == 0x000008, "Wrong alignment on UTedUserSettingsProjectConfiguration");
static_assert(sizeof(UTedUserSettingsProjectConfiguration) == 0x000050, "Wrong size on UTedUserSettingsProjectConfiguration");
static_assert(offsetof(UTedUserSettingsProjectConfiguration, GameUserSettingsUpscalersExtensionClassName) == 0x000028, "Member 'UTedUserSettingsProjectConfiguration::GameUserSettingsUpscalersExtensionClassName' has a wrong offset!");
static_assert(offsetof(UTedUserSettingsProjectConfiguration, GameUserSettingsUpscalersExtensionClass) == 0x000048, "Member 'UTedUserSettingsProjectConfiguration::GameUserSettingsUpscalersExtensionClass' has a wrong offset!");

// Class Tempest.TedUtilityAIConsideration_ValidAttackTarget
// 0x0000 (0x0060 - 0x0060)
class UTedUtilityAIConsideration_ValidAttackTarget final : public UUtilityAIConsideration
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUtilityAIConsideration_ValidAttackTarget">();
	}
	static class UTedUtilityAIConsideration_ValidAttackTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUtilityAIConsideration_ValidAttackTarget>();
	}
};
static_assert(alignof(UTedUtilityAIConsideration_ValidAttackTarget) == 0x000008, "Wrong alignment on UTedUtilityAIConsideration_ValidAttackTarget");
static_assert(sizeof(UTedUtilityAIConsideration_ValidAttackTarget) == 0x000060, "Wrong size on UTedUtilityAIConsideration_ValidAttackTarget");

// Class Tempest.TedUtilityAIConsideration_ContainerFilter
// 0x0000 (0x0060 - 0x0060)
class UTedUtilityAIConsideration_ContainerFilter final : public UUtilityAIConsideration
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUtilityAIConsideration_ContainerFilter">();
	}
	static class UTedUtilityAIConsideration_ContainerFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUtilityAIConsideration_ContainerFilter>();
	}
};
static_assert(alignof(UTedUtilityAIConsideration_ContainerFilter) == 0x000008, "Wrong alignment on UTedUtilityAIConsideration_ContainerFilter");
static_assert(sizeof(UTedUtilityAIConsideration_ContainerFilter) == 0x000060, "Wrong size on UTedUtilityAIConsideration_ContainerFilter");

// Class Tempest.TedUtilityAIConsideration_ExecutingCommand
// 0x0028 (0x0088 - 0x0060)
class UTedUtilityAIConsideration_ExecutingCommand final : public UUtilityAIConsideration
{
public:
	struct FGameplayTagContainer                  CommandTypes;                                      // 0x0060(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bExactMatch;                                       // 0x0080(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUtilityAIConsideration_ExecutingCommand">();
	}
	static class UTedUtilityAIConsideration_ExecutingCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUtilityAIConsideration_ExecutingCommand>();
	}
};
static_assert(alignof(UTedUtilityAIConsideration_ExecutingCommand) == 0x000008, "Wrong alignment on UTedUtilityAIConsideration_ExecutingCommand");
static_assert(sizeof(UTedUtilityAIConsideration_ExecutingCommand) == 0x000088, "Wrong size on UTedUtilityAIConsideration_ExecutingCommand");
static_assert(offsetof(UTedUtilityAIConsideration_ExecutingCommand, CommandTypes) == 0x000060, "Member 'UTedUtilityAIConsideration_ExecutingCommand::CommandTypes' has a wrong offset!");
static_assert(offsetof(UTedUtilityAIConsideration_ExecutingCommand, bExactMatch) == 0x000080, "Member 'UTedUtilityAIConsideration_ExecutingCommand::bExactMatch' has a wrong offset!");

// Class Tempest.TedUtils
// 0x0000 (0x0028 - 0x0028)
class UTedUtils final : public UBlueprintFunctionLibrary
{
public:
	static bool AdjustUnitSpawnLocation(const class UObject* WorldContextObject, TSubclassOf<class ATedUnitBase> UnitClass, const struct FVector& InLocation, struct FVector& OutLocation, float UnitRadiusMultiplier, float Extent2D);
	static void ApplyGEToPawnsInRange(const class UObject* WorldContextObject, const TSubclassOf<class UGameplayEffect> Effect, const struct FVector& EffectLocation, float EffectLevel, const float EffectRadius, const struct FTedUtilsPawnFilter& PawnFilter, class UAbilitySystemComponent* OwnerASC);
	static void CalculateFormation(int32 UnitCount, const struct FVector2D& Direction, const struct FVector2D& TargetLocation, const float UnitOffset, TArray<struct FVector2D>* OutLocations);
	static struct FVector2D CalculatePawnsLookAtLocation(const TArray<class ATedPawn*>& Pawns, const struct FVector2D& ViewerLocation);
	static bool CaptureStructure(class ATedStructureBase* Target, class AActor* Instigator, const ETedPlayerID NewOwner, bool bForceInstantCapture);
	static bool ClampLocationToNavigableArea(const class ATedUnitBase* Unit, const struct FVector& TargetLocation, const class AActor* TargetActor, struct FVector* OutAdjustedLocation);
	static void FindClosestPawnClusterToLocation(TArray<class ATedUnitBase*>* OutActorCluster, const struct FVector2D& Location);
	static bool FindValidGroundLocation(const class UObject* WorldContextObject, struct FVector* Location, const TSubclassOf<class UNavigationQueryFilter> FilterClass, const float Extent2D, class ARecastNavMesh* OverrideTargetNav);
	static bool FindValidGroundLocationWithMinArea(const class UObject* WorldContextObject, struct FVector* Location, const float MinArea, const bool bOptionalMinAreaRequirement, const TSubclassOf<class UNavigationQueryFilter> FilterClass, const float Extent2D, class ARecastNavMesh* OverrideTargetNav);
	static class FString GetAssetPath(const class UObject* InAsset);
	static TArray<ETedFaction> GetAvailablePlayerFactions();
	static TArray<ETedRankedFaction> GetAvailablePlayerFactions_Ranked();
	static TArray<ETedRankedTeam> GetAvailablePlayerTeams_Ranked();
	static bool GetButtonStyle(class USlateWidgetStyleAsset* InAsset, struct FButtonStyle* OutStyle);
	static bool GetButtonStyleFromWrapper(const struct FTedStyleAssetWrapper& InWrapper, struct FButtonStyle* OutStyle);
	static float GetCameraZoomPct(const class UObject* WorldContextObject, const bool bImmediate);
	static ETedServerType GetCurrentServerType(const class UObject* WorldContextObject);
	static struct FVector GetGroundLocation(const class UObject* WorldContextObject, const struct FVector2D& Location, class ARecastNavMesh* OverrideTargetNav, float Extent2D);
	static TSubclassOf<class UNavArea> GetGroundLocationAreaClass(const class UObject* WorldContextObject, const struct FVector2D& Location, class ARecastNavMesh* OverrideTargetNav);
	static TSubclassOf<class UNavArea> GetGroundLocationAreaClassFOW(const class UObject* WorldContextObject, const struct FVector2D& Location, TSubclassOf<class UNavArea> DefaultAreaClass, float DefaultZOffset, class ARecastNavMesh* OverrideTargetNav);
	static void GetMinMaxCoordsFromVectorArray(const TArray<struct FVector>& InVectorArray, struct FVector* OutMinCoords, struct FVector* OutMaxCoords);
	static class ARecastNavMesh* GetNavMeshForClass(class UObject* WorldContextObject, TSubclassOf<class APawn> PawnClass);
	static ENavigationQueryResult GetPathLength(const class UObject* WorldContextObject, const struct FVector2D& PathStart, const struct FVector2D& PathEnd, double* OutPathLength, class ARecastNavMesh* OverrideTargetNav, float Extent2D, TSubclassOf<class UNavigationQueryFilter> FilterClass);
	static void GetPawnsInCone(const class UObject* WorldContextObject, TArray<class ATedPawn*>* OutPawns, const struct FVector& Location, const struct FVector& Direction, const float MinLength, const float MaxLength, const float Angle, const struct FTedUtilsPawnFilter& Filter);
	static void GetPawnsInRange(const class UObject* WorldContextObject, TArray<class ATedPawn*>* OutPawns, const struct FVector& Location, const float Radius, const struct FTedUtilsPawnFilter& Filter);
	static struct FVector GetPlayerCameraLocation(const class UObject* WorldContextObject, int32 PlayerIndex);
	static struct FRTSPlayerColorPreset GetPlayerColorPreset(const class UObject* WorldContextObject, const ETedPlayerID PlayerID);
	static class ATedPlayerPawn* GetPlayerTedPawn(const class UObject* WorldContextObject, int32 PlayerIndex);
	static struct FVector GetPreCinematicPlayerCameraLocation(const class UObject* WorldContextObject);
	static float GetPreCinematicPlayerCameraZoomPct(const class UObject* WorldContextObject);
	static struct FRTSSelectionColorPreset GetSelectionColorPreset(const class UObject* WorldContextObject, const ETedPlayerID PlayerID);
	static struct FGenericTeamId GetTeamID(const class AActor* Target);
	static class ATedGameState* GetTedGameState(const class UObject* WorldContextObject);
	static class UTedPlayerCameraComponent* GetTedPlayerCameraComponent(const class UObject* WorldContextObject, int32 PlayerIndex);
	static class ATedPlayerCameraManager* GetTedPlayerCameraManager(const class UObject* WorldContextObject, int32 PlayerIndex);
	static class ATedPlayerController* GetTedPlayerController(const class UObject* WorldContextObject, int32 PlayerIndex);
	static class ATedPlayerController* GetTedPlayerControllerByPlayerID(const class UObject* WorldContextObject, const ETedPlayerID PlayerID);
	static float GetTimeForUIMaterials();
	static struct FBox GetWorldBounds(const class UObject* WorldContextObject);
	static bool HasOnlyThisCommandQueued(const class ATedUnitBase* Unit, TSubclassOf<class UGameplayCommand> CommandToCheck);
	static bool HasPlayedGameIntro(const class UObject* WorldContextObject);
	static bool IsCampaign(const class UObject* WorldContextObject);
	static bool IsCinematicModeEnabled(const class UObject* WorldContextObject);
	static bool IsCommandCompound(const class UObject* WorldContextObject);
	static bool IsInsideWorldBounds(const class UObject* WorldContextObject, const struct FVector& WorldLocation);
	static bool IsMainMenu(const class UObject* WorldContextObject);
	static bool IsMultiplayer(const class UObject* WorldContextObject);
	static bool IsSkirmish(const class UObject* WorldContextObject);
	static bool IsValidGroundLocation(const class UObject* WorldContextObject, const struct FVector2D& Location, const TSubclassOf<class UNavigationQueryFilter> FilterClass, const float Extent2D, class ARecastNavMesh* OverrideTargetNav);
	static bool IsValidGroundLocationForUnit(const class ATedUnitBase* Unit, const struct FVector2D& Location, const float Extent2D);
	static bool IsValidGroundLocationInRangeForUnit(const class ATedUnitBase* Unit, const struct FVector& Location, const float Range);
	static TArray<class ATedPawn*> K2_DealConeDamage(const class UObject* WorldContextObject, const struct FVector& Origin, const struct FVector& Direction, const struct FConeDamageParams& Params_0, const TSubclassOf<class UTedDamageType> DamageTypeClass, class AActor* DamageCauser, const struct FTedUtilsPawnFilter& Filter, const TSubclassOf<class UGameplayEffect> EffectToApply);
	static float K2_DealDamage(const class UObject* WorldContextObject, class AActor* DamageTarget, const float DamageAmount, const TSubclassOf<class UTedDamageType> DamageTypeClass, class AActor* DamageCauser, const TSubclassOf<class UGameplayEffect> EffectToApply);
	static TArray<class ATedPawn*> K2_DealRadialDamage(const class UObject* WorldContextObject, const struct FVector& Origin, const struct FRadialDamageParams& Params_0, const TSubclassOf<class UTedDamageType> DamageTypeClass, class AActor* DamageCauser, const struct FTedUtilsPawnFilter& Filter, const TSubclassOf<class UGameplayEffect> EffectToApply);
	static void LoadMainMenu(const class UObject* InWorldContext);
	static struct FAIRequestID MoveUnitAlongPath(const class ATedUnitBase* Unit, const TArray<struct FVector>& Path, float AcceptanceRadius);
	static struct FAIRequestID MoveUnitAlongSpline(const class ATedUnitBase* Unit, const class USplineComponent* Spline, const int32 StartingPointIdx, const int32 FinishPointIdx, float AcceptanceRadius);
	static bool OpenBriefingLevel(const class UObject* WorldContextObject, const class UTedMapInfo* InMap);
	static bool OpenBriefingLevelWithOptions(const class UObject* WorldContextObject, const class UTedMapInfo* InMap, const class FString& InOptions);
	static void OpenLevel(const class UObject* WorldContextObject, const class UTedMapInfo* InMap);
	static void OpenLevelWithOptions(const class UObject* WorldContextObject, const class UTedMapInfo* InMap, const class FString& InOptions);
	static void PlayAnnouncement(const class UObject* WorldContextObject, int32 PlayerIndex, TSubclassOf<class UTedAnnouncement> AnnouncementClass, const class UObject* OptionalObject);
	static void PlayFOWAwareWorldCameraShake(const class UObject* WorldContextObject, TSubclassOf<class UCameraShakeBase> Shake, const struct FVector& Epicenter, float InnerRadius, float OuterRadius, float Falloff, bool bOrientShakeTowardsEpicenter);
	static void RequestBatchSpawn(const TArray<class ATedUnitSpawner*>& Spawners, const bool bForce, TArray<class ATedUnitBase*>* OutSpawnedUnits);
	static void SetCameraZoomPct(const class UObject* WorldContextObject, const float ZoomPct);
	static void SetCinematicModeEnabled(const class UObject* WorldContextObject, const bool bEnabled, const bool bAffectsHUD, const class FString& CutsceneName);
	static void SetConsoleVariable_Bool(const class FString& InName, const bool InValue);
	static void SetConsoleVariable_Float(const class FString& InName, const float InValue);
	static void SetConsoleVariable_Integer(const class FString& InName, const int32 InValue);
	static void SetConsoleVariable_String(const class FString& InName, const class FString& InValue);
	static void SetMinimapState(const class UObject* WorldContextObject, EMinimapStateMode MinimapStateMode, class ATedPlayerState* InPlayerState);
	static void SetPlayedGameIntro(const class UObject* WorldContextObject, const bool bPlayedGameIntro);
	static void SetUseInverseSquaredFalloff(class UPointLightComponent* PointLight, const bool bUseInverseSquaredFalloff);
	static class ATedStructureBase* SpawnStructure(const class UObject* WorldContextObject, const ETedPlayerID Owner, TSubclassOf<class ATedStructureBase> StructureClass, const struct FVector& SpawnLocation);
	static class ATedUnitBase* SpawnUnit(TSubclassOf<class ATedUnitBase> UnitClass, class ATedPlayerState* Owner, const struct FTransform& SpawnTransform);
	static class ATedUnitBase* SpawnUnitForPlayer(const class UObject* WorldContextObject, TSubclassOf<class ATedUnitBase> UnitClass, const ETedPlayerID PlayerID, const struct FTransform& SpawnTransform);
	static void SyncCurrentCommand(const TArray<class AActor*>& CommandActors);
	static void SyncCurrentCommands(const TArray<class AActor*>& CommandActors);
	static const class UObject* TedGetDefaultObject(const TSubclassOf<class UObject>& Class_0);
	static void TeleportCamera(const class UObject* WorldContextObject, const struct FVector& TargetLocation);
	static bool TestReachability(const class UObject* WorldContextObject, const struct FVector& StartLocation, const struct FVector& EndLocation, const TSubclassOf<class UNavigationQueryFilter> FilterClass, const class ARecastNavMesh* OverrideTargetNav);
	static void UnsetConsoleVariable(const class FString& InName);
	static void WaitForMovieToFinish(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedUtils">();
	}
	static class UTedUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedUtils>();
	}
};
static_assert(alignof(UTedUtils) == 0x000008, "Wrong alignment on UTedUtils");
static_assert(sizeof(UTedUtils) == 0x000028, "Wrong size on UTedUtils");

// Class Tempest.TedVehicle_Harvester
// 0x0050 (0x1D10 - 0x1CC0)
class ATedVehicle_Harvester : public ATedVehicle
{
public:
	uint8                                         Pad_1CC0[0x30];                                    // 0x1CC0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHarvesterData                         HarvesterData;                                     // 0x1CF0(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         CurrentResource;                                   // 0x1D00(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D04[0xC];                                     // 0x1D04(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_CurrentResource();
	void SetResourceDepositSpeed(const int32 InResourceDepositSpeed);
	void SetResourceHarvestSpeed(const int32 InResourceHarvestSpeed);
	void SetResourceMaxCapacity(const int32 InResourceMaxCapacity);

	void K2_OnResourceChange(float ResourceToMaxCapacityPct) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedVehicle_Harvester">();
	}
	static class ATedVehicle_Harvester* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedVehicle_Harvester>();
	}
};
static_assert(alignof(ATedVehicle_Harvester) == 0x000010, "Wrong alignment on ATedVehicle_Harvester");
static_assert(sizeof(ATedVehicle_Harvester) == 0x001D10, "Wrong size on ATedVehicle_Harvester");
static_assert(offsetof(ATedVehicle_Harvester, HarvesterData) == 0x001CF0, "Member 'ATedVehicle_Harvester::HarvesterData' has a wrong offset!");
static_assert(offsetof(ATedVehicle_Harvester, CurrentResource) == 0x001D00, "Member 'ATedVehicle_Harvester::CurrentResource' has a wrong offset!");

// Class Tempest.TedVehicle_MobileRefinery
// 0x00D0 (0x1D90 - 0x1CC0)
class ATedVehicle_MobileRefinery : public ATedVehicle
{
public:
	uint8                                         Pad_1CC0[0xA8];                                    // 0x1CC0(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	class UTedPawnContainerComponent*             PawnContainerComponent;                            // 0x1D68(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoharvestOn;                                    // 0x1D70(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D71[0x3];                                     // 0x1D71(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TargetResourceVolumeBBKey;                         // 0x1D74(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D7C[0x4];                                     // 0x1D7C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATedUnitBase*>                   Harvesters;                                        // 0x1D80(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	class UTedPawnContainerComponent* GetPawnContainer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedVehicle_MobileRefinery">();
	}
	static class ATedVehicle_MobileRefinery* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedVehicle_MobileRefinery>();
	}
};
static_assert(alignof(ATedVehicle_MobileRefinery) == 0x000010, "Wrong alignment on ATedVehicle_MobileRefinery");
static_assert(sizeof(ATedVehicle_MobileRefinery) == 0x001D90, "Wrong size on ATedVehicle_MobileRefinery");
static_assert(offsetof(ATedVehicle_MobileRefinery, PawnContainerComponent) == 0x001D68, "Member 'ATedVehicle_MobileRefinery::PawnContainerComponent' has a wrong offset!");
static_assert(offsetof(ATedVehicle_MobileRefinery, bAutoharvestOn) == 0x001D70, "Member 'ATedVehicle_MobileRefinery::bAutoharvestOn' has a wrong offset!");
static_assert(offsetof(ATedVehicle_MobileRefinery, TargetResourceVolumeBBKey) == 0x001D74, "Member 'ATedVehicle_MobileRefinery::TargetResourceVolumeBBKey' has a wrong offset!");
static_assert(offsetof(ATedVehicle_MobileRefinery, Harvesters) == 0x001D80, "Member 'ATedVehicle_MobileRefinery::Harvesters' has a wrong offset!");

// Class Tempest.TedVetiDomeHelper
// 0x0040 (0x02D0 - 0x0290)
class ATedVetiDomeHelper final : public AActor
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bActive;                                           // 0x0298(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  GameplayTags;                                      // 0x02A0(0x0020)(NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnToggle;                                          // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void SetActive(bool bInActive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedVetiDomeHelper">();
	}
	static class ATedVetiDomeHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedVetiDomeHelper>();
	}
};
static_assert(alignof(ATedVetiDomeHelper) == 0x000008, "Wrong alignment on ATedVetiDomeHelper");
static_assert(sizeof(ATedVetiDomeHelper) == 0x0002D0, "Wrong size on ATedVetiDomeHelper");
static_assert(offsetof(ATedVetiDomeHelper, bActive) == 0x000298, "Member 'ATedVetiDomeHelper::bActive' has a wrong offset!");
static_assert(offsetof(ATedVetiDomeHelper, GameplayTags) == 0x0002A0, "Member 'ATedVetiDomeHelper::GameplayTags' has a wrong offset!");
static_assert(offsetof(ATedVetiDomeHelper, OnToggle) == 0x0002C0, "Member 'ATedVetiDomeHelper::OnToggle' has a wrong offset!");

// Class Tempest.TedWeapon
// 0x0088 (0x00B0 - 0x0028)
class UTedWeapon : public UObject
{
public:
	bool                                          bWeaponInfoSharedWithParentClass;                  // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UTedWeapon>                 SharedWeaponInfoClass;                             // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           DefinitionId;                                      // 0x0038(0x0008)(Edit, DisableEditOnInstance, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x70];                                      // 0x0040(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayerStateOuterEndPlay(class AActor* Actor, EEndPlayReason Reason);

	bool CanAttackGround() const;
	bool CanRechargeAmmoAutomatically() const;
	int32 GetAmmoCountMax() const;
	int32 GetAmmoCountPerRecharge() const;
	int32 GetAmmoCountStart() const;
	int32 GetAmmoCountUse() const;
	int32 GetAmmoRechargeCutoff() const;
	float GetAmmoRechargeTime() const;
	float GetAttackCooldown() const;
	float GetAttackGraceRange() const;
	float GetAttackRange() const;
	float GetAttackRangeThreshold() const;
	const struct FConeDamageParams GetConeDamageParams() const;
	float GetDamageAmount() const;
	EDamageKind GetDamageKind() const;
	TSubclassOf<class UTedDamageType> GetDamageType() const;
	const struct FGameplayTag GetDefinitionId() const;
	const TArray<class UGameplayEffect*> GetEffectsToApplyOnDamage() const;
	float GetGuardRange(const bool bForAI) const;
	struct FGameplayTagContainer GetOwnedTags() const;
	float GetPointDamageAmount() const;
	TSubclassOf<class ATedProjectile> GetProjectileClass() const;
	const struct FRadialDamageParams GetRadialDamageParams() const;
	struct FGameplayTagRequirements GetSourceTagRequirements() const;
	const struct FGameplayTagContainer GetTargetingDomains() const;
	struct FGameplayTagRequirements GetTargetTagRequirements() const;
	uint8 GetWeaponPriority() const;
	bool HasAutoAttack() const;
	bool HasFakeWeapon() const;
	bool IsDealingFullDamageToTarget() const;
	bool IsDealingInstantDamage() const;
	bool IsMeleeWeapon() const;
	bool ShouldApplyRadialDamageToFriendlies() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedWeapon">();
	}
	static class UTedWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedWeapon>();
	}
};
static_assert(alignof(UTedWeapon) == 0x000008, "Wrong alignment on UTedWeapon");
static_assert(sizeof(UTedWeapon) == 0x0000B0, "Wrong size on UTedWeapon");
static_assert(offsetof(UTedWeapon, bWeaponInfoSharedWithParentClass) == 0x000028, "Member 'UTedWeapon::bWeaponInfoSharedWithParentClass' has a wrong offset!");
static_assert(offsetof(UTedWeapon, SharedWeaponInfoClass) == 0x000030, "Member 'UTedWeapon::SharedWeaponInfoClass' has a wrong offset!");
static_assert(offsetof(UTedWeapon, DefinitionId) == 0x000038, "Member 'UTedWeapon::DefinitionId' has a wrong offset!");

// Class Tempest.TedWeaponDefinitionAsset
// 0x0258 (0x0308 - 0x00B0)
class UTedWeaponDefinitionAsset final : public UTedDefinitionAsset
{
public:
	TSoftClassPtr<class UClass>                   WeaponClass;                                       // 0x00B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATedProjectile>             ProjectileClass;                                   // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMeleeWeapon;                                    // 0x00E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFakeWeapon;                                       // 0x00E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         WeaponPriority;                                    // 0x00E2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E3[0x5];                                       // 0x00E3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UTedDamageType>             DamageType;                                        // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            EffectToApplyOnDamage;                             // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    EffectsToApplyOnDamage;                            // 0x00F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TargetingDomains;                                  // 0x0108(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bAutoAttack;                                       // 0x0128(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDealsInstantDamage;                               // 0x0129(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRadialDamageAppliesToFriendlies;                  // 0x012A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDealsFullDamageToTarget;                          // 0x012B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageKind                                   DamageKind;                                        // 0x012C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12D[0x3];                                      // 0x012D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageAmount;                                      // 0x0130(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRadialDamageParams                    RadialDamageParams;                                // 0x0134(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FConeDamageParams                      ConeDamageParams;                                  // 0x0148(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AttackCooldown;                                    // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackRangeThreshold;                              // 0x0164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackRange;                                       // 0x0168(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttackGraceRangeOverride;                         // 0x016C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16D[0x3];                                      // 0x016D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttackGraceRange;                                  // 0x0170(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GuardRange;                                        // 0x0174(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AiGuardRangeOverride;                              // 0x0178(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmmoCountUse;                                      // 0x017C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmmoCountMax;                                      // 0x0180(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmmoCountStart;                                    // 0x0184(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRechargeAmmoAutomatically;                        // 0x0188(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x3];                                      // 0x0189(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AmmoRechargeCutoff;                                // 0x018C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmmoRechargeTime;                                  // 0x0190(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmmoCountPerRecharge;                              // 0x0194(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  OwnedTags;                                         // 0x0198(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               SourceTagRequirements;                             // 0x01B8(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               TargetTagRequirements;                             // 0x0240(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bCanAttackGround;                                  // 0x02C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x02D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x02E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x02F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTedPassiveAbilityDefinitionAsset*> PassivieAbilityDefinitions;                     // 0x02F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedWeaponDefinitionAsset">();
	}
	static class UTedWeaponDefinitionAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedWeaponDefinitionAsset>();
	}
};
static_assert(alignof(UTedWeaponDefinitionAsset) == 0x000008, "Wrong alignment on UTedWeaponDefinitionAsset");
static_assert(sizeof(UTedWeaponDefinitionAsset) == 0x000308, "Wrong size on UTedWeaponDefinitionAsset");
static_assert(offsetof(UTedWeaponDefinitionAsset, WeaponClass) == 0x0000B0, "Member 'UTedWeaponDefinitionAsset::WeaponClass' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, ProjectileClass) == 0x0000D8, "Member 'UTedWeaponDefinitionAsset::ProjectileClass' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, bIsMeleeWeapon) == 0x0000E0, "Member 'UTedWeaponDefinitionAsset::bIsMeleeWeapon' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, bFakeWeapon) == 0x0000E1, "Member 'UTedWeaponDefinitionAsset::bFakeWeapon' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, WeaponPriority) == 0x0000E2, "Member 'UTedWeaponDefinitionAsset::WeaponPriority' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, DamageType) == 0x0000E8, "Member 'UTedWeaponDefinitionAsset::DamageType' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, EffectToApplyOnDamage) == 0x0000F0, "Member 'UTedWeaponDefinitionAsset::EffectToApplyOnDamage' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, EffectsToApplyOnDamage) == 0x0000F8, "Member 'UTedWeaponDefinitionAsset::EffectsToApplyOnDamage' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, TargetingDomains) == 0x000108, "Member 'UTedWeaponDefinitionAsset::TargetingDomains' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, bAutoAttack) == 0x000128, "Member 'UTedWeaponDefinitionAsset::bAutoAttack' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, bDealsInstantDamage) == 0x000129, "Member 'UTedWeaponDefinitionAsset::bDealsInstantDamage' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, bRadialDamageAppliesToFriendlies) == 0x00012A, "Member 'UTedWeaponDefinitionAsset::bRadialDamageAppliesToFriendlies' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, bDealsFullDamageToTarget) == 0x00012B, "Member 'UTedWeaponDefinitionAsset::bDealsFullDamageToTarget' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, DamageKind) == 0x00012C, "Member 'UTedWeaponDefinitionAsset::DamageKind' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, DamageAmount) == 0x000130, "Member 'UTedWeaponDefinitionAsset::DamageAmount' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, RadialDamageParams) == 0x000134, "Member 'UTedWeaponDefinitionAsset::RadialDamageParams' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, ConeDamageParams) == 0x000148, "Member 'UTedWeaponDefinitionAsset::ConeDamageParams' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, AttackCooldown) == 0x000160, "Member 'UTedWeaponDefinitionAsset::AttackCooldown' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, AttackRangeThreshold) == 0x000164, "Member 'UTedWeaponDefinitionAsset::AttackRangeThreshold' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, AttackRange) == 0x000168, "Member 'UTedWeaponDefinitionAsset::AttackRange' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, bAttackGraceRangeOverride) == 0x00016C, "Member 'UTedWeaponDefinitionAsset::bAttackGraceRangeOverride' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, AttackGraceRange) == 0x000170, "Member 'UTedWeaponDefinitionAsset::AttackGraceRange' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, GuardRange) == 0x000174, "Member 'UTedWeaponDefinitionAsset::GuardRange' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, AiGuardRangeOverride) == 0x000178, "Member 'UTedWeaponDefinitionAsset::AiGuardRangeOverride' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, AmmoCountUse) == 0x00017C, "Member 'UTedWeaponDefinitionAsset::AmmoCountUse' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, AmmoCountMax) == 0x000180, "Member 'UTedWeaponDefinitionAsset::AmmoCountMax' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, AmmoCountStart) == 0x000184, "Member 'UTedWeaponDefinitionAsset::AmmoCountStart' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, bRechargeAmmoAutomatically) == 0x000188, "Member 'UTedWeaponDefinitionAsset::bRechargeAmmoAutomatically' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, AmmoRechargeCutoff) == 0x00018C, "Member 'UTedWeaponDefinitionAsset::AmmoRechargeCutoff' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, AmmoRechargeTime) == 0x000190, "Member 'UTedWeaponDefinitionAsset::AmmoRechargeTime' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, AmmoCountPerRecharge) == 0x000194, "Member 'UTedWeaponDefinitionAsset::AmmoCountPerRecharge' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, OwnedTags) == 0x000198, "Member 'UTedWeaponDefinitionAsset::OwnedTags' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, SourceTagRequirements) == 0x0001B8, "Member 'UTedWeaponDefinitionAsset::SourceTagRequirements' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, TargetTagRequirements) == 0x000240, "Member 'UTedWeaponDefinitionAsset::TargetTagRequirements' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, bCanAttackGround) == 0x0002C8, "Member 'UTedWeaponDefinitionAsset::bCanAttackGround' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, DisplayName) == 0x0002D0, "Member 'UTedWeaponDefinitionAsset::DisplayName' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, Description) == 0x0002E0, "Member 'UTedWeaponDefinitionAsset::Description' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, Icon) == 0x0002F0, "Member 'UTedWeaponDefinitionAsset::Icon' has a wrong offset!");
static_assert(offsetof(UTedWeaponDefinitionAsset, PassivieAbilityDefinitions) == 0x0002F8, "Member 'UTedWeaponDefinitionAsset::PassivieAbilityDefinitions' has a wrong offset!");

// Class Tempest.TedWidgetVisibilityExtension_HideForSpectator
// 0x0050 (0x0080 - 0x0030)
class UTedWidgetVisibilityExtension_HideForSpectator final : public UTedWidgetVisibilityExtension
{
public:
	TSet<ETedSpectatorMode>                       HidingModes;                                       // 0x0030(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedWidgetVisibilityExtension_HideForSpectator">();
	}
	static class UTedWidgetVisibilityExtension_HideForSpectator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedWidgetVisibilityExtension_HideForSpectator>();
	}
};
static_assert(alignof(UTedWidgetVisibilityExtension_HideForSpectator) == 0x000008, "Wrong alignment on UTedWidgetVisibilityExtension_HideForSpectator");
static_assert(sizeof(UTedWidgetVisibilityExtension_HideForSpectator) == 0x000080, "Wrong size on UTedWidgetVisibilityExtension_HideForSpectator");
static_assert(offsetof(UTedWidgetVisibilityExtension_HideForSpectator, HidingModes) == 0x000030, "Member 'UTedWidgetVisibilityExtension_HideForSpectator::HidingModes' has a wrong offset!");

// Class Tempest.TedWindEffectConfig
// 0x0020 (0x0050 - 0x0030)
class UTedWindEffectConfig final : public UDataAsset
{
public:
	struct FWindEffectConfig                      Config;                                            // 0x0030(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedWindEffectConfig">();
	}
	static class UTedWindEffectConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedWindEffectConfig>();
	}
};
static_assert(alignof(UTedWindEffectConfig) == 0x000008, "Wrong alignment on UTedWindEffectConfig");
static_assert(sizeof(UTedWindEffectConfig) == 0x000050, "Wrong size on UTedWindEffectConfig");
static_assert(offsetof(UTedWindEffectConfig, Config) == 0x000030, "Member 'UTedWindEffectConfig::Config' has a wrong offset!");

// Class Tempest.TedWindEffectManager
// 0x0130 (0x0160 - 0x0030)
class UTedWindEffectManager : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LocationParameterName;                             // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 StrengthParameterName;                             // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 RadiusParameterName;                               // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 FalloffParameterName;                              // 0x0068(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialParameterCollection> MPC_WindEffects;                              // 0x0078(0x0028)(Edit, Config, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bEnableDistanceCulling : 1;                        // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CullingDistanceToCamera;                           // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ConcurrentCullingDistanceToCamera;                 // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           CachedMPC_WindEffects;                             // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FWindAnimationData>             ActiveWindEffects;                                 // 0x00B8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FWindEffectQueueData>           WindEffectsQueue;                                  // 0x00C8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class UTedWindEffectConfig*, float>      WindEffectsLastPlayedTime;                         // 0x00D8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSoftClassPath                         TedWindManagerName;                                // 0x0128(0x0020)(ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x18];                                     // 0x0148(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void RequestWindEffect(const class UObject* WorldContextObject, const class UTedWindEffectConfig* WindConfig, const struct FVector& Location);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedWindEffectManager">();
	}
	static class UTedWindEffectManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedWindEffectManager>();
	}
};
static_assert(alignof(UTedWindEffectManager) == 0x000008, "Wrong alignment on UTedWindEffectManager");
static_assert(sizeof(UTedWindEffectManager) == 0x000160, "Wrong size on UTedWindEffectManager");
static_assert(offsetof(UTedWindEffectManager, LocationParameterName) == 0x000038, "Member 'UTedWindEffectManager::LocationParameterName' has a wrong offset!");
static_assert(offsetof(UTedWindEffectManager, StrengthParameterName) == 0x000048, "Member 'UTedWindEffectManager::StrengthParameterName' has a wrong offset!");
static_assert(offsetof(UTedWindEffectManager, RadiusParameterName) == 0x000058, "Member 'UTedWindEffectManager::RadiusParameterName' has a wrong offset!");
static_assert(offsetof(UTedWindEffectManager, FalloffParameterName) == 0x000068, "Member 'UTedWindEffectManager::FalloffParameterName' has a wrong offset!");
static_assert(offsetof(UTedWindEffectManager, MPC_WindEffects) == 0x000078, "Member 'UTedWindEffectManager::MPC_WindEffects' has a wrong offset!");
static_assert(offsetof(UTedWindEffectManager, CullingDistanceToCamera) == 0x0000A4, "Member 'UTedWindEffectManager::CullingDistanceToCamera' has a wrong offset!");
static_assert(offsetof(UTedWindEffectManager, ConcurrentCullingDistanceToCamera) == 0x0000A8, "Member 'UTedWindEffectManager::ConcurrentCullingDistanceToCamera' has a wrong offset!");
static_assert(offsetof(UTedWindEffectManager, CachedMPC_WindEffects) == 0x0000B0, "Member 'UTedWindEffectManager::CachedMPC_WindEffects' has a wrong offset!");
static_assert(offsetof(UTedWindEffectManager, ActiveWindEffects) == 0x0000B8, "Member 'UTedWindEffectManager::ActiveWindEffects' has a wrong offset!");
static_assert(offsetof(UTedWindEffectManager, WindEffectsQueue) == 0x0000C8, "Member 'UTedWindEffectManager::WindEffectsQueue' has a wrong offset!");
static_assert(offsetof(UTedWindEffectManager, WindEffectsLastPlayedTime) == 0x0000D8, "Member 'UTedWindEffectManager::WindEffectsLastPlayedTime' has a wrong offset!");
static_assert(offsetof(UTedWindEffectManager, TedWindManagerName) == 0x000128, "Member 'UTedWindEffectManager::TedWindManagerName' has a wrong offset!");

// Class Tempest.TedWorkerButton_TempestWorkers
// 0x0000 (0x0438 - 0x0438)
class UTedWorkerButton_TempestWorkers : public UTedWorkerButton
{
public:
	void OnUpdateIdleState(bool NewIdleState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedWorkerButton_TempestWorkers">();
	}
	static class UTedWorkerButton_TempestWorkers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedWorkerButton_TempestWorkers>();
	}
};
static_assert(alignof(UTedWorkerButton_TempestWorkers) == 0x000008, "Wrong alignment on UTedWorkerButton_TempestWorkers");
static_assert(sizeof(UTedWorkerButton_TempestWorkers) == 0x000438, "Wrong size on UTedWorkerButton_TempestWorkers");

// Class Tempest.TedWorkerSlot
// 0x0048 (0x0480 - 0x0438)
class UTedWorkerSlot : public UTedPawnsPanelSlot
{
public:
	class FName                                   IconParam;                                         // 0x0438(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CapacityBarFillParam;                              // 0x0440(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_Icon;                                        // 0x0448(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Damage_Icon;                                       // 0x0450(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_CapacityBar;                                 // 0x0458(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                Widget_IdleIcon;                                   // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTedWorkersWidget*                      CachedParentWorkersWidget;                         // 0x0468(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_470[0x10];                                     // 0x0470(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearDamageIcon();
	class UTedWorkersWidget* GetParentWorkerWidget();
	void OnWorkerHealthChanged(const float OldValue, const float NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedWorkerSlot">();
	}
	static class UTedWorkerSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedWorkerSlot>();
	}
};
static_assert(alignof(UTedWorkerSlot) == 0x000008, "Wrong alignment on UTedWorkerSlot");
static_assert(sizeof(UTedWorkerSlot) == 0x000480, "Wrong size on UTedWorkerSlot");
static_assert(offsetof(UTedWorkerSlot, IconParam) == 0x000438, "Member 'UTedWorkerSlot::IconParam' has a wrong offset!");
static_assert(offsetof(UTedWorkerSlot, CapacityBarFillParam) == 0x000440, "Member 'UTedWorkerSlot::CapacityBarFillParam' has a wrong offset!");
static_assert(offsetof(UTedWorkerSlot, Image_Icon) == 0x000448, "Member 'UTedWorkerSlot::Image_Icon' has a wrong offset!");
static_assert(offsetof(UTedWorkerSlot, Damage_Icon) == 0x000450, "Member 'UTedWorkerSlot::Damage_Icon' has a wrong offset!");
static_assert(offsetof(UTedWorkerSlot, Image_CapacityBar) == 0x000458, "Member 'UTedWorkerSlot::Image_CapacityBar' has a wrong offset!");
static_assert(offsetof(UTedWorkerSlot, Widget_IdleIcon) == 0x000460, "Member 'UTedWorkerSlot::Widget_IdleIcon' has a wrong offset!");
static_assert(offsetof(UTedWorkerSlot, CachedParentWorkersWidget) == 0x000468, "Member 'UTedWorkerSlot::CachedParentWorkersWidget' has a wrong offset!");

// Class Tempest.TedWorkersWidget_TempestWorkers
// 0x0018 (0x04C0 - 0x04A8)
class UTedWorkersWidget_TempestWorkers : public UTedWorkersWidget
{
public:
	float                                         IdleStateEvaluationInterval;                       // 0x04A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bEvaluateIdleStateInBulk : 1;                      // 0x04AC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_4AD[0x3];                                      // 0x04AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           EvaluatingIdleStateHandleLoop;                     // 0x04B0(0x0008)(Transient, DuplicateTransient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           EvaluatingIdleStateHandleSingle;                   // 0x04B8(0x0008)(Transient, DuplicateTransient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static ETedContentSlotState GetState_TempestWorkerIdle();

	int32 GetCapacityFill(const class ATedPawn* Pawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedWorkersWidget_TempestWorkers">();
	}
	static class UTedWorkersWidget_TempestWorkers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedWorkersWidget_TempestWorkers>();
	}
};
static_assert(alignof(UTedWorkersWidget_TempestWorkers) == 0x000008, "Wrong alignment on UTedWorkersWidget_TempestWorkers");
static_assert(sizeof(UTedWorkersWidget_TempestWorkers) == 0x0004C0, "Wrong size on UTedWorkersWidget_TempestWorkers");
static_assert(offsetof(UTedWorkersWidget_TempestWorkers, IdleStateEvaluationInterval) == 0x0004A8, "Member 'UTedWorkersWidget_TempestWorkers::IdleStateEvaluationInterval' has a wrong offset!");
static_assert(offsetof(UTedWorkersWidget_TempestWorkers, EvaluatingIdleStateHandleLoop) == 0x0004B0, "Member 'UTedWorkersWidget_TempestWorkers::EvaluatingIdleStateHandleLoop' has a wrong offset!");
static_assert(offsetof(UTedWorkersWidget_TempestWorkers, EvaluatingIdleStateHandleSingle) == 0x0004B8, "Member 'UTedWorkersWidget_TempestWorkers::EvaluatingIdleStateHandleSingle' has a wrong offset!");

// Class Tempest.TedWorldHintActor
// 0x0028 (0x02B8 - 0x0290)
class ATedWorldHintActor : public AActor
{
public:
	class UTedHintsAsset*                         CachedHintData;                                    // 0x0290(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTedMarkerConfig*                       HintMinimapMarker;                                 // 0x0298(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      Particles;                                         // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       TextWidget;                                        // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 MarkedActor;                                       // 0x02B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void DestroyHint();
	void OnTargetActorEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason);
	void OnTargetPawnDeath(class ATedPawn* Pawn);
	void OnTargetPawnVisibilityChanged(class ATedPawn* Pawn, bool bIsVisible);
	void OnTargetPickedUp(class ATedUnitBase* PickedUpBy, class ATedPickupActor* PickupActor);
	void OnTargetRemoved();
	void SetHintData(class UTedHintsAsset* HintData, class AActor* AttachedToActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedWorldHintActor">();
	}
	static class ATedWorldHintActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATedWorldHintActor>();
	}
};
static_assert(alignof(ATedWorldHintActor) == 0x000008, "Wrong alignment on ATedWorldHintActor");
static_assert(sizeof(ATedWorldHintActor) == 0x0002B8, "Wrong size on ATedWorldHintActor");
static_assert(offsetof(ATedWorldHintActor, CachedHintData) == 0x000290, "Member 'ATedWorldHintActor::CachedHintData' has a wrong offset!");
static_assert(offsetof(ATedWorldHintActor, HintMinimapMarker) == 0x000298, "Member 'ATedWorldHintActor::HintMinimapMarker' has a wrong offset!");
static_assert(offsetof(ATedWorldHintActor, Particles) == 0x0002A0, "Member 'ATedWorldHintActor::Particles' has a wrong offset!");
static_assert(offsetof(ATedWorldHintActor, TextWidget) == 0x0002A8, "Member 'ATedWorldHintActor::TextWidget' has a wrong offset!");
static_assert(offsetof(ATedWorldHintActor, MarkedActor) == 0x0002B0, "Member 'ATedWorldHintActor::MarkedActor' has a wrong offset!");

// Class Tempest.TedWorldHintWidget
// 0x0028 (0x0428 - 0x0400)
class UTedWorldHintWidget : public UTedUserWidget
{
public:
	class UTedHintsAsset*                         CachedHintData;                                    // 0x0400(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  IgnoredHidingContext_;                             // 0x0408(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	void SetHintData(class UTedHintsAsset* HintData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedWorldHintWidget">();
	}
	static class UTedWorldHintWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedWorldHintWidget>();
	}
};
static_assert(alignof(UTedWorldHintWidget) == 0x000008, "Wrong alignment on UTedWorldHintWidget");
static_assert(sizeof(UTedWorldHintWidget) == 0x000428, "Wrong size on UTedWorldHintWidget");
static_assert(offsetof(UTedWorldHintWidget, CachedHintData) == 0x000400, "Member 'UTedWorldHintWidget::CachedHintData' has a wrong offset!");
static_assert(offsetof(UTedWorldHintWidget, IgnoredHidingContext_) == 0x000408, "Member 'UTedWorldHintWidget::IgnoredHidingContext_' has a wrong offset!");

// Class Tempest.TempestFieldElementProxy
// 0x0090 (0x00B8 - 0x0028)
class UTempestFieldElementProxy : public UObject
{
public:
	class ATedTempestVinesBase*                   MyOwner;                                           // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MyIndex;                                           // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0xC];                                       // 0x0034(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ISMCompClass;                                      // 0x0040(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNoPlacementCollision;                             // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CollisionRadius;                                   // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DesiredNumPerTile;                                 // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseRandomTransforms;                              // 0x0074(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FixedRandomSeed;                                   // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RandomXYOffset;                                    // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              RandomZOffset;                                     // 0x0080(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               RandomRotation;                                    // 0x0090(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              RandomScale;                                       // 0x00A8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddElementComponent(class USceneComponent* Comp) const;
	class USceneComponent* AddElementComponentOfClass(const TSubclassOf<class USceneComponent> CompClass, const struct FTransform& Transform) const;
	struct FFieldTileElementISMData AddElementSMInstance(class UStaticMesh* StaticMesh, const struct FTransform& Transform, const int32 NumCustomDataFloats) const;
	class USceneComponent* GetElementComponent(const TSubclassOf<class USceneComponent> CompClass) const;
	TArray<class USceneComponent*> GetElementComponents(const TSubclassOf<class USceneComponent> CompClass) const;
	ETempestFieldElementStage GetElementCurrentStage() const;
	ETempestFieldElementStage GetElementNextStage() const;
	TArray<struct FTransform> GetElementRandomTransforms() const;
	struct FFieldTileElementISMData GetElementSMInstance(const int32 InstanceIndex) const;
	int32 GetElementSMInstanceCount() const;
	TArray<struct FFieldTileElementISMData> GetElementSMInstances() const;
	struct FTransform GetElementTransform() const;
	void GetElementTransitionData(float* OutProgress, ETempestFieldElementStage* OutFromStage, ETempestFieldElementStage* OutToStage) const;
	float GetElementTransitionProgress() const;
	bool IsGeneratedInEditor() const;
	void K2_BeginTransition(const ETempestFieldElementStage PrevStage, const ETempestFieldElementStage NextStage) const;
	void K2_EndTransition(const ETempestFieldElementStage PrevStage, const ETempestFieldElementStage NextStage) const;
	void K2_InitializeElement(struct FRandomStream& RandomStream) const;
	void K2_ProcessTransition(float& Progress, const float DeltaTime, const ETempestFieldElementStage PrevStage, const ETempestFieldElementStage NextStage) const;
	void MarkComponentRenderStateDirty(class UPrimitiveComponent* PrimComp) const;
	void RemoveAllElementComponents(const float DestroyDelay) const;
	void RemoveElementComponent(class USceneComponent* Comp, const float DestroyDelay) const;
	void RemoveElementComponents(const TSubclassOf<class USceneComponent> CompClass, const float DestroyDelay) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TempestFieldElementProxy">();
	}
	static class UTempestFieldElementProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTempestFieldElementProxy>();
	}
};
static_assert(alignof(UTempestFieldElementProxy) == 0x000008, "Wrong alignment on UTempestFieldElementProxy");
static_assert(sizeof(UTempestFieldElementProxy) == 0x0000B8, "Wrong size on UTempestFieldElementProxy");
static_assert(offsetof(UTempestFieldElementProxy, MyOwner) == 0x000028, "Member 'UTempestFieldElementProxy::MyOwner' has a wrong offset!");
static_assert(offsetof(UTempestFieldElementProxy, MyIndex) == 0x000030, "Member 'UTempestFieldElementProxy::MyIndex' has a wrong offset!");
static_assert(offsetof(UTempestFieldElementProxy, ISMCompClass) == 0x000040, "Member 'UTempestFieldElementProxy::ISMCompClass' has a wrong offset!");
static_assert(offsetof(UTempestFieldElementProxy, bNoPlacementCollision) == 0x000068, "Member 'UTempestFieldElementProxy::bNoPlacementCollision' has a wrong offset!");
static_assert(offsetof(UTempestFieldElementProxy, CollisionRadius) == 0x00006C, "Member 'UTempestFieldElementProxy::CollisionRadius' has a wrong offset!");
static_assert(offsetof(UTempestFieldElementProxy, DesiredNumPerTile) == 0x000070, "Member 'UTempestFieldElementProxy::DesiredNumPerTile' has a wrong offset!");
static_assert(offsetof(UTempestFieldElementProxy, bUseRandomTransforms) == 0x000074, "Member 'UTempestFieldElementProxy::bUseRandomTransforms' has a wrong offset!");
static_assert(offsetof(UTempestFieldElementProxy, FixedRandomSeed) == 0x000078, "Member 'UTempestFieldElementProxy::FixedRandomSeed' has a wrong offset!");
static_assert(offsetof(UTempestFieldElementProxy, RandomXYOffset) == 0x00007C, "Member 'UTempestFieldElementProxy::RandomXYOffset' has a wrong offset!");
static_assert(offsetof(UTempestFieldElementProxy, RandomZOffset) == 0x000080, "Member 'UTempestFieldElementProxy::RandomZOffset' has a wrong offset!");
static_assert(offsetof(UTempestFieldElementProxy, RandomRotation) == 0x000090, "Member 'UTempestFieldElementProxy::RandomRotation' has a wrong offset!");
static_assert(offsetof(UTempestFieldElementProxy, RandomScale) == 0x0000A8, "Member 'UTempestFieldElementProxy::RandomScale' has a wrong offset!");

// Class Tempest.TempestFieldSubsystem
// 0x0008 (0x0038 - 0x0030)
class UTempestFieldSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TempestFieldSubsystem">();
	}
	static class UTempestFieldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTempestFieldSubsystem>();
	}
};
static_assert(alignof(UTempestFieldSubsystem) == 0x000008, "Wrong alignment on UTempestFieldSubsystem");
static_assert(sizeof(UTempestFieldSubsystem) == 0x000038, "Wrong size on UTempestFieldSubsystem");

// Class Tempest.TempestFieldEffectsConfigAsset
// 0x0050 (0x0080 - 0x0030)
class UTempestFieldEffectsConfigAsset final : public UDataAsset
{
public:
	struct FTempestFieldEffectsConfig             Data;                                              // 0x0030(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TempestFieldEffectsConfigAsset">();
	}
	static class UTempestFieldEffectsConfigAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTempestFieldEffectsConfigAsset>();
	}
};
static_assert(alignof(UTempestFieldEffectsConfigAsset) == 0x000008, "Wrong alignment on UTempestFieldEffectsConfigAsset");
static_assert(sizeof(UTempestFieldEffectsConfigAsset) == 0x000080, "Wrong size on UTempestFieldEffectsConfigAsset");
static_assert(offsetof(UTempestFieldEffectsConfigAsset, Data) == 0x000030, "Member 'UTempestFieldEffectsConfigAsset::Data' has a wrong offset!");

// Class Tempest.TempestFieldGameplayConfigAsset
// 0x01F8 (0x0228 - 0x0030)
class UTempestFieldGameplayConfigAsset final : public UDataAsset
{
public:
	struct FTempestFieldGameplayConfig            Data;                                              // 0x0030(0x0078)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bOverrideEasyMode;                                 // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTempestFieldGameplayConfig            Data_Easy;                                         // 0x00B0(0x0078)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bOverrideHardMode;                                 // 0x0128(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTempestFieldGameplayConfig            Data_Hard;                                         // 0x0130(0x0078)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bOverrideVeryHardMode;                             // 0x01A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTempestFieldGameplayConfig            Data_VeryHard;                                     // 0x01B0(0x0078)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TempestFieldGameplayConfigAsset">();
	}
	static class UTempestFieldGameplayConfigAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTempestFieldGameplayConfigAsset>();
	}
};
static_assert(alignof(UTempestFieldGameplayConfigAsset) == 0x000008, "Wrong alignment on UTempestFieldGameplayConfigAsset");
static_assert(sizeof(UTempestFieldGameplayConfigAsset) == 0x000228, "Wrong size on UTempestFieldGameplayConfigAsset");
static_assert(offsetof(UTempestFieldGameplayConfigAsset, Data) == 0x000030, "Member 'UTempestFieldGameplayConfigAsset::Data' has a wrong offset!");
static_assert(offsetof(UTempestFieldGameplayConfigAsset, bOverrideEasyMode) == 0x0000A8, "Member 'UTempestFieldGameplayConfigAsset::bOverrideEasyMode' has a wrong offset!");
static_assert(offsetof(UTempestFieldGameplayConfigAsset, Data_Easy) == 0x0000B0, "Member 'UTempestFieldGameplayConfigAsset::Data_Easy' has a wrong offset!");
static_assert(offsetof(UTempestFieldGameplayConfigAsset, bOverrideHardMode) == 0x000128, "Member 'UTempestFieldGameplayConfigAsset::bOverrideHardMode' has a wrong offset!");
static_assert(offsetof(UTempestFieldGameplayConfigAsset, Data_Hard) == 0x000130, "Member 'UTempestFieldGameplayConfigAsset::Data_Hard' has a wrong offset!");
static_assert(offsetof(UTempestFieldGameplayConfigAsset, bOverrideVeryHardMode) == 0x0001A8, "Member 'UTempestFieldGameplayConfigAsset::bOverrideVeryHardMode' has a wrong offset!");
static_assert(offsetof(UTempestFieldGameplayConfigAsset, Data_VeryHard) == 0x0001B0, "Member 'UTempestFieldGameplayConfigAsset::Data_VeryHard' has a wrong offset!");

// Class Tempest.TempestFieldConfigAsset
// 0x0018 (0x0048 - 0x0030)
class UTempestFieldConfigAsset final : public UDataAsset
{
public:
	class UTempestFieldBuildConfigAsset*          BuildConfig;                                       // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTempestFieldEffectsConfigAsset*        EffectsConfig;                                     // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTempestFieldGameplayConfigAsset*       GameplayConfig;                                    // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TempestFieldConfigAsset">();
	}
	static class UTempestFieldConfigAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTempestFieldConfigAsset>();
	}
};
static_assert(alignof(UTempestFieldConfigAsset) == 0x000008, "Wrong alignment on UTempestFieldConfigAsset");
static_assert(sizeof(UTempestFieldConfigAsset) == 0x000048, "Wrong size on UTempestFieldConfigAsset");
static_assert(offsetof(UTempestFieldConfigAsset, BuildConfig) == 0x000030, "Member 'UTempestFieldConfigAsset::BuildConfig' has a wrong offset!");
static_assert(offsetof(UTempestFieldConfigAsset, EffectsConfig) == 0x000038, "Member 'UTempestFieldConfigAsset::EffectsConfig' has a wrong offset!");
static_assert(offsetof(UTempestFieldConfigAsset, GameplayConfig) == 0x000040, "Member 'UTempestFieldConfigAsset::GameplayConfig' has a wrong offset!");

// Class Tempest.TempestFieldVolume
// 0x0398 (0x0768 - 0x03D0)
class ATempestFieldVolume final : public ATedTempestVinesBase
{
public:
	uint8                                         Pad_3D0[0x8];                                      // 0x03D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPendingBeginPlayNavigationUpdate;                 // 0x03D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D9[0x7];                                      // 0x03D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ATedPawn*, struct FTempestFieldOverlappedPawnGEData> OverlappedPawnGEData;            // 0x03E0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bDebugFieldGrid;                                   // 0x0430(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_431[0x3];                                      // 0x0431(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RandomSeed;                                        // 0x0434(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RootLocation;                                      // 0x0438(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTempestFieldConfigAsset> FieldConfigAsset;                                 // 0x0450(0x0028)(Edit, DisableEditOnTemplate, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasCrater;                                        // 0x0478(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBigCrater;                                        // 0x0479(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_47A[0x6];                                      // 0x047A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CraterOffset;                                      // 0x0480(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CraterScale;                                       // 0x0498(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               CraterRotation;                                    // 0x04B0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bHasSplineRoots;                                   // 0x04C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bManualSplineEdit;                                 // 0x04C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4CA[0x2];                                      // 0x04CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DebugSplineIterations;                             // 0x04CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawSplineDebug;                                  // 0x04D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D1[0x3];                                      // 0x04D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialGrowthPercentage;                           // 0x04D4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETempestFieldElementStage                     TestStartStage;                                    // 0x04D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETempestFieldElementStage                     TestDestStage;                                     // 0x04D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4DA[0x6];                                      // 0x04DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTempestFieldConfigAsset*               FieldConfig;                                       // 0x04E0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bResourceDepleted;                                 // 0x04E8(0x0001)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E9[0xD7];                                     // 0x04E9(0x00D7)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOffsetCoords>                  FieldCraterCoords;                                 // 0x05C0(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFieldTileData>                 FieldTileData;                                     // 0x05D0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FTempestFieldRepStage                  RepFieldTileStage;                                 // 0x05E0(0x0020)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FTempestFieldRepVisibility             RepFieldTilesVisibility;                           // 0x0600(0x0020)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_620[0x8];                                      // 0x0620(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFieldTileElement>              FieldTileElements;                                 // 0x0628(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UTempestFieldElementProxy*>      FieldProxies;                                      // 0x0638(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UInstancedStaticMeshComponent*>  FieldISMCs;                                        // 0x0648(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class USceneComponent*, float>           PendingDestroyFieldElementComponents;              // 0x0658(0x0050)(Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSet<class UPrimitiveComponent*>              PendingRenderStateDirtyElementComponents;          // 0x06A8(0x0050)(ExportObject, Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   CraterMeshComp;                                    // 0x06F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USplineMeshComponent*>           SplineMeshComps;                                   // 0x0700(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UAudioComponent*                        AmbientAudioComponent;                             // 0x0710(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_718[0x38];                                     // 0x0718(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class ASquareNavGrid*                         PlacementGrid;                                     // 0x0750(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_758[0x8];                                      // 0x0758(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorComponent*                        TempestFieldAudioAmbience;                         // 0x0760(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_RepFieldTileStage();
	void OnRep_RepFieldTilesVisibility();

	int32 GetClosestUnclaimedResourceTile(const struct FVector& InLocation, struct FVector* OutClosestLocation, bool bTestReachability, const class ATedUnitBase* InUnit) const;
	float GetResourceAtWorldLocation(const struct FVector& Location) const;
	float GetResourceLeft() const;
	float GetResourcePct() const;
	float GetVisibleResourceLeft() const;
	float GetVisibleResourcePct() const;
	bool HasUnlcaimedResourceTile() const;
	bool IsResourceDepleted() const;
	int32 NumClaimedTiles() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TempestFieldVolume">();
	}
	static class ATempestFieldVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATempestFieldVolume>();
	}
};
static_assert(alignof(ATempestFieldVolume) == 0x000008, "Wrong alignment on ATempestFieldVolume");
static_assert(sizeof(ATempestFieldVolume) == 0x000768, "Wrong size on ATempestFieldVolume");
static_assert(offsetof(ATempestFieldVolume, bPendingBeginPlayNavigationUpdate) == 0x0003D8, "Member 'ATempestFieldVolume::bPendingBeginPlayNavigationUpdate' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, OverlappedPawnGEData) == 0x0003E0, "Member 'ATempestFieldVolume::OverlappedPawnGEData' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, bDebugFieldGrid) == 0x000430, "Member 'ATempestFieldVolume::bDebugFieldGrid' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, RandomSeed) == 0x000434, "Member 'ATempestFieldVolume::RandomSeed' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, RootLocation) == 0x000438, "Member 'ATempestFieldVolume::RootLocation' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, FieldConfigAsset) == 0x000450, "Member 'ATempestFieldVolume::FieldConfigAsset' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, bHasCrater) == 0x000478, "Member 'ATempestFieldVolume::bHasCrater' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, bBigCrater) == 0x000479, "Member 'ATempestFieldVolume::bBigCrater' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, CraterOffset) == 0x000480, "Member 'ATempestFieldVolume::CraterOffset' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, CraterScale) == 0x000498, "Member 'ATempestFieldVolume::CraterScale' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, CraterRotation) == 0x0004B0, "Member 'ATempestFieldVolume::CraterRotation' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, bHasSplineRoots) == 0x0004C8, "Member 'ATempestFieldVolume::bHasSplineRoots' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, bManualSplineEdit) == 0x0004C9, "Member 'ATempestFieldVolume::bManualSplineEdit' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, DebugSplineIterations) == 0x0004CC, "Member 'ATempestFieldVolume::DebugSplineIterations' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, bDrawSplineDebug) == 0x0004D0, "Member 'ATempestFieldVolume::bDrawSplineDebug' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, InitialGrowthPercentage) == 0x0004D4, "Member 'ATempestFieldVolume::InitialGrowthPercentage' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, TestStartStage) == 0x0004D8, "Member 'ATempestFieldVolume::TestStartStage' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, TestDestStage) == 0x0004D9, "Member 'ATempestFieldVolume::TestDestStage' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, FieldConfig) == 0x0004E0, "Member 'ATempestFieldVolume::FieldConfig' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, bResourceDepleted) == 0x0004E8, "Member 'ATempestFieldVolume::bResourceDepleted' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, FieldCraterCoords) == 0x0005C0, "Member 'ATempestFieldVolume::FieldCraterCoords' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, FieldTileData) == 0x0005D0, "Member 'ATempestFieldVolume::FieldTileData' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, RepFieldTileStage) == 0x0005E0, "Member 'ATempestFieldVolume::RepFieldTileStage' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, RepFieldTilesVisibility) == 0x000600, "Member 'ATempestFieldVolume::RepFieldTilesVisibility' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, FieldTileElements) == 0x000628, "Member 'ATempestFieldVolume::FieldTileElements' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, FieldProxies) == 0x000638, "Member 'ATempestFieldVolume::FieldProxies' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, FieldISMCs) == 0x000648, "Member 'ATempestFieldVolume::FieldISMCs' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, PendingDestroyFieldElementComponents) == 0x000658, "Member 'ATempestFieldVolume::PendingDestroyFieldElementComponents' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, PendingRenderStateDirtyElementComponents) == 0x0006A8, "Member 'ATempestFieldVolume::PendingRenderStateDirtyElementComponents' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, CraterMeshComp) == 0x0006F8, "Member 'ATempestFieldVolume::CraterMeshComp' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, SplineMeshComps) == 0x000700, "Member 'ATempestFieldVolume::SplineMeshComps' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, AmbientAudioComponent) == 0x000710, "Member 'ATempestFieldVolume::AmbientAudioComponent' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, PlacementGrid) == 0x000750, "Member 'ATempestFieldVolume::PlacementGrid' has a wrong offset!");
static_assert(offsetof(ATempestFieldVolume, TempestFieldAudioAmbience) == 0x000760, "Member 'ATempestFieldVolume::TempestFieldAudioAmbience' has a wrong offset!");

// Class Tempest.TedInputTrigger_ActionBlockers
// 0x0050 (0x00A0 - 0x0050)
class UTedInputTrigger_ActionBlockers final : public UInputTrigger
{
public:
	TSet<class UInputAction*>                     BlockingActions;                                   // 0x0050(0x0050)(Edit, BlueprintVisible, DisableEditOnTemplate, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TedInputTrigger_ActionBlockers">();
	}
	static class UTedInputTrigger_ActionBlockers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTedInputTrigger_ActionBlockers>();
	}
};
static_assert(alignof(UTedInputTrigger_ActionBlockers) == 0x000008, "Wrong alignment on UTedInputTrigger_ActionBlockers");
static_assert(sizeof(UTedInputTrigger_ActionBlockers) == 0x0000A0, "Wrong size on UTedInputTrigger_ActionBlockers");
static_assert(offsetof(UTedInputTrigger_ActionBlockers, BlockingActions) == 0x000050, "Member 'UTedInputTrigger_ActionBlockers::BlockingActions' has a wrong offset!");

// Class Tempest.UtilityAIAction_IssueCommand
// 0x0010 (0x0048 - 0x0038)
class UUtilityAIAction_IssueCommand final : public UUtilityAIAction
{
public:
	struct FGameplayTag                           CommandType;                                       // 0x0038(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequireAutocastEnabled;                           // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInsertBeforeCurrentCommand;                       // 0x0041(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIAction_IssueCommand">();
	}
	static class UUtilityAIAction_IssueCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIAction_IssueCommand>();
	}
};
static_assert(alignof(UUtilityAIAction_IssueCommand) == 0x000008, "Wrong alignment on UUtilityAIAction_IssueCommand");
static_assert(sizeof(UUtilityAIAction_IssueCommand) == 0x000048, "Wrong size on UUtilityAIAction_IssueCommand");
static_assert(offsetof(UUtilityAIAction_IssueCommand, CommandType) == 0x000038, "Member 'UUtilityAIAction_IssueCommand::CommandType' has a wrong offset!");
static_assert(offsetof(UUtilityAIAction_IssueCommand, bRequireAutocastEnabled) == 0x000040, "Member 'UUtilityAIAction_IssueCommand::bRequireAutocastEnabled' has a wrong offset!");
static_assert(offsetof(UUtilityAIAction_IssueCommand, bInsertBeforeCurrentCommand) == 0x000041, "Member 'UUtilityAIAction_IssueCommand::bInsertBeforeCurrentCommand' has a wrong offset!");

// Class Tempest.UtilityAIAction_IssueCommandGeneratedLocation
// 0x0020 (0x0058 - 0x0038)
class UUtilityAIAction_IssueCommandGeneratedLocation final : public UUtilityAIAction
{
public:
	struct FGameplayTag                           CommandType;                                       // 0x0038(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInfluenceMapQueryPreset*               QueryPreset;                                       // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUtilityAIActionInfluenceMapQueryType         QueryType;                                         // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUtilityAIInfluenceMapQueryLocationType       QueryLocationType;                                 // 0x0049(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A[0x2];                                       // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SearchRange;                                       // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InfluenceThreshold;                                // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIAction_IssueCommandGeneratedLocation">();
	}
	static class UUtilityAIAction_IssueCommandGeneratedLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIAction_IssueCommandGeneratedLocation>();
	}
};
static_assert(alignof(UUtilityAIAction_IssueCommandGeneratedLocation) == 0x000008, "Wrong alignment on UUtilityAIAction_IssueCommandGeneratedLocation");
static_assert(sizeof(UUtilityAIAction_IssueCommandGeneratedLocation) == 0x000058, "Wrong size on UUtilityAIAction_IssueCommandGeneratedLocation");
static_assert(offsetof(UUtilityAIAction_IssueCommandGeneratedLocation, CommandType) == 0x000038, "Member 'UUtilityAIAction_IssueCommandGeneratedLocation::CommandType' has a wrong offset!");
static_assert(offsetof(UUtilityAIAction_IssueCommandGeneratedLocation, QueryPreset) == 0x000040, "Member 'UUtilityAIAction_IssueCommandGeneratedLocation::QueryPreset' has a wrong offset!");
static_assert(offsetof(UUtilityAIAction_IssueCommandGeneratedLocation, QueryType) == 0x000048, "Member 'UUtilityAIAction_IssueCommandGeneratedLocation::QueryType' has a wrong offset!");
static_assert(offsetof(UUtilityAIAction_IssueCommandGeneratedLocation, QueryLocationType) == 0x000049, "Member 'UUtilityAIAction_IssueCommandGeneratedLocation::QueryLocationType' has a wrong offset!");
static_assert(offsetof(UUtilityAIAction_IssueCommandGeneratedLocation, SearchRange) == 0x00004C, "Member 'UUtilityAIAction_IssueCommandGeneratedLocation::SearchRange' has a wrong offset!");
static_assert(offsetof(UUtilityAIAction_IssueCommandGeneratedLocation, InfluenceThreshold) == 0x000050, "Member 'UUtilityAIAction_IssueCommandGeneratedLocation::InfluenceThreshold' has a wrong offset!");

// Class Tempest.UtilityAITargetFilter_TagRequirements
// 0x0088 (0x00B0 - 0x0028)
class UUtilityAITargetFilter_TagRequirements final : public UUtilityAITargetFilter
{
public:
	struct FGameplayTagRequirements               TagRequirements;                                   // 0x0028(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAITargetFilter_TagRequirements">();
	}
	static class UUtilityAITargetFilter_TagRequirements* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAITargetFilter_TagRequirements>();
	}
};
static_assert(alignof(UUtilityAITargetFilter_TagRequirements) == 0x000008, "Wrong alignment on UUtilityAITargetFilter_TagRequirements");
static_assert(sizeof(UUtilityAITargetFilter_TagRequirements) == 0x0000B0, "Wrong size on UUtilityAITargetFilter_TagRequirements");
static_assert(offsetof(UUtilityAITargetFilter_TagRequirements, TagRequirements) == 0x000028, "Member 'UUtilityAITargetFilter_TagRequirements::TagRequirements' has a wrong offset!");

// Class Tempest.UtilityAITargetFilter_Domain
// 0x0028 (0x0050 - 0x0028)
class UUtilityAITargetFilter_Domain final : public UUtilityAITargetFilter
{
public:
	struct FGameplayTagContainer                  Domain;                                            // 0x0028(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bInvert;                                           // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAITargetFilter_Domain">();
	}
	static class UUtilityAITargetFilter_Domain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAITargetFilter_Domain>();
	}
};
static_assert(alignof(UUtilityAITargetFilter_Domain) == 0x000008, "Wrong alignment on UUtilityAITargetFilter_Domain");
static_assert(sizeof(UUtilityAITargetFilter_Domain) == 0x000050, "Wrong size on UUtilityAITargetFilter_Domain");
static_assert(offsetof(UUtilityAITargetFilter_Domain, Domain) == 0x000028, "Member 'UUtilityAITargetFilter_Domain::Domain' has a wrong offset!");
static_assert(offsetof(UUtilityAITargetFilter_Domain, bInvert) == 0x000048, "Member 'UUtilityAITargetFilter_Domain::bInvert' has a wrong offset!");

// Class Tempest.UtilityAITargetFilter_WeaponDomain
// 0x0000 (0x0028 - 0x0028)
class UUtilityAITargetFilter_WeaponDomain final : public UUtilityAITargetFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAITargetFilter_WeaponDomain">();
	}
	static class UUtilityAITargetFilter_WeaponDomain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAITargetFilter_WeaponDomain>();
	}
};
static_assert(alignof(UUtilityAITargetFilter_WeaponDomain) == 0x000008, "Wrong alignment on UUtilityAITargetFilter_WeaponDomain");
static_assert(sizeof(UUtilityAITargetFilter_WeaponDomain) == 0x000028, "Wrong size on UUtilityAITargetFilter_WeaponDomain");

// Class Tempest.UtilityAITargetFilter_ValidCommandTarget
// 0x0008 (0x0030 - 0x0028)
class UUtilityAITargetFilter_ValidCommandTarget final : public UUtilityAITargetFilter
{
public:
	struct FGameplayTag                           CommandType;                                       // 0x0028(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAITargetFilter_ValidCommandTarget">();
	}
	static class UUtilityAITargetFilter_ValidCommandTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAITargetFilter_ValidCommandTarget>();
	}
};
static_assert(alignof(UUtilityAITargetFilter_ValidCommandTarget) == 0x000008, "Wrong alignment on UUtilityAITargetFilter_ValidCommandTarget");
static_assert(sizeof(UUtilityAITargetFilter_ValidCommandTarget) == 0x000030, "Wrong size on UUtilityAITargetFilter_ValidCommandTarget");
static_assert(offsetof(UUtilityAITargetFilter_ValidCommandTarget, CommandType) == 0x000028, "Member 'UUtilityAITargetFilter_ValidCommandTarget::CommandType' has a wrong offset!");

// Class Tempest.UtilityAITargetFilter_ValidClass
// 0x0010 (0x0038 - 0x0028)
class UUtilityAITargetFilter_ValidClass final : public UUtilityAITargetFilter
{
public:
	TArray<TSubclassOf<class ATedPawn>>           Classes;                                           // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAITargetFilter_ValidClass">();
	}
	static class UUtilityAITargetFilter_ValidClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAITargetFilter_ValidClass>();
	}
};
static_assert(alignof(UUtilityAITargetFilter_ValidClass) == 0x000008, "Wrong alignment on UUtilityAITargetFilter_ValidClass");
static_assert(sizeof(UUtilityAITargetFilter_ValidClass) == 0x000038, "Wrong size on UUtilityAITargetFilter_ValidClass");
static_assert(offsetof(UUtilityAITargetFilter_ValidClass, Classes) == 0x000028, "Member 'UUtilityAITargetFilter_ValidClass::Classes' has a wrong offset!");

// Class Tempest.UtilityAITargetGenerator_Pawn
// 0x0108 (0x0130 - 0x0028)
class UUtilityAITargetGenerator_Pawn : public UUtilityAITargetGenerator
{
public:
	EUtilityAITargetGeneratorQueryLocationMode    QueryLocationMode;                                 // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUtilityAITargetGeneratorQueryRangeMode       QueryRangeMode;                                    // 0x0029(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReturnContainerOwnerWhenNotNull;                  // 0x002A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIDataProviderFloatValue              DataProviderQueryRange;                            // 0x0030(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAISenseAffiliationFilter              TargetAttitudeFilter;                              // 0x0068(0x0004)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  TargetDomain;                                      // 0x0070(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagRequirements               TargetTagRequirements;                             // 0x0090(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         ResultLimit;                                       // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ATedPawn>                   ClassFilter;                                       // 0x0120(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUtilityAITargetDistanceSorterMode            SorterMode;                                        // 0x0128(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAITargetGenerator_Pawn">();
	}
	static class UUtilityAITargetGenerator_Pawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAITargetGenerator_Pawn>();
	}
};
static_assert(alignof(UUtilityAITargetGenerator_Pawn) == 0x000008, "Wrong alignment on UUtilityAITargetGenerator_Pawn");
static_assert(sizeof(UUtilityAITargetGenerator_Pawn) == 0x000130, "Wrong size on UUtilityAITargetGenerator_Pawn");
static_assert(offsetof(UUtilityAITargetGenerator_Pawn, QueryLocationMode) == 0x000028, "Member 'UUtilityAITargetGenerator_Pawn::QueryLocationMode' has a wrong offset!");
static_assert(offsetof(UUtilityAITargetGenerator_Pawn, QueryRangeMode) == 0x000029, "Member 'UUtilityAITargetGenerator_Pawn::QueryRangeMode' has a wrong offset!");
static_assert(offsetof(UUtilityAITargetGenerator_Pawn, bReturnContainerOwnerWhenNotNull) == 0x00002A, "Member 'UUtilityAITargetGenerator_Pawn::bReturnContainerOwnerWhenNotNull' has a wrong offset!");
static_assert(offsetof(UUtilityAITargetGenerator_Pawn, DataProviderQueryRange) == 0x000030, "Member 'UUtilityAITargetGenerator_Pawn::DataProviderQueryRange' has a wrong offset!");
static_assert(offsetof(UUtilityAITargetGenerator_Pawn, TargetAttitudeFilter) == 0x000068, "Member 'UUtilityAITargetGenerator_Pawn::TargetAttitudeFilter' has a wrong offset!");
static_assert(offsetof(UUtilityAITargetGenerator_Pawn, TargetDomain) == 0x000070, "Member 'UUtilityAITargetGenerator_Pawn::TargetDomain' has a wrong offset!");
static_assert(offsetof(UUtilityAITargetGenerator_Pawn, TargetTagRequirements) == 0x000090, "Member 'UUtilityAITargetGenerator_Pawn::TargetTagRequirements' has a wrong offset!");
static_assert(offsetof(UUtilityAITargetGenerator_Pawn, ResultLimit) == 0x000118, "Member 'UUtilityAITargetGenerator_Pawn::ResultLimit' has a wrong offset!");
static_assert(offsetof(UUtilityAITargetGenerator_Pawn, ClassFilter) == 0x000120, "Member 'UUtilityAITargetGenerator_Pawn::ClassFilter' has a wrong offset!");
static_assert(offsetof(UUtilityAITargetGenerator_Pawn, SorterMode) == 0x000128, "Member 'UUtilityAITargetGenerator_Pawn::SorterMode' has a wrong offset!");

}

