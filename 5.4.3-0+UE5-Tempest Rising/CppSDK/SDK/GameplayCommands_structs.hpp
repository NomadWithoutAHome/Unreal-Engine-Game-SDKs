#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GameplayCommands

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"
#include "NubCore_structs.hpp"


namespace SDK
{

// Enum GameplayCommands.EGameplayReplicationCommandExecutionEvent
// NumValues: 0x0009
enum class EGameplayReplicationCommandExecutionEvent : uint8
{
	SetCurrent                               = 0,
	ClearCurrent                             = 1,
	DequeueAndSetAsCurrent                   = 2,
	Enqueue                                  = 3,
	EnqueueAtFront                           = 4,
	ClearQueue                               = 5,
	Reset                                    = 6,
	Invalid                                  = 7,
	EGameplayReplicationCommandExecutionEvent_MAX = 8,
};

// Enum GameplayCommands.EGameplayCommandTargetType
// NumValues: 0x0005
enum class EGameplayCommandTargetType : uint8
{
	None                                     = 0,
	Location                                 = 1,
	Actor                                    = 2,
	LocationOrActor                          = 3,
	EGameplayCommandTargetType_MAX           = 4,
};

// Enum GameplayCommands.EGameplayCommandGroupExecutionPolicy
// NumValues: 0x0005
enum class EGameplayCommandGroupExecutionPolicy : uint8
{
	All                                      = 0,
	SelectedSubGroup                         = 1,
	MainSelected                             = 2,
	MostSuitable                             = 3,
	EGameplayCommandGroupExecutionPolicy_MAX = 4,
};

// Enum GameplayCommands.EGameplayCommandProcessingPolicy
// NumValues: 0x0004
enum class EGameplayCommandProcessingPolicy : uint8
{
	Instant                                  = 0,
	CanBeCanceled                            = 1,
	CannotBeCanceled                         = 2,
	EGameplayCommandProcessingPolicy_MAX     = 3,
};

// Enum GameplayCommands.EGameplayCommandCooldownApplicationRule
// NumValues: 0x0004
enum class EGameplayCommandCooldownApplicationRule : uint8
{
	OnExecute                                = 0,
	OnFinished                               = 1,
	Custom                                   = 2,
	EGameplayCommandCooldownApplicationRule_MAX = 3,
};

// Enum GameplayCommands.EGameplayCommandApplicationRule
// NumValues: 0x0006
enum class EGameplayCommandApplicationRule : uint8
{
	None                                     = 0,
	OnExecute                                = 1,
	OnFinishedSuccessfully                   = 2,
	OnFinished                               = 3,
	Manual                                   = 4,
	EGameplayCommandApplicationRule_MAX      = 5,
};

// Enum GameplayCommands.EGameplayCommandNetExecutionPolicy
// NumValues: 0x0003
enum class EGameplayCommandNetExecutionPolicy : uint8
{
	ServerOnly                               = 0,
	LocalPredicted                           = 1,
	EGameplayCommandNetExecutionPolicy_MAX   = 2,
};

// Enum GameplayCommands.EGameplayCommandResult
// NumValues: 0x0004
enum class EGameplayCommandResult : uint8
{
	Succeeded                                = 0,
	Failed                                   = 1,
	Canceled                                 = 2,
	EGameplayCommandResult_MAX               = 3,
};

// Enum GameplayCommands.EGameplayCommandValueType
// NumValues: 0x0004
enum class EGameplayCommandValueType : uint8
{
	FixedValue                               = 0,
	CalculationBasedValue                    = 1,
	InstancedCalculationBasedValue           = 2,
	EGameplayCommandValueType_MAX            = 3,
};

// ScriptStruct GameplayCommands.GameplayReplicationCommandCooldown
// 0x000C (0x000C - 0x0000)
struct FGameplayReplicationCommandCooldown final
{
public:
	struct FGameplayTag                           CooldownTag;                                       // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpirationTime;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayReplicationCommandCooldown) == 0x000004, "Wrong alignment on FGameplayReplicationCommandCooldown");
static_assert(sizeof(FGameplayReplicationCommandCooldown) == 0x00000C, "Wrong size on FGameplayReplicationCommandCooldown");
static_assert(offsetof(FGameplayReplicationCommandCooldown, CooldownTag) == 0x000000, "Member 'FGameplayReplicationCommandCooldown::CooldownTag' has a wrong offset!");
static_assert(offsetof(FGameplayReplicationCommandCooldown, ExpirationTime) == 0x000008, "Member 'FGameplayReplicationCommandCooldown::ExpirationTime' has a wrong offset!");

// ScriptStruct GameplayCommands.GameplayCommandCooldowns
// 0x0060 (0x0070 - 0x0010)
struct FGameplayCommandCooldowns final : public FOwnedStruct
{
public:
	TMap<struct FGameplayTag, struct FTimerHandle> Handles;                                          // 0x0010(0x0050)(RepSkip, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayReplicationCommandCooldown> ReplicatedCooldowns;                          // 0x0060(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGameplayCommandCooldowns) == 0x000008, "Wrong alignment on FGameplayCommandCooldowns");
static_assert(sizeof(FGameplayCommandCooldowns) == 0x000070, "Wrong size on FGameplayCommandCooldowns");
static_assert(offsetof(FGameplayCommandCooldowns, Handles) == 0x000010, "Member 'FGameplayCommandCooldowns::Handles' has a wrong offset!");
static_assert(offsetof(FGameplayCommandCooldowns, ReplicatedCooldowns) == 0x000060, "Member 'FGameplayCommandCooldowns::ReplicatedCooldowns' has a wrong offset!");

// ScriptStruct GameplayCommands.GameplayCommandID
// 0x0002 (0x0002 - 0x0000)
struct alignas(0x02) FGameplayCommandID final
{
public:
	uint8                                         Pad_0[0x2];                                        // 0x0000(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayCommandID) == 0x000002, "Wrong alignment on FGameplayCommandID");
static_assert(sizeof(FGameplayCommandID) == 0x000002, "Wrong size on FGameplayCommandID");

// ScriptStruct GameplayCommands.GameplayCommandErrorTags
// 0x0060 (0x0060 - 0x0000)
struct FGameplayCommandErrorTags final
{
public:
	struct FGameplayTagContainer                  MissingTags;                                       // 0x0000(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BlockingTags;                                      // 0x0020(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ErrorTags;                                         // 0x0040(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayCommandErrorTags) == 0x000008, "Wrong alignment on FGameplayCommandErrorTags");
static_assert(sizeof(FGameplayCommandErrorTags) == 0x000060, "Wrong size on FGameplayCommandErrorTags");
static_assert(offsetof(FGameplayCommandErrorTags, MissingTags) == 0x000000, "Member 'FGameplayCommandErrorTags::MissingTags' has a wrong offset!");
static_assert(offsetof(FGameplayCommandErrorTags, BlockingTags) == 0x000020, "Member 'FGameplayCommandErrorTags::BlockingTags' has a wrong offset!");
static_assert(offsetof(FGameplayCommandErrorTags, ErrorTags) == 0x000040, "Member 'FGameplayCommandErrorTags::ErrorTags' has a wrong offset!");

// ScriptStruct GameplayCommands.GameplayCommandExecutionInfo
// 0x0050 (0x0060 - 0x0010)
struct FGameplayCommandExecutionInfo final : public FOwnedStruct
{
public:
	class UGameplayCommandComponentV2*            CommandComponent;                                  // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18[0x48];                                      // 0x0018(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayCommandExecutionInfo) == 0x000008, "Wrong alignment on FGameplayCommandExecutionInfo");
static_assert(sizeof(FGameplayCommandExecutionInfo) == 0x000060, "Wrong size on FGameplayCommandExecutionInfo");
static_assert(offsetof(FGameplayCommandExecutionInfo, CommandComponent) == 0x000010, "Member 'FGameplayCommandExecutionInfo::CommandComponent' has a wrong offset!");

// ScriptStruct GameplayCommands.GameplayReplicationCommandExecutionEvent
// 0x0004 (0x0004 - 0x0000)
struct FGameplayReplicationCommandExecutionEvent final
{
public:
	EGameplayReplicationCommandExecutionEvent     Event;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x1];                                        // 0x0001(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayCommandID                     CommandID;                                         // 0x0002(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayReplicationCommandExecutionEvent) == 0x000002, "Wrong alignment on FGameplayReplicationCommandExecutionEvent");
static_assert(sizeof(FGameplayReplicationCommandExecutionEvent) == 0x000004, "Wrong size on FGameplayReplicationCommandExecutionEvent");
static_assert(offsetof(FGameplayReplicationCommandExecutionEvent, Event) == 0x000000, "Member 'FGameplayReplicationCommandExecutionEvent::Event' has a wrong offset!");
static_assert(offsetof(FGameplayReplicationCommandExecutionEvent, CommandID) == 0x000002, "Member 'FGameplayReplicationCommandExecutionEvent::CommandID' has a wrong offset!");

// ScriptStruct GameplayCommands.GameplayCommandData
// 0x0048 (0x0048 - 0x0000)
struct FGameplayCommandData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayCommand>           Command;                                           // 0x0008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseLocation : 1;                                  // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D_NetQuantize                  TargetLocation;                                    // 0x0018(0x0010)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0028(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowReplicateEmpty;                              // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x17];                                      // 0x0031(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayCommandData) == 0x000008, "Wrong alignment on FGameplayCommandData");
static_assert(sizeof(FGameplayCommandData) == 0x000048, "Wrong size on FGameplayCommandData");
static_assert(offsetof(FGameplayCommandData, Command) == 0x000008, "Member 'FGameplayCommandData::Command' has a wrong offset!");
static_assert(offsetof(FGameplayCommandData, TargetLocation) == 0x000018, "Member 'FGameplayCommandData::TargetLocation' has a wrong offset!");
static_assert(offsetof(FGameplayCommandData, Target) == 0x000028, "Member 'FGameplayCommandData::Target' has a wrong offset!");
static_assert(offsetof(FGameplayCommandData, bAllowReplicateEmpty) == 0x000030, "Member 'FGameplayCommandData::bAllowReplicateEmpty' has a wrong offset!");

// ScriptStruct GameplayCommands.GameplayReplicationRegisterCommandEvent
// 0x0050 (0x0050 - 0x0000)
struct FGameplayReplicationRegisterCommandEvent final
{
public:
	bool                                          bRegister;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x1];                                        // 0x0001(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayCommandID                     CommandID;                                         // 0x0002(0x0002)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayCommandData                   CommandData;                                       // 0x0008(0x0048)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayReplicationRegisterCommandEvent) == 0x000008, "Wrong alignment on FGameplayReplicationRegisterCommandEvent");
static_assert(sizeof(FGameplayReplicationRegisterCommandEvent) == 0x000050, "Wrong size on FGameplayReplicationRegisterCommandEvent");
static_assert(offsetof(FGameplayReplicationRegisterCommandEvent, bRegister) == 0x000000, "Member 'FGameplayReplicationRegisterCommandEvent::bRegister' has a wrong offset!");
static_assert(offsetof(FGameplayReplicationRegisterCommandEvent, CommandID) == 0x000002, "Member 'FGameplayReplicationRegisterCommandEvent::CommandID' has a wrong offset!");
static_assert(offsetof(FGameplayReplicationRegisterCommandEvent, CommandData) == 0x000008, "Member 'FGameplayReplicationRegisterCommandEvent::CommandData' has a wrong offset!");

// ScriptStruct GameplayCommands.GameplayReplicationRegisterCommandEventsContainer
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FGameplayReplicationRegisterCommandEventsContainer final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayReplicationRegisterCommandEventsContainer) == 0x000008, "Wrong alignment on FGameplayReplicationRegisterCommandEventsContainer");
static_assert(sizeof(FGameplayReplicationRegisterCommandEventsContainer) == 0x000018, "Wrong size on FGameplayReplicationRegisterCommandEventsContainer");

// ScriptStruct GameplayCommands.GameplayCommandDataCustomPayload
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FGameplayCommandDataCustomPayload
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayCommandDataCustomPayload) == 0x000008, "Wrong alignment on FGameplayCommandDataCustomPayload");
static_assert(sizeof(FGameplayCommandDataCustomPayload) == 0x000008, "Wrong size on FGameplayCommandDataCustomPayload");

// ScriptStruct GameplayCommands.GameplayCommandFallbackRequirementEntry
// 0x0010 (0x0010 - 0x0000)
struct FGameplayCommandFallbackRequirementEntry final
{
public:
	TSubclassOf<class UGameplayCommandFallbackRequirement> Requirement;                              // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvert;                                           // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayCommandFallbackRequirementEntry) == 0x000008, "Wrong alignment on FGameplayCommandFallbackRequirementEntry");
static_assert(sizeof(FGameplayCommandFallbackRequirementEntry) == 0x000010, "Wrong size on FGameplayCommandFallbackRequirementEntry");
static_assert(offsetof(FGameplayCommandFallbackRequirementEntry, Requirement) == 0x000000, "Member 'FGameplayCommandFallbackRequirementEntry::Requirement' has a wrong offset!");
static_assert(offsetof(FGameplayCommandFallbackRequirementEntry, bInvert) == 0x000008, "Member 'FGameplayCommandFallbackRequirementEntry::bInvert' has a wrong offset!");

// ScriptStruct GameplayCommands.GameplayCommandFallback
// 0x0020 (0x0020 - 0x0000)
struct FGameplayCommandFallback final
{
public:
	TSubclassOf<class UGameplayCommand>           Command;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayCommandFallbackRequirementEntry> Requirements;                            // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayCommandDataConverter> DataConverter;                                  // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayCommandFallback) == 0x000008, "Wrong alignment on FGameplayCommandFallback");
static_assert(sizeof(FGameplayCommandFallback) == 0x000020, "Wrong size on FGameplayCommandFallback");
static_assert(offsetof(FGameplayCommandFallback, Command) == 0x000000, "Member 'FGameplayCommandFallback::Command' has a wrong offset!");
static_assert(offsetof(FGameplayCommandFallback, Requirements) == 0x000008, "Member 'FGameplayCommandFallback::Requirements' has a wrong offset!");
static_assert(offsetof(FGameplayCommandFallback, DataConverter) == 0x000018, "Member 'FGameplayCommandFallback::DataConverter' has a wrong offset!");

// ScriptStruct GameplayCommands.GameplayCommandCalculationBasedValue
// 0x0010 (0x0010 - 0x0000)
struct FGameplayCommandCalculationBasedValue final
{
public:
	TSubclassOf<class UGameplayCommandValueCalculation> CalculationClass;                            // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Coefficient;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayCommandCalculationBasedValue) == 0x000008, "Wrong alignment on FGameplayCommandCalculationBasedValue");
static_assert(sizeof(FGameplayCommandCalculationBasedValue) == 0x000010, "Wrong size on FGameplayCommandCalculationBasedValue");
static_assert(offsetof(FGameplayCommandCalculationBasedValue, CalculationClass) == 0x000000, "Member 'FGameplayCommandCalculationBasedValue::CalculationClass' has a wrong offset!");
static_assert(offsetof(FGameplayCommandCalculationBasedValue, Coefficient) == 0x000008, "Member 'FGameplayCommandCalculationBasedValue::Coefficient' has a wrong offset!");

// ScriptStruct GameplayCommands.GameplayCommandInstancedCalculationBasedValue
// 0x0010 (0x0010 - 0x0000)
struct FGameplayCommandInstancedCalculationBasedValue final
{
public:
	class UGameplayCommandValueCalculation*       CalculationInstance;                               // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Coefficient;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayCommandInstancedCalculationBasedValue) == 0x000008, "Wrong alignment on FGameplayCommandInstancedCalculationBasedValue");
static_assert(sizeof(FGameplayCommandInstancedCalculationBasedValue) == 0x000010, "Wrong size on FGameplayCommandInstancedCalculationBasedValue");
static_assert(offsetof(FGameplayCommandInstancedCalculationBasedValue, CalculationInstance) == 0x000000, "Member 'FGameplayCommandInstancedCalculationBasedValue::CalculationInstance' has a wrong offset!");
static_assert(offsetof(FGameplayCommandInstancedCalculationBasedValue, Coefficient) == 0x000008, "Member 'FGameplayCommandInstancedCalculationBasedValue::Coefficient' has a wrong offset!");

// ScriptStruct GameplayCommands.FGameplayCommandValue
// 0x0028 (0x0028 - 0x0000)
struct FFGameplayCommandValue final
{
public:
	EGameplayCommandValueType                     ValueType;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FixedValue;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayCommandCalculationBasedValue  CalculationBasedValue;                             // 0x0008(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCommandInstancedCalculationBasedValue InstancedCalculationBasedValue;            // 0x0018(0x0010)(Edit, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FFGameplayCommandValue) == 0x000008, "Wrong alignment on FFGameplayCommandValue");
static_assert(sizeof(FFGameplayCommandValue) == 0x000028, "Wrong size on FFGameplayCommandValue");
static_assert(offsetof(FFGameplayCommandValue, ValueType) == 0x000000, "Member 'FFGameplayCommandValue::ValueType' has a wrong offset!");
static_assert(offsetof(FFGameplayCommandValue, FixedValue) == 0x000004, "Member 'FFGameplayCommandValue::FixedValue' has a wrong offset!");
static_assert(offsetof(FFGameplayCommandValue, CalculationBasedValue) == 0x000008, "Member 'FFGameplayCommandValue::CalculationBasedValue' has a wrong offset!");
static_assert(offsetof(FFGameplayCommandValue, InstancedCalculationBasedValue) == 0x000018, "Member 'FFGameplayCommandValue::InstancedCalculationBasedValue' has a wrong offset!");

}

