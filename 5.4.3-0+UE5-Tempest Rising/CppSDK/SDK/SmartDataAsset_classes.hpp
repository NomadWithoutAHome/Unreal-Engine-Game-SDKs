#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SmartDataAsset

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "CoreUObject_classes.hpp"
#include "SmartDataAsset_structs.hpp"
#include "GameplayTags_structs.hpp"


namespace SDK
{

// Class SmartDataAsset.SmartDataAsset
// 0x0008 (0x0038 - 0x0030)
class USmartDataAsset : public UDataAsset
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmartDataAsset">();
	}
	static class USmartDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USmartDataAsset>();
	}
};
static_assert(alignof(USmartDataAsset) == 0x000008, "Wrong alignment on USmartDataAsset");
static_assert(sizeof(USmartDataAsset) == 0x000038, "Wrong size on USmartDataAsset");

// Class SmartDataAsset.SmartDataAssetTemplate
// 0x0018 (0x0048 - 0x0030)
class USmartDataAssetTemplate final : public UDataAsset
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class USmartDataAsset>            DataClass;                                         // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USmartDataAsset*                        Data;                                              // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmartDataAssetTemplate">();
	}
	static class USmartDataAssetTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<USmartDataAssetTemplate>();
	}
};
static_assert(alignof(USmartDataAssetTemplate) == 0x000008, "Wrong alignment on USmartDataAssetTemplate");
static_assert(sizeof(USmartDataAssetTemplate) == 0x000048, "Wrong size on USmartDataAssetTemplate");
static_assert(offsetof(USmartDataAssetTemplate, DataClass) == 0x000038, "Member 'USmartDataAssetTemplate::DataClass' has a wrong offset!");
static_assert(offsetof(USmartDataAssetTemplate, Data) == 0x000040, "Member 'USmartDataAssetTemplate::Data' has a wrong offset!");

// Class SmartDataAsset.SmartDataAssetTemplateInterface
// 0x0000 (0x0000 - 0x0000)
class ISmartDataAssetTemplateInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmartDataAssetTemplateInterface">();
	}
	static class ISmartDataAssetTemplateInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISmartDataAssetTemplateInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISmartDataAssetTemplateInterface) == 0x000001, "Wrong alignment on ISmartDataAssetTemplateInterface");
static_assert(sizeof(ISmartDataAssetTemplateInterface) == 0x000001, "Wrong size on ISmartDataAssetTemplateInterface");

// Class SmartDataAsset.MyDataAsset
// 0x0218 (0x0250 - 0x0038)
class UMyDataAsset : public USmartDataAsset
{
public:
	class FString                                 MyString;                                          // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MyInt;                                             // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         MyArray;                                           // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSet<class FString>                           MySet;                                             // 0x0060(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            MyMap;                                             // 0x00B0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FMyDataStruct                          MyStruct;                                          // 0x0100(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FMyInheritableDataStruct               MyStruct2;                                         // 0x0118(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FMyInheritableDataStruct               MyStruct3;                                         // 0x0148(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FMyInheritableArray                    MyInheritableArray;                                // 0x0178(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FMyInheritableSet                      MyInheritableSet;                                  // 0x0188(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FMyInheritableMap                      MyInheritableMap;                                  // 0x01D8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 MyString2;                                         // 0x0228(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MyInt2;                                            // 0x0238(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         MyArray2;                                          // 0x0240(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MyDataAsset">();
	}
	static class UMyDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMyDataAsset>();
	}
};
static_assert(alignof(UMyDataAsset) == 0x000008, "Wrong alignment on UMyDataAsset");
static_assert(sizeof(UMyDataAsset) == 0x000250, "Wrong size on UMyDataAsset");
static_assert(offsetof(UMyDataAsset, MyString) == 0x000038, "Member 'UMyDataAsset::MyString' has a wrong offset!");
static_assert(offsetof(UMyDataAsset, MyInt) == 0x000048, "Member 'UMyDataAsset::MyInt' has a wrong offset!");
static_assert(offsetof(UMyDataAsset, MyArray) == 0x000050, "Member 'UMyDataAsset::MyArray' has a wrong offset!");
static_assert(offsetof(UMyDataAsset, MySet) == 0x000060, "Member 'UMyDataAsset::MySet' has a wrong offset!");
static_assert(offsetof(UMyDataAsset, MyMap) == 0x0000B0, "Member 'UMyDataAsset::MyMap' has a wrong offset!");
static_assert(offsetof(UMyDataAsset, MyStruct) == 0x000100, "Member 'UMyDataAsset::MyStruct' has a wrong offset!");
static_assert(offsetof(UMyDataAsset, MyStruct2) == 0x000118, "Member 'UMyDataAsset::MyStruct2' has a wrong offset!");
static_assert(offsetof(UMyDataAsset, MyStruct3) == 0x000148, "Member 'UMyDataAsset::MyStruct3' has a wrong offset!");
static_assert(offsetof(UMyDataAsset, MyInheritableArray) == 0x000178, "Member 'UMyDataAsset::MyInheritableArray' has a wrong offset!");
static_assert(offsetof(UMyDataAsset, MyInheritableSet) == 0x000188, "Member 'UMyDataAsset::MyInheritableSet' has a wrong offset!");
static_assert(offsetof(UMyDataAsset, MyInheritableMap) == 0x0001D8, "Member 'UMyDataAsset::MyInheritableMap' has a wrong offset!");
static_assert(offsetof(UMyDataAsset, MyString2) == 0x000228, "Member 'UMyDataAsset::MyString2' has a wrong offset!");
static_assert(offsetof(UMyDataAsset, MyInt2) == 0x000238, "Member 'UMyDataAsset::MyInt2' has a wrong offset!");
static_assert(offsetof(UMyDataAsset, MyArray2) == 0x000240, "Member 'UMyDataAsset::MyArray2' has a wrong offset!");

// Class SmartDataAsset.MySubClassedDataAsset
// 0x0010 (0x0260 - 0x0250)
class UMySubClassedDataAsset final : public UMyDataAsset
{
public:
	class FString                                 MyExtraString;                                     // 0x0250(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MySubClassedDataAsset">();
	}
	static class UMySubClassedDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMySubClassedDataAsset>();
	}
};
static_assert(alignof(UMySubClassedDataAsset) == 0x000008, "Wrong alignment on UMySubClassedDataAsset");
static_assert(sizeof(UMySubClassedDataAsset) == 0x000260, "Wrong size on UMySubClassedDataAsset");
static_assert(offsetof(UMySubClassedDataAsset, MyExtraString) == 0x000250, "Member 'UMySubClassedDataAsset::MyExtraString' has a wrong offset!");

// Class SmartDataAsset.MyOtherDataAsset
// 0x0060 (0x0098 - 0x0038)
class UMyOtherDataAsset final : public USmartDataAsset
{
public:
	TMap<TSubclassOf<class UObject>, int32>       MyCustomMap;                                       // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FMyDataStruct>                  MyStructArray;                                     // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MyOtherDataAsset">();
	}
	static class UMyOtherDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMyOtherDataAsset>();
	}
};
static_assert(alignof(UMyOtherDataAsset) == 0x000008, "Wrong alignment on UMyOtherDataAsset");
static_assert(sizeof(UMyOtherDataAsset) == 0x000098, "Wrong size on UMyOtherDataAsset");
static_assert(offsetof(UMyOtherDataAsset, MyCustomMap) == 0x000038, "Member 'UMyOtherDataAsset::MyCustomMap' has a wrong offset!");
static_assert(offsetof(UMyOtherDataAsset, MyStructArray) == 0x000088, "Member 'UMyOtherDataAsset::MyStructArray' has a wrong offset!");

// Class SmartDataAsset.MySmartDataAsset
// 0x0218 (0x0250 - 0x0038)
class UMySmartDataAsset final : public USmartDataAsset
{
public:
	class FString                                 MyString;                                          // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MyInt;                                             // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         MyArray;                                           // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSet<class FString>                           MySet;                                             // 0x0060(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            MyMap;                                             // 0x00B0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FMyDataStruct                          MyStruct;                                          // 0x0100(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FMyInheritableDataStruct               MyStruct2;                                         // 0x0118(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FMyInheritableDataStruct               MyStruct3;                                         // 0x0148(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FMyInheritableArray                    MyInheritableArray;                                // 0x0178(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FMyInheritableSet                      MyInheritableSet;                                  // 0x0188(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FMyInheritableMap                      MyInheritableMap;                                  // 0x01D8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 MyString2;                                         // 0x0228(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MyInt2;                                            // 0x0238(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         MyArray2;                                          // 0x0240(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MySmartDataAsset">();
	}
	static class UMySmartDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMySmartDataAsset>();
	}
};
static_assert(alignof(UMySmartDataAsset) == 0x000008, "Wrong alignment on UMySmartDataAsset");
static_assert(sizeof(UMySmartDataAsset) == 0x000250, "Wrong size on UMySmartDataAsset");
static_assert(offsetof(UMySmartDataAsset, MyString) == 0x000038, "Member 'UMySmartDataAsset::MyString' has a wrong offset!");
static_assert(offsetof(UMySmartDataAsset, MyInt) == 0x000048, "Member 'UMySmartDataAsset::MyInt' has a wrong offset!");
static_assert(offsetof(UMySmartDataAsset, MyArray) == 0x000050, "Member 'UMySmartDataAsset::MyArray' has a wrong offset!");
static_assert(offsetof(UMySmartDataAsset, MySet) == 0x000060, "Member 'UMySmartDataAsset::MySet' has a wrong offset!");
static_assert(offsetof(UMySmartDataAsset, MyMap) == 0x0000B0, "Member 'UMySmartDataAsset::MyMap' has a wrong offset!");
static_assert(offsetof(UMySmartDataAsset, MyStruct) == 0x000100, "Member 'UMySmartDataAsset::MyStruct' has a wrong offset!");
static_assert(offsetof(UMySmartDataAsset, MyStruct2) == 0x000118, "Member 'UMySmartDataAsset::MyStruct2' has a wrong offset!");
static_assert(offsetof(UMySmartDataAsset, MyStruct3) == 0x000148, "Member 'UMySmartDataAsset::MyStruct3' has a wrong offset!");
static_assert(offsetof(UMySmartDataAsset, MyInheritableArray) == 0x000178, "Member 'UMySmartDataAsset::MyInheritableArray' has a wrong offset!");
static_assert(offsetof(UMySmartDataAsset, MyInheritableSet) == 0x000188, "Member 'UMySmartDataAsset::MyInheritableSet' has a wrong offset!");
static_assert(offsetof(UMySmartDataAsset, MyInheritableMap) == 0x0001D8, "Member 'UMySmartDataAsset::MyInheritableMap' has a wrong offset!");
static_assert(offsetof(UMySmartDataAsset, MyString2) == 0x000228, "Member 'UMySmartDataAsset::MyString2' has a wrong offset!");
static_assert(offsetof(UMySmartDataAsset, MyInt2) == 0x000238, "Member 'UMySmartDataAsset::MyInt2' has a wrong offset!");
static_assert(offsetof(UMySmartDataAsset, MyArray2) == 0x000240, "Member 'UMySmartDataAsset::MyArray2' has a wrong offset!");

// Class SmartDataAsset.SmartDataCollectableInterface
// 0x0000 (0x0000 - 0x0000)
class ISmartDataCollectableInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmartDataCollectableInterface">();
	}
	static class ISmartDataCollectableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISmartDataCollectableInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISmartDataCollectableInterface) == 0x000001, "Wrong alignment on ISmartDataCollectableInterface");
static_assert(sizeof(ISmartDataCollectableInterface) == 0x000001, "Wrong size on ISmartDataCollectableInterface");

// Class SmartDataAsset.SmartDataCollection
// 0x0088 (0x00C0 - 0x0038)
class USmartDataCollection final : public USmartDataAsset
{
public:
	TArray<struct FSmartDataSearchConfig>         AssetSearchConfigs;                                // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, class UDataAsset*>  RegisteredAssetsMap;                               // 0x0048(0x0050)(Edit, Transient, DisableEditOnInstance, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSmartDataBinding>              CustomBindings;                                    // 0x0098(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UDataAsset>>      PendingAssetsToLoad;                               // 0x00B0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void HandlePendingAssetsLoaded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmartDataCollection">();
	}
	static class USmartDataCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<USmartDataCollection>();
	}
};
static_assert(alignof(USmartDataCollection) == 0x000008, "Wrong alignment on USmartDataCollection");
static_assert(sizeof(USmartDataCollection) == 0x0000C0, "Wrong size on USmartDataCollection");
static_assert(offsetof(USmartDataCollection, AssetSearchConfigs) == 0x000038, "Member 'USmartDataCollection::AssetSearchConfigs' has a wrong offset!");
static_assert(offsetof(USmartDataCollection, RegisteredAssetsMap) == 0x000048, "Member 'USmartDataCollection::RegisteredAssetsMap' has a wrong offset!");
static_assert(offsetof(USmartDataCollection, CustomBindings) == 0x000098, "Member 'USmartDataCollection::CustomBindings' has a wrong offset!");
static_assert(offsetof(USmartDataCollection, PendingAssetsToLoad) == 0x0000B0, "Member 'USmartDataCollection::PendingAssetsToLoad' has a wrong offset!");

// Class SmartDataAsset.SmartDataCollectionSubsystem
// 0x0078 (0x00A8 - 0x0030)
class USmartDataCollectionSubsystem final : public UWorldSubsystem
{
public:
	TSoftObjectPtr<class USmartDataCollection>    BaseCollection;                                    // 0x0030(0x0028)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TSoftObjectPtr<class UObject>, class USmartDataCollection*> CollectionsMap;                 // 0x0058(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UDataAsset* K2_GetRegisteredAsset(const class UObject* WorldContextObject, const struct FGameplayTag& AssetIdentifier, const class UObject* CollectionContextObject, const bool bUseBaseCollectionIfContextInvalid);
	static class USmartDataCollection* K2_GetRegisteredCollection(const class UObject* WorldContextObject, class UObject* CollectionContextObject);
	static bool K2_RegisterAsset(const class UObject* WorldContextObject, class UDataAsset* Asset, const class UObject* CollectionContextObject, const struct FGameplayTag& AssetIdentifier, const bool bAllowOverwrite);
	static bool K2_RegisterCollection(const class UObject* WorldContextObject, class USmartDataCollection* Collection, const class UObject* CollectionContextObject, const bool bAllowOverwrite);
	static bool K2_UnregisterAsset(const class UObject* WorldContextObject, const class UObject* CollectionContextObject, const struct FGameplayTag& AssetIdentifier);
	static bool K2_UnregisterCollection(const class UObject* WorldContextObject, const class UObject* CollectionContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmartDataCollectionSubsystem">();
	}
	static class USmartDataCollectionSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USmartDataCollectionSubsystem>();
	}
};
static_assert(alignof(USmartDataCollectionSubsystem) == 0x000008, "Wrong alignment on USmartDataCollectionSubsystem");
static_assert(sizeof(USmartDataCollectionSubsystem) == 0x0000A8, "Wrong size on USmartDataCollectionSubsystem");
static_assert(offsetof(USmartDataCollectionSubsystem, BaseCollection) == 0x000030, "Member 'USmartDataCollectionSubsystem::BaseCollection' has a wrong offset!");
static_assert(offsetof(USmartDataCollectionSubsystem, CollectionsMap) == 0x000058, "Member 'USmartDataCollectionSubsystem::CollectionsMap' has a wrong offset!");

}

