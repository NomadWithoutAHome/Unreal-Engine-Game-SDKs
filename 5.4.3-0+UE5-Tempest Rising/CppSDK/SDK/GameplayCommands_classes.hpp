#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GameplayCommands

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "GameplayCommands_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class GameplayCommands.GameplayCommand
// 0x0258 (0x0280 - 0x0028)
class UGameplayCommand : public UObject
{
public:
	struct FGameplayTag                           CommandType;                                       // 0x0028(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Priority;                                          // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bUniversal : 1;                                    // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bContextual : 1;                                   // 0x0034(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bTreatInstantAsCanCancel : 1;                      // 0x0034(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	EGameplayCommandProcessingPolicy              ProcessingPolicy;                                  // 0x0035(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGameplayCommandGroupExecutionPolicy          GroupExecutionPolicy;                              // 0x0036(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bCanSyncExecution : 1;                             // 0x0037(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	TSubclassOf<class UGameplayCommandFallbackTemplate> FallbackCommandTemplate;                     // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGameplayCommandFallback>       FallbackCommands;                                  // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	EGameplayCommandTargetType                    TargetType;                                        // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagRequirements               SourceRequiredTags;                                // 0x0058(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UGameplayCommandCustomRequirement*      CustomSourceRequirement;                           // 0x00E0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagRequirements               TargetRequiredTags;                                // 0x00E8(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagRequirements               ExecutionRequiredTags;                             // 0x0170(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UGameplayCommandCustomRequirement*      CustomExecutionRequirement;                        // 0x01F8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIgnoreTargetTagRequirementsIfMissingTagInterface : 1; // 0x0200(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_201[0x3];                                      // 0x0201(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           CooldownTag;                                       // 0x0204(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20C[0x4];                                      // 0x020C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFGameplayCommandValue                 CooldownDuration;                                  // 0x0210(0x0028)(Edit, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EGameplayCommandApplicationRule               CooldownApplicationRule;                           // 0x0238(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGameplayCommandApplicationRule               CostApplicationRule;                               // 0x0239(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGameplayCommandNetExecutionPolicy            NetExecutionPolicy;                                // 0x023A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasAutoCast;                                      // 0x023B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           AutoCastTag;                                       // 0x023C(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStartWithAutoCastEnabled;                         // 0x0244(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_245[0x3];                                      // 0x0245(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   PreviewActorClass;                                 // 0x0248(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bCanEverShowPreview : 1;                           // 0x0270(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bShowPreviewIfPending : 1;                         // 0x0270(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bShowPreviewIfFreeLook : 1;                        // 0x0270(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bShowPreviewIfCinematic : 1;                       // 0x0270(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanAttachPreviewToTarget : 1;                     // 0x0270(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bReplicate : 1;                                    // 0x0270(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayCommand>           FallbackCommand;                                   // 0x0278(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayCommand">();
	}
	static class UGameplayCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayCommand>();
	}
};
static_assert(alignof(UGameplayCommand) == 0x000008, "Wrong alignment on UGameplayCommand");
static_assert(sizeof(UGameplayCommand) == 0x000280, "Wrong size on UGameplayCommand");
static_assert(offsetof(UGameplayCommand, CommandType) == 0x000028, "Member 'UGameplayCommand::CommandType' has a wrong offset!");
static_assert(offsetof(UGameplayCommand, Priority) == 0x000030, "Member 'UGameplayCommand::Priority' has a wrong offset!");
static_assert(offsetof(UGameplayCommand, ProcessingPolicy) == 0x000035, "Member 'UGameplayCommand::ProcessingPolicy' has a wrong offset!");
static_assert(offsetof(UGameplayCommand, GroupExecutionPolicy) == 0x000036, "Member 'UGameplayCommand::GroupExecutionPolicy' has a wrong offset!");
static_assert(offsetof(UGameplayCommand, FallbackCommandTemplate) == 0x000038, "Member 'UGameplayCommand::FallbackCommandTemplate' has a wrong offset!");
static_assert(offsetof(UGameplayCommand, FallbackCommands) == 0x000040, "Member 'UGameplayCommand::FallbackCommands' has a wrong offset!");
static_assert(offsetof(UGameplayCommand, TargetType) == 0x000050, "Member 'UGameplayCommand::TargetType' has a wrong offset!");
static_assert(offsetof(UGameplayCommand, SourceRequiredTags) == 0x000058, "Member 'UGameplayCommand::SourceRequiredTags' has a wrong offset!");
static_assert(offsetof(UGameplayCommand, CustomSourceRequirement) == 0x0000E0, "Member 'UGameplayCommand::CustomSourceRequirement' has a wrong offset!");
static_assert(offsetof(UGameplayCommand, TargetRequiredTags) == 0x0000E8, "Member 'UGameplayCommand::TargetRequiredTags' has a wrong offset!");
static_assert(offsetof(UGameplayCommand, ExecutionRequiredTags) == 0x000170, "Member 'UGameplayCommand::ExecutionRequiredTags' has a wrong offset!");
static_assert(offsetof(UGameplayCommand, CustomExecutionRequirement) == 0x0001F8, "Member 'UGameplayCommand::CustomExecutionRequirement' has a wrong offset!");
static_assert(offsetof(UGameplayCommand, CooldownTag) == 0x000204, "Member 'UGameplayCommand::CooldownTag' has a wrong offset!");
static_assert(offsetof(UGameplayCommand, CooldownDuration) == 0x000210, "Member 'UGameplayCommand::CooldownDuration' has a wrong offset!");
static_assert(offsetof(UGameplayCommand, CooldownApplicationRule) == 0x000238, "Member 'UGameplayCommand::CooldownApplicationRule' has a wrong offset!");
static_assert(offsetof(UGameplayCommand, CostApplicationRule) == 0x000239, "Member 'UGameplayCommand::CostApplicationRule' has a wrong offset!");
static_assert(offsetof(UGameplayCommand, NetExecutionPolicy) == 0x00023A, "Member 'UGameplayCommand::NetExecutionPolicy' has a wrong offset!");
static_assert(offsetof(UGameplayCommand, bHasAutoCast) == 0x00023B, "Member 'UGameplayCommand::bHasAutoCast' has a wrong offset!");
static_assert(offsetof(UGameplayCommand, AutoCastTag) == 0x00023C, "Member 'UGameplayCommand::AutoCastTag' has a wrong offset!");
static_assert(offsetof(UGameplayCommand, bStartWithAutoCastEnabled) == 0x000244, "Member 'UGameplayCommand::bStartWithAutoCastEnabled' has a wrong offset!");
static_assert(offsetof(UGameplayCommand, PreviewActorClass) == 0x000248, "Member 'UGameplayCommand::PreviewActorClass' has a wrong offset!");
static_assert(offsetof(UGameplayCommand, FallbackCommand) == 0x000278, "Member 'UGameplayCommand::FallbackCommand' has a wrong offset!");

// Class GameplayCommands.GameplayCommandAgentInterface
// 0x0000 (0x0000 - 0x0000)
class IGameplayCommandAgentInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayCommandAgentInterface">();
	}
	static class IGameplayCommandAgentInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGameplayCommandAgentInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IGameplayCommandAgentInterface) == 0x000001, "Wrong alignment on IGameplayCommandAgentInterface");
static_assert(sizeof(IGameplayCommandAgentInterface) == 0x000001, "Wrong size on IGameplayCommandAgentInterface");

// Class GameplayCommands.GameplayCommandComponent
// 0x0068 (0x0118 - 0x00B0)
class UGameplayCommandComponent final : public UActorComponent
{
public:
	struct FGameplayCommandData                   CurrentCommand;                                    // 0x00B0(0x0048)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayCommandData>           CommandQueue;                                      // 0x00F8(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class AGameplayCommandPreviewActor*>   CommandPreviewActors;                              // 0x0108(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void CancelCurrentCommand(bool bClearQueue);
	void ClearCommandQueue();
	bool EnqueueCommand(const struct FGameplayCommandData& CommandData);
	bool IssueCommand(const struct FGameplayCommandData& CommandData);
	void OnRep_CommandQueue();
	void OnRep_CurrentCommand();

	bool CanExecuteCommand(const struct FGameplayCommandData& CommandData, bool bIgnoreCurrentCommand, bool bVerboseLogs) const;
	const TArray<struct FGameplayCommandData> GetCommandQueue() const;
	const struct FGameplayCommandData GetCurrentCommand() const;
	TSubclassOf<class UGameplayCommand> GetCurrentCommandClass() const;
	class AActor* GetCurrentCommandTargetActor() const;
	struct FVector2D GetCurrentCommandTargetLocation() const;
	bool IsExecutingCommand() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayCommandComponent">();
	}
	static class UGameplayCommandComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayCommandComponent>();
	}
};
static_assert(alignof(UGameplayCommandComponent) == 0x000008, "Wrong alignment on UGameplayCommandComponent");
static_assert(sizeof(UGameplayCommandComponent) == 0x000118, "Wrong size on UGameplayCommandComponent");
static_assert(offsetof(UGameplayCommandComponent, CurrentCommand) == 0x0000B0, "Member 'UGameplayCommandComponent::CurrentCommand' has a wrong offset!");
static_assert(offsetof(UGameplayCommandComponent, CommandQueue) == 0x0000F8, "Member 'UGameplayCommandComponent::CommandQueue' has a wrong offset!");
static_assert(offsetof(UGameplayCommandComponent, CommandPreviewActors) == 0x000108, "Member 'UGameplayCommandComponent::CommandPreviewActors' has a wrong offset!");

// Class GameplayCommands.GameplayCommandComponentV2
// 0x0350 (0x0400 - 0x00B0)
class UGameplayCommandComponentV2 : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x50];                                      // 0x00B0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayCommandID, class AGameplayCommandPreviewActor*> InstancedCommandPreviewActors; // 0x0100(0x0050)(Protected, NativeAccessSpecifierProtected)
	class AGameplayCommandPreviewActor*           PendingCommandPreview;                             // 0x0150(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class AActor*>                           CommandPreviewContextActors;                       // 0x0158(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A8[0x10];                                     // 0x01A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FGameplayCommandID>               ContextsActorCommandIDs;                           // 0x01B8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_208[0xA0];                                     // 0x0208(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class AGameplayCommandPreviewActor*           PreviousCommandPreviewActor;                       // 0x02A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bFreeLookEnabled : 1;                              // 0x02B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCienematicMode : 1;                               // 0x02B0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2B1[0xE7];                                     // 0x02B1(0x00E7)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayReplicationRegisterCommandEventsContainer ReplicationCommandRegisterEventsContainer; // 0x0398(0x0018)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B0[0x50];                                     // 0x03B0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelCommands(class AActor* CommandActor, const bool bForceCancelNonCancelable);
	void ClearCommandQueue(class AActor* CommandActor);
	bool EnqueueBatchCommand(const TArray<class AActor*>& CommandActors, const struct FGameplayCommandData& CommandData);
	bool EnqueueCommand(class AActor* CommandActor, const struct FGameplayCommandData& CommandData);
	bool InsertCommandAfterCurrent(class AActor* CommandActor, const struct FGameplayCommandData& CommandData);
	bool InsertCommandBeforeCurrent(class AActor* CommandActor, const struct FGameplayCommandData& CommandData);
	bool IssueBatchCommand(const TArray<class AActor*>& CommandActors, const struct FGameplayCommandData& CommandData, bool bEnqueueIfCannotExecuteRightAway);
	bool IssueCommand(class AActor* CommandActor, const struct FGameplayCommandData& CommandData, bool bEnqueueIfCannotExecuteRightAway);
	void OnRep_ReplicationCommandRegisterEventsContainer();

	bool CanExecuteCommand(const class AActor* CommandActor, const struct FGameplayCommandData& CommandData, bool bIgnoreCurrentCommand, bool bVerboseLogs) const;
	TSubclassOf<class UGameplayCommand> GetCurrentCommandClass(const class AActor* CommandActor) const;
	const struct FGameplayCommandData GetCurrentCommandData(const class AActor* CommandActor) const;
	class AActor* GetCurrentCommandTargetActor(const class AActor* CommandActor) const;
	struct FVector2D GetCurrentCommandTargetLocation(const class AActor* CommandActor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayCommandComponentV2">();
	}
	static class UGameplayCommandComponentV2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayCommandComponentV2>();
	}
};
static_assert(alignof(UGameplayCommandComponentV2) == 0x000008, "Wrong alignment on UGameplayCommandComponentV2");
static_assert(sizeof(UGameplayCommandComponentV2) == 0x000400, "Wrong size on UGameplayCommandComponentV2");
static_assert(offsetof(UGameplayCommandComponentV2, InstancedCommandPreviewActors) == 0x000100, "Member 'UGameplayCommandComponentV2::InstancedCommandPreviewActors' has a wrong offset!");
static_assert(offsetof(UGameplayCommandComponentV2, PendingCommandPreview) == 0x000150, "Member 'UGameplayCommandComponentV2::PendingCommandPreview' has a wrong offset!");
static_assert(offsetof(UGameplayCommandComponentV2, CommandPreviewContextActors) == 0x000158, "Member 'UGameplayCommandComponentV2::CommandPreviewContextActors' has a wrong offset!");
static_assert(offsetof(UGameplayCommandComponentV2, ContextsActorCommandIDs) == 0x0001B8, "Member 'UGameplayCommandComponentV2::ContextsActorCommandIDs' has a wrong offset!");
static_assert(offsetof(UGameplayCommandComponentV2, PreviousCommandPreviewActor) == 0x0002A8, "Member 'UGameplayCommandComponentV2::PreviousCommandPreviewActor' has a wrong offset!");
static_assert(offsetof(UGameplayCommandComponentV2, ReplicationCommandRegisterEventsContainer) == 0x000398, "Member 'UGameplayCommandComponentV2::ReplicationCommandRegisterEventsContainer' has a wrong offset!");

// Class GameplayCommands.GameplayCommandCustomRequirement
// 0x0000 (0x0028 - 0x0028)
class UGameplayCommandCustomRequirement : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayCommandCustomRequirement">();
	}
	static class UGameplayCommandCustomRequirement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayCommandCustomRequirement>();
	}
};
static_assert(alignof(UGameplayCommandCustomRequirement) == 0x000008, "Wrong alignment on UGameplayCommandCustomRequirement");
static_assert(sizeof(UGameplayCommandCustomRequirement) == 0x000028, "Wrong size on UGameplayCommandCustomRequirement");

// Class GameplayCommands.GameplayCommandCustomRequirementBlueprintBase
// 0x0000 (0x0028 - 0x0028)
class UGameplayCommandCustomRequirementBlueprintBase final : public UGameplayCommandCustomRequirement
{
public:
	bool K2_MeetRequirement(const class AActor* CommandActor, const struct FGameplayCommandData& CommandData, struct FGameplayCommandErrorTags* OutErrorTags) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayCommandCustomRequirementBlueprintBase">();
	}
	static class UGameplayCommandCustomRequirementBlueprintBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayCommandCustomRequirementBlueprintBase>();
	}
};
static_assert(alignof(UGameplayCommandCustomRequirementBlueprintBase) == 0x000008, "Wrong alignment on UGameplayCommandCustomRequirementBlueprintBase");
static_assert(sizeof(UGameplayCommandCustomRequirementBlueprintBase) == 0x000028, "Wrong size on UGameplayCommandCustomRequirementBlueprintBase");

// Class GameplayCommands.GameplayCommandCustomRequirement_Compound
// 0x0010 (0x0038 - 0x0028)
class UGameplayCommandCustomRequirement_Compound final : public UGameplayCommandCustomRequirement
{
public:
	TArray<class UGameplayCommandCustomRequirement*> Requirements;                                   // 0x0028(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayCommandCustomRequirement_Compound">();
	}
	static class UGameplayCommandCustomRequirement_Compound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayCommandCustomRequirement_Compound>();
	}
};
static_assert(alignof(UGameplayCommandCustomRequirement_Compound) == 0x000008, "Wrong alignment on UGameplayCommandCustomRequirement_Compound");
static_assert(sizeof(UGameplayCommandCustomRequirement_Compound) == 0x000038, "Wrong size on UGameplayCommandCustomRequirement_Compound");
static_assert(offsetof(UGameplayCommandCustomRequirement_Compound, Requirements) == 0x000028, "Member 'UGameplayCommandCustomRequirement_Compound::Requirements' has a wrong offset!");

// Class GameplayCommands.GameplayCommandFallbackRequirement
// 0x0000 (0x0028 - 0x0028)
class UGameplayCommandFallbackRequirement : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayCommandFallbackRequirement">();
	}
	static class UGameplayCommandFallbackRequirement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayCommandFallbackRequirement>();
	}
};
static_assert(alignof(UGameplayCommandFallbackRequirement) == 0x000008, "Wrong alignment on UGameplayCommandFallbackRequirement");
static_assert(sizeof(UGameplayCommandFallbackRequirement) == 0x000028, "Wrong size on UGameplayCommandFallbackRequirement");

// Class GameplayCommands.GameplayCommandFallbackRequirement_HasTarget
// 0x0000 (0x0028 - 0x0028)
class UGameplayCommandFallbackRequirement_HasTarget final : public UGameplayCommandFallbackRequirement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayCommandFallbackRequirement_HasTarget">();
	}
	static class UGameplayCommandFallbackRequirement_HasTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayCommandFallbackRequirement_HasTarget>();
	}
};
static_assert(alignof(UGameplayCommandFallbackRequirement_HasTarget) == 0x000008, "Wrong alignment on UGameplayCommandFallbackRequirement_HasTarget");
static_assert(sizeof(UGameplayCommandFallbackRequirement_HasTarget) == 0x000028, "Wrong size on UGameplayCommandFallbackRequirement_HasTarget");

// Class GameplayCommands.GameplayCommandFallbackRequirement_HasTargetLocation
// 0x0000 (0x0028 - 0x0028)
class UGameplayCommandFallbackRequirement_HasTargetLocation final : public UGameplayCommandFallbackRequirement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayCommandFallbackRequirement_HasTargetLocation">();
	}
	static class UGameplayCommandFallbackRequirement_HasTargetLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayCommandFallbackRequirement_HasTargetLocation>();
	}
};
static_assert(alignof(UGameplayCommandFallbackRequirement_HasTargetLocation) == 0x000008, "Wrong alignment on UGameplayCommandFallbackRequirement_HasTargetLocation");
static_assert(sizeof(UGameplayCommandFallbackRequirement_HasTargetLocation) == 0x000028, "Wrong size on UGameplayCommandFallbackRequirement_HasTargetLocation");

// Class GameplayCommands.GameplayCommandDataConverter
// 0x0000 (0x0028 - 0x0028)
class UGameplayCommandDataConverter : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayCommandDataConverter">();
	}
	static class UGameplayCommandDataConverter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayCommandDataConverter>();
	}
};
static_assert(alignof(UGameplayCommandDataConverter) == 0x000008, "Wrong alignment on UGameplayCommandDataConverter");
static_assert(sizeof(UGameplayCommandDataConverter) == 0x000028, "Wrong size on UGameplayCommandDataConverter");

// Class GameplayCommands.GameplayCommandDataConverter_KeepTarget
// 0x0000 (0x0028 - 0x0028)
class UGameplayCommandDataConverter_KeepTarget final : public UGameplayCommandDataConverter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayCommandDataConverter_KeepTarget">();
	}
	static class UGameplayCommandDataConverter_KeepTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayCommandDataConverter_KeepTarget>();
	}
};
static_assert(alignof(UGameplayCommandDataConverter_KeepTarget) == 0x000008, "Wrong alignment on UGameplayCommandDataConverter_KeepTarget");
static_assert(sizeof(UGameplayCommandDataConverter_KeepTarget) == 0x000028, "Wrong size on UGameplayCommandDataConverter_KeepTarget");

// Class GameplayCommands.GameplayCommandDataConverter_KeepTargetLocation
// 0x0000 (0x0028 - 0x0028)
class UGameplayCommandDataConverter_KeepTargetLocation final : public UGameplayCommandDataConverter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayCommandDataConverter_KeepTargetLocation">();
	}
	static class UGameplayCommandDataConverter_KeepTargetLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayCommandDataConverter_KeepTargetLocation>();
	}
};
static_assert(alignof(UGameplayCommandDataConverter_KeepTargetLocation) == 0x000008, "Wrong alignment on UGameplayCommandDataConverter_KeepTargetLocation");
static_assert(sizeof(UGameplayCommandDataConverter_KeepTargetLocation) == 0x000028, "Wrong size on UGameplayCommandDataConverter_KeepTargetLocation");

// Class GameplayCommands.GameplayCommandFallbackTemplate
// 0x0010 (0x0038 - 0x0028)
class UGameplayCommandFallbackTemplate : public UObject
{
public:
	TArray<struct FGameplayCommandFallback>       FallbackCommands;                                  // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayCommandFallbackTemplate">();
	}
	static class UGameplayCommandFallbackTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayCommandFallbackTemplate>();
	}
};
static_assert(alignof(UGameplayCommandFallbackTemplate) == 0x000008, "Wrong alignment on UGameplayCommandFallbackTemplate");
static_assert(sizeof(UGameplayCommandFallbackTemplate) == 0x000038, "Wrong size on UGameplayCommandFallbackTemplate");
static_assert(offsetof(UGameplayCommandFallbackTemplate, FallbackCommands) == 0x000028, "Member 'UGameplayCommandFallbackTemplate::FallbackCommands' has a wrong offset!");

// Class GameplayCommands.GameplayCommandFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UGameplayCommandFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void CancelCommands(class AActor* CommandActor);
	static bool CanExecuteCommand(const class AActor* CommandActor, const struct FGameplayCommandData& CommandData, bool bIgnoreCurrentCommand);
	static void ClearCommandQueue(class AActor* CommandActor);
	static TSubclassOf<class UGameplayCommand> CommandData_GetCommandClass(const struct FGameplayCommandData& CommandData);
	static class AActor* CommandData_GetTarget(const struct FGameplayCommandData& CommandData);
	static struct FVector2D CommandData_GetTargetLocation(const struct FGameplayCommandData& CommandData, bool* bHasTargetLocation);
	static bool CommandData_IsValid(const struct FGameplayCommandData& CommandData);
	static bool EnqueueBatchCommand(const TArray<class AActor*>& CommandActors, const struct FGameplayCommandData& CommandData);
	static bool EnqueueBatchCommandByType(const TArray<class AActor*>& CommandActors, const struct FGameplayTag& CommandType, const class AActor* TargetActor, const struct FVector& TargetLocation);
	static bool EnqueueCommand(class AActor* CommandActor, const struct FGameplayCommandData& CommandData);
	static bool EnqueueCommandByType(class AActor* CommandActor, const struct FGameplayTag& CommandType, const class AActor* TargetActor, const struct FVector& TargetLocation);
	static TSubclassOf<class UGameplayCommand> GetCurrentCommandClass(const class AActor* CommandActor);
	static struct FGameplayCommandData GetCurrentCommandData(const class AActor* CommandActor);
	static struct FGameplayCommandID GetCurrentCommandID(const class AActor* CommandActor);
	static class AActor* GetCurrentCommandTargetActor(const class AActor* CommandActor);
	static struct FVector2D GetCurrentCommandTargetLocation(const class AActor* CommandActor);
	static bool InsertCommandAfterCurrent(class AActor* CommandActor, const struct FGameplayCommandData& CommandData);
	static bool InsertCommandAfterCurrentByType(class AActor* CommandActor, const struct FGameplayTag& CommandType, const class AActor* TargetActor, const struct FVector& TargetLocation);
	static bool InsertCommandBeforeCurrent(class AActor* CommandActor, const struct FGameplayCommandData& CommandData);
	static bool InsertCommandBeforeCurrentByType(class AActor* CommandActor, const struct FGameplayTag& CommandType, const class AActor* TargetActor, const struct FVector& TargetLocation);
	static bool IsCommandSupported(class AActor* CommandActor, const TSubclassOf<class UGameplayCommand> CommandClass);
	static bool IsCommandSupportedByType(class AActor* CommandActor, const struct FGameplayTag& CommandType);
	static bool IsExecutingAnyCommand(const class AActor* CommandActor);
	static bool IsExecutingCommandOfType(class AActor* CommandActor, const struct FGameplayTag& CommandType);
	static bool IsExecutionCommand(const class AActor* CommandActor, const TSubclassOf<class UGameplayCommand> CommandClass);
	static bool IssueBatchCommand(const TArray<class AActor*>& CommandActors, const struct FGameplayCommandData& CommandData, bool bEnqueueIfCannotExecuteRightAway);
	static bool IssueBatchCommandByType(const TArray<class AActor*>& CommandActors, const struct FGameplayTag& CommandType, const class AActor* TargetActor, const struct FVector& TargetLocation, bool bEnqueueIfCannotExecuteRightAway);
	static bool IssueCommand(class AActor* CommandActor, const struct FGameplayCommandData& CommandData, bool bEnqueueIfCannotExecuteRightAway);
	static bool IssueCommandByType(class AActor* CommandActor, const struct FGameplayTag& CommandType, const class AActor* TargetActor, const struct FVector& TargetLocation, bool bEnqueueIfCannotExecuteRightAway);
	static bool IssueContextualCommand(class AActor* CommandActor, const class AActor* TargetActor, const struct FVector& TargetLocation, bool bEnqueueIfCannotExecuteRightAway);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayCommandFunctionLibrary">();
	}
	static class UGameplayCommandFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayCommandFunctionLibrary>();
	}
};
static_assert(alignof(UGameplayCommandFunctionLibrary) == 0x000008, "Wrong alignment on UGameplayCommandFunctionLibrary");
static_assert(sizeof(UGameplayCommandFunctionLibrary) == 0x000028, "Wrong size on UGameplayCommandFunctionLibrary");

// Class GameplayCommands.GameplayCommandPreviewActor
// 0x00D8 (0x0368 - 0x0290)
class AGameplayCommandPreviewActor : public AActor
{
public:
	uint8                                         Pad_290[0x18];                                     // 0x0290(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShowAlsoIfHiddenTarget;                           // 0x02A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneRoot;                                         // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bActive : 1;                                       // 0x02B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AActor*>                           ContextActors;                                     // 0x02C0(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	uint8                                         bIsQueuedCommandPreview : 1;                       // 0x0310(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_311[0x7];                                      // 0x0311(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayCommandData                   CachedCommandData;                                 // 0x0318(0x0048)(Transient, DuplicateTransient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_360[0x8];                                      // 0x0360(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActiveStateChanged(bool bNewActive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayCommandPreviewActor">();
	}
	static class AGameplayCommandPreviewActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameplayCommandPreviewActor>();
	}
};
static_assert(alignof(AGameplayCommandPreviewActor) == 0x000008, "Wrong alignment on AGameplayCommandPreviewActor");
static_assert(sizeof(AGameplayCommandPreviewActor) == 0x000368, "Wrong size on AGameplayCommandPreviewActor");
static_assert(offsetof(AGameplayCommandPreviewActor, bShowAlsoIfHiddenTarget) == 0x0002A8, "Member 'AGameplayCommandPreviewActor::bShowAlsoIfHiddenTarget' has a wrong offset!");
static_assert(offsetof(AGameplayCommandPreviewActor, SceneRoot) == 0x0002B0, "Member 'AGameplayCommandPreviewActor::SceneRoot' has a wrong offset!");
static_assert(offsetof(AGameplayCommandPreviewActor, ContextActors) == 0x0002C0, "Member 'AGameplayCommandPreviewActor::ContextActors' has a wrong offset!");
static_assert(offsetof(AGameplayCommandPreviewActor, CachedCommandData) == 0x000318, "Member 'AGameplayCommandPreviewActor::CachedCommandData' has a wrong offset!");

// Class GameplayCommands.GameplayCommandValueCalculation
// 0x0000 (0x0028 - 0x0028)
class UGameplayCommandValueCalculation : public UObject
{
public:
	float CalculateValue(const class AActor* CommandActor, const class UGameplayCommand* Command) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayCommandValueCalculation">();
	}
	static class UGameplayCommandValueCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayCommandValueCalculation>();
	}
};
static_assert(alignof(UGameplayCommandValueCalculation) == 0x000008, "Wrong alignment on UGameplayCommandValueCalculation");
static_assert(sizeof(UGameplayCommandValueCalculation) == 0x000028, "Wrong size on UGameplayCommandValueCalculation");

}

