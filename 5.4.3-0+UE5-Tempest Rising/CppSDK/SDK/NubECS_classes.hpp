#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: NubECS

#include "Basic.hpp"

#include "NubECS_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class NubECS.EcsActor
// 0x0008 (0x0298 - 0x0290)
class AEcsActor : public AActor
{
public:
	class UEcsActorComponent*                     EcsActor;                                          // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EcsActor">();
	}
	static class AEcsActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEcsActor>();
	}
};
static_assert(alignof(AEcsActor) == 0x000008, "Wrong alignment on AEcsActor");
static_assert(sizeof(AEcsActor) == 0x000298, "Wrong size on AEcsActor");
static_assert(offsetof(AEcsActor, EcsActor) == 0x000290, "Member 'AEcsActor::EcsActor' has a wrong offset!");

// Class NubECS.EcsActorArchetype
// 0x0028 (0x0058 - 0x0030)
class UEcsActorArchetype final : public UDataAsset
{
public:
	EEcsTransformSyncType                         TransformSync;                                     // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UEcsTypeDesc>>       Descriptors;                                       // 0x0038(0x0010)(Edit, ZeroConstructor, EditConst, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UEcsTypeDesc*>                   DescriptorsWithDefaults;                           // 0x0048(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EcsActorArchetype">();
	}
	static class UEcsActorArchetype* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEcsActorArchetype>();
	}
};
static_assert(alignof(UEcsActorArchetype) == 0x000008, "Wrong alignment on UEcsActorArchetype");
static_assert(sizeof(UEcsActorArchetype) == 0x000058, "Wrong size on UEcsActorArchetype");
static_assert(offsetof(UEcsActorArchetype, TransformSync) == 0x000030, "Member 'UEcsActorArchetype::TransformSync' has a wrong offset!");
static_assert(offsetof(UEcsActorArchetype, Descriptors) == 0x000038, "Member 'UEcsActorArchetype::Descriptors' has a wrong offset!");
static_assert(offsetof(UEcsActorArchetype, DescriptorsWithDefaults) == 0x000048, "Member 'UEcsActorArchetype::DescriptorsWithDefaults' has a wrong offset!");

// Class NubECS.EcsActorComponent
// 0x0028 (0x00D8 - 0x00B0)
class UEcsActorComponent : public UActorComponent
{
public:
	class UEcsActorArchetype*                     EcsArchetype;                                      // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDumpDebug;                                        // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDumpExtendedDebug;                                // 0x00B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BA[0x16];                                      // 0x00BA(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEcsEntityHandle                       EntityHandle;                                      // 0x00D0(0x0008)(Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_EntityHandle();

	struct FEcsEntityHandle GetEntityHandle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EcsActorComponent">();
	}
	static class UEcsActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEcsActorComponent>();
	}
};
static_assert(alignof(UEcsActorComponent) == 0x000008, "Wrong alignment on UEcsActorComponent");
static_assert(sizeof(UEcsActorComponent) == 0x0000D8, "Wrong size on UEcsActorComponent");
static_assert(offsetof(UEcsActorComponent, EcsArchetype) == 0x0000B0, "Member 'UEcsActorComponent::EcsArchetype' has a wrong offset!");
static_assert(offsetof(UEcsActorComponent, bDumpDebug) == 0x0000B8, "Member 'UEcsActorComponent::bDumpDebug' has a wrong offset!");
static_assert(offsetof(UEcsActorComponent, bDumpExtendedDebug) == 0x0000B9, "Member 'UEcsActorComponent::bDumpExtendedDebug' has a wrong offset!");
static_assert(offsetof(UEcsActorComponent, EntityHandle) == 0x0000D0, "Member 'UEcsActorComponent::EntityHandle' has a wrong offset!");

// Class NubECS.EcsActorComponent_AutoObstacle
// 0x0020 (0x00F8 - 0x00D8)
class UEcsActorComponent_AutoObstacle final : public UEcsActorComponent
{
public:
	struct FVector2D                              EllipseCompensation;                               // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEllipseAutoFit;                                   // 0x00E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCircleFitInsideBox;                               // 0x00E9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EA[0x2];                                       // 0x00EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	EEcsMovementPlane                             MovementPlane;                                     // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EMovementColliderType                         ColliderType;                                      // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EcsActorComponent_AutoObstacle">();
	}
	static class UEcsActorComponent_AutoObstacle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEcsActorComponent_AutoObstacle>();
	}
};
static_assert(alignof(UEcsActorComponent_AutoObstacle) == 0x000008, "Wrong alignment on UEcsActorComponent_AutoObstacle");
static_assert(sizeof(UEcsActorComponent_AutoObstacle) == 0x0000F8, "Wrong size on UEcsActorComponent_AutoObstacle");
static_assert(offsetof(UEcsActorComponent_AutoObstacle, EllipseCompensation) == 0x0000D8, "Member 'UEcsActorComponent_AutoObstacle::EllipseCompensation' has a wrong offset!");
static_assert(offsetof(UEcsActorComponent_AutoObstacle, bEllipseAutoFit) == 0x0000E8, "Member 'UEcsActorComponent_AutoObstacle::bEllipseAutoFit' has a wrong offset!");
static_assert(offsetof(UEcsActorComponent_AutoObstacle, bCircleFitInsideBox) == 0x0000E9, "Member 'UEcsActorComponent_AutoObstacle::bCircleFitInsideBox' has a wrong offset!");
static_assert(offsetof(UEcsActorComponent_AutoObstacle, MovementPlane) == 0x0000EC, "Member 'UEcsActorComponent_AutoObstacle::MovementPlane' has a wrong offset!");
static_assert(offsetof(UEcsActorComponent_AutoObstacle, ColliderType) == 0x0000F0, "Member 'UEcsActorComponent_AutoObstacle::ColliderType' has a wrong offset!");

// Class NubECS.EcsActorComponent_Unit
// 0x0008 (0x00E0 - 0x00D8)
class UEcsActorComponent_Unit final : public UEcsActorComponent
{
public:
	float                                         RVOScale;                                          // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SeparationScale;                                   // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EcsActorComponent_Unit">();
	}
	static class UEcsActorComponent_Unit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEcsActorComponent_Unit>();
	}
};
static_assert(alignof(UEcsActorComponent_Unit) == 0x000008, "Wrong alignment on UEcsActorComponent_Unit");
static_assert(sizeof(UEcsActorComponent_Unit) == 0x0000E0, "Wrong size on UEcsActorComponent_Unit");
static_assert(offsetof(UEcsActorComponent_Unit, RVOScale) == 0x0000D8, "Member 'UEcsActorComponent_Unit::RVOScale' has a wrong offset!");
static_assert(offsetof(UEcsActorComponent_Unit, SeparationScale) == 0x0000DC, "Member 'UEcsActorComponent_Unit::SeparationScale' has a wrong offset!");

// Class NubECS.EcsModule
// 0x0008 (0x0030 - 0x0028)
class UEcsModule : public UObject
{
public:
	bool                                          bAutoRegister;                                     // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EcsModule">();
	}
	static class UEcsModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEcsModule>();
	}
};
static_assert(alignof(UEcsModule) == 0x000008, "Wrong alignment on UEcsModule");
static_assert(sizeof(UEcsModule) == 0x000030, "Wrong size on UEcsModule");
static_assert(offsetof(UEcsModule, bAutoRegister) == 0x000028, "Member 'UEcsModule::bAutoRegister' has a wrong offset!");

// Class NubECS.NubEcsModule_Attitude
// 0x0000 (0x0030 - 0x0030)
class UNubEcsModule_Attitude : public UEcsModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NubEcsModule_Attitude">();
	}
	static class UNubEcsModule_Attitude* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNubEcsModule_Attitude>();
	}
};
static_assert(alignof(UNubEcsModule_Attitude) == 0x000008, "Wrong alignment on UNubEcsModule_Attitude");
static_assert(sizeof(UNubEcsModule_Attitude) == 0x000030, "Wrong size on UNubEcsModule_Attitude");

// Class NubECS.EcsTypeDesc
// 0x0000 (0x0028 - 0x0028)
class UEcsTypeDesc : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EcsTypeDesc">();
	}
	static class UEcsTypeDesc* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEcsTypeDesc>();
	}
};
static_assert(alignof(UEcsTypeDesc) == 0x000008, "Wrong alignment on UEcsTypeDesc");
static_assert(sizeof(UEcsTypeDesc) == 0x000028, "Wrong size on UEcsTypeDesc");

// Class NubECS.EcsTypeDesc_BaseCollider
// 0x0008 (0x0030 - 0x0028)
class UEcsTypeDesc_BaseCollider : public UEcsTypeDesc
{
public:
	bool                                          bStaticCollider;                                   // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bGenerateOverlapEvents;                            // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreOtherCollisionRadius;                       // 0x002A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EcsTypeDesc_BaseCollider">();
	}
	static class UEcsTypeDesc_BaseCollider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEcsTypeDesc_BaseCollider>();
	}
};
static_assert(alignof(UEcsTypeDesc_BaseCollider) == 0x000008, "Wrong alignment on UEcsTypeDesc_BaseCollider");
static_assert(sizeof(UEcsTypeDesc_BaseCollider) == 0x000030, "Wrong size on UEcsTypeDesc_BaseCollider");
static_assert(offsetof(UEcsTypeDesc_BaseCollider, bStaticCollider) == 0x000028, "Member 'UEcsTypeDesc_BaseCollider::bStaticCollider' has a wrong offset!");
static_assert(offsetof(UEcsTypeDesc_BaseCollider, bGenerateOverlapEvents) == 0x000029, "Member 'UEcsTypeDesc_BaseCollider::bGenerateOverlapEvents' has a wrong offset!");
static_assert(offsetof(UEcsTypeDesc_BaseCollider, bIgnoreOtherCollisionRadius) == 0x00002A, "Member 'UEcsTypeDesc_BaseCollider::bIgnoreOtherCollisionRadius' has a wrong offset!");

// Class NubECS.EcsTypeDesc_SimpleCollider
// 0x0000 (0x0030 - 0x0030)
class UEcsTypeDesc_SimpleCollider final : public UEcsTypeDesc_BaseCollider
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EcsTypeDesc_SimpleCollider">();
	}
	static class UEcsTypeDesc_SimpleCollider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEcsTypeDesc_SimpleCollider>();
	}
};
static_assert(alignof(UEcsTypeDesc_SimpleCollider) == 0x000008, "Wrong alignment on UEcsTypeDesc_SimpleCollider");
static_assert(sizeof(UEcsTypeDesc_SimpleCollider) == 0x000030, "Wrong size on UEcsTypeDesc_SimpleCollider");

// Class NubECS.EcsTypeDesc_VolumeCollider
// 0x0000 (0x0030 - 0x0030)
class UEcsTypeDesc_VolumeCollider final : public UEcsTypeDesc_BaseCollider
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EcsTypeDesc_VolumeCollider">();
	}
	static class UEcsTypeDesc_VolumeCollider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEcsTypeDesc_VolumeCollider>();
	}
};
static_assert(alignof(UEcsTypeDesc_VolumeCollider) == 0x000008, "Wrong alignment on UEcsTypeDesc_VolumeCollider");
static_assert(sizeof(UEcsTypeDesc_VolumeCollider) == 0x000030, "Wrong size on UEcsTypeDesc_VolumeCollider");

// Class NubECS.NubEcsModule_Collision
// 0x0000 (0x0030 - 0x0030)
class UNubEcsModule_Collision : public UEcsModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NubEcsModule_Collision">();
	}
	static class UNubEcsModule_Collision* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNubEcsModule_Collision>();
	}
};
static_assert(alignof(UNubEcsModule_Collision) == 0x000008, "Wrong alignment on UNubEcsModule_Collision");
static_assert(sizeof(UNubEcsModule_Collision) == 0x000030, "Wrong size on UNubEcsModule_Collision");

// Class NubECS.EcsDesc_Transform
// 0x0000 (0x0028 - 0x0028)
class UEcsDesc_Transform final : public UEcsTypeDesc
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EcsDesc_Transform">();
	}
	static class UEcsDesc_Transform* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEcsDesc_Transform>();
	}
};
static_assert(alignof(UEcsDesc_Transform) == 0x000008, "Wrong alignment on UEcsDesc_Transform");
static_assert(sizeof(UEcsDesc_Transform) == 0x000028, "Wrong size on UEcsDesc_Transform");

// Class NubECS.NubEcsModule_Core
// 0x0000 (0x0030 - 0x0030)
class UNubEcsModule_Core final : public UEcsModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NubEcsModule_Core">();
	}
	static class UNubEcsModule_Core* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNubEcsModule_Core>();
	}
};
static_assert(alignof(UNubEcsModule_Core) == 0x000008, "Wrong alignment on UNubEcsModule_Core");
static_assert(sizeof(UNubEcsModule_Core) == 0x000030, "Wrong size on UNubEcsModule_Core");

// Class NubECS.EcsTypeDesc_MovementObstacle
// 0x0008 (0x0030 - 0x0028)
class UEcsTypeDesc_MovementObstacle final : public UEcsTypeDesc
{
public:
	bool                                          bStaticObstacle;                                   // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EEcsMovementPlane                             MovementPlane;                                     // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EcsTypeDesc_MovementObstacle">();
	}
	static class UEcsTypeDesc_MovementObstacle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEcsTypeDesc_MovementObstacle>();
	}
};
static_assert(alignof(UEcsTypeDesc_MovementObstacle) == 0x000008, "Wrong alignment on UEcsTypeDesc_MovementObstacle");
static_assert(sizeof(UEcsTypeDesc_MovementObstacle) == 0x000030, "Wrong size on UEcsTypeDesc_MovementObstacle");
static_assert(offsetof(UEcsTypeDesc_MovementObstacle, bStaticObstacle) == 0x000028, "Member 'UEcsTypeDesc_MovementObstacle::bStaticObstacle' has a wrong offset!");
static_assert(offsetof(UEcsTypeDesc_MovementObstacle, MovementPlane) == 0x00002C, "Member 'UEcsTypeDesc_MovementObstacle::MovementPlane' has a wrong offset!");

// Class NubECS.EcsTypeDesc_Moveable
// 0x0000 (0x0028 - 0x0028)
class UEcsTypeDesc_Moveable final : public UEcsTypeDesc
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EcsTypeDesc_Moveable">();
	}
	static class UEcsTypeDesc_Moveable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEcsTypeDesc_Moveable>();
	}
};
static_assert(alignof(UEcsTypeDesc_Moveable) == 0x000008, "Wrong alignment on UEcsTypeDesc_Moveable");
static_assert(sizeof(UEcsTypeDesc_Moveable) == 0x000028, "Wrong size on UEcsTypeDesc_Moveable");

// Class NubECS.NubEcsModule_Movement
// 0x0000 (0x0030 - 0x0030)
class UNubEcsModule_Movement : public UEcsModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NubEcsModule_Movement">();
	}
	static class UNubEcsModule_Movement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNubEcsModule_Movement>();
	}
};
static_assert(alignof(UNubEcsModule_Movement) == 0x000008, "Wrong alignment on UNubEcsModule_Movement");
static_assert(sizeof(UNubEcsModule_Movement) == 0x000030, "Wrong size on UNubEcsModule_Movement");

// Class NubECS.NubObstacle
// 0x0010 (0x02A0 - 0x0290)
class ANubObstacle final : public AActor
{
public:
	struct FEcsComp_Obstacle                      Vertices;                                          // 0x0290(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NubObstacle">();
	}
	static class ANubObstacle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANubObstacle>();
	}
};
static_assert(alignof(ANubObstacle) == 0x000008, "Wrong alignment on ANubObstacle");
static_assert(sizeof(ANubObstacle) == 0x0002A0, "Wrong size on ANubObstacle");
static_assert(offsetof(ANubObstacle, Vertices) == 0x000290, "Member 'ANubObstacle::Vertices' has a wrong offset!");

// Class NubECS.NubSplineObstacle
// 0x0000 (0x0290 - 0x0290)
class ANubSplineObstacle final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NubSplineObstacle">();
	}
	static class ANubSplineObstacle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANubSplineObstacle>();
	}
};
static_assert(alignof(ANubSplineObstacle) == 0x000008, "Wrong alignment on ANubSplineObstacle");
static_assert(sizeof(ANubSplineObstacle) == 0x000290, "Wrong size on ANubSplineObstacle");

// Class NubECS.NubStaticObstacle
// 0x0018 (0x02A8 - 0x0290)
class ANubStaticObstacle final : public AActor
{
public:
	class UEcsActorComponent_AutoObstacle*        EcsActor;                                          // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          Collider;                                          // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNavModifierComponent*                  NavModifier;                                       // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NubStaticObstacle">();
	}
	static class ANubStaticObstacle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANubStaticObstacle>();
	}
};
static_assert(alignof(ANubStaticObstacle) == 0x000008, "Wrong alignment on ANubStaticObstacle");
static_assert(sizeof(ANubStaticObstacle) == 0x0002A8, "Wrong size on ANubStaticObstacle");
static_assert(offsetof(ANubStaticObstacle, EcsActor) == 0x000290, "Member 'ANubStaticObstacle::EcsActor' has a wrong offset!");
static_assert(offsetof(ANubStaticObstacle, Collider) == 0x000298, "Member 'ANubStaticObstacle::Collider' has a wrong offset!");
static_assert(offsetof(ANubStaticObstacle, NavModifier) == 0x0002A0, "Member 'ANubStaticObstacle::NavModifier' has a wrong offset!");

// Class NubECS.NubEcsModule_SpatialQuery
// 0x0000 (0x0030 - 0x0030)
class UNubEcsModule_SpatialQuery : public UEcsModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NubEcsModule_SpatialQuery">();
	}
	static class UNubEcsModule_SpatialQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNubEcsModule_SpatialQuery>();
	}
};
static_assert(alignof(UNubEcsModule_SpatialQuery) == 0x000008, "Wrong alignment on UNubEcsModule_SpatialQuery");
static_assert(sizeof(UNubEcsModule_SpatialQuery) == 0x000030, "Wrong size on UNubEcsModule_SpatialQuery");

// Class NubECS.EcsUtils
// 0x0000 (0x0028 - 0x0028)
class UEcsUtils final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EcsUtils">();
	}
	static class UEcsUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEcsUtils>();
	}
};
static_assert(alignof(UEcsUtils) == 0x000008, "Wrong alignment on UEcsUtils");
static_assert(sizeof(UEcsUtils) == 0x000028, "Wrong size on UEcsUtils");

// Class NubECS.EcsWorldSubsystem
// 0x0060 (0x0090 - 0x0030)
class UEcsWorldSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TSubclassOf<class UEcsModule>>           RegisteredModules;                                 // 0x0038(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EcsWorldSubsystem">();
	}
	static class UEcsWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEcsWorldSubsystem>();
	}
};
static_assert(alignof(UEcsWorldSubsystem) == 0x000008, "Wrong alignment on UEcsWorldSubsystem");
static_assert(sizeof(UEcsWorldSubsystem) == 0x000090, "Wrong size on UEcsWorldSubsystem");
static_assert(offsetof(UEcsWorldSubsystem, RegisteredModules) == 0x000038, "Member 'UEcsWorldSubsystem::RegisteredModules' has a wrong offset!");

// Class NubECS.NubMath
// 0x0000 (0x0028 - 0x0028)
class UNubMath final : public UBlueprintFunctionLibrary
{
public:
	static float GetDiagonal(const struct FVector& Extent);
	static float GetDiagonalFromBox(const struct FBox& Box);
	static struct FVector2D GetPillRadiusAndHalfLength(const struct FVector& Extent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NubMath">();
	}
	static class UNubMath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNubMath>();
	}
};
static_assert(alignof(UNubMath) == 0x000008, "Wrong alignment on UNubMath");
static_assert(sizeof(UNubMath) == 0x000028, "Wrong size on UNubMath");

}

