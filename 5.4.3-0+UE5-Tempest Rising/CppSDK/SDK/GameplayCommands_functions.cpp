#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GameplayCommands

#include "Basic.hpp"

#include "GameplayCommands_classes.hpp"
#include "GameplayCommands_parameters.hpp"


namespace SDK
{

// Function GameplayCommands.GameplayCommandComponent.CancelCurrentCommand
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bClearQueue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayCommandComponent::CancelCurrentCommand(bool bClearQueue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCommandComponent", "CancelCurrentCommand");

	Params::GameplayCommandComponent_CancelCurrentCommand Parms{};

	Parms.bClearQueue = bClearQueue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameplayCommands.GameplayCommandComponent.ClearCommandQueue
// (Final, Native, Public, BlueprintCallable)

void UGameplayCommandComponent::ClearCommandQueue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCommandComponent", "ClearCommandQueue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameplayCommands.GameplayCommandComponent.EnqueueCommand
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayCommandData&      CommandData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCommandComponent::EnqueueCommand(const struct FGameplayCommandData& CommandData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCommandComponent", "EnqueueCommand");

	Params::GameplayCommandComponent_EnqueueCommand Parms{};

	Parms.CommandData = std::move(CommandData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandComponent.IssueCommand
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayCommandData&      CommandData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCommandComponent::IssueCommand(const struct FGameplayCommandData& CommandData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCommandComponent", "IssueCommand");

	Params::GameplayCommandComponent_IssueCommand Parms{};

	Parms.CommandData = std::move(CommandData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandComponent.OnRep_CommandQueue
// (Final, Native, Protected)

void UGameplayCommandComponent::OnRep_CommandQueue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCommandComponent", "OnRep_CommandQueue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameplayCommands.GameplayCommandComponent.OnRep_CurrentCommand
// (Final, Native, Protected)

void UGameplayCommandComponent::OnRep_CurrentCommand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCommandComponent", "OnRep_CurrentCommand");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameplayCommands.GameplayCommandComponent.CanExecuteCommand
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayCommandData&      CommandData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bIgnoreCurrentCommand                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bVerboseLogs                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCommandComponent::CanExecuteCommand(const struct FGameplayCommandData& CommandData, bool bIgnoreCurrentCommand, bool bVerboseLogs) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCommandComponent", "CanExecuteCommand");

	Params::GameplayCommandComponent_CanExecuteCommand Parms{};

	Parms.CommandData = std::move(CommandData);
	Parms.bIgnoreCurrentCommand = bIgnoreCurrentCommand;
	Parms.bVerboseLogs = bVerboseLogs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandComponent.GetCommandQueue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FGameplayCommandData>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FGameplayCommandData> UGameplayCommandComponent::GetCommandQueue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCommandComponent", "GetCommandQueue");

	Params::GameplayCommandComponent_GetCommandQueue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandComponent.GetCurrentCommand
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayCommandData       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGameplayCommandData UGameplayCommandComponent::GetCurrentCommand() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCommandComponent", "GetCurrentCommand");

	Params::GameplayCommandComponent_GetCurrentCommand Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandComponent.GetCurrentCommandClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UGameplayCommand>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UGameplayCommand> UGameplayCommandComponent::GetCurrentCommandClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCommandComponent", "GetCurrentCommandClass");

	Params::GameplayCommandComponent_GetCurrentCommandClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandComponent.GetCurrentCommandTargetActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UGameplayCommandComponent::GetCurrentCommandTargetActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCommandComponent", "GetCurrentCommandTargetActor");

	Params::GameplayCommandComponent_GetCurrentCommandTargetActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandComponent.GetCurrentCommandTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UGameplayCommandComponent::GetCurrentCommandTargetLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCommandComponent", "GetCurrentCommandTargetLocation");

	Params::GameplayCommandComponent_GetCurrentCommandTargetLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandComponent.IsExecutingCommand
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCommandComponent::IsExecutingCommand() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCommandComponent", "IsExecutingCommand");

	Params::GameplayCommandComponent_IsExecutingCommand Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandComponentV2.CancelCommands
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CommandActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bForceCancelNonCancelable                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayCommandComponentV2::CancelCommands(class AActor* CommandActor, const bool bForceCancelNonCancelable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCommandComponentV2", "CancelCommands");

	Params::GameplayCommandComponentV2_CancelCommands Parms{};

	Parms.CommandActor = CommandActor;
	Parms.bForceCancelNonCancelable = bForceCancelNonCancelable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameplayCommands.GameplayCommandComponentV2.ClearCommandQueue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CommandActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayCommandComponentV2::ClearCommandQueue(class AActor* CommandActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCommandComponentV2", "ClearCommandQueue");

	Params::GameplayCommandComponentV2_ClearCommandQueue Parms{};

	Parms.CommandActor = CommandActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameplayCommands.GameplayCommandComponentV2.EnqueueBatchCommand
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class AActor*>&            CommandActors                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGameplayCommandData&      CommandData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCommandComponentV2::EnqueueBatchCommand(const TArray<class AActor*>& CommandActors, const struct FGameplayCommandData& CommandData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCommandComponentV2", "EnqueueBatchCommand");

	Params::GameplayCommandComponentV2_EnqueueBatchCommand Parms{};

	Parms.CommandActors = std::move(CommandActors);
	Parms.CommandData = std::move(CommandData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandComponentV2.EnqueueCommand
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           CommandActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayCommandData&      CommandData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCommandComponentV2::EnqueueCommand(class AActor* CommandActor, const struct FGameplayCommandData& CommandData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCommandComponentV2", "EnqueueCommand");

	Params::GameplayCommandComponentV2_EnqueueCommand Parms{};

	Parms.CommandActor = CommandActor;
	Parms.CommandData = std::move(CommandData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandComponentV2.InsertCommandAfterCurrent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           CommandActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayCommandData&      CommandData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCommandComponentV2::InsertCommandAfterCurrent(class AActor* CommandActor, const struct FGameplayCommandData& CommandData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCommandComponentV2", "InsertCommandAfterCurrent");

	Params::GameplayCommandComponentV2_InsertCommandAfterCurrent Parms{};

	Parms.CommandActor = CommandActor;
	Parms.CommandData = std::move(CommandData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandComponentV2.InsertCommandBeforeCurrent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           CommandActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayCommandData&      CommandData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCommandComponentV2::InsertCommandBeforeCurrent(class AActor* CommandActor, const struct FGameplayCommandData& CommandData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCommandComponentV2", "InsertCommandBeforeCurrent");

	Params::GameplayCommandComponentV2_InsertCommandBeforeCurrent Parms{};

	Parms.CommandActor = CommandActor;
	Parms.CommandData = std::move(CommandData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandComponentV2.IssueBatchCommand
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class AActor*>&            CommandActors                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGameplayCommandData&      CommandData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bEnqueueIfCannotExecuteRightAway                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCommandComponentV2::IssueBatchCommand(const TArray<class AActor*>& CommandActors, const struct FGameplayCommandData& CommandData, bool bEnqueueIfCannotExecuteRightAway)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCommandComponentV2", "IssueBatchCommand");

	Params::GameplayCommandComponentV2_IssueBatchCommand Parms{};

	Parms.CommandActors = std::move(CommandActors);
	Parms.CommandData = std::move(CommandData);
	Parms.bEnqueueIfCannotExecuteRightAway = bEnqueueIfCannotExecuteRightAway;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandComponentV2.IssueCommand
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           CommandActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayCommandData&      CommandData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bEnqueueIfCannotExecuteRightAway                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCommandComponentV2::IssueCommand(class AActor* CommandActor, const struct FGameplayCommandData& CommandData, bool bEnqueueIfCannotExecuteRightAway)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCommandComponentV2", "IssueCommand");

	Params::GameplayCommandComponentV2_IssueCommand Parms{};

	Parms.CommandActor = CommandActor;
	Parms.CommandData = std::move(CommandData);
	Parms.bEnqueueIfCannotExecuteRightAway = bEnqueueIfCannotExecuteRightAway;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandComponentV2.OnRep_ReplicationCommandRegisterEventsContainer
// (Final, Native, Protected)

void UGameplayCommandComponentV2::OnRep_ReplicationCommandRegisterEventsContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCommandComponentV2", "OnRep_ReplicationCommandRegisterEventsContainer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameplayCommands.GameplayCommandComponentV2.CanExecuteCommand
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AActor*                     CommandActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayCommandData&      CommandData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bIgnoreCurrentCommand                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bVerboseLogs                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCommandComponentV2::CanExecuteCommand(const class AActor* CommandActor, const struct FGameplayCommandData& CommandData, bool bIgnoreCurrentCommand, bool bVerboseLogs) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCommandComponentV2", "CanExecuteCommand");

	Params::GameplayCommandComponentV2_CanExecuteCommand Parms{};

	Parms.CommandActor = CommandActor;
	Parms.CommandData = std::move(CommandData);
	Parms.bIgnoreCurrentCommand = bIgnoreCurrentCommand;
	Parms.bVerboseLogs = bVerboseLogs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandComponentV2.GetCurrentCommandClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AActor*                     CommandActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayCommand>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UGameplayCommand> UGameplayCommandComponentV2::GetCurrentCommandClass(const class AActor* CommandActor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCommandComponentV2", "GetCurrentCommandClass");

	Params::GameplayCommandComponentV2_GetCurrentCommandClass Parms{};

	Parms.CommandActor = CommandActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandComponentV2.GetCurrentCommandData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AActor*                     CommandActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayCommandData       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGameplayCommandData UGameplayCommandComponentV2::GetCurrentCommandData(const class AActor* CommandActor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCommandComponentV2", "GetCurrentCommandData");

	Params::GameplayCommandComponentV2_GetCurrentCommandData Parms{};

	Parms.CommandActor = CommandActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandComponentV2.GetCurrentCommandTargetActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AActor*                     CommandActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UGameplayCommandComponentV2::GetCurrentCommandTargetActor(const class AActor* CommandActor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCommandComponentV2", "GetCurrentCommandTargetActor");

	Params::GameplayCommandComponentV2_GetCurrentCommandTargetActor Parms{};

	Parms.CommandActor = CommandActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandComponentV2.GetCurrentCommandTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AActor*                     CommandActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UGameplayCommandComponentV2::GetCurrentCommandTargetLocation(const class AActor* CommandActor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCommandComponentV2", "GetCurrentCommandTargetLocation");

	Params::GameplayCommandComponentV2_GetCurrentCommandTargetLocation Parms{};

	Parms.CommandActor = CommandActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandCustomRequirementBlueprintBase.K2_MeetRequirement
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// const class AActor*                     CommandActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayCommandData&      CommandData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayCommandErrorTags*       OutErrorTags                                           (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCommandCustomRequirementBlueprintBase::K2_MeetRequirement(const class AActor* CommandActor, const struct FGameplayCommandData& CommandData, struct FGameplayCommandErrorTags* OutErrorTags) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCommandCustomRequirementBlueprintBase", "K2_MeetRequirement");

	Params::GameplayCommandCustomRequirementBlueprintBase_K2_MeetRequirement Parms{};

	Parms.CommandActor = CommandActor;
	Parms.CommandData = std::move(CommandData);

	UObject::ProcessEvent(Func, &Parms);

	if (OutErrorTags != nullptr)
		*OutErrorTags = std::move(Parms.OutErrorTags);

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandFunctionLibrary.CancelCommands
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CommandActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayCommandFunctionLibrary::CancelCommands(class AActor* CommandActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayCommandFunctionLibrary", "CancelCommands");

	Params::GameplayCommandFunctionLibrary_CancelCommands Parms{};

	Parms.CommandActor = CommandActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameplayCommands.GameplayCommandFunctionLibrary.CanExecuteCommand
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class AActor*                     CommandActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayCommandData&      CommandData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bIgnoreCurrentCommand                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCommandFunctionLibrary::CanExecuteCommand(const class AActor* CommandActor, const struct FGameplayCommandData& CommandData, bool bIgnoreCurrentCommand)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayCommandFunctionLibrary", "CanExecuteCommand");

	Params::GameplayCommandFunctionLibrary_CanExecuteCommand Parms{};

	Parms.CommandActor = CommandActor;
	Parms.CommandData = std::move(CommandData);
	Parms.bIgnoreCurrentCommand = bIgnoreCurrentCommand;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandFunctionLibrary.ClearCommandQueue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CommandActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayCommandFunctionLibrary::ClearCommandQueue(class AActor* CommandActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayCommandFunctionLibrary", "ClearCommandQueue");

	Params::GameplayCommandFunctionLibrary_ClearCommandQueue Parms{};

	Parms.CommandActor = CommandActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameplayCommands.GameplayCommandFunctionLibrary.CommandData_GetCommandClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayCommandData&      CommandData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayCommand>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UGameplayCommand> UGameplayCommandFunctionLibrary::CommandData_GetCommandClass(const struct FGameplayCommandData& CommandData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayCommandFunctionLibrary", "CommandData_GetCommandClass");

	Params::GameplayCommandFunctionLibrary_CommandData_GetCommandClass Parms{};

	Parms.CommandData = std::move(CommandData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandFunctionLibrary.CommandData_GetTarget
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayCommandData&      CommandData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UGameplayCommandFunctionLibrary::CommandData_GetTarget(const struct FGameplayCommandData& CommandData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayCommandFunctionLibrary", "CommandData_GetTarget");

	Params::GameplayCommandFunctionLibrary_CommandData_GetTarget Parms{};

	Parms.CommandData = std::move(CommandData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandFunctionLibrary.CommandData_GetTargetLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayCommandData&      CommandData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool*                                   bHasTargetLocation                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UGameplayCommandFunctionLibrary::CommandData_GetTargetLocation(const struct FGameplayCommandData& CommandData, bool* bHasTargetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayCommandFunctionLibrary", "CommandData_GetTargetLocation");

	Params::GameplayCommandFunctionLibrary_CommandData_GetTargetLocation Parms{};

	Parms.CommandData = std::move(CommandData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bHasTargetLocation != nullptr)
		*bHasTargetLocation = Parms.bHasTargetLocation;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandFunctionLibrary.CommandData_IsValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayCommandData&      CommandData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCommandFunctionLibrary::CommandData_IsValid(const struct FGameplayCommandData& CommandData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayCommandFunctionLibrary", "CommandData_IsValid");

	Params::GameplayCommandFunctionLibrary_CommandData_IsValid Parms{};

	Parms.CommandData = std::move(CommandData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandFunctionLibrary.EnqueueBatchCommand
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class AActor*>&            CommandActors                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGameplayCommandData&      CommandData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCommandFunctionLibrary::EnqueueBatchCommand(const TArray<class AActor*>& CommandActors, const struct FGameplayCommandData& CommandData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayCommandFunctionLibrary", "EnqueueBatchCommand");

	Params::GameplayCommandFunctionLibrary_EnqueueBatchCommand Parms{};

	Parms.CommandActors = std::move(CommandActors);
	Parms.CommandData = std::move(CommandData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandFunctionLibrary.EnqueueBatchCommandByType
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const TArray<class AActor*>&            CommandActors                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              CommandType                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     TargetActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   TargetLocation                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCommandFunctionLibrary::EnqueueBatchCommandByType(const TArray<class AActor*>& CommandActors, const struct FGameplayTag& CommandType, const class AActor* TargetActor, const struct FVector& TargetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayCommandFunctionLibrary", "EnqueueBatchCommandByType");

	Params::GameplayCommandFunctionLibrary_EnqueueBatchCommandByType Parms{};

	Parms.CommandActors = std::move(CommandActors);
	Parms.CommandType = std::move(CommandType);
	Parms.TargetActor = TargetActor;
	Parms.TargetLocation = std::move(TargetLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandFunctionLibrary.EnqueueCommand
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           CommandActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayCommandData&      CommandData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCommandFunctionLibrary::EnqueueCommand(class AActor* CommandActor, const struct FGameplayCommandData& CommandData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayCommandFunctionLibrary", "EnqueueCommand");

	Params::GameplayCommandFunctionLibrary_EnqueueCommand Parms{};

	Parms.CommandActor = CommandActor;
	Parms.CommandData = std::move(CommandData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandFunctionLibrary.EnqueueCommandByType
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           CommandActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              CommandType                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     TargetActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   TargetLocation                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCommandFunctionLibrary::EnqueueCommandByType(class AActor* CommandActor, const struct FGameplayTag& CommandType, const class AActor* TargetActor, const struct FVector& TargetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayCommandFunctionLibrary", "EnqueueCommandByType");

	Params::GameplayCommandFunctionLibrary_EnqueueCommandByType Parms{};

	Parms.CommandActor = CommandActor;
	Parms.CommandType = std::move(CommandType);
	Parms.TargetActor = TargetActor;
	Parms.TargetLocation = std::move(TargetLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandFunctionLibrary.GetCurrentCommandClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     CommandActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayCommand>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UGameplayCommand> UGameplayCommandFunctionLibrary::GetCurrentCommandClass(const class AActor* CommandActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayCommandFunctionLibrary", "GetCurrentCommandClass");

	Params::GameplayCommandFunctionLibrary_GetCurrentCommandClass Parms{};

	Parms.CommandActor = CommandActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandFunctionLibrary.GetCurrentCommandData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     CommandActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCommandData             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayCommandData UGameplayCommandFunctionLibrary::GetCurrentCommandData(const class AActor* CommandActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayCommandFunctionLibrary", "GetCurrentCommandData");

	Params::GameplayCommandFunctionLibrary_GetCurrentCommandData Parms{};

	Parms.CommandActor = CommandActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandFunctionLibrary.GetCurrentCommandID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     CommandActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCommandID               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayCommandID UGameplayCommandFunctionLibrary::GetCurrentCommandID(const class AActor* CommandActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayCommandFunctionLibrary", "GetCurrentCommandID");

	Params::GameplayCommandFunctionLibrary_GetCurrentCommandID Parms{};

	Parms.CommandActor = CommandActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandFunctionLibrary.GetCurrentCommandTargetActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     CommandActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UGameplayCommandFunctionLibrary::GetCurrentCommandTargetActor(const class AActor* CommandActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayCommandFunctionLibrary", "GetCurrentCommandTargetActor");

	Params::GameplayCommandFunctionLibrary_GetCurrentCommandTargetActor Parms{};

	Parms.CommandActor = CommandActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandFunctionLibrary.GetCurrentCommandTargetLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     CommandActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UGameplayCommandFunctionLibrary::GetCurrentCommandTargetLocation(const class AActor* CommandActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayCommandFunctionLibrary", "GetCurrentCommandTargetLocation");

	Params::GameplayCommandFunctionLibrary_GetCurrentCommandTargetLocation Parms{};

	Parms.CommandActor = CommandActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandFunctionLibrary.InsertCommandAfterCurrent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           CommandActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayCommandData&      CommandData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCommandFunctionLibrary::InsertCommandAfterCurrent(class AActor* CommandActor, const struct FGameplayCommandData& CommandData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayCommandFunctionLibrary", "InsertCommandAfterCurrent");

	Params::GameplayCommandFunctionLibrary_InsertCommandAfterCurrent Parms{};

	Parms.CommandActor = CommandActor;
	Parms.CommandData = std::move(CommandData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandFunctionLibrary.InsertCommandAfterCurrentByType
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           CommandActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              CommandType                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     TargetActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   TargetLocation                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCommandFunctionLibrary::InsertCommandAfterCurrentByType(class AActor* CommandActor, const struct FGameplayTag& CommandType, const class AActor* TargetActor, const struct FVector& TargetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayCommandFunctionLibrary", "InsertCommandAfterCurrentByType");

	Params::GameplayCommandFunctionLibrary_InsertCommandAfterCurrentByType Parms{};

	Parms.CommandActor = CommandActor;
	Parms.CommandType = std::move(CommandType);
	Parms.TargetActor = TargetActor;
	Parms.TargetLocation = std::move(TargetLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandFunctionLibrary.InsertCommandBeforeCurrent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           CommandActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayCommandData&      CommandData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCommandFunctionLibrary::InsertCommandBeforeCurrent(class AActor* CommandActor, const struct FGameplayCommandData& CommandData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayCommandFunctionLibrary", "InsertCommandBeforeCurrent");

	Params::GameplayCommandFunctionLibrary_InsertCommandBeforeCurrent Parms{};

	Parms.CommandActor = CommandActor;
	Parms.CommandData = std::move(CommandData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandFunctionLibrary.InsertCommandBeforeCurrentByType
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           CommandActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              CommandType                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     TargetActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   TargetLocation                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCommandFunctionLibrary::InsertCommandBeforeCurrentByType(class AActor* CommandActor, const struct FGameplayTag& CommandType, const class AActor* TargetActor, const struct FVector& TargetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayCommandFunctionLibrary", "InsertCommandBeforeCurrentByType");

	Params::GameplayCommandFunctionLibrary_InsertCommandBeforeCurrentByType Parms{};

	Parms.CommandActor = CommandActor;
	Parms.CommandType = std::move(CommandType);
	Parms.TargetActor = TargetActor;
	Parms.TargetLocation = std::move(TargetLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandFunctionLibrary.IsCommandSupported
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CommandActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSubclassOf<class UGameplayCommand>CommandClass                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCommandFunctionLibrary::IsCommandSupported(class AActor* CommandActor, const TSubclassOf<class UGameplayCommand> CommandClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayCommandFunctionLibrary", "IsCommandSupported");

	Params::GameplayCommandFunctionLibrary_IsCommandSupported Parms{};

	Parms.CommandActor = CommandActor;
	Parms.CommandClass = CommandClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandFunctionLibrary.IsCommandSupportedByType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           CommandActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              CommandType                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCommandFunctionLibrary::IsCommandSupportedByType(class AActor* CommandActor, const struct FGameplayTag& CommandType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayCommandFunctionLibrary", "IsCommandSupportedByType");

	Params::GameplayCommandFunctionLibrary_IsCommandSupportedByType Parms{};

	Parms.CommandActor = CommandActor;
	Parms.CommandType = std::move(CommandType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandFunctionLibrary.IsExecutingAnyCommand
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     CommandActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCommandFunctionLibrary::IsExecutingAnyCommand(const class AActor* CommandActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayCommandFunctionLibrary", "IsExecutingAnyCommand");

	Params::GameplayCommandFunctionLibrary_IsExecutingAnyCommand Parms{};

	Parms.CommandActor = CommandActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandFunctionLibrary.IsExecutingCommandOfType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           CommandActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              CommandType                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCommandFunctionLibrary::IsExecutingCommandOfType(class AActor* CommandActor, const struct FGameplayTag& CommandType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayCommandFunctionLibrary", "IsExecutingCommandOfType");

	Params::GameplayCommandFunctionLibrary_IsExecutingCommandOfType Parms{};

	Parms.CommandActor = CommandActor;
	Parms.CommandType = std::move(CommandType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandFunctionLibrary.IsExecutionCommand
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     CommandActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSubclassOf<class UGameplayCommand>CommandClass                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCommandFunctionLibrary::IsExecutionCommand(const class AActor* CommandActor, const TSubclassOf<class UGameplayCommand> CommandClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayCommandFunctionLibrary", "IsExecutionCommand");

	Params::GameplayCommandFunctionLibrary_IsExecutionCommand Parms{};

	Parms.CommandActor = CommandActor;
	Parms.CommandClass = CommandClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandFunctionLibrary.IssueBatchCommand
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class AActor*>&            CommandActors                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGameplayCommandData&      CommandData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bEnqueueIfCannotExecuteRightAway                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCommandFunctionLibrary::IssueBatchCommand(const TArray<class AActor*>& CommandActors, const struct FGameplayCommandData& CommandData, bool bEnqueueIfCannotExecuteRightAway)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayCommandFunctionLibrary", "IssueBatchCommand");

	Params::GameplayCommandFunctionLibrary_IssueBatchCommand Parms{};

	Parms.CommandActors = std::move(CommandActors);
	Parms.CommandData = std::move(CommandData);
	Parms.bEnqueueIfCannotExecuteRightAway = bEnqueueIfCannotExecuteRightAway;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandFunctionLibrary.IssueBatchCommandByType
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const TArray<class AActor*>&            CommandActors                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              CommandType                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     TargetActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   TargetLocation                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnqueueIfCannotExecuteRightAway                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCommandFunctionLibrary::IssueBatchCommandByType(const TArray<class AActor*>& CommandActors, const struct FGameplayTag& CommandType, const class AActor* TargetActor, const struct FVector& TargetLocation, bool bEnqueueIfCannotExecuteRightAway)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayCommandFunctionLibrary", "IssueBatchCommandByType");

	Params::GameplayCommandFunctionLibrary_IssueBatchCommandByType Parms{};

	Parms.CommandActors = std::move(CommandActors);
	Parms.CommandType = std::move(CommandType);
	Parms.TargetActor = TargetActor;
	Parms.TargetLocation = std::move(TargetLocation);
	Parms.bEnqueueIfCannotExecuteRightAway = bEnqueueIfCannotExecuteRightAway;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandFunctionLibrary.IssueCommand
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           CommandActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayCommandData&      CommandData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bEnqueueIfCannotExecuteRightAway                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCommandFunctionLibrary::IssueCommand(class AActor* CommandActor, const struct FGameplayCommandData& CommandData, bool bEnqueueIfCannotExecuteRightAway)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayCommandFunctionLibrary", "IssueCommand");

	Params::GameplayCommandFunctionLibrary_IssueCommand Parms{};

	Parms.CommandActor = CommandActor;
	Parms.CommandData = std::move(CommandData);
	Parms.bEnqueueIfCannotExecuteRightAway = bEnqueueIfCannotExecuteRightAway;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandFunctionLibrary.IssueCommandByType
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           CommandActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              CommandType                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     TargetActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   TargetLocation                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnqueueIfCannotExecuteRightAway                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCommandFunctionLibrary::IssueCommandByType(class AActor* CommandActor, const struct FGameplayTag& CommandType, const class AActor* TargetActor, const struct FVector& TargetLocation, bool bEnqueueIfCannotExecuteRightAway)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayCommandFunctionLibrary", "IssueCommandByType");

	Params::GameplayCommandFunctionLibrary_IssueCommandByType Parms{};

	Parms.CommandActor = CommandActor;
	Parms.CommandType = std::move(CommandType);
	Parms.TargetActor = TargetActor;
	Parms.TargetLocation = std::move(TargetLocation);
	Parms.bEnqueueIfCannotExecuteRightAway = bEnqueueIfCannotExecuteRightAway;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandFunctionLibrary.IssueContextualCommand
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           CommandActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     TargetActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   TargetLocation                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnqueueIfCannotExecuteRightAway                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayCommandFunctionLibrary::IssueContextualCommand(class AActor* CommandActor, const class AActor* TargetActor, const struct FVector& TargetLocation, bool bEnqueueIfCannotExecuteRightAway)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayCommandFunctionLibrary", "IssueContextualCommand");

	Params::GameplayCommandFunctionLibrary_IssueContextualCommand Parms{};

	Parms.CommandActor = CommandActor;
	Parms.TargetActor = TargetActor;
	Parms.TargetLocation = std::move(TargetLocation);
	Parms.bEnqueueIfCannotExecuteRightAway = bEnqueueIfCannotExecuteRightAway;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayCommands.GameplayCommandPreviewActor.OnActiveStateChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bNewActive                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameplayCommandPreviewActor::OnActiveStateChanged(bool bNewActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCommandPreviewActor", "OnActiveStateChanged");

	Params::GameplayCommandPreviewActor_OnActiveStateChanged Parms{};

	Parms.bNewActive = bNewActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameplayCommands.GameplayCommandValueCalculation.CalculateValue
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// const class AActor*                     CommandActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UGameplayCommand*           Command                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayCommandValueCalculation::CalculateValue(const class AActor* CommandActor, const class UGameplayCommand* Command) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayCommandValueCalculation", "CalculateValue");

	Params::GameplayCommandValueCalculation_CalculateValue Parms{};

	Parms.CommandActor = CommandActor;
	Parms.Command = Command;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

