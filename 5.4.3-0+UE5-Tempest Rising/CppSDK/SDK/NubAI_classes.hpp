#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: NubAI

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "NubAI_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class NubAI.AIDataProvider_BlackboardValue
// 0x0018 (0x0040 - 0x0028)
class UAIDataProvider_BlackboardValue final : public UAIDataProvider
{
public:
	class FName                                   KeyName;                                           // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FloatValue;                                        // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         IntValue;                                          // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BoolValue;                                         // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDataProvider_BlackboardValue">();
	}
	static class UAIDataProvider_BlackboardValue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDataProvider_BlackboardValue>();
	}
};
static_assert(alignof(UAIDataProvider_BlackboardValue) == 0x000008, "Wrong alignment on UAIDataProvider_BlackboardValue");
static_assert(sizeof(UAIDataProvider_BlackboardValue) == 0x000040, "Wrong size on UAIDataProvider_BlackboardValue");
static_assert(offsetof(UAIDataProvider_BlackboardValue, KeyName) == 0x000028, "Member 'UAIDataProvider_BlackboardValue::KeyName' has a wrong offset!");
static_assert(offsetof(UAIDataProvider_BlackboardValue, FloatValue) == 0x000030, "Member 'UAIDataProvider_BlackboardValue::FloatValue' has a wrong offset!");
static_assert(offsetof(UAIDataProvider_BlackboardValue, IntValue) == 0x000034, "Member 'UAIDataProvider_BlackboardValue::IntValue' has a wrong offset!");
static_assert(offsetof(UAIDataProvider_BlackboardValue, BoolValue) == 0x000038, "Member 'UAIDataProvider_BlackboardValue::BoolValue' has a wrong offset!");

// Class NubAI.AIDataProvider_GameplayAttribute
// 0x0048 (0x0070 - 0x0028)
class UAIDataProvider_GameplayAttribute final : public UAIDataProvider
{
public:
	struct FGameplayAttribute                     Attribute;                                         // 0x0028(0x0038)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FloatValue;                                        // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         IntValue;                                          // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BoolValue;                                         // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDataProvider_GameplayAttribute">();
	}
	static class UAIDataProvider_GameplayAttribute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDataProvider_GameplayAttribute>();
	}
};
static_assert(alignof(UAIDataProvider_GameplayAttribute) == 0x000008, "Wrong alignment on UAIDataProvider_GameplayAttribute");
static_assert(sizeof(UAIDataProvider_GameplayAttribute) == 0x000070, "Wrong size on UAIDataProvider_GameplayAttribute");
static_assert(offsetof(UAIDataProvider_GameplayAttribute, Attribute) == 0x000028, "Member 'UAIDataProvider_GameplayAttribute::Attribute' has a wrong offset!");
static_assert(offsetof(UAIDataProvider_GameplayAttribute, FloatValue) == 0x000060, "Member 'UAIDataProvider_GameplayAttribute::FloatValue' has a wrong offset!");
static_assert(offsetof(UAIDataProvider_GameplayAttribute, IntValue) == 0x000064, "Member 'UAIDataProvider_GameplayAttribute::IntValue' has a wrong offset!");
static_assert(offsetof(UAIDataProvider_GameplayAttribute, BoolValue) == 0x000068, "Member 'UAIDataProvider_GameplayAttribute::BoolValue' has a wrong offset!");

// Class NubAI.BTService_RunInfluenceMapQuery
// 0x0018 (0x00B0 - 0x0098)
class UBTService_RunInfluenceMapQuery final : public UBTService_BlackboardBase
{
public:
	class UInfluenceMapQueryPreset*               QueryPreset;                                       // 0x0098(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInfluenceMapQueryType                        QueryType;                                         // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InfluenceThreshold;                                // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SearchRadius;                                      // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_RunInfluenceMapQuery">();
	}
	static class UBTService_RunInfluenceMapQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_RunInfluenceMapQuery>();
	}
};
static_assert(alignof(UBTService_RunInfluenceMapQuery) == 0x000008, "Wrong alignment on UBTService_RunInfluenceMapQuery");
static_assert(sizeof(UBTService_RunInfluenceMapQuery) == 0x0000B0, "Wrong size on UBTService_RunInfluenceMapQuery");
static_assert(offsetof(UBTService_RunInfluenceMapQuery, QueryPreset) == 0x000098, "Member 'UBTService_RunInfluenceMapQuery::QueryPreset' has a wrong offset!");
static_assert(offsetof(UBTService_RunInfluenceMapQuery, QueryType) == 0x0000A0, "Member 'UBTService_RunInfluenceMapQuery::QueryType' has a wrong offset!");
static_assert(offsetof(UBTService_RunInfluenceMapQuery, InfluenceThreshold) == 0x0000A4, "Member 'UBTService_RunInfluenceMapQuery::InfluenceThreshold' has a wrong offset!");
static_assert(offsetof(UBTService_RunInfluenceMapQuery, SearchRadius) == 0x0000A8, "Member 'UBTService_RunInfluenceMapQuery::SearchRadius' has a wrong offset!");

// Class NubAI.InfluenceMap
// 0x0000 (0x0028 - 0x0028)
class UInfluenceMap : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InfluenceMap">();
	}
	static class UInfluenceMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInfluenceMap>();
	}
};
static_assert(alignof(UInfluenceMap) == 0x000008, "Wrong alignment on UInfluenceMap");
static_assert(sizeof(UInfluenceMap) == 0x000028, "Wrong size on UInfluenceMap");

// Class NubAI.InfluenceMapQueryPreset
// 0x0010 (0x0040 - 0x0030)
class UInfluenceMapQueryPreset final : public UDataAsset
{
public:
	struct FInfluenceMapQueryParams               QueryParams;                                       // 0x0030(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InfluenceMapQueryPreset">();
	}
	static class UInfluenceMapQueryPreset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInfluenceMapQueryPreset>();
	}
};
static_assert(alignof(UInfluenceMapQueryPreset) == 0x000008, "Wrong alignment on UInfluenceMapQueryPreset");
static_assert(sizeof(UInfluenceMapQueryPreset) == 0x000040, "Wrong size on UInfluenceMapQueryPreset");
static_assert(offsetof(UInfluenceMapQueryPreset, QueryParams) == 0x000030, "Member 'UInfluenceMapQueryPreset::QueryParams' has a wrong offset!");

// Class NubAI.InfluenceMapTestingActor
// 0x0060 (0x02F0 - 0x0290)
class AInfluenceMapTestingActor final : public AActor
{
public:
	class USceneComponent*                        ActorRootComponent;                                // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 QueryOwner;                                        // 0x0298(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInfluenceMapQueryPreset*               QueryPreset;                                       // 0x02A0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FInfluenceMapQueryParams               QueryParams;                                       // 0x02A8(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bUseOwnerLocation;                                 // 0x02B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TestLocation;                                      // 0x02C0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SampleRange;                                       // 0x02D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SampleResolution;                                  // 0x02DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LowHighSearchRadius;                               // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LowSpotThreshold;                                  // 0x02E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HighSpotThreshold;                                 // 0x02E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawInfluenceGrid;                                // 0x02EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawInfluenceValues;                              // 0x02ED(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawGradientValues;                               // 0x02EE(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawGradient;                                     // 0x02EF(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InfluenceMapTestingActor">();
	}
	static class AInfluenceMapTestingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInfluenceMapTestingActor>();
	}
};
static_assert(alignof(AInfluenceMapTestingActor) == 0x000008, "Wrong alignment on AInfluenceMapTestingActor");
static_assert(sizeof(AInfluenceMapTestingActor) == 0x0002F0, "Wrong size on AInfluenceMapTestingActor");
static_assert(offsetof(AInfluenceMapTestingActor, ActorRootComponent) == 0x000290, "Member 'AInfluenceMapTestingActor::ActorRootComponent' has a wrong offset!");
static_assert(offsetof(AInfluenceMapTestingActor, QueryOwner) == 0x000298, "Member 'AInfluenceMapTestingActor::QueryOwner' has a wrong offset!");
static_assert(offsetof(AInfluenceMapTestingActor, QueryPreset) == 0x0002A0, "Member 'AInfluenceMapTestingActor::QueryPreset' has a wrong offset!");
static_assert(offsetof(AInfluenceMapTestingActor, QueryParams) == 0x0002A8, "Member 'AInfluenceMapTestingActor::QueryParams' has a wrong offset!");
static_assert(offsetof(AInfluenceMapTestingActor, bUseOwnerLocation) == 0x0002B8, "Member 'AInfluenceMapTestingActor::bUseOwnerLocation' has a wrong offset!");
static_assert(offsetof(AInfluenceMapTestingActor, TestLocation) == 0x0002C0, "Member 'AInfluenceMapTestingActor::TestLocation' has a wrong offset!");
static_assert(offsetof(AInfluenceMapTestingActor, SampleRange) == 0x0002D8, "Member 'AInfluenceMapTestingActor::SampleRange' has a wrong offset!");
static_assert(offsetof(AInfluenceMapTestingActor, SampleResolution) == 0x0002DC, "Member 'AInfluenceMapTestingActor::SampleResolution' has a wrong offset!");
static_assert(offsetof(AInfluenceMapTestingActor, LowHighSearchRadius) == 0x0002E0, "Member 'AInfluenceMapTestingActor::LowHighSearchRadius' has a wrong offset!");
static_assert(offsetof(AInfluenceMapTestingActor, LowSpotThreshold) == 0x0002E4, "Member 'AInfluenceMapTestingActor::LowSpotThreshold' has a wrong offset!");
static_assert(offsetof(AInfluenceMapTestingActor, HighSpotThreshold) == 0x0002E8, "Member 'AInfluenceMapTestingActor::HighSpotThreshold' has a wrong offset!");
static_assert(offsetof(AInfluenceMapTestingActor, bDrawInfluenceGrid) == 0x0002EC, "Member 'AInfluenceMapTestingActor::bDrawInfluenceGrid' has a wrong offset!");
static_assert(offsetof(AInfluenceMapTestingActor, bDrawInfluenceValues) == 0x0002ED, "Member 'AInfluenceMapTestingActor::bDrawInfluenceValues' has a wrong offset!");
static_assert(offsetof(AInfluenceMapTestingActor, bDrawGradientValues) == 0x0002EE, "Member 'AInfluenceMapTestingActor::bDrawGradientValues' has a wrong offset!");
static_assert(offsetof(AInfluenceMapTestingActor, bDrawGradient) == 0x0002EF, "Member 'AInfluenceMapTestingActor::bDrawGradient' has a wrong offset!");

// Class NubAI.InfluenceMap_NavWall
// 0x0000 (0x0028 - 0x0028)
class UInfluenceMap_NavWall final : public UInfluenceMap
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InfluenceMap_NavWall">();
	}
	static class UInfluenceMap_NavWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInfluenceMap_NavWall>();
	}
};
static_assert(alignof(UInfluenceMap_NavWall) == 0x000008, "Wrong alignment on UInfluenceMap_NavWall");
static_assert(sizeof(UInfluenceMap_NavWall) == 0x000028, "Wrong size on UInfluenceMap_NavWall");

// Class NubAI.UtilityAIAction
// 0x0010 (0x0038 - 0x0028)
class UUtilityAIAction : public UObject
{
public:
	EUtilityAIActionInterruptionPolicy            InterruptionPolicy;                                // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideDefaultThinkInterval;                     // 0x0029(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ThinkInterval;                                     // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIAction">();
	}
	static class UUtilityAIAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIAction>();
	}
};
static_assert(alignof(UUtilityAIAction) == 0x000008, "Wrong alignment on UUtilityAIAction");
static_assert(sizeof(UUtilityAIAction) == 0x000038, "Wrong size on UUtilityAIAction");
static_assert(offsetof(UUtilityAIAction, InterruptionPolicy) == 0x000028, "Member 'UUtilityAIAction::InterruptionPolicy' has a wrong offset!");
static_assert(offsetof(UUtilityAIAction, bOverrideDefaultThinkInterval) == 0x000029, "Member 'UUtilityAIAction::bOverrideDefaultThinkInterval' has a wrong offset!");
static_assert(offsetof(UUtilityAIAction, ThinkInterval) == 0x00002C, "Member 'UUtilityAIAction::ThinkInterval' has a wrong offset!");

// Class NubAI.UtilityAIAction_BlueprintBase
// 0x0010 (0x0048 - 0x0038)
class UUtilityAIAction_BlueprintBase final : public UUtilityAIAction
{
public:
	struct FIntervalCountdown                     TickInterval;                                      // 0x0038(0x0008)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinishAbort();
	void FinishExecute(bool bSuccess);
	void ReceiveAbort(const struct FUtilityAIActionContext& Context);
	void ReceiveExecute(const struct FUtilityAIActionContext& Context);
	void ReceiveTick(const struct FUtilityAIActionContext& Context, float DeltaSeconds);

	bool IsAborting() const;
	bool IsExecuting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIAction_BlueprintBase">();
	}
	static class UUtilityAIAction_BlueprintBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIAction_BlueprintBase>();
	}
};
static_assert(alignof(UUtilityAIAction_BlueprintBase) == 0x000008, "Wrong alignment on UUtilityAIAction_BlueprintBase");
static_assert(sizeof(UUtilityAIAction_BlueprintBase) == 0x000048, "Wrong size on UUtilityAIAction_BlueprintBase");
static_assert(offsetof(UUtilityAIAction_BlueprintBase, TickInterval) == 0x000038, "Member 'UUtilityAIAction_BlueprintBase::TickInterval' has a wrong offset!");

// Class NubAI.UtilityAIAction_Test
// 0x0008 (0x0040 - 0x0038)
class UUtilityAIAction_Test final : public UUtilityAIAction
{
public:
	float                                         ActionTimeout;                                     // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUtilityAIActionResult                        Result;                                            // 0x003C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIAction_Test">();
	}
	static class UUtilityAIAction_Test* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIAction_Test>();
	}
};
static_assert(alignof(UUtilityAIAction_Test) == 0x000008, "Wrong alignment on UUtilityAIAction_Test");
static_assert(sizeof(UUtilityAIAction_Test) == 0x000040, "Wrong size on UUtilityAIAction_Test");
static_assert(offsetof(UUtilityAIAction_Test, ActionTimeout) == 0x000038, "Member 'UUtilityAIAction_Test::ActionTimeout' has a wrong offset!");
static_assert(offsetof(UUtilityAIAction_Test, Result) == 0x00003C, "Member 'UUtilityAIAction_Test::Result' has a wrong offset!");

// Class NubAI.UtilityAIBehavior
// 0x0180 (0x01B0 - 0x0030)
class UUtilityAIBehavior final : public UDataAsset
{
public:
	class FString                                 FriendlyName;                                      // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  BehaviorTags;                                      // 0x0040(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagRequirements               OwnerRequiredTags;                                 // 0x0060(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UUtilityAIAction*                       Action;                                            // 0x00E8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUtilityAIDecisionContextType                 ContextType;                                       // 0x00F0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUtilityAITargetGenerator>  TargetGeneratorClass;                              // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUtilityAITargetFilter*>         TargetFilters;                                     // 0x0100(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UUtilityAIDecisionScoreEvaluatorAsset*  ScoreEvaluatorAsset;                               // 0x0110(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FUtilityAIDecisionScoreEvaluator       ScoreEvaluator;                                    // 0x0118(0x0010)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              Weight;                                            // 0x0128(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              Momentum;                                          // 0x0160(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAIDataProviderFloatValue>      AdditionalBonuses;                                 // 0x0198(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UUtilityAIDecisionGroup>    DecisionGroup;                                     // 0x01A8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIBehavior">();
	}
	static class UUtilityAIBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIBehavior>();
	}
};
static_assert(alignof(UUtilityAIBehavior) == 0x000008, "Wrong alignment on UUtilityAIBehavior");
static_assert(sizeof(UUtilityAIBehavior) == 0x0001B0, "Wrong size on UUtilityAIBehavior");
static_assert(offsetof(UUtilityAIBehavior, FriendlyName) == 0x000030, "Member 'UUtilityAIBehavior::FriendlyName' has a wrong offset!");
static_assert(offsetof(UUtilityAIBehavior, BehaviorTags) == 0x000040, "Member 'UUtilityAIBehavior::BehaviorTags' has a wrong offset!");
static_assert(offsetof(UUtilityAIBehavior, OwnerRequiredTags) == 0x000060, "Member 'UUtilityAIBehavior::OwnerRequiredTags' has a wrong offset!");
static_assert(offsetof(UUtilityAIBehavior, Action) == 0x0000E8, "Member 'UUtilityAIBehavior::Action' has a wrong offset!");
static_assert(offsetof(UUtilityAIBehavior, ContextType) == 0x0000F0, "Member 'UUtilityAIBehavior::ContextType' has a wrong offset!");
static_assert(offsetof(UUtilityAIBehavior, TargetGeneratorClass) == 0x0000F8, "Member 'UUtilityAIBehavior::TargetGeneratorClass' has a wrong offset!");
static_assert(offsetof(UUtilityAIBehavior, TargetFilters) == 0x000100, "Member 'UUtilityAIBehavior::TargetFilters' has a wrong offset!");
static_assert(offsetof(UUtilityAIBehavior, ScoreEvaluatorAsset) == 0x000110, "Member 'UUtilityAIBehavior::ScoreEvaluatorAsset' has a wrong offset!");
static_assert(offsetof(UUtilityAIBehavior, ScoreEvaluator) == 0x000118, "Member 'UUtilityAIBehavior::ScoreEvaluator' has a wrong offset!");
static_assert(offsetof(UUtilityAIBehavior, Weight) == 0x000128, "Member 'UUtilityAIBehavior::Weight' has a wrong offset!");
static_assert(offsetof(UUtilityAIBehavior, Momentum) == 0x000160, "Member 'UUtilityAIBehavior::Momentum' has a wrong offset!");
static_assert(offsetof(UUtilityAIBehavior, AdditionalBonuses) == 0x000198, "Member 'UUtilityAIBehavior::AdditionalBonuses' has a wrong offset!");
static_assert(offsetof(UUtilityAIBehavior, DecisionGroup) == 0x0001A8, "Member 'UUtilityAIBehavior::DecisionGroup' has a wrong offset!");

// Class NubAI.UtilityAIBehaviorSet
// 0x0010 (0x0040 - 0x0030)
class UUtilityAIBehaviorSet final : public UDataAsset
{
public:
	TArray<class UUtilityAIBehavior*>             Behaviors;                                         // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIBehaviorSet">();
	}
	static class UUtilityAIBehaviorSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIBehaviorSet>();
	}
};
static_assert(alignof(UUtilityAIBehaviorSet) == 0x000008, "Wrong alignment on UUtilityAIBehaviorSet");
static_assert(sizeof(UUtilityAIBehaviorSet) == 0x000040, "Wrong size on UUtilityAIBehaviorSet");
static_assert(offsetof(UUtilityAIBehaviorSet, Behaviors) == 0x000030, "Member 'UUtilityAIBehaviorSet::Behaviors' has a wrong offset!");

// Class NubAI.UtilityAIBrain
// 0x0338 (0x0360 - 0x0028)
class UUtilityAIBrain final : public UObject
{
public:
	class UObject*                                Owner;                                             // 0x0028(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AController*                            Controller;                                        // 0x0030(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 Avatar;                                            // 0x0038(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlackboardComponent*                   LocalBlackboard;                                   // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlackboardComponent*                   WorldBlackboard;                                   // 0x0048(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UUtilityAIBehaviorSet*>            RegisteredBehaviorSets;                            // 0x0060(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TSet<class UUtilityAIBehavior*>               RegisteredLooseBehaviorList;                       // 0x00B0(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_100[0xA0];                                     // 0x0100(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUtilityAIDecision>             DecisionList;                                      // 0x01A0(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	struct FUtilityAIDecision                     LastDecision;                                      // 0x01B0(0x0048)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F8[0x58];                                     // 0x01F8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UUtilityAIAction*                       ActiveAction;                                      // 0x0250(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FUtilityAIActionContext                ActiveActionContext;                               // 0x0258(0x0058)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	TMap<class UUtilityAIBehavior*, struct FUtilityAIActionInstance> ActionInstanceMap;              // 0x02B0(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_300[0x8];                                      // 0x0300(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UUtilityAIBehavior*, struct FUtilityAIDecisionHistory> DecisionHistoryMap;            // 0x0308(0x0050)(Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBehaviorSet(const class UUtilityAIBehaviorSet* BehaviorSet);
	void AddLooseBehavior(const class UUtilityAIBehavior* Behavior);
	void RemoveBehaviorSet(const class UUtilityAIBehaviorSet* BehaviorSet);
	void RemoveLooseBehavior(const class UUtilityAIBehavior* Behavior);

	bool HasBehavior(const class UUtilityAIBehavior* Behavior) const;
	bool HasBehaviorSet(const class UUtilityAIBehaviorSet* BehaviorSet) const;
	bool HasLooseBehavior(const class UUtilityAIBehavior* Behavior) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIBrain">();
	}
	static class UUtilityAIBrain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIBrain>();
	}
};
static_assert(alignof(UUtilityAIBrain) == 0x000008, "Wrong alignment on UUtilityAIBrain");
static_assert(sizeof(UUtilityAIBrain) == 0x000360, "Wrong size on UUtilityAIBrain");
static_assert(offsetof(UUtilityAIBrain, Owner) == 0x000028, "Member 'UUtilityAIBrain::Owner' has a wrong offset!");
static_assert(offsetof(UUtilityAIBrain, Controller) == 0x000030, "Member 'UUtilityAIBrain::Controller' has a wrong offset!");
static_assert(offsetof(UUtilityAIBrain, Avatar) == 0x000038, "Member 'UUtilityAIBrain::Avatar' has a wrong offset!");
static_assert(offsetof(UUtilityAIBrain, LocalBlackboard) == 0x000040, "Member 'UUtilityAIBrain::LocalBlackboard' has a wrong offset!");
static_assert(offsetof(UUtilityAIBrain, WorldBlackboard) == 0x000048, "Member 'UUtilityAIBrain::WorldBlackboard' has a wrong offset!");
static_assert(offsetof(UUtilityAIBrain, RegisteredBehaviorSets) == 0x000060, "Member 'UUtilityAIBrain::RegisteredBehaviorSets' has a wrong offset!");
static_assert(offsetof(UUtilityAIBrain, RegisteredLooseBehaviorList) == 0x0000B0, "Member 'UUtilityAIBrain::RegisteredLooseBehaviorList' has a wrong offset!");
static_assert(offsetof(UUtilityAIBrain, DecisionList) == 0x0001A0, "Member 'UUtilityAIBrain::DecisionList' has a wrong offset!");
static_assert(offsetof(UUtilityAIBrain, LastDecision) == 0x0001B0, "Member 'UUtilityAIBrain::LastDecision' has a wrong offset!");
static_assert(offsetof(UUtilityAIBrain, ActiveAction) == 0x000250, "Member 'UUtilityAIBrain::ActiveAction' has a wrong offset!");
static_assert(offsetof(UUtilityAIBrain, ActiveActionContext) == 0x000258, "Member 'UUtilityAIBrain::ActiveActionContext' has a wrong offset!");
static_assert(offsetof(UUtilityAIBrain, ActionInstanceMap) == 0x0002B0, "Member 'UUtilityAIBrain::ActionInstanceMap' has a wrong offset!");
static_assert(offsetof(UUtilityAIBrain, DecisionHistoryMap) == 0x000308, "Member 'UUtilityAIBrain::DecisionHistoryMap' has a wrong offset!");

// Class NubAI.UtilityAIBrainComponent
// 0x0008 (0x0110 - 0x0108)
class UUtilityAIBrainComponent final : public UBrainComponent
{
public:
	class UUtilityAIBrain*                        Brain;                                             // 0x0108(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIBrainComponent">();
	}
	static class UUtilityAIBrainComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIBrainComponent>();
	}
};
static_assert(alignof(UUtilityAIBrainComponent) == 0x000008, "Wrong alignment on UUtilityAIBrainComponent");
static_assert(sizeof(UUtilityAIBrainComponent) == 0x000110, "Wrong size on UUtilityAIBrainComponent");
static_assert(offsetof(UUtilityAIBrainComponent, Brain) == 0x000108, "Member 'UUtilityAIBrainComponent::Brain' has a wrong offset!");

// Class NubAI.UtilityAIBrainOwnerInterface
// 0x0000 (0x0000 - 0x0000)
class IUtilityAIBrainOwnerInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIBrainOwnerInterface">();
	}
	static class IUtilityAIBrainOwnerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IUtilityAIBrainOwnerInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IUtilityAIBrainOwnerInterface) == 0x000001, "Wrong alignment on IUtilityAIBrainOwnerInterface");
static_assert(sizeof(IUtilityAIBrainOwnerInterface) == 0x000001, "Wrong size on IUtilityAIBrainOwnerInterface");

// Class NubAI.UtilityAIConsideration
// 0x0038 (0x0060 - 0x0028)
class UUtilityAIConsideration : public UObject
{
public:
	struct FUtilityAIResponseCurve                ResponseCurve;                                     // 0x0028(0x0014)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         ScoreClampMin;                                     // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScoreClampMax;                                     // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScoreFactor;                                       // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUtilityAIConsiderationScoringCost            ScoringCost;                                       // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisabled;                                         // 0x0049(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FriendlyName;                                      // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIConsideration">();
	}
	static class UUtilityAIConsideration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIConsideration>();
	}
};
static_assert(alignof(UUtilityAIConsideration) == 0x000008, "Wrong alignment on UUtilityAIConsideration");
static_assert(sizeof(UUtilityAIConsideration) == 0x000060, "Wrong size on UUtilityAIConsideration");
static_assert(offsetof(UUtilityAIConsideration, ResponseCurve) == 0x000028, "Member 'UUtilityAIConsideration::ResponseCurve' has a wrong offset!");
static_assert(offsetof(UUtilityAIConsideration, ScoreClampMin) == 0x00003C, "Member 'UUtilityAIConsideration::ScoreClampMin' has a wrong offset!");
static_assert(offsetof(UUtilityAIConsideration, ScoreClampMax) == 0x000040, "Member 'UUtilityAIConsideration::ScoreClampMax' has a wrong offset!");
static_assert(offsetof(UUtilityAIConsideration, ScoreFactor) == 0x000044, "Member 'UUtilityAIConsideration::ScoreFactor' has a wrong offset!");
static_assert(offsetof(UUtilityAIConsideration, ScoringCost) == 0x000048, "Member 'UUtilityAIConsideration::ScoringCost' has a wrong offset!");
static_assert(offsetof(UUtilityAIConsideration, bDisabled) == 0x000049, "Member 'UUtilityAIConsideration::bDisabled' has a wrong offset!");
static_assert(offsetof(UUtilityAIConsideration, FriendlyName) == 0x000050, "Member 'UUtilityAIConsideration::FriendlyName' has a wrong offset!");

// Class NubAI.UtilityAIConsideration_BlueprintBase
// 0x0000 (0x0060 - 0x0060)
class UUtilityAIConsideration_BlueprintBase final : public UUtilityAIConsideration
{
public:
	float ReceiveCalculateScore(const struct FUtilityAIDecisionContext& Context) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIConsideration_BlueprintBase">();
	}
	static class UUtilityAIConsideration_BlueprintBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIConsideration_BlueprintBase>();
	}
};
static_assert(alignof(UUtilityAIConsideration_BlueprintBase) == 0x000008, "Wrong alignment on UUtilityAIConsideration_BlueprintBase");
static_assert(sizeof(UUtilityAIConsideration_BlueprintBase) == 0x000060, "Wrong size on UUtilityAIConsideration_BlueprintBase");

// Class NubAI.UtilityAIConsideration_FixedScore
// 0x0038 (0x0098 - 0x0060)
class UUtilityAIConsideration_FixedScore final : public UUtilityAIConsideration
{
public:
	struct FAIDataProviderFloatValue              FixedScore;                                        // 0x0060(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIConsideration_FixedScore">();
	}
	static class UUtilityAIConsideration_FixedScore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIConsideration_FixedScore>();
	}
};
static_assert(alignof(UUtilityAIConsideration_FixedScore) == 0x000008, "Wrong alignment on UUtilityAIConsideration_FixedScore");
static_assert(sizeof(UUtilityAIConsideration_FixedScore) == 0x000098, "Wrong size on UUtilityAIConsideration_FixedScore");
static_assert(offsetof(UUtilityAIConsideration_FixedScore, FixedScore) == 0x000060, "Member 'UUtilityAIConsideration_FixedScore::FixedScore' has a wrong offset!");

// Class NubAI.UtilityAIConsideration_DistanceBase
// 0x0070 (0x00D0 - 0x0060)
class UUtilityAIConsideration_DistanceBase : public UUtilityAIConsideration
{
public:
	struct FAIDataProviderFloatValue              DistanceMin;                                       // 0x0060(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              DistanceMax;                                       // 0x0098(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIConsideration_DistanceBase">();
	}
	static class UUtilityAIConsideration_DistanceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIConsideration_DistanceBase>();
	}
};
static_assert(alignof(UUtilityAIConsideration_DistanceBase) == 0x000008, "Wrong alignment on UUtilityAIConsideration_DistanceBase");
static_assert(sizeof(UUtilityAIConsideration_DistanceBase) == 0x0000D0, "Wrong size on UUtilityAIConsideration_DistanceBase");
static_assert(offsetof(UUtilityAIConsideration_DistanceBase, DistanceMin) == 0x000060, "Member 'UUtilityAIConsideration_DistanceBase::DistanceMin' has a wrong offset!");
static_assert(offsetof(UUtilityAIConsideration_DistanceBase, DistanceMax) == 0x000098, "Member 'UUtilityAIConsideration_DistanceBase::DistanceMax' has a wrong offset!");

// Class NubAI.UtilityAIConsideration_DistanceToTarget
// 0x0008 (0x00D8 - 0x00D0)
class UUtilityAIConsideration_DistanceToTarget final : public UUtilityAIConsideration_DistanceBase
{
public:
	EUtilityAIConsiderationtDistanceType          DistanceType;                                      // 0x00D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIConsideration_DistanceToTarget">();
	}
	static class UUtilityAIConsideration_DistanceToTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIConsideration_DistanceToTarget>();
	}
};
static_assert(alignof(UUtilityAIConsideration_DistanceToTarget) == 0x000008, "Wrong alignment on UUtilityAIConsideration_DistanceToTarget");
static_assert(sizeof(UUtilityAIConsideration_DistanceToTarget) == 0x0000D8, "Wrong size on UUtilityAIConsideration_DistanceToTarget");
static_assert(offsetof(UUtilityAIConsideration_DistanceToTarget, DistanceType) == 0x0000D0, "Member 'UUtilityAIConsideration_DistanceToTarget::DistanceType' has a wrong offset!");

// Class NubAI.UtilityAIConsideration_PathDistanceToTarget
// 0x0010 (0x00E0 - 0x00D0)
class UUtilityAIConsideration_PathDistanceToTarget final : public UUtilityAIConsideration_DistanceBase
{
public:
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowPartialPath;                                 // 0x00D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIConsideration_PathDistanceToTarget">();
	}
	static class UUtilityAIConsideration_PathDistanceToTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIConsideration_PathDistanceToTarget>();
	}
};
static_assert(alignof(UUtilityAIConsideration_PathDistanceToTarget) == 0x000008, "Wrong alignment on UUtilityAIConsideration_PathDistanceToTarget");
static_assert(sizeof(UUtilityAIConsideration_PathDistanceToTarget) == 0x0000E0, "Wrong size on UUtilityAIConsideration_PathDistanceToTarget");
static_assert(offsetof(UUtilityAIConsideration_PathDistanceToTarget, FilterClass) == 0x0000D0, "Member 'UUtilityAIConsideration_PathDistanceToTarget::FilterClass' has a wrong offset!");
static_assert(offsetof(UUtilityAIConsideration_PathDistanceToTarget, bAllowPartialPath) == 0x0000D8, "Member 'UUtilityAIConsideration_PathDistanceToTarget::bAllowPartialPath' has a wrong offset!");

// Class NubAI.UtilityAIConsideration_ValueBase
// 0x0080 (0x00E0 - 0x0060)
class UUtilityAIConsideration_ValueBase : public UUtilityAIConsideration
{
public:
	struct FAIDataProviderFloatValue              LeftValue;                                         // 0x0060(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EUtilityAIDataProviderOwnerType               LeftValueProviderOwnerType;                        // 0x0098(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIDataProviderFloatValue              RightValue;                                        // 0x00A0(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EUtilityAIDataProviderOwnerType               RightValueProviderOwnerType;                       // 0x00D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIConsideration_ValueBase">();
	}
	static class UUtilityAIConsideration_ValueBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIConsideration_ValueBase>();
	}
};
static_assert(alignof(UUtilityAIConsideration_ValueBase) == 0x000008, "Wrong alignment on UUtilityAIConsideration_ValueBase");
static_assert(sizeof(UUtilityAIConsideration_ValueBase) == 0x0000E0, "Wrong size on UUtilityAIConsideration_ValueBase");
static_assert(offsetof(UUtilityAIConsideration_ValueBase, LeftValue) == 0x000060, "Member 'UUtilityAIConsideration_ValueBase::LeftValue' has a wrong offset!");
static_assert(offsetof(UUtilityAIConsideration_ValueBase, LeftValueProviderOwnerType) == 0x000098, "Member 'UUtilityAIConsideration_ValueBase::LeftValueProviderOwnerType' has a wrong offset!");
static_assert(offsetof(UUtilityAIConsideration_ValueBase, RightValue) == 0x0000A0, "Member 'UUtilityAIConsideration_ValueBase::RightValue' has a wrong offset!");
static_assert(offsetof(UUtilityAIConsideration_ValueBase, RightValueProviderOwnerType) == 0x0000D8, "Member 'UUtilityAIConsideration_ValueBase::RightValueProviderOwnerType' has a wrong offset!");

// Class NubAI.UtilityAIConsideration_ValueArithmetic
// 0x0008 (0x00E8 - 0x00E0)
class UUtilityAIConsideration_ValueArithmetic final : public UUtilityAIConsideration_ValueBase
{
public:
	EUtilityAIArithmeticOperationType             OperationType;                                     // 0x00E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIConsideration_ValueArithmetic">();
	}
	static class UUtilityAIConsideration_ValueArithmetic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIConsideration_ValueArithmetic>();
	}
};
static_assert(alignof(UUtilityAIConsideration_ValueArithmetic) == 0x000008, "Wrong alignment on UUtilityAIConsideration_ValueArithmetic");
static_assert(sizeof(UUtilityAIConsideration_ValueArithmetic) == 0x0000E8, "Wrong size on UUtilityAIConsideration_ValueArithmetic");
static_assert(offsetof(UUtilityAIConsideration_ValueArithmetic, OperationType) == 0x0000E0, "Member 'UUtilityAIConsideration_ValueArithmetic::OperationType' has a wrong offset!");

// Class NubAI.UtilityAIConsideration_ValueComparison
// 0x0008 (0x00E8 - 0x00E0)
class UUtilityAIConsideration_ValueComparison final : public UUtilityAIConsideration_ValueBase
{
public:
	EUtilityAIValueComparisonType                 ComparisonType;                                    // 0x00E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIConsideration_ValueComparison">();
	}
	static class UUtilityAIConsideration_ValueComparison* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIConsideration_ValueComparison>();
	}
};
static_assert(alignof(UUtilityAIConsideration_ValueComparison) == 0x000008, "Wrong alignment on UUtilityAIConsideration_ValueComparison");
static_assert(sizeof(UUtilityAIConsideration_ValueComparison) == 0x0000E8, "Wrong size on UUtilityAIConsideration_ValueComparison");
static_assert(offsetof(UUtilityAIConsideration_ValueComparison, ComparisonType) == 0x0000E0, "Member 'UUtilityAIConsideration_ValueComparison::ComparisonType' has a wrong offset!");

// Class NubAI.UtilityAIConsideration_CompoundScore
// 0x0018 (0x0078 - 0x0060)
class UUtilityAIConsideration_CompoundScore final : public UUtilityAIConsideration
{
public:
	EUtilityAICompoundScoreOperator               ScoreOperator;                                     // 0x0060(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUtilityAIConsideration*>        Considerations;                                    // 0x0068(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIConsideration_CompoundScore">();
	}
	static class UUtilityAIConsideration_CompoundScore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIConsideration_CompoundScore>();
	}
};
static_assert(alignof(UUtilityAIConsideration_CompoundScore) == 0x000008, "Wrong alignment on UUtilityAIConsideration_CompoundScore");
static_assert(sizeof(UUtilityAIConsideration_CompoundScore) == 0x000078, "Wrong size on UUtilityAIConsideration_CompoundScore");
static_assert(offsetof(UUtilityAIConsideration_CompoundScore, ScoreOperator) == 0x000060, "Member 'UUtilityAIConsideration_CompoundScore::ScoreOperator' has a wrong offset!");
static_assert(offsetof(UUtilityAIConsideration_CompoundScore, Considerations) == 0x000068, "Member 'UUtilityAIConsideration_CompoundScore::Considerations' has a wrong offset!");

// Class NubAI.UtilityAIConsideration_TagBase
// 0x0008 (0x0068 - 0x0060)
class UUtilityAIConsideration_TagBase : public UUtilityAIConsideration
{
public:
	EUtilityAITagsOwnerType                       TagsOwnerType;                                     // 0x0060(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIConsideration_TagBase">();
	}
	static class UUtilityAIConsideration_TagBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIConsideration_TagBase>();
	}
};
static_assert(alignof(UUtilityAIConsideration_TagBase) == 0x000008, "Wrong alignment on UUtilityAIConsideration_TagBase");
static_assert(sizeof(UUtilityAIConsideration_TagBase) == 0x000068, "Wrong size on UUtilityAIConsideration_TagBase");
static_assert(offsetof(UUtilityAIConsideration_TagBase, TagsOwnerType) == 0x000060, "Member 'UUtilityAIConsideration_TagBase::TagsOwnerType' has a wrong offset!");

// Class NubAI.UtilityAIConsideration_MatchTags
// 0x0028 (0x0090 - 0x0068)
class UUtilityAIConsideration_MatchTags final : public UUtilityAIConsideration_TagBase
{
public:
	struct FGameplayTagContainer                  MachedTags;                                        // 0x0068(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	EGameplayContainerMatchType                   MatchType;                                         // 0x0088(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExactMatch;                                       // 0x0089(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8A[0x6];                                       // 0x008A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIConsideration_MatchTags">();
	}
	static class UUtilityAIConsideration_MatchTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIConsideration_MatchTags>();
	}
};
static_assert(alignof(UUtilityAIConsideration_MatchTags) == 0x000008, "Wrong alignment on UUtilityAIConsideration_MatchTags");
static_assert(sizeof(UUtilityAIConsideration_MatchTags) == 0x000090, "Wrong size on UUtilityAIConsideration_MatchTags");
static_assert(offsetof(UUtilityAIConsideration_MatchTags, MachedTags) == 0x000068, "Member 'UUtilityAIConsideration_MatchTags::MachedTags' has a wrong offset!");
static_assert(offsetof(UUtilityAIConsideration_MatchTags, MatchType) == 0x000088, "Member 'UUtilityAIConsideration_MatchTags::MatchType' has a wrong offset!");
static_assert(offsetof(UUtilityAIConsideration_MatchTags, bExactMatch) == 0x000089, "Member 'UUtilityAIConsideration_MatchTags::bExactMatch' has a wrong offset!");

// Class NubAI.UtilityAIConsideration_QueryTags
// 0x0048 (0x00B0 - 0x0068)
class UUtilityAIConsideration_QueryTags final : public UUtilityAIConsideration_TagBase
{
public:
	struct FGameplayTagQuery                      TagQuery;                                          // 0x0068(0x0048)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIConsideration_QueryTags">();
	}
	static class UUtilityAIConsideration_QueryTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIConsideration_QueryTags>();
	}
};
static_assert(alignof(UUtilityAIConsideration_QueryTags) == 0x000008, "Wrong alignment on UUtilityAIConsideration_QueryTags");
static_assert(sizeof(UUtilityAIConsideration_QueryTags) == 0x0000B0, "Wrong size on UUtilityAIConsideration_QueryTags");
static_assert(offsetof(UUtilityAIConsideration_QueryTags, TagQuery) == 0x000068, "Member 'UUtilityAIConsideration_QueryTags::TagQuery' has a wrong offset!");

// Class NubAI.UtilityAIConsideration_ActiveAbility
// 0x0030 (0x0090 - 0x0060)
class UUtilityAIConsideration_ActiveAbility final : public UUtilityAIConsideration
{
public:
	EUtilityAIAbilityOwnerType                    AbilityOwnerType;                                  // 0x0060(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AbilityTags;                                       // 0x0068(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	EGameplayContainerMatchType                   MatchType;                                         // 0x0088(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExactMatch;                                       // 0x0089(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8A[0x6];                                       // 0x008A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIConsideration_ActiveAbility">();
	}
	static class UUtilityAIConsideration_ActiveAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIConsideration_ActiveAbility>();
	}
};
static_assert(alignof(UUtilityAIConsideration_ActiveAbility) == 0x000008, "Wrong alignment on UUtilityAIConsideration_ActiveAbility");
static_assert(sizeof(UUtilityAIConsideration_ActiveAbility) == 0x000090, "Wrong size on UUtilityAIConsideration_ActiveAbility");
static_assert(offsetof(UUtilityAIConsideration_ActiveAbility, AbilityOwnerType) == 0x000060, "Member 'UUtilityAIConsideration_ActiveAbility::AbilityOwnerType' has a wrong offset!");
static_assert(offsetof(UUtilityAIConsideration_ActiveAbility, AbilityTags) == 0x000068, "Member 'UUtilityAIConsideration_ActiveAbility::AbilityTags' has a wrong offset!");
static_assert(offsetof(UUtilityAIConsideration_ActiveAbility, MatchType) == 0x000088, "Member 'UUtilityAIConsideration_ActiveAbility::MatchType' has a wrong offset!");
static_assert(offsetof(UUtilityAIConsideration_ActiveAbility, bExactMatch) == 0x000089, "Member 'UUtilityAIConsideration_ActiveAbility::bExactMatch' has a wrong offset!");

// Class NubAI.UtilityAIConsideration_ExecutingBehavior
// 0x0028 (0x0088 - 0x0060)
class UUtilityAIConsideration_ExecutingBehavior final : public UUtilityAIConsideration
{
public:
	struct FGameplayTagContainer                  BehaviorTags;                                      // 0x0060(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	EGameplayContainerMatchType                   MatchType;                                         // 0x0080(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExactMatch;                                       // 0x0081(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIConsideration_ExecutingBehavior">();
	}
	static class UUtilityAIConsideration_ExecutingBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIConsideration_ExecutingBehavior>();
	}
};
static_assert(alignof(UUtilityAIConsideration_ExecutingBehavior) == 0x000008, "Wrong alignment on UUtilityAIConsideration_ExecutingBehavior");
static_assert(sizeof(UUtilityAIConsideration_ExecutingBehavior) == 0x000088, "Wrong size on UUtilityAIConsideration_ExecutingBehavior");
static_assert(offsetof(UUtilityAIConsideration_ExecutingBehavior, BehaviorTags) == 0x000060, "Member 'UUtilityAIConsideration_ExecutingBehavior::BehaviorTags' has a wrong offset!");
static_assert(offsetof(UUtilityAIConsideration_ExecutingBehavior, MatchType) == 0x000080, "Member 'UUtilityAIConsideration_ExecutingBehavior::MatchType' has a wrong offset!");
static_assert(offsetof(UUtilityAIConsideration_ExecutingBehavior, bExactMatch) == 0x000081, "Member 'UUtilityAIConsideration_ExecutingBehavior::bExactMatch' has a wrong offset!");

// Class NubAI.UtilityAIConsideration_ExecutingThisBehavior
// 0x0008 (0x0068 - 0x0060)
class UUtilityAIConsideration_ExecutingThisBehavior final : public UUtilityAIConsideration
{
public:
	bool                                          bMatchDecisionTarget;                              // 0x0060(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIConsideration_ExecutingThisBehavior">();
	}
	static class UUtilityAIConsideration_ExecutingThisBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIConsideration_ExecutingThisBehavior>();
	}
};
static_assert(alignof(UUtilityAIConsideration_ExecutingThisBehavior) == 0x000008, "Wrong alignment on UUtilityAIConsideration_ExecutingThisBehavior");
static_assert(sizeof(UUtilityAIConsideration_ExecutingThisBehavior) == 0x000068, "Wrong size on UUtilityAIConsideration_ExecutingThisBehavior");
static_assert(offsetof(UUtilityAIConsideration_ExecutingThisBehavior, bMatchDecisionTarget) == 0x000060, "Member 'UUtilityAIConsideration_ExecutingThisBehavior::bMatchDecisionTarget' has a wrong offset!");

// Class NubAI.UtilityAIConsideration_TimeSinceDecision
// 0x0008 (0x0068 - 0x0060)
class UUtilityAIConsideration_TimeSinceDecision final : public UUtilityAIConsideration
{
public:
	struct FGameplayTag                           BehaviorTag;                                       // 0x0060(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIConsideration_TimeSinceDecision">();
	}
	static class UUtilityAIConsideration_TimeSinceDecision* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIConsideration_TimeSinceDecision>();
	}
};
static_assert(alignof(UUtilityAIConsideration_TimeSinceDecision) == 0x000008, "Wrong alignment on UUtilityAIConsideration_TimeSinceDecision");
static_assert(sizeof(UUtilityAIConsideration_TimeSinceDecision) == 0x000068, "Wrong size on UUtilityAIConsideration_TimeSinceDecision");
static_assert(offsetof(UUtilityAIConsideration_TimeSinceDecision, BehaviorTag) == 0x000060, "Member 'UUtilityAIConsideration_TimeSinceDecision::BehaviorTag' has a wrong offset!");

// Class NubAI.UtilityAIConsideration_TimeSinceThisDecision
// 0x0000 (0x0060 - 0x0060)
class UUtilityAIConsideration_TimeSinceThisDecision final : public UUtilityAIConsideration
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIConsideration_TimeSinceThisDecision">();
	}
	static class UUtilityAIConsideration_TimeSinceThisDecision* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIConsideration_TimeSinceThisDecision>();
	}
};
static_assert(alignof(UUtilityAIConsideration_TimeSinceThisDecision) == 0x000008, "Wrong alignment on UUtilityAIConsideration_TimeSinceThisDecision");
static_assert(sizeof(UUtilityAIConsideration_TimeSinceThisDecision) == 0x000060, "Wrong size on UUtilityAIConsideration_TimeSinceThisDecision");

// Class NubAI.UtilityAIConsideration_DecisionRepetitions
// 0x0008 (0x0068 - 0x0060)
class UUtilityAIConsideration_DecisionRepetitions final : public UUtilityAIConsideration
{
public:
	float                                         TimePeriod;                                        // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIConsideration_DecisionRepetitions">();
	}
	static class UUtilityAIConsideration_DecisionRepetitions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIConsideration_DecisionRepetitions>();
	}
};
static_assert(alignof(UUtilityAIConsideration_DecisionRepetitions) == 0x000008, "Wrong alignment on UUtilityAIConsideration_DecisionRepetitions");
static_assert(sizeof(UUtilityAIConsideration_DecisionRepetitions) == 0x000068, "Wrong size on UUtilityAIConsideration_DecisionRepetitions");
static_assert(offsetof(UUtilityAIConsideration_DecisionRepetitions, TimePeriod) == 0x000060, "Member 'UUtilityAIConsideration_DecisionRepetitions::TimePeriod' has a wrong offset!");

// Class NubAI.UtilityAIConsideration_MatchDecisionLastTarget
// 0x0008 (0x0068 - 0x0060)
class UUtilityAIConsideration_MatchDecisionLastTarget final : public UUtilityAIConsideration
{
public:
	struct FGameplayTag                           BehaviorTag;                                       // 0x0060(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIConsideration_MatchDecisionLastTarget">();
	}
	static class UUtilityAIConsideration_MatchDecisionLastTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIConsideration_MatchDecisionLastTarget>();
	}
};
static_assert(alignof(UUtilityAIConsideration_MatchDecisionLastTarget) == 0x000008, "Wrong alignment on UUtilityAIConsideration_MatchDecisionLastTarget");
static_assert(sizeof(UUtilityAIConsideration_MatchDecisionLastTarget) == 0x000068, "Wrong size on UUtilityAIConsideration_MatchDecisionLastTarget");
static_assert(offsetof(UUtilityAIConsideration_MatchDecisionLastTarget, BehaviorTag) == 0x000060, "Member 'UUtilityAIConsideration_MatchDecisionLastTarget::BehaviorTag' has a wrong offset!");

// Class NubAI.UtilityAIConsideration_MatchThisDecisionLastTarget
// 0x0000 (0x0060 - 0x0060)
class UUtilityAIConsideration_MatchThisDecisionLastTarget final : public UUtilityAIConsideration
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIConsideration_MatchThisDecisionLastTarget">();
	}
	static class UUtilityAIConsideration_MatchThisDecisionLastTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIConsideration_MatchThisDecisionLastTarget>();
	}
};
static_assert(alignof(UUtilityAIConsideration_MatchThisDecisionLastTarget) == 0x000008, "Wrong alignment on UUtilityAIConsideration_MatchThisDecisionLastTarget");
static_assert(sizeof(UUtilityAIConsideration_MatchThisDecisionLastTarget) == 0x000060, "Wrong size on UUtilityAIConsideration_MatchThisDecisionLastTarget");

// Class NubAI.UtilityAIConsideration_InfluenceValue
// 0x0018 (0x0078 - 0x0060)
class UUtilityAIConsideration_InfluenceValue final : public UUtilityAIConsideration
{
public:
	class UInfluenceMapQueryPreset*               QueryPreset;                                       // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUtilityAIInfluenceMapQueryOwnerType          QueryOwnerType;                                    // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUtilityAIInfluenceMapQueryType               QueryType;                                         // 0x0069(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A[0x2];                                       // 0x006A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SearchRange;                                       // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InfluenceThreshold;                                // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUtilityAIInfluenceMapQueryLocationType       QueryLocationType;                                 // 0x0074(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIConsideration_InfluenceValue">();
	}
	static class UUtilityAIConsideration_InfluenceValue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIConsideration_InfluenceValue>();
	}
};
static_assert(alignof(UUtilityAIConsideration_InfluenceValue) == 0x000008, "Wrong alignment on UUtilityAIConsideration_InfluenceValue");
static_assert(sizeof(UUtilityAIConsideration_InfluenceValue) == 0x000078, "Wrong size on UUtilityAIConsideration_InfluenceValue");
static_assert(offsetof(UUtilityAIConsideration_InfluenceValue, QueryPreset) == 0x000060, "Member 'UUtilityAIConsideration_InfluenceValue::QueryPreset' has a wrong offset!");
static_assert(offsetof(UUtilityAIConsideration_InfluenceValue, QueryOwnerType) == 0x000068, "Member 'UUtilityAIConsideration_InfluenceValue::QueryOwnerType' has a wrong offset!");
static_assert(offsetof(UUtilityAIConsideration_InfluenceValue, QueryType) == 0x000069, "Member 'UUtilityAIConsideration_InfluenceValue::QueryType' has a wrong offset!");
static_assert(offsetof(UUtilityAIConsideration_InfluenceValue, SearchRange) == 0x00006C, "Member 'UUtilityAIConsideration_InfluenceValue::SearchRange' has a wrong offset!");
static_assert(offsetof(UUtilityAIConsideration_InfluenceValue, InfluenceThreshold) == 0x000070, "Member 'UUtilityAIConsideration_InfluenceValue::InfluenceThreshold' has a wrong offset!");
static_assert(offsetof(UUtilityAIConsideration_InfluenceValue, QueryLocationType) == 0x000074, "Member 'UUtilityAIConsideration_InfluenceValue::QueryLocationType' has a wrong offset!");

// Class NubAI.UtilityAIConsideration_Test
// 0x0008 (0x0068 - 0x0060)
class UUtilityAIConsideration_Test final : public UUtilityAIConsideration
{
public:
	float                                         TestValue;                                         // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIConsideration_Test">();
	}
	static class UUtilityAIConsideration_Test* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIConsideration_Test>();
	}
};
static_assert(alignof(UUtilityAIConsideration_Test) == 0x000008, "Wrong alignment on UUtilityAIConsideration_Test");
static_assert(sizeof(UUtilityAIConsideration_Test) == 0x000068, "Wrong size on UUtilityAIConsideration_Test");
static_assert(offsetof(UUtilityAIConsideration_Test, TestValue) == 0x000060, "Member 'UUtilityAIConsideration_Test::TestValue' has a wrong offset!");

// Class NubAI.UtilityAIController
// 0x0000 (0x03B8 - 0x03B8)
class AUtilityAIController final : public AAIController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIController">();
	}
	static class AUtilityAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUtilityAIController>();
	}
};
static_assert(alignof(AUtilityAIController) == 0x000008, "Wrong alignment on AUtilityAIController");
static_assert(sizeof(AUtilityAIController) == 0x0003B8, "Wrong size on AUtilityAIController");

// Class NubAI.UtilityAIDecisionGroup
// 0x0000 (0x0028 - 0x0028)
class UUtilityAIDecisionGroup : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIDecisionGroup">();
	}
	static class UUtilityAIDecisionGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIDecisionGroup>();
	}
};
static_assert(alignof(UUtilityAIDecisionGroup) == 0x000008, "Wrong alignment on UUtilityAIDecisionGroup");
static_assert(sizeof(UUtilityAIDecisionGroup) == 0x000028, "Wrong size on UUtilityAIDecisionGroup");

// Class NubAI.UtilityAIDecisionGroup_Default
// 0x0000 (0x0028 - 0x0028)
class UUtilityAIDecisionGroup_Default final : public UUtilityAIDecisionGroup
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIDecisionGroup_Default">();
	}
	static class UUtilityAIDecisionGroup_Default* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIDecisionGroup_Default>();
	}
};
static_assert(alignof(UUtilityAIDecisionGroup_Default) == 0x000008, "Wrong alignment on UUtilityAIDecisionGroup_Default");
static_assert(sizeof(UUtilityAIDecisionGroup_Default) == 0x000028, "Wrong size on UUtilityAIDecisionGroup_Default");

// Class NubAI.UtilityAIDecisionScoreEvaluatorAsset
// 0x0010 (0x0040 - 0x0030)
class UUtilityAIDecisionScoreEvaluatorAsset final : public UDataAsset
{
public:
	struct FUtilityAIDecisionScoreEvaluator       ScoreEvaluator;                                    // 0x0030(0x0010)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIDecisionScoreEvaluatorAsset">();
	}
	static class UUtilityAIDecisionScoreEvaluatorAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIDecisionScoreEvaluatorAsset>();
	}
};
static_assert(alignof(UUtilityAIDecisionScoreEvaluatorAsset) == 0x000008, "Wrong alignment on UUtilityAIDecisionScoreEvaluatorAsset");
static_assert(sizeof(UUtilityAIDecisionScoreEvaluatorAsset) == 0x000040, "Wrong size on UUtilityAIDecisionScoreEvaluatorAsset");
static_assert(offsetof(UUtilityAIDecisionScoreEvaluatorAsset, ScoreEvaluator) == 0x000030, "Member 'UUtilityAIDecisionScoreEvaluatorAsset::ScoreEvaluator' has a wrong offset!");

// Class NubAI.UtilityAIFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UUtilityAIFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAIFunctionLibrary">();
	}
	static class UUtilityAIFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAIFunctionLibrary>();
	}
};
static_assert(alignof(UUtilityAIFunctionLibrary) == 0x000008, "Wrong alignment on UUtilityAIFunctionLibrary");
static_assert(sizeof(UUtilityAIFunctionLibrary) == 0x000028, "Wrong size on UUtilityAIFunctionLibrary");

// Class NubAI.UtilityAISubsystem
// 0x0120 (0x0160 - 0x0040)
class UUtilityAISubsystem final : public UTickableWorldSubsystem
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUtilityAIBrain*>                RegisteredBrains;                                  // 0x0048(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class UObject*, struct FUtilityAIBrainArray> OwnerBrainMap;                                 // 0x0058(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class UUtilityAIBrain*, float>           ScheduledBrainThink;                               // 0x00A8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UUtilityAIBrain*>                ThinkingBrains;                                    // 0x00F8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TSet<class UUtilityAIBrain*>                  ActingBrains;                                      // 0x0108(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	class UAISystem*                              AISystem;                                          // 0x0158(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAISubsystem">();
	}
	static class UUtilityAISubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAISubsystem>();
	}
};
static_assert(alignof(UUtilityAISubsystem) == 0x000008, "Wrong alignment on UUtilityAISubsystem");
static_assert(sizeof(UUtilityAISubsystem) == 0x000160, "Wrong size on UUtilityAISubsystem");
static_assert(offsetof(UUtilityAISubsystem, RegisteredBrains) == 0x000048, "Member 'UUtilityAISubsystem::RegisteredBrains' has a wrong offset!");
static_assert(offsetof(UUtilityAISubsystem, OwnerBrainMap) == 0x000058, "Member 'UUtilityAISubsystem::OwnerBrainMap' has a wrong offset!");
static_assert(offsetof(UUtilityAISubsystem, ScheduledBrainThink) == 0x0000A8, "Member 'UUtilityAISubsystem::ScheduledBrainThink' has a wrong offset!");
static_assert(offsetof(UUtilityAISubsystem, ThinkingBrains) == 0x0000F8, "Member 'UUtilityAISubsystem::ThinkingBrains' has a wrong offset!");
static_assert(offsetof(UUtilityAISubsystem, ActingBrains) == 0x000108, "Member 'UUtilityAISubsystem::ActingBrains' has a wrong offset!");
static_assert(offsetof(UUtilityAISubsystem, AISystem) == 0x000158, "Member 'UUtilityAISubsystem::AISystem' has a wrong offset!");

// Class NubAI.UtilityAITargetFilter
// 0x0000 (0x0028 - 0x0028)
class UUtilityAITargetFilter : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAITargetFilter">();
	}
	static class UUtilityAITargetFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAITargetFilter>();
	}
};
static_assert(alignof(UUtilityAITargetFilter) == 0x000008, "Wrong alignment on UUtilityAITargetFilter");
static_assert(sizeof(UUtilityAITargetFilter) == 0x000028, "Wrong size on UUtilityAITargetFilter");

// Class NubAI.UtilityAITargetGenerator
// 0x0000 (0x0028 - 0x0028)
class UUtilityAITargetGenerator : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilityAITargetGenerator">();
	}
	static class UUtilityAITargetGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilityAITargetGenerator>();
	}
};
static_assert(alignof(UUtilityAITargetGenerator) == 0x000008, "Wrong alignment on UUtilityAITargetGenerator");
static_assert(sizeof(UUtilityAITargetGenerator) == 0x000028, "Wrong size on UUtilityAITargetGenerator");

}

