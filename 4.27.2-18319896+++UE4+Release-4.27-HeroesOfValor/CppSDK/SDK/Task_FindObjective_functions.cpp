#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Task_FindObjective

#include "Basic.hpp"

#include "Task_FindObjective_classes.hpp"
#include "Task_FindObjective_parameters.hpp"


namespace SDK
{

// Function Task_FindObjective.Task_FindObjective_C.ExecuteUbergraph_Task_FindObjective
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UTask_FindObjective_C::ExecuteUbergraph_Task_FindObjective(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Task_FindObjective_C", "ExecuteUbergraph_Task_FindObjective");

	Params::Task_FindObjective_C_ExecuteUbergraph_Task_FindObjective Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Task_FindObjective.Task_FindObjective_C.ReceiveTickAI
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AAIController*                    OwnerController                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class APawn*                            ControlledPawn                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UTask_FindObjective_C::ReceiveTickAI(class AAIController* OwnerController, class APawn* ControlledPawn, float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Task_FindObjective_C", "ReceiveTickAI");

	Params::Task_FindObjective_C_ReceiveTickAI Parms{};

	Parms.OwnerController = OwnerController;
	Parms.ControlledPawn = ControlledPawn;
	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Task_FindObjective.Task_FindObjective_C.GetClosestObjective
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ControlledPawn                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_ObjectiveBase_C**             ClosestObjective                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UTask_FindObjective_C::GetClosestObjective(class AActor* ControlledPawn, class ABP_ObjectiveBase_C** ClosestObjective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Task_FindObjective_C", "GetClosestObjective");

	Params::Task_FindObjective_C_GetClosestObjective Parms{};

	Parms.ControlledPawn = ControlledPawn;

	UObject::ProcessEvent(Func, &Parms);

	if (ClosestObjective != nullptr)
		*ClosestObjective = Parms.ClosestObjective;
}


// Function Task_FindObjective.Task_FindObjective_C.GetRandomObjective
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APawn*                            ControlledPawn                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_ObjectiveBase_C**             Objective                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UTask_FindObjective_C::GetRandomObjective(class APawn* ControlledPawn, class ABP_ObjectiveBase_C** Objective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Task_FindObjective_C", "GetRandomObjective");

	Params::Task_FindObjective_C_GetRandomObjective Parms{};

	Parms.ControlledPawn = ControlledPawn;

	UObject::ProcessEvent(Func, &Parms);

	if (Objective != nullptr)
		*Objective = Parms.Objective;
}


// Function Task_FindObjective.Task_FindObjective_C.IsCurrentObjectiveWon?
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           PawnActor                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   ObjectiveWon                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UTask_FindObjective_C::IsCurrentObjectiveWon_(class AActor* PawnActor, bool* ObjectiveWon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Task_FindObjective_C", "IsCurrentObjectiveWon?");

	Params::Task_FindObjective_C_IsCurrentObjectiveWon_ Parms{};

	Parms.PawnActor = PawnActor;

	UObject::ProcessEvent(Func, &Parms);

	if (ObjectiveWon != nullptr)
		*ObjectiveWon = Parms.ObjectiveWon;
}


// Function Task_FindObjective.Task_FindObjective_C.GetDefendChance
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class APawn*                            ControlledPawn                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Defend                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// E_AITeamPlayStyles*                     PlayStyle                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UTask_FindObjective_C::GetDefendChance(class APawn* ControlledPawn, bool* Defend, E_AITeamPlayStyles* PlayStyle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Task_FindObjective_C", "GetDefendChance");

	Params::Task_FindObjective_C_GetDefendChance Parms{};

	Parms.ControlledPawn = ControlledPawn;

	UObject::ProcessEvent(Func, &Parms);

	if (Defend != nullptr)
		*Defend = Parms.Defend;

	if (PlayStyle != nullptr)
		*PlayStyle = Parms.PlayStyle;
}


// Function Task_FindObjective.Task_FindObjective_C.GetTeamSupremacy
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_Teams                                 Team                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Supremacy                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UTask_FindObjective_C::GetTeamSupremacy(E_Teams Team, bool* Supremacy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Task_FindObjective_C", "GetTeamSupremacy");

	Params::Task_FindObjective_C_GetTeamSupremacy Parms{};

	Parms.Team = Team;

	UObject::ProcessEvent(Func, &Parms);

	if (Supremacy != nullptr)
		*Supremacy = Parms.Supremacy;
}


// Function Task_FindObjective.Task_FindObjective_C.DoWeHaveAnObjective?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           Pawn                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   ValidObjective                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UTask_FindObjective_C::DoWeHaveAnObjective_(class AActor* Pawn, bool* ValidObjective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Task_FindObjective_C", "DoWeHaveAnObjective?");

	Params::Task_FindObjective_C_DoWeHaveAnObjective_ Parms{};

	Parms.Pawn = Pawn;

	UObject::ProcessEvent(Func, &Parms);

	if (ValidObjective != nullptr)
		*ValidObjective = Parms.ValidObjective;
}


// Function Task_FindObjective.Task_FindObjective_C.IsObjectiveStillRelevant?
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APawn*                            Pawn                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   StillRelevant                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UTask_FindObjective_C::IsObjectiveStillRelevant_(class APawn* Pawn, bool* StillRelevant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Task_FindObjective_C", "IsObjectiveStillRelevant?");

	Params::Task_FindObjective_C_IsObjectiveStillRelevant_ Parms{};

	Parms.Pawn = Pawn;

	UObject::ProcessEvent(Func, &Parms);

	if (StillRelevant != nullptr)
		*StillRelevant = Parms.StillRelevant;
}

}

