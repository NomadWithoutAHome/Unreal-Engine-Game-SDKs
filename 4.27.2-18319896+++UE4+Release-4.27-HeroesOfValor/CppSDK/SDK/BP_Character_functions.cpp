#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_Character

#include "Basic.hpp"

#include "BP_Character_classes.hpp"
#include "BP_Character_parameters.hpp"


namespace SDK
{

// Function BP_Character.BP_Character_C.ExecuteUbergraph_BP_Character
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::ExecuteUbergraph_BP_Character(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ExecuteUbergraph_BP_Character");

	Params::BP_Character_C_ExecuteUbergraph_BP_Character Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.SetVehicleState
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::SetVehicleState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SetVehicleState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.ApplyDamage
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   DamageAmount                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   DamageHitLocation                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   DamageDirection                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class APawn*                            AttackerPawn                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UClass*                           Debuff                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_DamageTypes                           DamageType                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   PlayerIndex                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsCriticalHit                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    IgnoreTeamProtection                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const class FText&                      SpecialKillMessage                                     (BlueprintVisible, BlueprintReadOnly, Parm)
// bool                                    ShouldBreakInvisibility                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    IsPiercingDamage                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::ApplyDamage(int32 DamageAmount, const struct FVector& DamageHitLocation, const struct FVector& DamageDirection, class APawn* AttackerPawn, class UClass* Debuff, E_DamageTypes DamageType, int32 PlayerIndex, bool IsCriticalHit, bool IgnoreTeamProtection, const class FText& SpecialKillMessage, bool ShouldBreakInvisibility, bool IsPiercingDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ApplyDamage");

	Params::BP_Character_C_ApplyDamage Parms{};

	Parms.DamageAmount = DamageAmount;
	Parms.DamageHitLocation = std::move(DamageHitLocation);
	Parms.DamageDirection = std::move(DamageDirection);
	Parms.AttackerPawn = AttackerPawn;
	Parms.Debuff = Debuff;
	Parms.DamageType = DamageType;
	Parms.PlayerIndex = PlayerIndex;
	Parms.IsCriticalHit = IsCriticalHit;
	Parms.IgnoreTeamProtection = IgnoreTeamProtection;
	Parms.SpecialKillMessage = std::move(SpecialKillMessage);
	Parms.ShouldBreakInvisibility = ShouldBreakInvisibility;
	Parms.IsPiercingDamage = IsPiercingDamage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.MC_AddDeathImpulse
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   DamageDirection                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   DamageAmount                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::MC_AddDeathImpulse(const struct FVector& DamageDirection, int32 DamageAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MC_AddDeathImpulse");

	Params::BP_Character_C_MC_AddDeathImpulse Parms{};

	Parms.DamageDirection = std::move(DamageDirection);
	Parms.DamageAmount = DamageAmount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.OC_Hit
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   DamageAmount                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   AttackerLocation                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::OC_Hit(int32 DamageAmount, const struct FVector& AttackerLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OC_Hit");

	Params::BP_Character_C_OC_Hit Parms{};

	Parms.DamageAmount = DamageAmount;
	Parms.AttackerLocation = std::move(AttackerLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.MC_HealEffect
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::MC_HealEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MC_HealEffect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.KillCharacter
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class APawn*                            AttackerPawn                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::KillCharacter(class APawn* AttackerPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "KillCharacter");

	Params::BP_Character_C_KillCharacter Parms{};

	Parms.AttackerPawn = AttackerPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.S_ActivateSkill
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UClass*                           Skill                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_SkillSlots                            SkillSlot                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::S_ActivateSkill(class UClass* Skill, E_SkillSlots SkillSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_ActivateSkill");

	Params::BP_Character_C_S_ActivateSkill Parms{};

	Parms.Skill = Skill;
	Parms.SkillSlot = SkillSlot;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.AI_UseSkill1
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::AI_UseSkill1()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AI_UseSkill1");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.AI_UseSkill2
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::AI_UseSkill2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AI_UseSkill2");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.S_BreakInvisibility
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::S_BreakInvisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_BreakInvisibility");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.S_SetActiveEquipable
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Equipable                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReloadPreviousWeapon                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    RemoveTempThrowable                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::S_SetActiveEquipable(int32 Equipable, bool ReloadPreviousWeapon, bool RemoveTempThrowable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_SetActiveEquipable");

	Params::BP_Character_C_S_SetActiveEquipable Parms{};

	Parms.Equipable = Equipable;
	Parms.ReloadPreviousWeapon = ReloadPreviousWeapon;
	Parms.RemoveTempThrowable = RemoveTempThrowable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.MC_Swap
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   EquipableWeAreSwappingTo                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::MC_Swap(int32 EquipableWeAreSwappingTo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MC_Swap");

	Params::BP_Character_C_MC_Swap Parms{};

	Parms.EquipableWeAreSwappingTo = EquipableWeAreSwappingTo;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.StopUsingEquipable
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::StopUsingEquipable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "StopUsingEquipable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Swap(Local)
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Equipable_We_Are_Swapping_To_0                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Delay                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::Swap_Local_(int32 Equipable_We_Are_Swapping_To_0, float Delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Swap(Local)");

	Params::BP_Character_C_Swap_Local_ Parms{};

	Parms.Equipable_We_Are_Swapping_To_0 = Equipable_We_Are_Swapping_To_0;
	Parms.Delay = Delay;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.ForceEndAllCurrentSkills
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::ForceEndAllCurrentSkills()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ForceEndAllCurrentSkills");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.S_Aiming
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Aiming                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::S_Aiming(bool Aiming)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_Aiming");

	Params::BP_Character_C_S_Aiming Parms{};

	Parms.Aiming = Aiming;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.S_EquipTempThrowable
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UClass*                           ThrowableClas                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::S_EquipTempThrowable(class UClass* ThrowableClas)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_EquipTempThrowable");

	Params::BP_Character_C_S_EquipTempThrowable Parms{};

	Parms.ThrowableClas = ThrowableClas;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.S_RemoveTempThrowable
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::S_RemoveTempThrowable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_RemoveTempThrowable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.UseTempThrowable
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::UseTempThrowable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "UseTempThrowable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.S_TempHideEquipables
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Duration                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::S_TempHideEquipables(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_TempHideEquipables");

	Params::BP_Character_C_S_TempHideEquipables Parms{};

	Parms.Duration = Duration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.TempHideEquipables(Local)
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Duration                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::TempHideEquipables_Local_(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "TempHideEquipables(Local)");

	Params::BP_Character_C_TempHideEquipables_Local_ Parms{};

	Parms.Duration = Duration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.SetInitialWeapon
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::SetInitialWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SetInitialWeapon");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.OC_SwapToPreferedEquipable
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Delay                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::OC_SwapToPreferedEquipable(float Delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OC_SwapToPreferedEquipable");

	Params::BP_Character_C_OC_SwapToPreferedEquipable Parms{};

	Parms.Delay = Delay;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.QueueRequestedSwap
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::QueueRequestedSwap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "QueueRequestedSwap");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.AddFullBodyAnimationTakeOverTime
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Duration                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::AddFullBodyAnimationTakeOverTime(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AddFullBodyAnimationTakeOverTime");

	Params::BP_Character_C_AddFullBodyAnimationTakeOverTime Parms{};

	Parms.Duration = Duration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.AI_UseEquipable
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::AI_UseEquipable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AI_UseEquipable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.AI_StopUseEquipable
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::AI_StopUseEquipable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AI_StopUseEquipable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.S_HasFiredAWeapon
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::S_HasFiredAWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_HasFiredAWeapon");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.InpAxisEvt_Turn_K2Node_InputAxisEvent_47
// (BlueprintEvent)
// Parameters:
// float                                   AxisValue                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::InpAxisEvt_Turn_K2Node_InputAxisEvent_47(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "InpAxisEvt_Turn_K2Node_InputAxisEvent_47");

	Params::BP_Character_C_InpAxisEvt_Turn_K2Node_InputAxisEvent_47 Parms{};

	Parms.AxisValue = AxisValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.CheckSprint
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::CheckSprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "CheckSprint");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Server_SetSprinting
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bRunning                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::Server_SetSprinting(bool bRunning)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Server_SetSprinting");

	Params::BP_Character_C_Server_SetSprinting Parms{};

	Parms.bRunning = bRunning;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.ResetJump
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::ResetJump()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ResetJump");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.MC_JumpSound
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::MC_JumpSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MC_JumpSound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.S_JumpSound
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::S_JumpSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_JumpSound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.S_OpenParachute
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::S_OpenParachute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_OpenParachute");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.S_CloseParachute
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::S_CloseParachute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_CloseParachute");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.DeployParachute
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::DeployParachute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "DeployParachute");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.StowParachute
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::StowParachute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "StowParachute");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.BlockSprint
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Duration                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::BlockSprint(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "BlockSprint");

	Params::BP_Character_C_BlockSprint Parms{};

	Parms.Duration = Duration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.OnLanded
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FHitResult&                Hit                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_Character_C::OnLanded(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnLanded");

	Params::BP_Character_C_OnLanded Parms{};

	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.FallDamage
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::FallDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "FallDamage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.InpAxisEvt_Move Forward_K2Node_InputAxisEvent_0
// (BlueprintEvent)
// Parameters:
// float                                   AxisValue                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::InpAxisEvt_Move_Forward_K2Node_InputAxisEvent_0(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "InpAxisEvt_Move Forward_K2Node_InputAxisEvent_0");

	Params::BP_Character_C_InpAxisEvt_Move_Forward_K2Node_InputAxisEvent_0 Parms{};

	Parms.AxisValue = AxisValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.InpAxisEvt_Move Backward_K2Node_InputAxisEvent_1
// (BlueprintEvent)
// Parameters:
// float                                   AxisValue                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::InpAxisEvt_Move_Backward_K2Node_InputAxisEvent_1(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "InpAxisEvt_Move Backward_K2Node_InputAxisEvent_1");

	Params::BP_Character_C_InpAxisEvt_Move_Backward_K2Node_InputAxisEvent_1 Parms{};

	Parms.AxisValue = AxisValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.InpAxisEvt_Move Left_K2Node_InputAxisEvent_2
// (BlueprintEvent)
// Parameters:
// float                                   AxisValue                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::InpAxisEvt_Move_Left_K2Node_InputAxisEvent_2(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "InpAxisEvt_Move Left_K2Node_InputAxisEvent_2");

	Params::BP_Character_C_InpAxisEvt_Move_Left_K2Node_InputAxisEvent_2 Parms{};

	Parms.AxisValue = AxisValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.InpAxisEvt_Move Right_K2Node_InputAxisEvent_3
// (BlueprintEvent)
// Parameters:
// float                                   AxisValue                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::InpAxisEvt_Move_Right_K2Node_InputAxisEvent_3(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "InpAxisEvt_Move Right_K2Node_InputAxisEvent_3");

	Params::BP_Character_C_InpAxisEvt_Move_Right_K2Node_InputAxisEvent_3 Parms{};

	Parms.AxisValue = AxisValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.InpAxisEvt_LookUpDown_K2Node_InputAxisEvent_4
// (BlueprintEvent)
// Parameters:
// float                                   AxisValue                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::InpAxisEvt_LookUpDown_K2Node_InputAxisEvent_4(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "InpAxisEvt_LookUpDown_K2Node_InputAxisEvent_4");

	Params::BP_Character_C_InpAxisEvt_LookUpDown_K2Node_InputAxisEvent_4 Parms{};

	Parms.AxisValue = AxisValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.S_Crouching
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Crouching_0                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::S_Crouching(bool Crouching_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_Crouching");

	Params::BP_Character_C_S_Crouching Parms{};

	Parms.Crouching_0 = Crouching_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.S_VehicleDucking
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    VehicleDucking_0                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::S_VehicleDucking(bool VehicleDucking_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_VehicleDucking");

	Params::BP_Character_C_S_VehicleDucking Parms{};

	Parms.VehicleDucking_0 = VehicleDucking_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.InpAxisEvt_Sprint_K2Node_InputAxisEvent_5
// (BlueprintEvent)
// Parameters:
// float                                   AxisValue                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::InpAxisEvt_Sprint_K2Node_InputAxisEvent_5(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "InpAxisEvt_Sprint_K2Node_InputAxisEvent_5");

	Params::BP_Character_C_InpAxisEvt_Sprint_K2Node_InputAxisEvent_5 Parms{};

	Parms.AxisValue = AxisValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.TeamChanged
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::TeamChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "TeamChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.MC_SetAISprint
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Sprint                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::MC_SetAISprint(bool Sprint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MC_SetAISprint");

	Params::BP_Character_C_MC_SetAISprint Parms{};

	Parms.Sprint = Sprint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.AI_ChangeWeapon
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Slot                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::AI_ChangeWeapon(int32 Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AI_ChangeWeapon");

	Params::BP_Character_C_AI_ChangeWeapon Parms{};

	Parms.Slot = Slot;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.AI_EnterFallState
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::AI_EnterFallState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AI_EnterFallState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.SwapToRegularWeapon
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::SwapToRegularWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SwapToRegularWeapon");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.AI_StopWeaponUse
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::AI_StopWeaponUse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AI_StopWeaponUse");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.S_SentCharData
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FST_CharacterData&         CharData                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::S_SentCharData(const struct FST_CharacterData& CharData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_SentCharData");

	Params::BP_Character_C_S_SentCharData Parms{};

	Parms.CharData = std::move(CharData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.S_SetUserName
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    UserName_0                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void ABP_Character_C::S_SetUserName(const class FString& UserName_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_SetUserName");

	Params::BP_Character_C_S_SetUserName Parms{};

	Parms.UserName_0 = std::move(UserName_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.S_ShareCameraRotation
// (Net, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FRotator&                  Rotation                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::S_ShareCameraRotation(const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_ShareCameraRotation");

	Params::BP_Character_C_S_ShareCameraRotation Parms{};

	Parms.Rotation = std::move(Rotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.MC_ShareCameraRotation
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FRotator&                  Rotation                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::MC_ShareCameraRotation(const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MC_ShareCameraRotation");

	Params::BP_Character_C_MC_ShareCameraRotation Parms{};

	Parms.Rotation = std::move(Rotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.S_UsingEquipable
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::S_UsingEquipable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_UsingEquipable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.SetUsingEquipable
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Using                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::SetUsingEquipable(bool Using)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SetUsingEquipable");

	Params::BP_Character_C_SetUsingEquipable Parms{};

	Parms.Using = Using;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.MC_UsingEquipable
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::MC_UsingEquipable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MC_UsingEquipable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.S_SetCharacterCustomization
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FST_CharacterCustomization&CharacterCustomization_0                               (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::S_SetCharacterCustomization(const struct FST_CharacterCustomization& CharacterCustomization_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_SetCharacterCustomization");

	Params::BP_Character_C_S_SetCharacterCustomization Parms{};

	Parms.CharacterCustomization_0 = std::move(CharacterCustomization_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.S_SetPlayerRank
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   PlayerRank                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   PlayerIndex                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::S_SetPlayerRank(int32 PlayerRank, int32 PlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_SetPlayerRank");

	Params::BP_Character_C_S_SetPlayerRank Parms{};

	Parms.PlayerRank = PlayerRank;
	Parms.PlayerIndex = PlayerIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.MC_ShareAdvancedCameraState
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   FOV                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   CameraBoomRelLocation                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::MC_ShareAdvancedCameraState(int32 FOV, const struct FVector& CameraBoomRelLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MC_ShareAdvancedCameraState");

	Params::BP_Character_C_MC_ShareAdvancedCameraState Parms{};

	Parms.FOV = FOV;
	Parms.CameraBoomRelLocation = std::move(CameraBoomRelLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.S_ShareAdvancedCameraState
// (Net, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   FOV                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   CameraBoomRelLocation                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::S_ShareAdvancedCameraState(int32 FOV, const struct FVector& CameraBoomRelLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_ShareAdvancedCameraState");

	Params::BP_Character_C_S_ShareAdvancedCameraState Parms{};

	Parms.FOV = FOV;
	Parms.CameraBoomRelLocation = std::move(CameraBoomRelLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.RegisterSpectator
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const int32&                            Index_0                                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::RegisterSpectator(const int32& Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "RegisterSpectator");

	Params::BP_Character_C_RegisterSpectator Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.S_SetRecentlyTeleported
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::S_SetRecentlyTeleported()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_SetRecentlyTeleported");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.S_SetPing
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APlayerState*                     PlayerState_0                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::S_SetPing(class APlayerState* PlayerState_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_SetPing");

	Params::BP_Character_C_S_SetPing Parms{};

	Parms.PlayerState_0 = PlayerState_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.S_SetGodMode
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enabled                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::S_SetGodMode(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_SetGodMode");

	Params::BP_Character_C_S_SetGodMode Parms{};

	Parms.Enabled = Enabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.S_SetInvisibility
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enabled                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::S_SetInvisibility(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_SetInvisibility");

	Params::BP_Character_C_S_SetInvisibility Parms{};

	Parms.Enabled = Enabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.S_SetNoClip
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enabled                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::S_SetNoClip(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_SetNoClip");

	Params::BP_Character_C_S_SetNoClip Parms{};

	Parms.Enabled = Enabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.S_RestoreHealthOfOtherPlayer
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_Character_C*                  OtherCharacter                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   HealAmount                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    HealEffect                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class APawn*                            PawnThatAppliedTheHeal                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    CleanseDebuffs                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   ScoreMultiplier                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::S_RestoreHealthOfOtherPlayer(class ABP_Character_C* OtherCharacter, int32 HealAmount, bool HealEffect, class APawn* PawnThatAppliedTheHeal, bool CleanseDebuffs, float ScoreMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_RestoreHealthOfOtherPlayer");

	Params::BP_Character_C_S_RestoreHealthOfOtherPlayer Parms{};

	Parms.OtherCharacter = OtherCharacter;
	Parms.HealAmount = HealAmount;
	Parms.HealEffect = HealEffect;
	Parms.PawnThatAppliedTheHeal = PawnThatAppliedTheHeal;
	Parms.CleanseDebuffs = CleanseDebuffs;
	Parms.ScoreMultiplier = ScoreMultiplier;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.S_RestoreHealth
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    HealEffect                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class APawn*                            PawnThatAppliedTheHP                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    CleanseDebuffs                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   ScoreMultiplier                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::S_RestoreHealth(int32 Amount, bool HealEffect, class APawn* PawnThatAppliedTheHP, bool CleanseDebuffs, float ScoreMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_RestoreHealth");

	Params::BP_Character_C_S_RestoreHealth Parms{};

	Parms.Amount = Amount;
	Parms.HealEffect = HealEffect;
	Parms.PawnThatAppliedTheHP = PawnThatAppliedTheHP;
	Parms.CleanseDebuffs = CleanseDebuffs;
	Parms.ScoreMultiplier = ScoreMultiplier;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.S_EndCurrentSkill
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_SkillBase_C*                  Skill                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::S_EndCurrentSkill(class ABP_SkillBase_C* Skill)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_EndCurrentSkill");

	Params::BP_Character_C_S_EndCurrentSkill Parms{};

	Parms.Skill = Skill;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.BndEvt__BP_Character_PawnSensing_K2Node_ComponentBoundEvent_1_SeePawnDelegate__DelegateSignature
// (BlueprintEvent)
// Parameters:
// class APawn*                            Pawn                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::BndEvt__BP_Character_PawnSensing_K2Node_ComponentBoundEvent_1_SeePawnDelegate__DelegateSignature(class APawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "BndEvt__BP_Character_PawnSensing_K2Node_ComponentBoundEvent_1_SeePawnDelegate__DelegateSignature");

	Params::BP_Character_C_BndEvt__BP_Character_PawnSensing_K2Node_ComponentBoundEvent_1_SeePawnDelegate__DelegateSignature Parms{};

	Parms.Pawn = Pawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.ApplyPostDeathRagdoll
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Velocity                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::ApplyPostDeathRagdoll(const struct FVector& Velocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ApplyPostDeathRagdoll");

	Params::BP_Character_C_ApplyPostDeathRagdoll Parms{};

	Parms.Velocity = std::move(Velocity);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.TeleportCharacter
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   TeleportLocation_0                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::TeleportCharacter(const struct FVector& TeleportLocation_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "TeleportCharacter");

	Params::BP_Character_C_TeleportCharacter Parms{};

	Parms.TeleportLocation_0 = std::move(TeleportLocation_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.MC_PlayEmote
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimMontage*                     EmoteMontage                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   EmoteDuration                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::MC_PlayEmote(class UAnimMontage* EmoteMontage, float EmoteDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MC_PlayEmote");

	Params::BP_Character_C_MC_PlayEmote Parms{};

	Parms.EmoteMontage = EmoteMontage;
	Parms.EmoteDuration = EmoteDuration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.PlayEmote
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimMontage*                     EmoteMontage                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   EmoteDuration                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::PlayEmote(class UAnimMontage* EmoteMontage, float EmoteDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "PlayEmote");

	Params::BP_Character_C_PlayEmote Parms{};

	Parms.EmoteMontage = EmoteMontage;
	Parms.EmoteDuration = EmoteDuration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.ApplyRecoil
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   RecoilAmount                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    AddSideWaysRecoil                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    RandomRecoil                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::ApplyRecoil(float RecoilAmount, bool AddSideWaysRecoil, bool RandomRecoil)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ApplyRecoil");

	Params::BP_Character_C_ApplyRecoil Parms{};

	Parms.RecoilAmount = RecoilAmount;
	Parms.AddSideWaysRecoil = AddSideWaysRecoil;
	Parms.RandomRecoil = RandomRecoil;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.CloseEmoteMenu
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::CloseEmoteMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "CloseEmoteMenu");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.MC_StopEmote
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimMontage*                     EmoteMontage                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::MC_StopEmote(class UAnimMontage* EmoteMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MC_StopEmote");

	Params::BP_Character_C_MC_StopEmote Parms{};

	Parms.EmoteMontage = EmoteMontage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.S_StopEmote
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::S_StopEmote()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_StopEmote");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.S_PlayEmote
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimMontage*                     EmoteMontage                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   EmoteDuration                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::S_PlayEmote(class UAnimMontage* EmoteMontage, float EmoteDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_PlayEmote");

	Params::BP_Character_C_S_PlayEmote Parms{};

	Parms.EmoteMontage = EmoteMontage;
	Parms.EmoteDuration = EmoteDuration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.MC_FireAnimation
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::MC_FireAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MC_FireAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.S_FireAnimation
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::S_FireAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_FireAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.FireAnimation
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::FireAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "FireAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.ReceiveHit
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              MyComp                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Other                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bSelfMoved                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FVector&                   HitLocation                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   HitNormal                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   NormalImpulse                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FHitResult&                Hit                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_Character_C::ReceiveHit(class UPrimitiveComponent* MyComp, class AActor* Other, class UPrimitiveComponent* OtherComp, bool bSelfMoved, const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ReceiveHit");

	Params::BP_Character_C_ReceiveHit Parms{};

	Parms.MyComp = MyComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.bSelfMoved = bSelfMoved;
	Parms.HitLocation = std::move(HitLocation);
	Parms.HitNormal = std::move(HitNormal);
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.MC_LaunchCharacter
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   LaunchVelocity                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class APawn*                            LaunchInflicter                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    DealImpactDamage_0                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::MC_LaunchCharacter(const struct FVector& LaunchVelocity, class APawn* LaunchInflicter, bool DealImpactDamage_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MC_LaunchCharacter");

	Params::BP_Character_C_MC_LaunchCharacter Parms{};

	Parms.LaunchVelocity = std::move(LaunchVelocity);
	Parms.LaunchInflicter = LaunchInflicter;
	Parms.DealImpactDamage_0 = DealImpactDamage_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.S_IncreaseEventToken
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::S_IncreaseEventToken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_IncreaseEventToken");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.OC_TeleportCharacter
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   TeleportLocation_0                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::OC_TeleportCharacter(const struct FVector& TeleportLocation_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OC_TeleportCharacter");

	Params::BP_Character_C_OC_TeleportCharacter Parms{};

	Parms.TeleportLocation_0 = std::move(TeleportLocation_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.PlayMontage
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimMontage*                     MontageToPlay                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bStopAllMontages                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   BlockIncomingMontagesTime                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   InPlayRate                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ForcePlayMontage_OverrideWhenAlreadyPlayingMontage_    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::PlayMontage(class UAnimMontage* MontageToPlay, bool bStopAllMontages, float BlockIncomingMontagesTime, float InPlayRate, bool ForcePlayMontage_OverrideWhenAlreadyPlayingMontage_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "PlayMontage");

	Params::BP_Character_C_PlayMontage Parms{};

	Parms.MontageToPlay = MontageToPlay;
	Parms.bStopAllMontages = bStopAllMontages;
	Parms.BlockIncomingMontagesTime = BlockIncomingMontagesTime;
	Parms.InPlayRate = InPlayRate;
	Parms.ForcePlayMontage_OverrideWhenAlreadyPlayingMontage_ = ForcePlayMontage_OverrideWhenAlreadyPlayingMontage_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.PlayMontageFromClient
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimMontage*                     MontageToPlay                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bStopAllMontages                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   BlockIncomingMontagesTime                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ForcePlayMontage_OverrideWhenAlreadyPlayingMontage_    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   InPlayRate                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::PlayMontageFromClient(class UAnimMontage* MontageToPlay, bool bStopAllMontages, float BlockIncomingMontagesTime, bool ForcePlayMontage_OverrideWhenAlreadyPlayingMontage_, float InPlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "PlayMontageFromClient");

	Params::BP_Character_C_PlayMontageFromClient Parms{};

	Parms.MontageToPlay = MontageToPlay;
	Parms.bStopAllMontages = bStopAllMontages;
	Parms.BlockIncomingMontagesTime = BlockIncomingMontagesTime;
	Parms.ForcePlayMontage_OverrideWhenAlreadyPlayingMontage_ = ForcePlayMontage_OverrideWhenAlreadyPlayingMontage_;
	Parms.InPlayRate = InPlayRate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.CleanUp
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::CleanUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "CleanUp");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.ReceiveDestroyed
// (Event, Public, BlueprintEvent)

void ABP_Character_C::ReceiveDestroyed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ReceiveDestroyed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ReceiveTick");

	Params::BP_Character_C_ReceiveTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.MC_PlayMontage
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimMontage*                     Montage                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    PlayOnOwningClient                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bStopAllMontages                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   BlockIncomingMontagesTime                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ForcePlayMontage_OverrideWhenAlreadyPlayingMontage_    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   InPlayRate                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::MC_PlayMontage(class UAnimMontage* Montage, bool PlayOnOwningClient, bool bStopAllMontages, float BlockIncomingMontagesTime, bool ForcePlayMontage_OverrideWhenAlreadyPlayingMontage_, float InPlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MC_PlayMontage");

	Params::BP_Character_C_MC_PlayMontage Parms{};

	Parms.Montage = Montage;
	Parms.PlayOnOwningClient = PlayOnOwningClient;
	Parms.bStopAllMontages = bStopAllMontages;
	Parms.BlockIncomingMontagesTime = BlockIncomingMontagesTime;
	Parms.ForcePlayMontage_OverrideWhenAlreadyPlayingMontage_ = ForcePlayMontage_OverrideWhenAlreadyPlayingMontage_;
	Parms.InPlayRate = InPlayRate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.S_PlayMontage
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimMontage*                     Montage                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bStopAllMontages                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   BlockIncomingMontagesTime                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    PlayOnOwningClient                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    ForcePlayMontage_OverrideWhenAlreadyPlayingMontage_    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   InPlayRate                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::S_PlayMontage(class UAnimMontage* Montage, bool bStopAllMontages, float BlockIncomingMontagesTime, bool PlayOnOwningClient, bool ForcePlayMontage_OverrideWhenAlreadyPlayingMontage_, float InPlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "S_PlayMontage");

	Params::BP_Character_C_S_PlayMontage Parms{};

	Parms.Montage = Montage;
	Parms.bStopAllMontages = bStopAllMontages;
	Parms.BlockIncomingMontagesTime = BlockIncomingMontagesTime;
	Parms.PlayOnOwningClient = PlayOnOwningClient;
	Parms.ForcePlayMontage_OverrideWhenAlreadyPlayingMontage_ = ForcePlayMontage_OverrideWhenAlreadyPlayingMontage_;
	Parms.InPlayRate = InPlayRate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void ABP_Character_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.InpActEvt_Interact_K2Node_InputActionEvent_0
// (BlueprintEvent)
// Parameters:
// const struct FKey&                      Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_Character_C::InpActEvt_Interact_K2Node_InputActionEvent_0(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "InpActEvt_Interact_K2Node_InputActionEvent_0");

	Params::BP_Character_C_InpActEvt_Interact_K2Node_InputActionEvent_0 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.InpActEvt_MouseScrollUp_K2Node_InputKeyEvent_0
// (BlueprintEvent)
// Parameters:
// const struct FKey&                      Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_Character_C::InpActEvt_MouseScrollUp_K2Node_InputKeyEvent_0(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "InpActEvt_MouseScrollUp_K2Node_InputKeyEvent_0");

	Params::BP_Character_C_InpActEvt_MouseScrollUp_K2Node_InputKeyEvent_0 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.InpActEvt_MouseScrollDown_K2Node_InputKeyEvent_1
// (BlueprintEvent)
// Parameters:
// const struct FKey&                      Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_Character_C::InpActEvt_MouseScrollDown_K2Node_InputKeyEvent_1(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "InpActEvt_MouseScrollDown_K2Node_InputKeyEvent_1");

	Params::BP_Character_C_InpActEvt_MouseScrollDown_K2Node_InputKeyEvent_1 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.InpActEvt_Actionbar Slot 1_K2Node_InputActionEvent_1
// (BlueprintEvent)
// Parameters:
// const struct FKey&                      Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_Character_C::InpActEvt_Actionbar_Slot_1_K2Node_InputActionEvent_1(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "InpActEvt_Actionbar Slot 1_K2Node_InputActionEvent_1");

	Params::BP_Character_C_InpActEvt_Actionbar_Slot_1_K2Node_InputActionEvent_1 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.InpActEvt_Actionbar Slot 2_K2Node_InputActionEvent_2
// (BlueprintEvent)
// Parameters:
// const struct FKey&                      Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_Character_C::InpActEvt_Actionbar_Slot_2_K2Node_InputActionEvent_2(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "InpActEvt_Actionbar Slot 2_K2Node_InputActionEvent_2");

	Params::BP_Character_C_InpActEvt_Actionbar_Slot_2_K2Node_InputActionEvent_2 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.InpActEvt_Actionbar Slot 3_K2Node_InputActionEvent_3
// (BlueprintEvent)
// Parameters:
// const struct FKey&                      Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_Character_C::InpActEvt_Actionbar_Slot_3_K2Node_InputActionEvent_3(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "InpActEvt_Actionbar Slot 3_K2Node_InputActionEvent_3");

	Params::BP_Character_C_InpActEvt_Actionbar_Slot_3_K2Node_InputActionEvent_3 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.InpActEvt_Skill 1_K2Node_InputActionEvent_4
// (BlueprintEvent)
// Parameters:
// const struct FKey&                      Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_Character_C::InpActEvt_Skill_1_K2Node_InputActionEvent_4(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "InpActEvt_Skill 1_K2Node_InputActionEvent_4");

	Params::BP_Character_C_InpActEvt_Skill_1_K2Node_InputActionEvent_4 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.InpActEvt_Skill 2_K2Node_InputActionEvent_5
// (BlueprintEvent)
// Parameters:
// const struct FKey&                      Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_Character_C::InpActEvt_Skill_2_K2Node_InputActionEvent_5(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "InpActEvt_Skill 2_K2Node_InputActionEvent_5");

	Params::BP_Character_C_InpActEvt_Skill_2_K2Node_InputActionEvent_5 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.InpActEvt_Reload_K2Node_InputActionEvent_6
// (BlueprintEvent)
// Parameters:
// const struct FKey&                      Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_Character_C::InpActEvt_Reload_K2Node_InputActionEvent_6(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "InpActEvt_Reload_K2Node_InputActionEvent_6");

	Params::BP_Character_C_InpActEvt_Reload_K2Node_InputActionEvent_6 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.InpActEvt_Attack_K2Node_InputActionEvent_7
// (BlueprintEvent)
// Parameters:
// const struct FKey&                      Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_Character_C::InpActEvt_Attack_K2Node_InputActionEvent_7(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "InpActEvt_Attack_K2Node_InputActionEvent_7");

	Params::BP_Character_C_InpActEvt_Attack_K2Node_InputActionEvent_7 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.InpActEvt_Attack_K2Node_InputActionEvent_8
// (BlueprintEvent)
// Parameters:
// const struct FKey&                      Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_Character_C::InpActEvt_Attack_K2Node_InputActionEvent_8(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "InpActEvt_Attack_K2Node_InputActionEvent_8");

	Params::BP_Character_C_InpActEvt_Attack_K2Node_InputActionEvent_8 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C. alt attack_K2Node_InputActionEvent_9
// (BlueprintEvent)
// Parameters:
// const struct FKey&                      Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_Character_C::_alt_attack_K2Node_InputActionEvent_9(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", " alt attack_K2Node_InputActionEvent_9");

	Params::BP_Character_C__alt_attack_K2Node_InputActionEvent_9 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C. alt attack_K2Node_InputActionEvent_10
// (BlueprintEvent)
// Parameters:
// const struct FKey&                      Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_Character_C::_alt_attack_K2Node_InputActionEvent_10(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", " alt attack_K2Node_InputActionEvent_10");

	Params::BP_Character_C__alt_attack_K2Node_InputActionEvent_10 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.InpActEvt_Weapon Quick Swap_K2Node_InputActionEvent_11
// (BlueprintEvent)
// Parameters:
// const struct FKey&                      Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_Character_C::InpActEvt_Weapon_Quick_Swap_K2Node_InputActionEvent_11(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "InpActEvt_Weapon Quick Swap_K2Node_InputActionEvent_11");

	Params::BP_Character_C_InpActEvt_Weapon_Quick_Swap_K2Node_InputActionEvent_11 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.InpActEvt_Actionbar Slot 4_K2Node_InputActionEvent_12
// (BlueprintEvent)
// Parameters:
// const struct FKey&                      Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_Character_C::InpActEvt_Actionbar_Slot_4_K2Node_InputActionEvent_12(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "InpActEvt_Actionbar Slot 4_K2Node_InputActionEvent_12");

	Params::BP_Character_C_InpActEvt_Actionbar_Slot_4_K2Node_InputActionEvent_12 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.InpActEvt_Jump_K2Node_InputActionEvent_13
// (BlueprintEvent)
// Parameters:
// const struct FKey&                      Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_Character_C::InpActEvt_Jump_K2Node_InputActionEvent_13(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "InpActEvt_Jump_K2Node_InputActionEvent_13");

	Params::BP_Character_C_InpActEvt_Jump_K2Node_InputActionEvent_13 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.InpActEvt_Jump_K2Node_InputActionEvent_14
// (BlueprintEvent)
// Parameters:
// const struct FKey&                      Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_Character_C::InpActEvt_Jump_K2Node_InputActionEvent_14(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "InpActEvt_Jump_K2Node_InputActionEvent_14");

	Params::BP_Character_C_InpActEvt_Jump_K2Node_InputActionEvent_14 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.InpActEvt_F1_K2Node_InputKeyEvent_2
// (BlueprintEvent)
// Parameters:
// const struct FKey&                      Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_Character_C::InpActEvt_F1_K2Node_InputKeyEvent_2(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "InpActEvt_F1_K2Node_InputKeyEvent_2");

	Params::BP_Character_C_InpActEvt_F1_K2Node_InputKeyEvent_2 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.InpActEvt_V_K2Node_InputKeyEvent_3
// (BlueprintEvent)
// Parameters:
// const struct FKey&                      Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_Character_C::InpActEvt_V_K2Node_InputKeyEvent_3(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "InpActEvt_V_K2Node_InputKeyEvent_3");

	Params::BP_Character_C_InpActEvt_V_K2Node_InputKeyEvent_3 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.InpActEvt_Crouch_K2Node_InputActionEvent_15
// (BlueprintEvent)
// Parameters:
// const struct FKey&                      Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_Character_C::InpActEvt_Crouch_K2Node_InputActionEvent_15(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "InpActEvt_Crouch_K2Node_InputActionEvent_15");

	Params::BP_Character_C_InpActEvt_Crouch_K2Node_InputActionEvent_15 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.InpActEvt_Crouch_K2Node_InputActionEvent_16
// (BlueprintEvent)
// Parameters:
// const struct FKey&                      Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_Character_C::InpActEvt_Crouch_K2Node_InputActionEvent_16(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "InpActEvt_Crouch_K2Node_InputActionEvent_16");

	Params::BP_Character_C_InpActEvt_Crouch_K2Node_InputActionEvent_16 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.InpActEvt_Front Face Camera (Self Inspect)_K2Node_InputActionEvent_17
// (BlueprintEvent)
// Parameters:
// const struct FKey&                      Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_Character_C::InpActEvt_Front_Face_Camera__Self_Inspect__K2Node_InputActionEvent_17(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "InpActEvt_Front Face Camera (Self Inspect)_K2Node_InputActionEvent_17");

	Params::BP_Character_C_InpActEvt_Front_Face_Camera__Self_Inspect__K2Node_InputActionEvent_17 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.InpActEvt_Front Face Camera (Self Inspect)_K2Node_InputActionEvent_18
// (BlueprintEvent)
// Parameters:
// const struct FKey&                      Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_Character_C::InpActEvt_Front_Face_Camera__Self_Inspect__K2Node_InputActionEvent_18(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "InpActEvt_Front Face Camera (Self Inspect)_K2Node_InputActionEvent_18");

	Params::BP_Character_C_InpActEvt_Front_Face_Camera__Self_Inspect__K2Node_InputActionEvent_18 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.InpActEvt_Emote Menu_K2Node_InputActionEvent_19
// (BlueprintEvent)
// Parameters:
// const struct FKey&                      Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_Character_C::InpActEvt_Emote_Menu_K2Node_InputActionEvent_19(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "InpActEvt_Emote Menu_K2Node_InputActionEvent_19");

	Params::BP_Character_C_InpActEvt_Emote_Menu_K2Node_InputActionEvent_19 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.InpActEvt_Emote Menu_K2Node_InputActionEvent_20
// (BlueprintEvent)
// Parameters:
// const struct FKey&                      Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_Character_C::InpActEvt_Emote_Menu_K2Node_InputActionEvent_20(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "InpActEvt_Emote Menu_K2Node_InputActionEvent_20");

	Params::BP_Character_C_InpActEvt_Emote_Menu_K2Node_InputActionEvent_20 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.ParachuteDeploy__UpdateFunc
// (BlueprintEvent)

void ABP_Character_C::ParachuteDeploy__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ParachuteDeploy__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.ParachuteDeploy__FinishedFunc
// (BlueprintEvent)

void ABP_Character_C::ParachuteDeploy__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ParachuteDeploy__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Timeline_1__UpdateFunc
// (BlueprintEvent)

void ABP_Character_C::Timeline_1__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Timeline_1__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Timeline_1__FinishedFunc
// (BlueprintEvent)

void ABP_Character_C::Timeline_1__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Timeline_1__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.FireAnimationTL__UpdateFunc
// (BlueprintEvent)

void ABP_Character_C::FireAnimationTL__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "FireAnimationTL__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.FireAnimationTL__FinishedFunc
// (BlueprintEvent)

void ABP_Character_C::FireAnimationTL__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "FireAnimationTL__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.UserConstructionScript
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.OnRep_IsDead
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnRep_IsDead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRep_IsDead");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.OnRep_AI_Target
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnRep_AI_Target()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRep_AI_Target");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.OnRep_AimingMode
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnRep_AimingMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRep_AimingMode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.RestoreHealth
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   HealAmount                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    HealEffect                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class APawn*                            PawnThatAppliedTheHeal                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    CleanseDebuffs                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   ScoreMultiplier                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::RestoreHealth(int32 HealAmount, bool HealEffect, class APawn* PawnThatAppliedTheHeal, bool CleanseDebuffs, float ScoreMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "RestoreHealth");

	Params::BP_Character_C_RestoreHealth Parms{};

	Parms.HealAmount = HealAmount;
	Parms.HealEffect = HealEffect;
	Parms.PawnThatAppliedTheHeal = PawnThatAppliedTheHeal;
	Parms.CleanseDebuffs = CleanseDebuffs;
	Parms.ScoreMultiplier = ScoreMultiplier;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.AddBuffDebuff
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UClass*                           BuffDebuff                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class APawn*                            BuffApplier                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   BuffScaler                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_SkillBase_C*                  LinkedSkill_Optional_                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    CanRefresh                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class ABP_BuffDebuffBase_C**            SpawnedBuffRef                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::AddBuffDebuff(class UClass* BuffDebuff, class APawn* BuffApplier, float BuffScaler, class ABP_SkillBase_C* LinkedSkill_Optional_, bool CanRefresh, class ABP_BuffDebuffBase_C** SpawnedBuffRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AddBuffDebuff");

	Params::BP_Character_C_AddBuffDebuff Parms{};

	Parms.BuffDebuff = BuffDebuff;
	Parms.BuffApplier = BuffApplier;
	Parms.BuffScaler = BuffScaler;
	Parms.LinkedSkill_Optional_ = LinkedSkill_Optional_;
	Parms.CanRefresh = CanRefresh;

	UObject::ProcessEvent(Func, &Parms);

	if (SpawnedBuffRef != nullptr)
		*SpawnedBuffRef = Parms.SpawnedBuffRef;
}


// Function BP_Character.BP_Character_C.EndBuffDebuff
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UClass*                           BuffDebuffClass                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::EndBuffDebuff(class UClass* BuffDebuffClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "EndBuffDebuff");

	Params::BP_Character_C_EndBuffDebuff Parms{};

	Parms.BuffDebuffClass = BuffDebuffClass;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.OnRep_Invisible
// (HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnRep_Invisible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRep_Invisible");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.SetInvisibility
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::SetInvisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SetInvisibility");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.OnRep_ActiveEquipable
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnRep_ActiveEquipable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRep_ActiveEquipable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.OnRep_FirstEquipable
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnRep_FirstEquipable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRep_FirstEquipable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.OnRep_SecondEquipable
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnRep_SecondEquipable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRep_SecondEquipable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.OnRep_ExplosiveEquipable
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnRep_ExplosiveEquipable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRep_ExplosiveEquipable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.InitActiveEquipable
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Equipable                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::InitActiveEquipable(int32 Equipable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "InitActiveEquipable");

	Params::BP_Character_C_InitActiveEquipable Parms{};

	Parms.Equipable = Equipable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.OnRep_Equipable1
// (HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnRep_Equipable1()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRep_Equipable1");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.OnRep_Equipable2
// (HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnRep_Equipable2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRep_Equipable2");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.OnRep_Explosive
// (HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnRep_Explosive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRep_Explosive");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.OnRep_VehicleRef
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnRep_VehicleRef()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRep_VehicleRef");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.SetActiveEquipable
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::SetActiveEquipable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SetActiveEquipable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.AddRecoil
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   RecoilAmount                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    AddSideWaysRecoil                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    RandomRecoil                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::AddRecoil(float RecoilAmount, bool AddSideWaysRecoil, bool RandomRecoil)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AddRecoil");

	Params::BP_Character_C_AddRecoil Parms{};

	Parms.RecoilAmount = RecoilAmount;
	Parms.AddSideWaysRecoil = AddSideWaysRecoil;
	Parms.RandomRecoil = RandomRecoil;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.ScaleAxisInput
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   InputAxisValue                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float*                                  OutputAxisValue                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::ScaleAxisInput(float InputAxisValue, float* OutputAxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ScaleAxisInput");

	Params::BP_Character_C_ScaleAxisInput Parms{};

	Parms.InputAxisValue = InputAxisValue;

	UObject::ProcessEvent(Func, &Parms);

	if (OutputAxisValue != nullptr)
		*OutputAxisValue = Parms.OutputAxisValue;
}


// Function BP_Character.BP_Character_C.ApplyMovementTypeMultiplier
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   A                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float*                                  Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::ApplyMovementTypeMultiplier(float A, float* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ApplyMovementTypeMultiplier");

	Params::BP_Character_C_ApplyMovementTypeMultiplier Parms{};

	Parms.A = A;

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function BP_Character.BP_Character_C.OnRep_Skill1
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnRep_Skill1()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRep_Skill1");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.OnRep_Skill2
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnRep_Skill2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRep_Skill2");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.HideSelf(Scope)
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    HideSelf                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::HideSelf_Scope_(bool HideSelf)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "HideSelf(Scope)");

	Params::BP_Character_C_HideSelf_Scope_ Parms{};

	Parms.HideSelf = HideSelf;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.RefreshAimingMode
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::RefreshAimingMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "RefreshAimingMode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.getSkill
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   SkillIndex                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FDataTableRowHandle*             Skill                                                  (Parm, OutParm, NoDestructor)

void ABP_Character_C::getSkill(int32 SkillIndex, struct FDataTableRowHandle* Skill)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "getSkill");

	Params::BP_Character_C_getSkill Parms{};

	Parms.SkillIndex = SkillIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (Skill != nullptr)
		*Skill = std::move(Parms.Skill);
}


// Function BP_Character.BP_Character_C.AI_GetRandomSkill
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32*                                  SkillIndex                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::AI_GetRandomSkill(int32* SkillIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AI_GetRandomSkill");

	Params::BP_Character_C_AI_GetRandomSkill Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SkillIndex != nullptr)
		*SkillIndex = Parms.SkillIndex;
}


// Function BP_Character.BP_Character_C.AI_FilterAvailableSkills
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::AI_FilterAvailableSkills()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AI_FilterAvailableSkills");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.AI_GetEnemyEngagementDelay
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           EnemyToEngage                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float*                                  Delay                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::AI_GetEnemyEngagementDelay(class AActor* EnemyToEngage, float* Delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AI_GetEnemyEngagementDelay");

	Params::BP_Character_C_AI_GetEnemyEngagementDelay Parms{};

	Parms.EnemyToEngage = EnemyToEngage;

	UObject::ProcessEvent(Func, &Parms);

	if (Delay != nullptr)
		*Delay = Parms.Delay;
}


// Function BP_Character.BP_Character_C.AI_SkillUse
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             SkillName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   SkillIndex                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::AI_SkillUse(class FName SkillName, int32 SkillIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AI_SkillUse");

	Params::BP_Character_C_AI_SkillUse Parms{};

	Parms.SkillName = SkillName;
	Parms.SkillIndex = SkillIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.OnRep_ThrowableRef
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnRep_ThrowableRef()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRep_ThrowableRef");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.GetWeaponOfTypeSlot
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<E_WeaponTypes>&                  WeaponTypes                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// int32*                                  WeaponSlot                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   WeaponTypeFound                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::GetWeaponOfTypeSlot(TArray<E_WeaponTypes>& WeaponTypes, int32* WeaponSlot, bool* WeaponTypeFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetWeaponOfTypeSlot");

	Params::BP_Character_C_GetWeaponOfTypeSlot Parms{};

	Parms.WeaponTypes = std::move(WeaponTypes);

	UObject::ProcessEvent(Func, &Parms);

	WeaponTypes = std::move(Parms.WeaponTypes);

	if (WeaponSlot != nullptr)
		*WeaponSlot = Parms.WeaponSlot;

	if (WeaponTypeFound != nullptr)
		*WeaponTypeFound = Parms.WeaponTypeFound;
}


// Function BP_Character.BP_Character_C.OnRep_CharacterClass
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnRep_CharacterClass()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRep_CharacterClass");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.OnRep_ParachuteOpen
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnRep_ParachuteOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRep_ParachuteOpen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.CalculateFallDamageAmount
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   TakeFallDamage                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float*                                  DamageAmount                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::CalculateFallDamageAmount(bool* TakeFallDamage, float* DamageAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "CalculateFallDamageAmount");

	Params::BP_Character_C_CalculateFallDamageAmount Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (TakeFallDamage != nullptr)
		*TakeFallDamage = Parms.TakeFallDamage;

	if (DamageAmount != nullptr)
		*DamageAmount = Parms.DamageAmount;
}


// Function BP_Character.BP_Character_C.OnRep_Skill1onCD
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnRep_Skill1onCD()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRep_Skill1onCD");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.OnRep_Skill2onCD
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnRep_Skill2onCD()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRep_Skill2onCD");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.IsReloadingCurrentWeapon?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   Reloading                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float*                                  ReloadPercentage                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::IsReloadingCurrentWeapon_(bool* Reloading, float* ReloadPercentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "IsReloadingCurrentWeapon?");

	Params::BP_Character_C_IsReloadingCurrentWeapon_ Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Reloading != nullptr)
		*Reloading = Parms.Reloading;

	if (ReloadPercentage != nullptr)
		*ReloadPercentage = Parms.ReloadPercentage;
}


// Function BP_Character.BP_Character_C.FindPlayerInGameStateStats
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   PlayerIndex                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   PlayerFound                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::FindPlayerInGameStateStats(int32 PlayerIndex, bool* PlayerFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "FindPlayerInGameStateStats");

	Params::BP_Character_C_FindPlayerInGameStateStats Parms{};

	Parms.PlayerIndex = PlayerIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (PlayerFound != nullptr)
		*PlayerFound = Parms.PlayerFound;
}


// Function BP_Character.BP_Character_C.CheckIfVulnerable
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   Vulnerable                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::CheckIfVulnerable(bool* Vulnerable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "CheckIfVulnerable");

	Params::BP_Character_C_CheckIfVulnerable Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Vulnerable != nullptr)
		*Vulnerable = Parms.Vulnerable;
}


// Function BP_Character.BP_Character_C.OnRep_CharacterCustomization
// (HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnRep_CharacterCustomization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRep_CharacterCustomization");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.CanSwapToThrowable?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          Weapon                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   CanSwap_0                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::CanSwapToThrowable_(class UObject* Weapon, bool* CanSwap_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "CanSwapToThrowable?");

	Params::BP_Character_C_CanSwapToThrowable_ Parms{};

	Parms.Weapon = Weapon;

	UObject::ProcessEvent(Func, &Parms);

	if (CanSwap_0 != nullptr)
		*CanSwap_0 = Parms.CanSwap_0;
}


// Function BP_Character.BP_Character_C.OnRep_AI_Controlled
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnRep_AI_Controlled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRep_AI_Controlled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.GetTickRate
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

float ABP_Character_C::GetTickRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetTickRate");

	Params::BP_Character_C_GetTickRate Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.CheckIfWeaponNeedsToAutoReload
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   AutoReload                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::CheckIfWeaponNeedsToAutoReload(bool* AutoReload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "CheckIfWeaponNeedsToAutoReload");

	Params::BP_Character_C_CheckIfWeaponNeedsToAutoReload Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (AutoReload != nullptr)
		*AutoReload = Parms.AutoReload;
}


// Function BP_Character.BP_Character_C.SetRimLight
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    EnableRimLight                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::SetRimLight(bool EnableRimLight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SetRimLight");

	Params::BP_Character_C_SetRimLight Parms{};

	Parms.EnableRimLight = EnableRimLight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.OnRep_CoreWeapon
// (HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnRep_CoreWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRep_CoreWeapon");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.OnRep_CoreWeaponEquipable
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnRep_CoreWeaponEquipable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRep_CoreWeaponEquipable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.AI_CheckIfTargetIsStillValid
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   Valid                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::AI_CheckIfTargetIsStillValid(bool* Valid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AI_CheckIfTargetIsStillValid");

	Params::BP_Character_C_AI_CheckIfTargetIsStillValid Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Valid != nullptr)
		*Valid = Parms.Valid;
}


// Function BP_Character.BP_Character_C.OnRep_VehicleSeat
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnRep_VehicleSeat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRep_VehicleSeat");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.ExitVehicleOrSeat
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::ExitVehicleOrSeat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ExitVehicleOrSeat");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.AI_IsEnemyCharacterLowHealth
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ABP_Character_C*                  Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsLowHealth                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::AI_IsEnemyCharacterLowHealth(class ABP_Character_C* Character, bool* IsLowHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AI_IsEnemyCharacterLowHealth");

	Params::BP_Character_C_AI_IsEnemyCharacterLowHealth Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);

	if (IsLowHealth != nullptr)
		*IsLowHealth = Parms.IsLowHealth;
}


// Function BP_Character.BP_Character_C.AI_IsTargetInRange
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   Range                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   InCloseRange                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::AI_IsTargetInRange(float Range, bool* InCloseRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AI_IsTargetInRange");

	Params::BP_Character_C_AI_IsTargetInRange Parms{};

	Parms.Range = Range;

	UObject::ProcessEvent(Func, &Parms);

	if (InCloseRange != nullptr)
		*InCloseRange = Parms.InCloseRange;
}


// Function BP_Character.BP_Character_C.GetEquipableWithIndex
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Index_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_EquipableBase_C**             Equipable                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::GetEquipableWithIndex(int32 Index_0, class ABP_EquipableBase_C** Equipable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetEquipableWithIndex");

	Params::BP_Character_C_GetEquipableWithIndex Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);

	if (Equipable != nullptr)
		*Equipable = Parms.Equipable;
}


// Function BP_Character.BP_Character_C.OnRep_Crouching
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnRep_Crouching()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRep_Crouching");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.GetWeaponSwapMontage
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Index_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

class UAnimMontage* ABP_Character_C::GetWeaponSwapMontage(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetWeaponSwapMontage");

	Params::BP_Character_C_GetWeaponSwapMontage Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.Get Kill Assist Player
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32*                                  AssistPlayerIndex                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_PlayerState_C**               AssistPlayerState                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   AssistsFound                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class APawn**                           AssistPawn                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Count_as_kill                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::Get_Kill_Assist_Player(int32* AssistPlayerIndex, class ABP_PlayerState_C** AssistPlayerState, bool* AssistsFound, class APawn** AssistPawn, bool* Count_as_kill)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Get Kill Assist Player");

	Params::BP_Character_C_Get_Kill_Assist_Player Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (AssistPlayerIndex != nullptr)
		*AssistPlayerIndex = Parms.AssistPlayerIndex;

	if (AssistPlayerState != nullptr)
		*AssistPlayerState = Parms.AssistPlayerState;

	if (AssistsFound != nullptr)
		*AssistsFound = Parms.AssistsFound;

	if (AssistPawn != nullptr)
		*AssistPawn = Parms.AssistPawn;

	if (Count_as_kill != nullptr)
		*Count_as_kill = Parms.Count_as_kill;
}


// Function BP_Character.BP_Character_C.GetCurrentEquipedWeaponType
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_WeaponTypes*                          WeaponType                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::GetCurrentEquipedWeaponType(E_WeaponTypes* WeaponType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetCurrentEquipedWeaponType");

	Params::BP_Character_C_GetCurrentEquipedWeaponType Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (WeaponType != nullptr)
		*WeaponType = Parms.WeaponType;
}


// Function BP_Character.BP_Character_C.OnRep_CharacterHasPlayerOwner
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnRep_CharacterHasPlayerOwner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRep_CharacterHasPlayerOwner");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.AI_GetForceLock(TargetPrioritize)
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          Object                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool ABP_Character_C::AI_GetForceLock_TargetPrioritize_(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AI_GetForceLock(TargetPrioritize)");

	Params::BP_Character_C_AI_GetForceLock_TargetPrioritize_ Parms{};

	Parms.Object = Object;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.OnRep_VehicleDucking
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnRep_VehicleDucking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRep_VehicleDucking");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.ShouldSlowDownWhenUsingEquipable?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   SlowDownWhenUsing_HaltSprint_                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::ShouldSlowDownWhenUsingEquipable_(bool* SlowDownWhenUsing_HaltSprint_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ShouldSlowDownWhenUsingEquipable?");

	Params::BP_Character_C_ShouldSlowDownWhenUsingEquipable_ Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SlowDownWhenUsing_HaltSprint_ != nullptr)
		*SlowDownWhenUsing_HaltSprint_ = Parms.SlowDownWhenUsing_HaltSprint_;
}


// Function BP_Character.BP_Character_C.IsShielded?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   Shielded_0                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::IsShielded_(bool* Shielded_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "IsShielded?");

	Params::BP_Character_C_IsShielded_ Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Shielded_0 != nullptr)
		*Shielded_0 = Parms.Shielded_0;
}


// Function BP_Character.BP_Character_C.FetchPing
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APlayerState**                    PlayerState_0                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::FetchPing(class APlayerState** PlayerState_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "FetchPing");

	Params::BP_Character_C_FetchPing Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PlayerState_0 != nullptr)
		*PlayerState_0 = Parms.PlayerState_0;
}

}

