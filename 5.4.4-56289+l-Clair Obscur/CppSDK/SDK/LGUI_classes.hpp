#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: LGUI

#include "Basic.hpp"

#include "MovieScene_structs.hpp"
#include "MovieScene_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "LGUI_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "UMG_structs.hpp"
#include "LTween_structs.hpp"
#include "SlateCore_structs.hpp"
#include "MovieSceneTracks_classes.hpp"
#include "InputCore_structs.hpp"
#include "Slate_structs.hpp"


namespace SDK
{

// Class LGUI.LGUICultureChangedInterface
// 0x0000 (0x0000 - 0x0000)
class ILGUICultureChangedInterface final
{
public:
	void OnCultureChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUICultureChangedInterface">();
	}
	static class ILGUICultureChangedInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILGUICultureChangedInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILGUICultureChangedInterface) == 0x000001, "Wrong alignment on ILGUICultureChangedInterface");
static_assert(sizeof(ILGUICultureChangedInterface) == 0x000001, "Wrong size on ILGUICultureChangedInterface");

// Class LGUI.UIEffectTextAnimation_Property
// 0x0000 (0x0028 - 0x0028)
class UUIEffectTextAnimation_Property : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_Property">();
	}
	static class UUIEffectTextAnimation_Property* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_Property>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_Property) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_Property");
static_assert(sizeof(UUIEffectTextAnimation_Property) == 0x000028, "Wrong size on UUIEffectTextAnimation_Property");

// Class LGUI.UIEffectTextAnimation_PropertyWithEase
// 0x0020 (0x0048 - 0x0028)
class UUIEffectTextAnimation_PropertyWithEase : public UUIEffectTextAnimation_Property
{
public:
	ELTweenEase                                   easetype;                                          // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            easeCurve;                                         // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEaseCurve(class UCurveFloat* Value);
	void SetEaseType(ELTweenEase Value);

	class UCurveFloat* GetCurveFloat() const;
	ELTweenEase GetEaseType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_PropertyWithEase">();
	}
	static class UUIEffectTextAnimation_PropertyWithEase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_PropertyWithEase>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_PropertyWithEase) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_PropertyWithEase");
static_assert(sizeof(UUIEffectTextAnimation_PropertyWithEase) == 0x000048, "Wrong size on UUIEffectTextAnimation_PropertyWithEase");
static_assert(offsetof(UUIEffectTextAnimation_PropertyWithEase, easetype) == 0x000028, "Member 'UUIEffectTextAnimation_PropertyWithEase::easetype' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_PropertyWithEase, easeCurve) == 0x000030, "Member 'UUIEffectTextAnimation_PropertyWithEase::easeCurve' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_ColorRandomProperty
// 0x0010 (0x0058 - 0x0048)
class UUIEffectTextAnimation_ColorRandomProperty final : public UUIEffectTextAnimation_PropertyWithEase
{
public:
	int32                                         Seed;                                              // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FColor                                 min_0;                                             // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FColor                                 max_0;                                             // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          useHSV;                                            // 0x0054(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMax(const struct FColor& Value);
	void SetMin(const struct FColor& Value);
	void SetSeed(int32 Value);
	void SetUseHSV(bool Value);

	struct FColor GetMax() const;
	struct FColor GetMin() const;
	int32 GetSeed() const;
	bool GetUseHSV() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_ColorRandomProperty">();
	}
	static class UUIEffectTextAnimation_ColorRandomProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_ColorRandomProperty>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_ColorRandomProperty) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_ColorRandomProperty");
static_assert(sizeof(UUIEffectTextAnimation_ColorRandomProperty) == 0x000058, "Wrong size on UUIEffectTextAnimation_ColorRandomProperty");
static_assert(offsetof(UUIEffectTextAnimation_ColorRandomProperty, Seed) == 0x000048, "Member 'UUIEffectTextAnimation_ColorRandomProperty::Seed' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_ColorRandomProperty, min_0) == 0x00004C, "Member 'UUIEffectTextAnimation_ColorRandomProperty::min_0' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_ColorRandomProperty, max_0) == 0x000050, "Member 'UUIEffectTextAnimation_ColorRandomProperty::max_0' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_ColorRandomProperty, useHSV) == 0x000054, "Member 'UUIEffectTextAnimation_ColorRandomProperty::useHSV' has a wrong offset!");

// Class LGUI.LGUILayoutElementInterface
// 0x0000 (0x0000 - 0x0000)
class ILGUILayoutElementInterface final
{
public:
	float GetConstantSize(ELayoutElementSizeType Type) const;
	ELayoutElementType GetLayoutType() const;
	float GetRatioSize(ELayoutElementSizeType Type) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUILayoutElementInterface">();
	}
	static class ILGUILayoutElementInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILGUILayoutElementInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILGUILayoutElementInterface) == 0x000001, "Wrong alignment on ILGUILayoutElementInterface");
static_assert(sizeof(ILGUILayoutElementInterface) == 0x000001, "Wrong size on ILGUILayoutElementInterface");

// Class LGUI.LGUILayoutInterface
// 0x0000 (0x0000 - 0x0000)
class ILGUILayoutInterface final
{
public:
	void MarkRebuildLayout();
	void OnUpdateLayout();

	bool GetCanLayoutControlAnchor(class UUIItem* InUIItem, struct FLGUICanLayoutControlAnchor* OutResult) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUILayoutInterface">();
	}
	static class ILGUILayoutInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILGUILayoutInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILGUILayoutInterface) == 0x000001, "Wrong alignment on ILGUILayoutInterface");
static_assert(sizeof(ILGUILayoutInterface) == 0x000001, "Wrong size on ILGUILayoutInterface");

// Class LGUI.LGUIPrefabInterface
// 0x0000 (0x0000 - 0x0000)
class ILGUIPrefabInterface final
{
public:
	void Awake();
	void EditorAwake();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPrefabInterface">();
	}
	static class ILGUIPrefabInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILGUIPrefabInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILGUIPrefabInterface) == 0x000001, "Wrong alignment on ILGUIPrefabInterface");
static_assert(sizeof(ILGUIPrefabInterface) == 0x000001, "Wrong size on ILGUIPrefabInterface");

// Class LGUI.LGUIPrefabSequencePlayer
// 0x0000 (0x0460 - 0x0460)
class ULGUIPrefabSequencePlayer final : public UMovieSceneSequencePlayer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPrefabSequencePlayer">();
	}
	static class ULGUIPrefabSequencePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPrefabSequencePlayer>();
	}
};
static_assert(alignof(ULGUIPrefabSequencePlayer) == 0x000008, "Wrong alignment on ULGUIPrefabSequencePlayer");
static_assert(sizeof(ULGUIPrefabSequencePlayer) == 0x000460, "Wrong size on ULGUIPrefabSequencePlayer");

// Class LGUI.UISpriteRenderableInterface
// 0x0000 (0x0000 - 0x0000)
class IUISpriteRenderableInterface final
{
public:
	void ApplyAtlasTextureChange();
	void ApplyAtlasTextureScaleUp();

	class ULGUISpriteData_BaseObject* SpriteRenderableGetSprite() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISpriteRenderableInterface">();
	}
	static class IUISpriteRenderableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IUISpriteRenderableInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IUISpriteRenderableInterface) == 0x000001, "Wrong alignment on IUISpriteRenderableInterface");
static_assert(sizeof(IUISpriteRenderableInterface) == 0x000001, "Wrong size on IUISpriteRenderableInterface");

// Class LGUI.LGUIBaseEventData
// 0x0010 (0x0038 - 0x0028)
class ULGUIBaseEventData : public UObject
{
public:
	class USceneComponent*                        SelectedComponent;                                 // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPointerEventType                             EventType;                                         // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString ToString() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIBaseEventData">();
	}
	static class ULGUIBaseEventData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIBaseEventData>();
	}
};
static_assert(alignof(ULGUIBaseEventData) == 0x000008, "Wrong alignment on ULGUIBaseEventData");
static_assert(sizeof(ULGUIBaseEventData) == 0x000038, "Wrong size on ULGUIBaseEventData");
static_assert(offsetof(ULGUIBaseEventData, SelectedComponent) == 0x000028, "Member 'ULGUIBaseEventData::SelectedComponent' has a wrong offset!");
static_assert(offsetof(ULGUIBaseEventData, EventType) == 0x000030, "Member 'ULGUIBaseEventData::EventType' has a wrong offset!");

// Class LGUI.LGUIPrefabHelperObject
// 0x00B0 (0x00D8 - 0x0028)
class ULGUIPrefabHelperObject final : public UObject
{
public:
	class ULGUIPrefab*                            PrefabAsset;                                       // 0x0028(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 LoadedRootActor;                                   // 0x0030(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGuid, class UObject*>            MapGuidToObject;                                   // 0x0038(0x0050)(Edit, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class AActor*, struct FLGUISubPrefabData> SubPrefabMap;                                     // 0x0088(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPrefabHelperObject">();
	}
	static class ULGUIPrefabHelperObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPrefabHelperObject>();
	}
};
static_assert(alignof(ULGUIPrefabHelperObject) == 0x000008, "Wrong alignment on ULGUIPrefabHelperObject");
static_assert(sizeof(ULGUIPrefabHelperObject) == 0x0000D8, "Wrong size on ULGUIPrefabHelperObject");
static_assert(offsetof(ULGUIPrefabHelperObject, PrefabAsset) == 0x000028, "Member 'ULGUIPrefabHelperObject::PrefabAsset' has a wrong offset!");
static_assert(offsetof(ULGUIPrefabHelperObject, LoadedRootActor) == 0x000030, "Member 'ULGUIPrefabHelperObject::LoadedRootActor' has a wrong offset!");
static_assert(offsetof(ULGUIPrefabHelperObject, MapGuidToObject) == 0x000038, "Member 'ULGUIPrefabHelperObject::MapGuidToObject' has a wrong offset!");
static_assert(offsetof(ULGUIPrefabHelperObject, SubPrefabMap) == 0x000088, "Member 'ULGUIPrefabHelperObject::SubPrefabMap' has a wrong offset!");

// Class LGUI.LGUIBaseInputModule
// 0x0000 (0x00A0 - 0x00A0)
class ULGUIBaseInputModule : public UActorComponent
{
public:
	void ClearEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIBaseInputModule">();
	}
	static class ULGUIBaseInputModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIBaseInputModule>();
	}
};
static_assert(alignof(ULGUIBaseInputModule) == 0x000008, "Wrong alignment on ULGUIBaseInputModule");
static_assert(sizeof(ULGUIBaseInputModule) == 0x0000A0, "Wrong size on ULGUIBaseInputModule");

// Class LGUI.UIEffectTextAnimation_AlphaProperty
// 0x0008 (0x0050 - 0x0048)
class UUIEffectTextAnimation_AlphaProperty final : public UUIEffectTextAnimation_PropertyWithEase
{
public:
	float                                         Alpha;                                             // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAlpha(float Value);

	float GetAlpha() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_AlphaProperty">();
	}
	static class UUIEffectTextAnimation_AlphaProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_AlphaProperty>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_AlphaProperty) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_AlphaProperty");
static_assert(sizeof(UUIEffectTextAnimation_AlphaProperty) == 0x000050, "Wrong size on UUIEffectTextAnimation_AlphaProperty");
static_assert(offsetof(UUIEffectTextAnimation_AlphaProperty, Alpha) == 0x000048, "Member 'UUIEffectTextAnimation_AlphaProperty::Alpha' has a wrong offset!");

// Class LGUI.LGUIBaseRaycaster
// 0x0070 (0x02A0 - 0x0230)
class ULGUIBaseRaycaster : public USceneComponent
{
public:
	uint8                                         Pad_230[0x10];                                     // 0x0230(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         pointerID;                                         // 0x0240(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Depth;                                             // 0x0244(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         rayLength;                                         // 0x0248(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETraceTypeQuery                               TraceChannel;                                      // 0x024C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELGUIEventFireType                            eventFireType;                                     // 0x024D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24E[0x2];                                      // 0x024E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         clickThreshold;                                    // 0x0250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          holdToDrag;                                        // 0x0254(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_255[0x3];                                      // 0x0255(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         holdToDragTime;                                    // 0x0258(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25C[0x44];                                     // 0x025C(0x0044)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateRaycaster();
	void DeactivateRaycaster();
	void SetClickThreshold(float Value);
	void SetHoldToDrag(bool Value);
	void SetHoldToDragTime(float Value);

	bool GetAffectByGamePause() const;
	float GetClickThreshold() const;
	int32 GetDepth() const;
	ELGUIEventFireType GetEventFireType() const;
	bool GetHoldToDrag() const;
	float GetHoldToDragTime() const;
	int32 GetPointerID() const;
	struct FVector GetRayDirection() const;
	float GetRayLength() const;
	struct FVector GetRayOrigin() const;
	ETraceTypeQuery GetTraceChannel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIBaseRaycaster">();
	}
	static class ULGUIBaseRaycaster* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIBaseRaycaster>();
	}
};
static_assert(alignof(ULGUIBaseRaycaster) == 0x000010, "Wrong alignment on ULGUIBaseRaycaster");
static_assert(sizeof(ULGUIBaseRaycaster) == 0x0002A0, "Wrong size on ULGUIBaseRaycaster");
static_assert(offsetof(ULGUIBaseRaycaster, pointerID) == 0x000240, "Member 'ULGUIBaseRaycaster::pointerID' has a wrong offset!");
static_assert(offsetof(ULGUIBaseRaycaster, Depth) == 0x000244, "Member 'ULGUIBaseRaycaster::Depth' has a wrong offset!");
static_assert(offsetof(ULGUIBaseRaycaster, rayLength) == 0x000248, "Member 'ULGUIBaseRaycaster::rayLength' has a wrong offset!");
static_assert(offsetof(ULGUIBaseRaycaster, TraceChannel) == 0x00024C, "Member 'ULGUIBaseRaycaster::TraceChannel' has a wrong offset!");
static_assert(offsetof(ULGUIBaseRaycaster, eventFireType) == 0x00024D, "Member 'ULGUIBaseRaycaster::eventFireType' has a wrong offset!");
static_assert(offsetof(ULGUIBaseRaycaster, clickThreshold) == 0x000250, "Member 'ULGUIBaseRaycaster::clickThreshold' has a wrong offset!");
static_assert(offsetof(ULGUIBaseRaycaster, holdToDrag) == 0x000254, "Member 'ULGUIBaseRaycaster::holdToDrag' has a wrong offset!");
static_assert(offsetof(ULGUIBaseRaycaster, holdToDragTime) == 0x000258, "Member 'ULGUIBaseRaycaster::holdToDragTime' has a wrong offset!");

// Class LGUI.LGUIBPLibrary
// 0x0000 (0x0028 - 0x0028)
class ULGUIBPLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class ULTweener* AlphaFrom(class UUIBaseRenderable* Target, float StartValue, float Duration, float Delay, ELTweenEase Ease);
	static class ULTweener* AlphaTo(class UUIBaseRenderable* Target, float endValue, float Duration, float Delay, ELTweenEase Ease);
	static class ULTweener* AnchorBottomTo(class UUIItem* Target, float endValue, float Duration, float Delay, ELTweenEase Ease);
	static class ULTweener* AnchoredPositionTo(class UUIItem* Target, const struct FVector2D& endValue, float Duration, float Delay, ELTweenEase Ease);
	static class ULTweener* AnchorLeftTo(class UUIItem* Target, float endValue, float Duration, float Delay, ELTweenEase Ease);
	static class ULTweener* AnchorOffsetTo(class UUIItem* Target, const struct FVector2D& endValue, float Duration, float Delay, ELTweenEase Ease);
	static class ULTweener* AnchorOffsetXTo(class UUIItem* Target, float endValue, float Duration, float Delay, ELTweenEase Ease);
	static class ULTweener* AnchorOffsetYTo(class UUIItem* Target, float endValue, float Duration, float Delay, ELTweenEase Ease);
	static class ULTweener* AnchorRightTo(class UUIItem* Target, float endValue, float Duration, float Delay, ELTweenEase Ease);
	static class ULTweener* AnchorTopTo(class UUIItem* Target, float endValue, float Duration, float Delay, ELTweenEase Ease);
	static class ULTweener* ColorFrom(class UUIBaseRenderable* Target, const struct FColor& StartValue, float Duration, float Delay, ELTweenEase Ease);
	static class ULTweener* ColorTo(class UUIBaseRenderable* Target, const struct FColor& endValue, float Duration, float Delay, ELTweenEase Ease);
	static void DestroyActorWithHierarchy(class AActor* Target, bool WithHierarchy);
	static class AActor* DuplicateActor(class AActor* Target, class USceneComponent* Parent);
	static class AActor* DuplicateActorWithPreparedData(struct FLGUIDuplicateDataContainer& Data, class USceneComponent* Parent);
	static class UActorComponent* GetComponentInChildren(class AActor* InActor, TSubclassOf<class UActorComponent> ComponentClass, bool IncludeSelf, const TSet<class AActor*>& InExcludeNode);
	static class UActorComponent* GetComponentInParent(class AActor* InActor, TSubclassOf<class UActorComponent> ComponentClass, bool IncludeSelf, class AActor* InStopNode);
	static TArray<class UActorComponent*> GetComponentsInChildren(class AActor* InActor, TSubclassOf<class UActorComponent> ComponentClass, bool IncludeSelf, const TSet<class AActor*>& InExcludeNode);
	static void GetSpriteBorderSize(const struct FLGUISpriteInfo& SpriteInfo, int32* borderLeft, int32* borderRight, int32* borderTop, int32* borderBottom);
	static void GetSpriteBorderUV(const struct FLGUISpriteInfo& SpriteInfo, float* borderUV0X, float* borderUV0Y, float* borderUV3X, float* borderUV3Y);
	static void GetSpriteSize(const struct FLGUISpriteInfo& SpriteInfo, int32* Width, int32* Height);
	static void GetSpriteUV(const struct FLGUISpriteInfo& SpriteInfo, float* uv0X, float* uv0Y, float* uv3X, float* uv3Y);
	static class ULTweener* HeightTo(class UUIItem* Target, float endValue, float Duration, float Delay, ELTweenEase Ease);
	static class ULTweener* HorizontalAnchoredPositionTo(class UUIItem* Target, float endValue, float Duration, float Delay, ELTweenEase Ease);
	static void K2_LGUICompRef_GetComponent(const struct FLGUIComponentReference& InLGUICompRef, class UActorComponent** OutResult);
	static class AActor* LGUICompRef_GetActor(const struct FLGUIComponentReference& InLGUIComponentReference);
	static class UActorComponent* LGUICompRef_GetComponent(const struct FLGUIComponentReference& InLGUIComponentReference, TSubclassOf<class UActorComponent> InComponentType);
	static TSubclassOf<class UActorComponent> LGUICompRef_GetComponentClass(const struct FLGUIComponentReference& InLGUIComponentReference);
	static void LGUIEventDelegate_Actor_Execute(const struct FLGUIEventDelegate_Actor& InEvent, class AActor* InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIEventDelegate_Actor_Register(const struct FLGUIEventDelegate_Actor& InEvent, TDelegate<void(class AActor* Value)> InDelegate);
	static void LGUIEventDelegate_Actor_Unregister(const struct FLGUIEventDelegate_Actor& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIEventDelegate_Bool_Execute(const struct FLGUIEventDelegate_Bool& InEvent, bool InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIEventDelegate_Bool_Register(const struct FLGUIEventDelegate_Bool& InEvent, TDelegate<void(bool Value)> InDelegate);
	static void LGUIEventDelegate_Bool_Unregister(const struct FLGUIEventDelegate_Bool& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIEventDelegate_Class_Execute(const struct FLGUIEventDelegate_Class& InEvent, class UClass* InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIEventDelegate_Class_Register(const struct FLGUIEventDelegate_Class& InEvent, TDelegate<void(class UClass* Value)> InDelegate);
	static void LGUIEventDelegate_Class_Unregister(const struct FLGUIEventDelegate_Class& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIEventDelegate_Color_Execute(const struct FLGUIEventDelegate_Color& InEvent, const struct FColor& InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIEventDelegate_Color_Register(const struct FLGUIEventDelegate_Color& InEvent, TDelegate<void(const struct FColor& Value)> InDelegate);
	static void LGUIEventDelegate_Color_Unregister(const struct FLGUIEventDelegate_Color& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIEventDelegate_Double_Execute(const struct FLGUIEventDelegate_Double& InEvent, double InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIEventDelegate_Double_Register(const struct FLGUIEventDelegate_Double& InEvent, TDelegate<void(double Value)> InDelegate);
	static void LGUIEventDelegate_Double_Unregister(const struct FLGUIEventDelegate_Double& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIEventDelegate_Empty_Execute(const struct FLGUIEventDelegate_Empty& InEvent);
	static struct FLGUIDelegateHandleWrapper LGUIEventDelegate_Empty_Register(const struct FLGUIEventDelegate_Empty& InEvent, TDelegate<void()> InDelegate);
	static void LGUIEventDelegate_Empty_Unregister(const struct FLGUIEventDelegate_Empty& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIEventDelegate_Float_Execute(const struct FLGUIEventDelegate_Float& InEvent, float InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIEventDelegate_Float_Register(const struct FLGUIEventDelegate_Float& InEvent, TDelegate<void(float Value)> InDelegate);
	static void LGUIEventDelegate_Float_Unregister(const struct FLGUIEventDelegate_Float& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIEventDelegate_Int32_Execute(const struct FLGUIEventDelegate_Int32& InEvent, int32 InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIEventDelegate_Int32_Register(const struct FLGUIEventDelegate_Int32& InEvent, TDelegate<void(int32 Value)> InDelegate);
	static void LGUIEventDelegate_Int32_Unregister(const struct FLGUIEventDelegate_Int32& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIEventDelegate_Int64_Execute(const struct FLGUIEventDelegate_Int64& InEvent, int64 InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIEventDelegate_Int64_Register(const struct FLGUIEventDelegate_Int64& InEvent, TDelegate<void(int64 Value)> InDelegate);
	static void LGUIEventDelegate_Int64_Unregister(const struct FLGUIEventDelegate_Int64& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIEventDelegate_LinearColor_Execute(const struct FLGUIEventDelegate_LinearColor& InEvent, const struct FLinearColor& InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIEventDelegate_LinearColor_Register(const struct FLGUIEventDelegate_LinearColor& InEvent, TDelegate<void(const struct FLinearColor& Value)> InDelegate);
	static void LGUIEventDelegate_LinearColor_Unregister(const struct FLGUIEventDelegate_LinearColor& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIEventDelegate_Name_Execute(const struct FLGUIEventDelegate_Name& InEvent, class FName InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIEventDelegate_Name_Register(const struct FLGUIEventDelegate_Name& InEvent, TDelegate<void(class FName Value)> InDelegate);
	static void LGUIEventDelegate_Name_Unregister(const struct FLGUIEventDelegate_Name& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIEventDelegate_Object_Execute(const struct FLGUIEventDelegate_Object& InEvent, class UObject* InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIEventDelegate_Object_Register(const struct FLGUIEventDelegate_Object& InEvent, TDelegate<void(class UObject* Value)> InDelegate);
	static void LGUIEventDelegate_Object_Unregister(const struct FLGUIEventDelegate_Object& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIEventDelegate_PointerEvent_Execute(const struct FLGUIEventDelegate_PointerEvent& InEvent, class ULGUIPointerEventData* InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIEventDelegate_PointerEvent_Register(const struct FLGUIEventDelegate_PointerEvent& InEvent, TDelegate<void(class ULGUIPointerEventData* Value)> InDelegate);
	static void LGUIEventDelegate_PointerEvent_Unregister(const struct FLGUIEventDelegate_PointerEvent& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIEventDelegate_Quaternion_Execute(const struct FLGUIEventDelegate_Quaternion& InEvent, const struct FQuat& InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIEventDelegate_Quaternion_Register(const struct FLGUIEventDelegate_Quaternion& InEvent, TDelegate<void(const struct FQuat& Value)> InDelegate);
	static void LGUIEventDelegate_Quaternion_Unregister(const struct FLGUIEventDelegate_Quaternion& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIEventDelegate_Rotator_Execute(const struct FLGUIEventDelegate_Rotator& InEvent, const struct FRotator& InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIEventDelegate_Rotator_Register(const struct FLGUIEventDelegate_Rotator& InEvent, TDelegate<void(const struct FRotator& Value)> InDelegate);
	static void LGUIEventDelegate_Rotator_Unregister(const struct FLGUIEventDelegate_Rotator& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIEventDelegate_String_Execute(const struct FLGUIEventDelegate_String& InEvent, const class FString& InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIEventDelegate_String_Register(const struct FLGUIEventDelegate_String& InEvent, TDelegate<void(const class FString& Value)> InDelegate);
	static void LGUIEventDelegate_String_Unregister(const struct FLGUIEventDelegate_String& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIEventDelegate_Text_Execute(const struct FLGUIEventDelegate_Text& InEvent, const class FText& InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIEventDelegate_Text_Register(const struct FLGUIEventDelegate_Text& InEvent, TDelegate<void(class FText Value)> InDelegate);
	static void LGUIEventDelegate_Text_Unregister(const struct FLGUIEventDelegate_Text& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIEventDelegate_UInt8_Execute(const struct FLGUIEventDelegate_UInt8& InEvent, uint8 InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIEventDelegate_UInt8_Register(const struct FLGUIEventDelegate_UInt8& InEvent, TDelegate<void(uint8 Value)> InDelegate);
	static void LGUIEventDelegate_UInt8_Unregister(const struct FLGUIEventDelegate_UInt8& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIEventDelegate_Vector2_Execute(const struct FLGUIEventDelegate_Vector2& InEvent, const struct FVector2D& InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIEventDelegate_Vector2_Register(const struct FLGUIEventDelegate_Vector2& InEvent, TDelegate<void(const struct FVector2D& Value)> InDelegate);
	static void LGUIEventDelegate_Vector2_Unregister(const struct FLGUIEventDelegate_Vector2& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIEventDelegate_Vector3_Execute(const struct FLGUIEventDelegate_Vector3& InEvent, const struct FVector& InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIEventDelegate_Vector3_Register(const struct FLGUIEventDelegate_Vector3& InEvent, TDelegate<void(const struct FVector& Value)> InDelegate);
	static void LGUIEventDelegate_Vector3_Unregister(const struct FLGUIEventDelegate_Vector3& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIEventDelegate_Vector4_Execute(const struct FLGUIEventDelegate_Vector4& InEvent, const struct FVector4& InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIEventDelegate_Vector4_Register(const struct FLGUIEventDelegate_Vector4& InEvent, TDelegate<void(const struct FVector4& Value)> InDelegate);
	static void LGUIEventDelegate_Vector4_Unregister(const struct FLGUIEventDelegate_Vector4& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIEventDelegateExecuteActor(const struct FLGUIEventDelegate& InEvent, class AActor* InParameter);
	static void LGUIEventDelegateExecuteBool(const struct FLGUIEventDelegate& InEvent, const bool& InParameter);
	static void LGUIEventDelegateExecuteClass(const struct FLGUIEventDelegate& InEvent, class UClass* InParameter);
	static void LGUIEventDelegateExecuteColor(const struct FLGUIEventDelegate& InEvent, const struct FColor& InParameter);
	static void LGUIEventDelegateExecuteEmpty(const struct FLGUIEventDelegate& InEvent);
	static void LGUIEventDelegateExecuteFloat(const struct FLGUIEventDelegate& InEvent, const float& InParameter);
	static void LGUIEventDelegateExecuteInt32(const struct FLGUIEventDelegate& InEvent, const int32& InParameter);
	static void LGUIEventDelegateExecuteLinearColor(const struct FLGUIEventDelegate& InEvent, const struct FLinearColor& InParameter);
	static void LGUIEventDelegateExecuteName(const struct FLGUIEventDelegate& InEvent, const class FName& InParameter);
	static void LGUIEventDelegateExecuteObject(const struct FLGUIEventDelegate& InEvent, class UObject* InParameter);
	static void LGUIEventDelegateExecutePointerEvent(const struct FLGUIEventDelegate& InEvent, class ULGUIPointerEventData* InParameter);
	static void LGUIEventDelegateExecuteQuaternion(const struct FLGUIEventDelegate& InEvent, const struct FQuat& InParameter);
	static void LGUIEventDelegateExecuteRotator(const struct FLGUIEventDelegate& InEvent, const struct FRotator& InParameter);
	static void LGUIEventDelegateExecuteString(const struct FLGUIEventDelegate& InEvent, const class FString& InParameter);
	static void LGUIEventDelegateExecuteText(const struct FLGUIEventDelegate& InEvent, const class FText& InParameter);
	static void LGUIEventDelegateExecuteUInt8(const struct FLGUIEventDelegate& InEvent, const uint8& InParameter);
	static void LGUIEventDelegateExecuteVector2(const struct FLGUIEventDelegate& InEvent, const struct FVector2D& InParameter);
	static void LGUIEventDelegateExecuteVector3(const struct FLGUIEventDelegate& InEvent, const struct FVector& InParameter);
	static void LGUIEventDelegateExecuteVector4(const struct FLGUIEventDelegate& InEvent, const struct FVector4& InParameter);
	static void LGUIExecuteControllerInputAction(const struct FKey& InputKey, bool pressOrRelease);
	static void LGUIExecuteControllerInputAxis(const struct FKey& InputKey, float Value);
	static void LGUIExecuteInputAction(const struct FKey& InputKey, bool pressOrRelease);
	static void LGUIExecuteInputAxis(const struct FKey& InputKey, float Value);
	static class AActor* LoadPrefab(class UObject* WorldContextObject, class ULGUIPrefab* InPrefab, class USceneComponent* InParent, const TDelegate<void(class AActor* LoadedRootActor)>& InCallbackBeforeAwake, bool SetRelativeTransformToIdentity);
	static class AActor* LoadPrefabWithReplacement(class UObject* WorldContextObject, class ULGUIPrefab* InPrefab, class USceneComponent* InParent, const TMap<class UObject*, class UObject*>& InReplaceAssetMap, const TMap<class UClass*, class UClass*>& InReplaceClassMap, const TDelegate<void(class AActor* LoadedRootActor)>& InCallbackBeforeAwake);
	static class AActor* LoadPrefabWithTransform(class UObject* WorldContextObject, class ULGUIPrefab* InPrefab, class USceneComponent* InParent, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, const TDelegate<void(class AActor* LoadedRootActor)>& InCallbackBeforeAwake);
	static class ULTweener* PivotTo(class UUIItem* Target, const struct FVector2D& endValue, float Duration, float Delay, ELTweenEase Ease);
	static void PrepareDuplicateData(class AActor* Target, struct FLGUIDuplicateDataContainer* Data);
	static class ULTweener* StretchBottomTo(class UUIItem* Target, float endValue, float Duration, float Delay, ELTweenEase Ease);
	static class ULTweener* StretchLeftTo(class UUIItem* Target, float endValue, float Duration, float Delay, ELTweenEase Ease);
	static class ULTweener* StretchRightTo(class UUIItem* Target, float endValue, float Duration, float Delay, ELTweenEase Ease);
	static class ULTweener* StretchTopTo(class UUIItem* Target, float endValue, float Duration, float Delay, ELTweenEase Ease);
	static class ULTweener* UILocalPositionTo(class UUIItem* Target, const struct FVector& endValue, float Duration, float Delay, ELTweenEase Ease);
	static class ULTweener* VerticalAnchoredPositionTo(class UUIItem* Target, float endValue, float Duration, float Delay, ELTweenEase Ease);
	static class ULTweener* WidthTo(class UUIItem* Target, float endValue, float Duration, float Delay, ELTweenEase Ease);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIBPLibrary">();
	}
	static class ULGUIBPLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIBPLibrary>();
	}
};
static_assert(alignof(ULGUIBPLibrary) == 0x000008, "Wrong alignment on ULGUIBPLibrary");
static_assert(sizeof(ULGUIBPLibrary) == 0x000028, "Wrong size on ULGUIBPLibrary");

// Class LGUI.UIEventBlockerComponent
// 0x0040 (0x00E0 - 0x00A0)
class UUIEventBlockerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x38];                                      // 0x00A0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          AllowEventBubbleUp;                                // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEventBlockerComponent">();
	}
	static class UUIEventBlockerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEventBlockerComponent>();
	}
};
static_assert(alignof(UUIEventBlockerComponent) == 0x000008, "Wrong alignment on UUIEventBlockerComponent");
static_assert(sizeof(UUIEventBlockerComponent) == 0x0000E0, "Wrong size on UUIEventBlockerComponent");
static_assert(offsetof(UUIEventBlockerComponent, AllowEventBubbleUp) == 0x0000D8, "Member 'UUIEventBlockerComponent::AllowEventBubbleUp' has a wrong offset!");

// Class LGUI.LGUICanvas
// 0x0350 (0x03F0 - 0x00A0)
class alignas(0x10) ULGUICanvas final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x40];                                      // 0x00A0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ULGUICanvas>             RootCanvas;                                        // 0x00E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ULGUICanvas>             ParentCanvas;                                      // 0x00E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UUIItem>                 UIItem;                                            // 0x00F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x10];                                      // 0x00F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	ELGUIRenderMode                               renderMode;                                        // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0110(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELGUICanvasRenderTargetUpdateMode             RenderTargetUpdateMode;                            // 0x0118(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELGUICanvasRenderTargetSizeMode               RenderTargetSizeMode;                              // 0x0119(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11A[0x2];                                      // 0x011A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RenderTargetResolutionScale;                       // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          pixelPerfect;                                      // 0x0120(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideSorting;                                  // 0x0121(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int16                                         SortOrder;                                         // 0x0122(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELGUICanvasClipType                           clipType;                                          // 0x0124(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_125[0x3];                                      // 0x0125(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              clipFeather;                                       // 0x0128(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                clipRectOffset;                                    // 0x0138(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             ClipTexture;                                       // 0x0148(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         clipTextureHitTestThreshold;                       // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          inheritRectClip;                                   // 0x0154(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_155[0x3];                                      // 0x0155(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ULGUICanvasCustomClip*                  customClip;                                        // 0x0158(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         dynamicPixelsPerUnit;                              // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int8                                          additionalShaderChannels;                          // 0x0164(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_165[0x3];                                      // 0x0165(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     DefaultMaterials[0x3];                             // 0x0168(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlendDepth;                                        // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         depthFade;                                         // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableDepthTest;                                  // 0x0188(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int8                                          OverrideParameters;                                // 0x0189(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_18A[0x6];                                      // 0x018A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ULGUIMeshComponent>         DefaultMeshType;                                   // 0x0190(0x0008)(Edit, ZeroConstructor, NoDestructor, AdvancedDisplay, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_198[0x168];                                    // 0x0198(0x0168)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ULGUIMeshComponent>      UIMesh;                                            // 0x0300(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FLGUIMaterialArrayContainer>    PooledUIMaterialList;                              // 0x0308(0x0010)(Edit, ZeroConstructor, Transient, EditConst, AdvancedDisplay, NativeAccessSpecifierPrivate)
	uint8                                         Pad_318[0x20];                                     // 0x0318(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIItem*>                        UIRenderableList;                                  // 0x0338(0x0010)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, ContainsInstancedReference, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UUIItem*>                        UIItemList;                                        // 0x0348(0x0010)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, ContainsInstancedReference, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_358[0x80];                                     // 0x0358(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class ULGUICanvas>>     ChildrenCanvasArray;                               // 0x03D8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E8[0x8];                                      // 0x03E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RequestUpdateForRenderTarget();
	void SetBlendDepth(float Value);
	void SetClipTexture(class UTexture2D* newTexture);
	void SetClipType(ELGUICanvasClipType newClipType);
	void SetCustomClip(class ULGUICanvasCustomClip* Value);
	void SetDefaultMaterials(const TArray<class UMaterialInterface*>& InMaterialArray);
	void SetDefaultMeshType(TSubclassOf<class ULGUIMeshComponent> InValue);
	void SetDepthFade(int32 Value);
	void SetDynamicPixelsPerUnit(float NewValue);
	void SetEnableDepthTest(bool Value);
	void SetInheriRectClip(bool newBool);
	void SetOverrideFovAngle(bool InOverride, float InValue);
	void SetOverrideProjectionMatrix(bool InOverride, const struct FMatrix& InValue);
	void SetOverrideSorting(bool Value);
	void SetOverrideViewLoation(bool InOverride, const struct FVector& InValue);
	void SetOverrideViewRotation(bool InOverride, const struct FRotator& InValue);
	void SetPixelPerfect(bool Value);
	void SetProjectionParameters(ECameraProjectionMode InProjectionType, float InFovAngle, float InNearClipPlane, float InFarClipPlane);
	void SetRectClipFeather(const struct FVector2D& newFeather);
	void SetRectClipOffset(const struct FMargin& newOffset);
	void SetRenderMode(ELGUIRenderMode Value);
	void SetRenderTarget(class UTextureRenderTarget2D* Value);
	void SetRenderTargetResolutionScale(float Value);
	void SetRenderTargetSizeMode(ELGUICanvasRenderTargetSizeMode Value);
	void SetRenderTargetUpdateMode(ELGUICanvasRenderTargetUpdateMode Value);
	void SetSortOrder(int32 NewValue, bool propagateToChildrenCanvas);
	void SetSortOrderToHighestOfHierarchy(bool propagateToChildrenCanvas);
	void SetSortOrderToLowestOfHierarchy(bool propagateToChildrenCanvas);

	float GetActualBlendDepth() const;
	ELGUICanvasClipType GetActualClipType() const;
	class ULGUICanvasCustomClip* GetActualCustomClip() const;
	int32 GetActualDepthFade() const;
	float GetActualDynamicPixelsPerUnit() const;
	bool GetActualPixelPerfect() const;
	ELGUIRenderMode GetActualRenderMode() const;
	class UTextureRenderTarget2D* GetActualRenderTarget() const;
	float GetActualRenderTargetResolutionScale() const;
	ELGUICanvasRenderTargetSizeMode GetActualRenderTargetSizeMode() const;
	ELGUICanvasRenderTargetUpdateMode GetActualRenderTargetUpdateMode() const;
	int32 GetActualSortOrder() const;
	float GetBlendDepth() const;
	struct FVector2D GetClipFeather() const;
	class UTexture2D* GetClipTexture() const;
	ELGUICanvasClipType GetClipType() const;
	class ULGUICanvasCustomClip* GetCustomClip() const;
	TArray<class UMaterialInterface*> GetDefaultMaterials() const;
	TSubclassOf<class ULGUIMeshComponent> GetDefaultMeshType() const;
	int32 GetDepthFade() const;
	float GetDynamicPixelsPerUnit() const;
	bool GetEnableDepthTest() const;
	bool GetInheritRectClip() const;
	bool GetOverrideSorting() const;
	bool GetPixelPerfect() const;
	ELGUIRenderMode GetRenderMode() const;
	class UTextureRenderTarget2D* GetRenderTarget() const;
	float GetRenderTargetResolutionScale() const;
	ELGUICanvasRenderTargetSizeMode GetRenderTargetSizeMode() const;
	ELGUICanvasRenderTargetUpdateMode GetRenderTargetUpdateMode() const;
	bool GetRequireNormal() const;
	bool GetRequireTangent() const;
	bool GetRequireUV1() const;
	bool GetRequireUV2() const;
	bool GetRequireUV3() const;
	class ULGUICanvas* GetRootCanvas() const;
	int32 GetSortOrder() const;
	class UUIItem* GetUIItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUICanvas">();
	}
	static class ULGUICanvas* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUICanvas>();
	}
};
static_assert(alignof(ULGUICanvas) == 0x000010, "Wrong alignment on ULGUICanvas");
static_assert(sizeof(ULGUICanvas) == 0x0003F0, "Wrong size on ULGUICanvas");
static_assert(offsetof(ULGUICanvas, RootCanvas) == 0x0000E0, "Member 'ULGUICanvas::RootCanvas' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, ParentCanvas) == 0x0000E8, "Member 'ULGUICanvas::ParentCanvas' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, UIItem) == 0x0000F0, "Member 'ULGUICanvas::UIItem' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, renderMode) == 0x000108, "Member 'ULGUICanvas::renderMode' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, RenderTarget) == 0x000110, "Member 'ULGUICanvas::RenderTarget' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, RenderTargetUpdateMode) == 0x000118, "Member 'ULGUICanvas::RenderTargetUpdateMode' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, RenderTargetSizeMode) == 0x000119, "Member 'ULGUICanvas::RenderTargetSizeMode' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, RenderTargetResolutionScale) == 0x00011C, "Member 'ULGUICanvas::RenderTargetResolutionScale' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, pixelPerfect) == 0x000120, "Member 'ULGUICanvas::pixelPerfect' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, bOverrideSorting) == 0x000121, "Member 'ULGUICanvas::bOverrideSorting' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, SortOrder) == 0x000122, "Member 'ULGUICanvas::SortOrder' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, clipType) == 0x000124, "Member 'ULGUICanvas::clipType' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, clipFeather) == 0x000128, "Member 'ULGUICanvas::clipFeather' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, clipRectOffset) == 0x000138, "Member 'ULGUICanvas::clipRectOffset' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, ClipTexture) == 0x000148, "Member 'ULGUICanvas::ClipTexture' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, clipTextureHitTestThreshold) == 0x000150, "Member 'ULGUICanvas::clipTextureHitTestThreshold' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, inheritRectClip) == 0x000154, "Member 'ULGUICanvas::inheritRectClip' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, customClip) == 0x000158, "Member 'ULGUICanvas::customClip' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, dynamicPixelsPerUnit) == 0x000160, "Member 'ULGUICanvas::dynamicPixelsPerUnit' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, additionalShaderChannels) == 0x000164, "Member 'ULGUICanvas::additionalShaderChannels' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, DefaultMaterials) == 0x000168, "Member 'ULGUICanvas::DefaultMaterials' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, BlendDepth) == 0x000180, "Member 'ULGUICanvas::BlendDepth' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, depthFade) == 0x000184, "Member 'ULGUICanvas::depthFade' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, bEnableDepthTest) == 0x000188, "Member 'ULGUICanvas::bEnableDepthTest' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, OverrideParameters) == 0x000189, "Member 'ULGUICanvas::OverrideParameters' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, DefaultMeshType) == 0x000190, "Member 'ULGUICanvas::DefaultMeshType' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, UIMesh) == 0x000300, "Member 'ULGUICanvas::UIMesh' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, PooledUIMaterialList) == 0x000308, "Member 'ULGUICanvas::PooledUIMaterialList' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, UIRenderableList) == 0x000338, "Member 'ULGUICanvas::UIRenderableList' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, UIItemList) == 0x000348, "Member 'ULGUICanvas::UIItemList' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, ChildrenCanvasArray) == 0x0003D8, "Member 'ULGUICanvas::ChildrenCanvasArray' has a wrong offset!");

// Class LGUI.LGUICanvasCustomClip
// 0x0058 (0x0080 - 0x0028)
class ULGUICanvasCustomClip : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UMaterialInterface*, class UMaterialInterface*> replaceMaterialMap;                   // 0x0030(0x0050)(Edit, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void ReceiveApplyMaterialParameter(class UMaterialInstanceDynamic* InMaterial, class ULGUICanvas* InCanvas, class UUIItem* InUIItem);
	bool ReceiveCheckPointVisible(const struct FVector& InWorldPoint, class ULGUICanvas* InCanvas, class UUIItem* InUIItem);
	void ReceiveInit();
	bool ReceiveMaterialContainsClipParameter(class UMaterialInterface* InMaterial);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUICanvasCustomClip">();
	}
	static class ULGUICanvasCustomClip* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUICanvasCustomClip>();
	}
};
static_assert(alignof(ULGUICanvasCustomClip) == 0x000008, "Wrong alignment on ULGUICanvasCustomClip");
static_assert(sizeof(ULGUICanvasCustomClip) == 0x000080, "Wrong size on ULGUICanvasCustomClip");
static_assert(offsetof(ULGUICanvasCustomClip, replaceMaterialMap) == 0x000030, "Member 'ULGUICanvasCustomClip::replaceMaterialMap' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_PropertyWithWave
// 0x0020 (0x0048 - 0x0028)
class UUIEffectTextAnimation_PropertyWithWave : public UUIEffectTextAnimation_Property
{
public:
	float                                         Frequency;                                         // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Speed;                                             // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          flipDirection;                                     // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0xF];                                       // 0x0031(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIText*                                UIText;                                            // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetFrequency(float Value);

	float GetFrequency() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_PropertyWithWave">();
	}
	static class UUIEffectTextAnimation_PropertyWithWave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_PropertyWithWave>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_PropertyWithWave) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_PropertyWithWave");
static_assert(sizeof(UUIEffectTextAnimation_PropertyWithWave) == 0x000048, "Wrong size on UUIEffectTextAnimation_PropertyWithWave");
static_assert(offsetof(UUIEffectTextAnimation_PropertyWithWave, Frequency) == 0x000028, "Member 'UUIEffectTextAnimation_PropertyWithWave::Frequency' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_PropertyWithWave, Speed) == 0x00002C, "Member 'UUIEffectTextAnimation_PropertyWithWave::Speed' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_PropertyWithWave, flipDirection) == 0x000030, "Member 'UUIEffectTextAnimation_PropertyWithWave::flipDirection' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_PropertyWithWave, UIText) == 0x000040, "Member 'UUIEffectTextAnimation_PropertyWithWave::UIText' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_PositionWaveProperty
// 0x0018 (0x0060 - 0x0048)
class UUIEffectTextAnimation_PositionWaveProperty final : public UUIEffectTextAnimation_PropertyWithWave
{
public:
	struct FVector                                position;                                          // 0x0048(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetPosition(const struct FVector& Value);

	struct FVector GetPosition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_PositionWaveProperty">();
	}
	static class UUIEffectTextAnimation_PositionWaveProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_PositionWaveProperty>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_PositionWaveProperty) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_PositionWaveProperty");
static_assert(sizeof(UUIEffectTextAnimation_PositionWaveProperty) == 0x000060, "Wrong size on UUIEffectTextAnimation_PositionWaveProperty");
static_assert(offsetof(UUIEffectTextAnimation_PositionWaveProperty, position) == 0x000048, "Member 'UUIEffectTextAnimation_PositionWaveProperty::position' has a wrong offset!");

// Class LGUI.LGUICanvasCustomClip_Circle
// 0x0008 (0x0088 - 0x0080)
class ULGUICanvasCustomClip_Circle final : public ULGUICanvasCustomClip
{
public:
	float                                         sizeMultiply;                                      // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSizeMultiply(float Value);

	float GetSizeMultiply() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUICanvasCustomClip_Circle">();
	}
	static class ULGUICanvasCustomClip_Circle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUICanvasCustomClip_Circle>();
	}
};
static_assert(alignof(ULGUICanvasCustomClip_Circle) == 0x000008, "Wrong alignment on ULGUICanvasCustomClip_Circle");
static_assert(sizeof(ULGUICanvasCustomClip_Circle) == 0x000088, "Wrong size on ULGUICanvasCustomClip_Circle");
static_assert(offsetof(ULGUICanvasCustomClip_Circle, sizeMultiply) == 0x000080, "Member 'ULGUICanvasCustomClip_Circle::sizeMultiply' has a wrong offset!");

// Class LGUI.LGUICanvasCustomClip_RoundedRect
// 0x0020 (0x00A0 - 0x0080)
class ULGUICanvasCustomClip_RoundedRect final : public ULGUICanvasCustomClip
{
public:
	struct FVector4f                              CornerRadius;                                      // 0x0080(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELGUICanvasCustomClip_RoundedRect_UnitMode    CornerRadiusUnitMode;                              // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_91[0xF];                                       // 0x0091(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCornerRadius(const struct FVector4f& Value);
	void SetCornerRadiusUnitMode(ELGUICanvasCustomClip_RoundedRect_UnitMode Value);

	struct FVector4f GetCornerRadius() const;
	ELGUICanvasCustomClip_RoundedRect_UnitMode GetCornerRadiusUnitMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUICanvasCustomClip_RoundedRect">();
	}
	static class ULGUICanvasCustomClip_RoundedRect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUICanvasCustomClip_RoundedRect>();
	}
};
static_assert(alignof(ULGUICanvasCustomClip_RoundedRect) == 0x000010, "Wrong alignment on ULGUICanvasCustomClip_RoundedRect");
static_assert(sizeof(ULGUICanvasCustomClip_RoundedRect) == 0x0000A0, "Wrong size on ULGUICanvasCustomClip_RoundedRect");
static_assert(offsetof(ULGUICanvasCustomClip_RoundedRect, CornerRadius) == 0x000080, "Member 'ULGUICanvasCustomClip_RoundedRect::CornerRadius' has a wrong offset!");
static_assert(offsetof(ULGUICanvasCustomClip_RoundedRect, CornerRadiusUnitMode) == 0x000090, "Member 'ULGUICanvasCustomClip_RoundedRect::CornerRadiusUnitMode' has a wrong offset!");

// Class LGUI.LGUIProceduralRectData
// 0x0060 (0x0088 - 0x0028)
class ULGUIProceduralRectData final : public UObject
{
public:
	class UMaterialInterface*                     DefaultMaterials[0x3];                             // 0x0028(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture*                               Texture;                                           // 0x0040(0x0008)(Edit, ZeroConstructor, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x40];                                      // 0x0048(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIProceduralRectData">();
	}
	static class ULGUIProceduralRectData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIProceduralRectData>();
	}
};
static_assert(alignof(ULGUIProceduralRectData) == 0x000008, "Wrong alignment on ULGUIProceduralRectData");
static_assert(sizeof(ULGUIProceduralRectData) == 0x000088, "Wrong size on ULGUIProceduralRectData");
static_assert(offsetof(ULGUIProceduralRectData, DefaultMaterials) == 0x000028, "Member 'ULGUIProceduralRectData::DefaultMaterials' has a wrong offset!");
static_assert(offsetof(ULGUIProceduralRectData, Texture) == 0x000040, "Member 'ULGUIProceduralRectData::Texture' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_ScaleProperty
// 0x0018 (0x0060 - 0x0048)
class UUIEffectTextAnimation_ScaleProperty final : public UUIEffectTextAnimation_PropertyWithEase
{
public:
	struct FVector                                Scale;                                             // 0x0048(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetScale(const struct FVector& Value);

	struct FVector GetScale() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_ScaleProperty">();
	}
	static class UUIEffectTextAnimation_ScaleProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_ScaleProperty>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_ScaleProperty) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_ScaleProperty");
static_assert(sizeof(UUIEffectTextAnimation_ScaleProperty) == 0x000060, "Wrong size on UUIEffectTextAnimation_ScaleProperty");
static_assert(offsetof(UUIEffectTextAnimation_ScaleProperty, Scale) == 0x000048, "Member 'UUIEffectTextAnimation_ScaleProperty::Scale' has a wrong offset!");

// Class LGUI.LGUICanvasScalerCustomScale
// 0x0000 (0x0028 - 0x0028)
class ULGUICanvasScalerCustomScale final : public UObject
{
public:
	void ReceiveCalculateSizeAndScale(class ULGUICanvasScaler* InCanvasScaler, const struct FIntPoint& InViewportSize, struct FIntPoint* OutLGUICanvasSize, float* OutScale);
	void ReceiveInit(class ULGUICanvasScaler* InCanvasScaler);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUICanvasScalerCustomScale">();
	}
	static class ULGUICanvasScalerCustomScale* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUICanvasScalerCustomScale>();
	}
};
static_assert(alignof(ULGUICanvasScalerCustomScale) == 0x000008, "Wrong alignment on ULGUICanvasScalerCustomScale");
static_assert(sizeof(ULGUICanvasScalerCustomScale) == 0x000028, "Wrong size on ULGUICanvasScalerCustomScale");

// Class LGUI.LGUILifeCycleBehaviour
// 0x0028 (0x00C8 - 0x00A0)
class ULGUILifeCycleBehaviour : public UActorComponent
{
public:
	bool                                          Enable;                                            // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x1B];                                      // 0x00A1(0x001B)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class USceneComponent>         RootComp;                                          // 0x00BC(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AActor* InstantiateActor(class AActor* OriginObject, class USceneComponent* Parent);
	class AActor* InstantiatePrefab(class ULGUIPrefab* OriginObject, class USceneComponent* Parent);
	class AActor* InstantiatePrefabWithTransform(class ULGUIPrefab* OriginObject, class USceneComponent* Parent, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale);
	void ReceiveAwake();
	void ReceiveOnDestroy();
	void ReceiveOnDisable();
	void ReceiveOnEnable();
	void ReceiveStart();
	void ReceiveUpdate(float DeltaTime);
	void SetCanExecuteUpdate(bool Value);
	void SetEnable(bool Value);

	bool GetEnable() const;
	bool GetIsActiveAndEnable() const;
	class USceneComponent* GetRootSceneComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUILifeCycleBehaviour">();
	}
	static class ULGUILifeCycleBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUILifeCycleBehaviour>();
	}
};
static_assert(alignof(ULGUILifeCycleBehaviour) == 0x000008, "Wrong alignment on ULGUILifeCycleBehaviour");
static_assert(sizeof(ULGUILifeCycleBehaviour) == 0x0000C8, "Wrong size on ULGUILifeCycleBehaviour");
static_assert(offsetof(ULGUILifeCycleBehaviour, Enable) == 0x0000A0, "Member 'ULGUILifeCycleBehaviour::Enable' has a wrong offset!");
static_assert(offsetof(ULGUILifeCycleBehaviour, RootComp) == 0x0000BC, "Member 'ULGUILifeCycleBehaviour::RootComp' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_Selector
// 0x0010 (0x0038 - 0x0028)
class UUIEffectTextAnimation_Selector : public UObject
{
public:
	float                                         Offset;                                            // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C[0xC];                                       // 0x002C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetOffset(float Value);

	float GetOffset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_Selector">();
	}
	static class UUIEffectTextAnimation_Selector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_Selector>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_Selector) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_Selector");
static_assert(sizeof(UUIEffectTextAnimation_Selector) == 0x000038, "Wrong size on UUIEffectTextAnimation_Selector");
static_assert(offsetof(UUIEffectTextAnimation_Selector, Offset) == 0x000028, "Member 'UUIEffectTextAnimation_Selector::Offset' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_RandomSelector
// 0x0010 (0x0048 - 0x0038)
class UUIEffectTextAnimation_RandomSelector final : public UUIEffectTextAnimation_Selector
{
public:
	int32                                         Seed;                                              // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Start;                                             // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         End;                                               // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEnd(float Value);
	void SetSeed(int32 Value);
	void SetStart(float Value);

	float GetEnd() const;
	int32 GetSeed() const;
	float GetStart() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_RandomSelector">();
	}
	static class UUIEffectTextAnimation_RandomSelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_RandomSelector>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_RandomSelector) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_RandomSelector");
static_assert(sizeof(UUIEffectTextAnimation_RandomSelector) == 0x000048, "Wrong size on UUIEffectTextAnimation_RandomSelector");
static_assert(offsetof(UUIEffectTextAnimation_RandomSelector, Seed) == 0x000038, "Member 'UUIEffectTextAnimation_RandomSelector::Seed' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_RandomSelector, Start) == 0x00003C, "Member 'UUIEffectTextAnimation_RandomSelector::Start' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_RandomSelector, End) == 0x000040, "Member 'UUIEffectTextAnimation_RandomSelector::End' has a wrong offset!");

// Class LGUI.LGUICanvasScaler
// 0x0050 (0x0118 - 0x00C8)
class ULGUICanvasScaler final : public ULGUILifeCycleBehaviour
{
public:
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ECameraProjectionMode                         ProjectionType;                                    // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FOVAngle;                                          // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NearClipPlane;                                     // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FarClipPlane;                                      // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELGUICanvasScaleMode                          UIScaleMode;                                       // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ReferenceResolution;                               // 0x00E8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MatchFromWidthToHeight;                            // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELGUICanvasScreenMatchMode                    ScreenMatchMode;                                   // 0x00FC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ULGUICanvasScalerCustomScale*           CustomScale;                                       // 0x0100(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_108[0x10];                                     // 0x0108(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceUpdate();
	float GetMatchFromWidthToHeight();
	struct FVector2D GetReferenceResolution();
	ELGUICanvasScreenMatchMode GetScreenMatchMode();
	ELGUICanvasScaleMode GetUIScaleMode();
	void SetCustomScale(class ULGUICanvasScalerCustomScale* Value);
	void SetFarClipPlane(float Value);
	void SetFovAngle(float Value);
	void SetMatchFromWidthToHeight(float Value);
	void SetNearClipPlane(float Value);
	void SetProjectionType(ECameraProjectionMode Value);
	void SetReferenceResolution(const struct FVector2D& Value);
	void SetScreenMatchMode(ELGUICanvasScreenMatchMode Value);
	void SetUIScaleMode(ELGUICanvasScaleMode Value);

	struct FVector2D ConvertPositionFromLGUICanvasToViewport(const struct FVector2D& position) const;
	struct FVector2D ConvertPositionFromViewportToLGUICanvas(const struct FVector2D& position) const;
	class ULGUICanvasScalerCustomScale* GetCustomScale() const;
	float GetFarClipPlane() const;
	float GetFOVAngle() const;
	float GetNearClipPlane() const;
	ECameraProjectionMode GetProjectionType() const;
	bool Project3DToScreen(const struct FVector& Position3D, struct FVector2D* OutPosition2D) const;
	bool ProjectWorldToScreen(class APlayerController* Player, const struct FVector& Position3D, struct FVector2D* OutPosition2D) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUICanvasScaler">();
	}
	static class ULGUICanvasScaler* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUICanvasScaler>();
	}
};
static_assert(alignof(ULGUICanvasScaler) == 0x000008, "Wrong alignment on ULGUICanvasScaler");
static_assert(sizeof(ULGUICanvasScaler) == 0x000118, "Wrong size on ULGUICanvasScaler");
static_assert(offsetof(ULGUICanvasScaler, ProjectionType) == 0x0000D0, "Member 'ULGUICanvasScaler::ProjectionType' has a wrong offset!");
static_assert(offsetof(ULGUICanvasScaler, FOVAngle) == 0x0000D4, "Member 'ULGUICanvasScaler::FOVAngle' has a wrong offset!");
static_assert(offsetof(ULGUICanvasScaler, NearClipPlane) == 0x0000D8, "Member 'ULGUICanvasScaler::NearClipPlane' has a wrong offset!");
static_assert(offsetof(ULGUICanvasScaler, FarClipPlane) == 0x0000DC, "Member 'ULGUICanvasScaler::FarClipPlane' has a wrong offset!");
static_assert(offsetof(ULGUICanvasScaler, UIScaleMode) == 0x0000E0, "Member 'ULGUICanvasScaler::UIScaleMode' has a wrong offset!");
static_assert(offsetof(ULGUICanvasScaler, ReferenceResolution) == 0x0000E8, "Member 'ULGUICanvasScaler::ReferenceResolution' has a wrong offset!");
static_assert(offsetof(ULGUICanvasScaler, MatchFromWidthToHeight) == 0x0000F8, "Member 'ULGUICanvasScaler::MatchFromWidthToHeight' has a wrong offset!");
static_assert(offsetof(ULGUICanvasScaler, ScreenMatchMode) == 0x0000FC, "Member 'ULGUICanvasScaler::ScreenMatchMode' has a wrong offset!");
static_assert(offsetof(ULGUICanvasScaler, CustomScale) == 0x000100, "Member 'ULGUICanvasScaler::CustomScale' has a wrong offset!");

// Class LGUI.LGUIGeometryHelper
// 0x0008 (0x0030 - 0x0028)
class ULGUIGeometryHelper : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FVector2D CalculatePivotOffset(float InWidth, float InHeight, const struct FVector2D& InPivot);

	void AddTriangle(int32 Index0, int32 index1, int32 index2);
	void AddVertexFull(const struct FVector& position, const struct FColor& Color, const struct FVector2D& UV0, const struct FVector2D& UV1, const struct FVector2D& UV2, const struct FVector2D& UV3, const struct FVector& Normal, const struct FVector& Tangent);
	void AddVertexSimple(const struct FVector& position, const struct FColor& Color, const struct FVector2D& UV0);
	void AddVertexStruct(const struct FLGUIGeometryVertex& Vertex);
	void AddVertexTriangleStream(const TArray<struct FLGUIGeometryVertex>& InVertexTriangleStream);
	void Clear();
	void GetVertexTriangleStream(TArray<struct FLGUIGeometryVertex>* OutVertexTriangleStream);
	void SetMesh(const TArray<struct FLGUIGeometryVertex>& InVertices, const TArray<int32>& InIndices);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIGeometryHelper">();
	}
	static class ULGUIGeometryHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIGeometryHelper>();
	}
};
static_assert(alignof(ULGUIGeometryHelper) == 0x000008, "Wrong alignment on ULGUIGeometryHelper");
static_assert(sizeof(ULGUIGeometryHelper) == 0x000030, "Wrong size on ULGUIGeometryHelper");

// Class LGUI.UIBaseActor
// 0x0000 (0x0290 - 0x0290)
class AUIBaseActor : public AActor
{
public:
	class UUIItem* GetUIItem() const;
	class UUIItem* GetUIItem_BP() const;
	class UUIItem* GetUIItem_Impl() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBaseActor">();
	}
	static class AUIBaseActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIBaseActor>();
	}
};
static_assert(alignof(AUIBaseActor) == 0x000008, "Wrong alignment on AUIBaseActor");
static_assert(sizeof(AUIBaseActor) == 0x000290, "Wrong size on AUIBaseActor");

// Class LGUI.UIBaseRenderableActor
// 0x0000 (0x0290 - 0x0290)
class AUIBaseRenderableActor : public AUIBaseActor
{
public:
	class UUIBaseRenderable* GetUIRenderable() const;
	class UUIBaseRenderable* GetUIRenderable_BP() const;
	class UUIBaseRenderable* GetUIRenderable_Impl() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBaseRenderableActor">();
	}
	static class AUIBaseRenderableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIBaseRenderableActor>();
	}
};
static_assert(alignof(AUIBaseRenderableActor) == 0x000008, "Wrong alignment on AUIBaseRenderableActor");
static_assert(sizeof(AUIBaseRenderableActor) == 0x000290, "Wrong size on AUIBaseRenderableActor");

// Class LGUI.UIBasePostProcessActor
// 0x0000 (0x0290 - 0x0290)
class AUIBasePostProcessActor : public AUIBaseRenderableActor
{
public:
	class UUIPostProcessRenderable* GetUIPostProcessRenderable() const;
	class UUIPostProcessRenderable* GetUIPostProcessRenderable_BP() const;
	class UUIPostProcessRenderable* GetUIPostProcessRenderable_Impl() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBasePostProcessActor">();
	}
	static class AUIBasePostProcessActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIBasePostProcessActor>();
	}
};
static_assert(alignof(AUIBasePostProcessActor) == 0x000008, "Wrong alignment on AUIBasePostProcessActor");
static_assert(sizeof(AUIBasePostProcessActor) == 0x000290, "Wrong size on AUIBasePostProcessActor");

// Class LGUI.UIFrameCaptureActor
// 0x0008 (0x0298 - 0x0290)
class AUIFrameCaptureActor final : public AUIBasePostProcessActor
{
public:
	class UUIFrameCapture*                        UIFrameCapture;                                    // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UUIFrameCapture* GetUIFrameCapture() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFrameCaptureActor">();
	}
	static class AUIFrameCaptureActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIFrameCaptureActor>();
	}
};
static_assert(alignof(AUIFrameCaptureActor) == 0x000008, "Wrong alignment on AUIFrameCaptureActor");
static_assert(sizeof(AUIFrameCaptureActor) == 0x000298, "Wrong size on AUIFrameCaptureActor");
static_assert(offsetof(AUIFrameCaptureActor, UIFrameCapture) == 0x000290, "Member 'AUIFrameCaptureActor::UIFrameCapture' has a wrong offset!");

// Class LGUI.LGUICustomMesh
// 0x0000 (0x0030 - 0x0030)
class ULGUICustomMesh : public ULGUIGeometryHelper
{
public:
	void ReceiveOnFillMesh(class UUIBatchMeshRenderable* InRenderable, bool InTriangleChanged, bool InVertexPositionChanged, bool InVertexUVChanged, bool InVertexColorChanged);

	bool GetHitUVbyFaceIndex(const class UUIBatchMeshRenderable* InRenderable, const int32& InHitFaceIndex, const struct FVector& InHitPoint, struct FVector2D* OutHitUV) const;
	bool ReceiveGetHitUV(const class UUIBatchMeshRenderable* InRenderable, const int32& InHitFaceIndex, const struct FVector& InHitPoint, const struct FVector& InLineStart, const struct FVector& InLineEnd, struct FVector2D* OutHitUV) const;
	bool ReceiveSupportDrawcallBatching() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUICustomMesh">();
	}
	static class ULGUICustomMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUICustomMesh>();
	}
};
static_assert(alignof(ULGUICustomMesh) == 0x000008, "Wrong alignment on ULGUICustomMesh");
static_assert(sizeof(ULGUICustomMesh) == 0x000030, "Wrong size on ULGUICustomMesh");

// Class LGUI.LGUICustomMesh_Cylinder
// 0x0008 (0x0038 - 0x0030)
class ULGUICustomMesh_Cylinder final : public ULGUICustomMesh
{
public:
	float                                         CylinderArcAngle;                                  // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUICustomMesh_Cylinder">();
	}
	static class ULGUICustomMesh_Cylinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUICustomMesh_Cylinder>();
	}
};
static_assert(alignof(ULGUICustomMesh_Cylinder) == 0x000008, "Wrong alignment on ULGUICustomMesh_Cylinder");
static_assert(sizeof(ULGUICustomMesh_Cylinder) == 0x000038, "Wrong size on ULGUICustomMesh_Cylinder");
static_assert(offsetof(ULGUICustomMesh_Cylinder, CylinderArcAngle) == 0x000030, "Member 'ULGUICustomMesh_Cylinder::CylinderArcAngle' has a wrong offset!");

// Class LGUI.LGUILifeCycleUIBehaviour
// 0x0018 (0x00E0 - 0x00C8)
class ULGUILifeCycleUIBehaviour : public ULGUILifeCycleBehaviour
{
public:
	uint8                                         Pad_C8[0x10];                                      // 0x00C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UUIItem>                 RootUIComp;                                        // 0x00D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ReceiveOnUIActiveInHierarchy(bool activeOrInactive);
	void ReceiveOnUIAttachmentChanged();
	void ReceiveOnUIChildAcitveInHierarchy(class UUIItem* Child, bool ativeOrInactive);
	void ReceiveOnUIChildAttachmentChanged(class UUIItem* Child, bool attachOrDetach);
	void ReceiveOnUIChildDimensionsChanged(class UUIItem* Child, bool horizontalPositionChanged, bool verticalPositionChanged, bool widthChanged, bool heightChanged);
	void ReceiveOnUIChildHierarchyIndexChanged(class UUIItem* Child);
	void ReceiveOnUIDimensionsChanged(bool horizontalPositionChanged, bool verticalPositionChanged, bool widthChanged, bool heightChanged);
	void ReceiveOnUIInteractionStateChanged(bool interactableOrNot);

	bool CheckRootUIComponent() const;
	class UUIItem* GetRootComponent() const;
	class UUIItem* GetRootUIComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUILifeCycleUIBehaviour">();
	}
	static class ULGUILifeCycleUIBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUILifeCycleUIBehaviour>();
	}
};
static_assert(alignof(ULGUILifeCycleUIBehaviour) == 0x000008, "Wrong alignment on ULGUILifeCycleUIBehaviour");
static_assert(sizeof(ULGUILifeCycleUIBehaviour) == 0x0000E0, "Wrong size on ULGUILifeCycleUIBehaviour");
static_assert(offsetof(ULGUILifeCycleUIBehaviour, RootUIComp) == 0x0000D8, "Member 'ULGUILifeCycleUIBehaviour::RootUIComp' has a wrong offset!");

// Class LGUI.UILayoutBase
// 0x0010 (0x00F0 - 0x00E0)
class UUILayoutBase : public ULGUILifeCycleUIBehaviour
{
public:
	uint8                                         Pad_E0[0x10];                                      // 0x00E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MarkNeedRebuildLayout();
	void OnRebuildLayout();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILayoutBase">();
	}
	static class UUILayoutBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILayoutBase>();
	}
};
static_assert(alignof(UUILayoutBase) == 0x000008, "Wrong alignment on UUILayoutBase");
static_assert(sizeof(UUILayoutBase) == 0x0000F0, "Wrong size on UUILayoutBase");

// Class LGUI.LGUICustomMesh_CurvyPlane
// 0x0098 (0x00C8 - 0x0030)
class ULGUICustomMesh_CurvyPlane final : public ULGUICustomMesh
{
public:
	int32                                         Segment;                                           // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     ShapeCurve;                                        // 0x0038(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         CurveScale;                                        // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUICustomMesh_CurvyPlane">();
	}
	static class ULGUICustomMesh_CurvyPlane* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUICustomMesh_CurvyPlane>();
	}
};
static_assert(alignof(ULGUICustomMesh_CurvyPlane) == 0x000008, "Wrong alignment on ULGUICustomMesh_CurvyPlane");
static_assert(sizeof(ULGUICustomMesh_CurvyPlane) == 0x0000C8, "Wrong size on ULGUICustomMesh_CurvyPlane");
static_assert(offsetof(ULGUICustomMesh_CurvyPlane, Segment) == 0x000030, "Member 'ULGUICustomMesh_CurvyPlane::Segment' has a wrong offset!");
static_assert(offsetof(ULGUICustomMesh_CurvyPlane, ShapeCurve) == 0x000038, "Member 'ULGUICustomMesh_CurvyPlane::ShapeCurve' has a wrong offset!");
static_assert(offsetof(ULGUICustomMesh_CurvyPlane, CurveScale) == 0x0000C0, "Member 'ULGUICustomMesh_CurvyPlane::CurveScale' has a wrong offset!");

// Class LGUI.LGUIDynamicSpriteAtlasManager
// 0x0068 (0x0090 - 0x0028)
class ULGUIDynamicSpriteAtlasManager final : public UObject
{
public:
	TMap<class FName, struct FLGUIDynamicSpriteAtlasData> atlasMap;                                  // 0x0028(0x0050)(Edit, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x18];                                      // 0x0078(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void DisposeAtlasByPackingTag(class FName inPackingTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIDynamicSpriteAtlasManager">();
	}
	static class ULGUIDynamicSpriteAtlasManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIDynamicSpriteAtlasManager>();
	}
};
static_assert(alignof(ULGUIDynamicSpriteAtlasManager) == 0x000008, "Wrong alignment on ULGUIDynamicSpriteAtlasManager");
static_assert(sizeof(ULGUIDynamicSpriteAtlasManager) == 0x000090, "Wrong size on ULGUIDynamicSpriteAtlasManager");
static_assert(offsetof(ULGUIDynamicSpriteAtlasManager, atlasMap) == 0x000028, "Member 'ULGUIDynamicSpriteAtlasManager::atlasMap' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_ScaleWaveProperty
// 0x0018 (0x0060 - 0x0048)
class UUIEffectTextAnimation_ScaleWaveProperty final : public UUIEffectTextAnimation_PropertyWithWave
{
public:
	struct FVector                                Scale;                                             // 0x0048(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetScale(const struct FVector& Value);

	struct FVector GetScale() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_ScaleWaveProperty">();
	}
	static class UUIEffectTextAnimation_ScaleWaveProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_ScaleWaveProperty>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_ScaleWaveProperty) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_ScaleWaveProperty");
static_assert(sizeof(UUIEffectTextAnimation_ScaleWaveProperty) == 0x000060, "Wrong size on UUIEffectTextAnimation_ScaleWaveProperty");
static_assert(offsetof(UUIEffectTextAnimation_ScaleWaveProperty, Scale) == 0x000048, "Member 'UUIEffectTextAnimation_ScaleWaveProperty::Scale' has a wrong offset!");

// Class LGUI.LGUIEventSystem
// 0x00B0 (0x0150 - 0x00A0)
class ULGUIEventSystem final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x1];                                       // 0x00A0(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRayEventEnable;                                   // 0x00A1(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class ULGUIPointerEventData*>     pointerEventDataMap;                               // 0x00A8(0x0050)(Edit, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x48];                                      // 0x00F8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	ELGUIPointerInputType                         DefaultInputType;                                  // 0x0140(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELGUIEventFireType                            eventFireTypeForNavigation;                        // 0x0141(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_142[0x2];                                      // 0x0142(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         navigateInputInterval;                             // 0x0144(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         navigateInputIntervalForFirstTime;                 // 0x0148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ExecuteEvent_OnPointerBeginDrag(class USceneComponent* TargetRootComponent, class ULGUIPointerEventData* pointerEventData, ELGUIEventFireType eventFireType, bool AllowEventBubbleUp);
	static void ExecuteEvent_OnPointerClick(class USceneComponent* TargetRootComponent, class ULGUIPointerEventData* pointerEventData, ELGUIEventFireType eventFireType, bool AllowEventBubbleUp);
	static void ExecuteEvent_OnPointerDeselect(class USceneComponent* TargetRootComponent, class ULGUIBaseEventData* EventData, ELGUIEventFireType eventFireType, bool AllowEventBubbleUp);
	static void ExecuteEvent_OnPointerDown(class USceneComponent* TargetRootComponent, class ULGUIPointerEventData* pointerEventData, ELGUIEventFireType eventFireType, bool AllowEventBubbleUp);
	static void ExecuteEvent_OnPointerDrag(class USceneComponent* TargetRootComponent, class ULGUIPointerEventData* pointerEventData, ELGUIEventFireType eventFireType, bool AllowEventBubbleUp);
	static void ExecuteEvent_OnPointerDragDrop(class USceneComponent* TargetRootComponent, class ULGUIPointerEventData* pointerEventData, ELGUIEventFireType eventFireType, bool AllowEventBubbleUp);
	static void ExecuteEvent_OnPointerEndDrag(class USceneComponent* TargetRootComponent, class ULGUIPointerEventData* pointerEventData, ELGUIEventFireType eventFireType, bool AllowEventBubbleUp);
	static void ExecuteEvent_OnPointerEnter(class USceneComponent* TargetRootComponent, class ULGUIPointerEventData* pointerEventData, ELGUIEventFireType eventFireType, bool AllowEventBubbleUp);
	static void ExecuteEvent_OnPointerExit(class USceneComponent* TargetRootComponent, class ULGUIPointerEventData* pointerEventData, ELGUIEventFireType eventFireType, bool AllowEventBubbleUp);
	static void ExecuteEvent_OnPointerScroll(class USceneComponent* TargetRootComponent, class ULGUIPointerEventData* pointerEventData, ELGUIEventFireType eventFireType, bool AllowEventBubbleUp);
	static void ExecuteEvent_OnPointerSelect(class USceneComponent* TargetRootComponent, class ULGUIBaseEventData* EventData, ELGUIEventFireType eventFireType, bool AllowEventBubbleUp);
	static void ExecuteEvent_OnPointerUp(class USceneComponent* TargetRootComponent, class ULGUIPointerEventData* pointerEventData, ELGUIEventFireType eventFireType, bool AllowEventBubbleUp);
	static class ULGUIEventSystem* GetLGUIEventSystemInstance(class UObject* WorldContextObject);

	void ActivateNavigationInput(int32 InPointerID, class USceneComponent* InDefaultHighlightedComponent);
	void ClearEvent();
	class ULGUIBaseInputModule* GetCurrentInputModule();
	bool IsPointerOverUIByPointerID(int32 pointerID);
	struct FLGUIDelegateHandleWrapper RegisterGlobalListener(const TDelegate<void(class ULGUIBaseEventData* EventData)>& InDelegate);
	struct FLGUIDelegateHandleWrapper RegisterHitEvent(const TDelegate<void(bool isHit, const struct FHitResult& HitResult, class USceneComponent* HitComponent)>& InDelegate);
	struct FLGUIDelegateHandleWrapper RegisterInputChangeEvent(const TDelegate<void(int32 pointerID, ELGUIPointerInputType Type)>& pointerInputChange);
	void RemovePointerEventData(int32 pointerID);
	void SetHighlightedComponentForNavigation(class USceneComponent* InComp, int32 InPointerID);
	bool SetPointerInputTypeByPointerID(int32 InPointerID, ELGUIPointerInputType InInputType);
	void SetRaycastEnable(bool Enable, bool ClearEvent);
	void SetSelectComponent(class USceneComponent* InSelectComp, class ULGUIBaseEventData* EventData, ELGUIEventFireType eventFireType);
	void SetSelectComponentWithDefault(class USceneComponent* InSelectComp);
	void UnregisterGlobalListener(const struct FLGUIDelegateHandleWrapper& InHandle);
	void UnregisterHitEvent(const struct FLGUIDelegateHandleWrapper& InHandle);
	void UnregisterInputChangeEvent(const struct FLGUIDelegateHandleWrapper& delegateHandle);

	class USceneComponent* GetCurrentSelectedComponent(int32 InPointerID) const;
	class USceneComponent* GetHighlightedComponentForNavigation(int32 InPointerID) const;
	class ULGUIPointerEventData* GetPointerEventData(int32 pointerID, bool createIfNotExist) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIEventSystem">();
	}
	static class ULGUIEventSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIEventSystem>();
	}
};
static_assert(alignof(ULGUIEventSystem) == 0x000008, "Wrong alignment on ULGUIEventSystem");
static_assert(sizeof(ULGUIEventSystem) == 0x000150, "Wrong size on ULGUIEventSystem");
static_assert(offsetof(ULGUIEventSystem, bRayEventEnable) == 0x0000A1, "Member 'ULGUIEventSystem::bRayEventEnable' has a wrong offset!");
static_assert(offsetof(ULGUIEventSystem, pointerEventDataMap) == 0x0000A8, "Member 'ULGUIEventSystem::pointerEventDataMap' has a wrong offset!");
static_assert(offsetof(ULGUIEventSystem, DefaultInputType) == 0x000140, "Member 'ULGUIEventSystem::DefaultInputType' has a wrong offset!");
static_assert(offsetof(ULGUIEventSystem, eventFireTypeForNavigation) == 0x000141, "Member 'ULGUIEventSystem::eventFireTypeForNavigation' has a wrong offset!");
static_assert(offsetof(ULGUIEventSystem, navigateInputInterval) == 0x000144, "Member 'ULGUIEventSystem::navigateInputInterval' has a wrong offset!");
static_assert(offsetof(ULGUIEventSystem, navigateInputIntervalForFirstTime) == 0x000148, "Member 'ULGUIEventSystem::navigateInputIntervalForFirstTime' has a wrong offset!");

// Class LGUI.LGUIPlayTween
// 0x00C0 (0x00E8 - 0x0028)
class ULGUIPlayTween : public UObject
{
public:
	ELTweenLoop                                   loopType;                                          // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LoopCount;                                         // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELTweenEase                                   easetype;                                          // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            easeCurve;                                         // 0x0038(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Duration;                                          // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartDelay;                                        // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLGUIEventDelegate                     OnStart;                                           // 0x0048(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FLGUIEventDelegate                     onUpdateProgress;                                  // 0x0060(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FLGUIEventDelegate                     OnComplete;                                        // 0x0078(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FLGUIEventDelegate                     OnCycleComplete;                                   // 0x0090(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          affectByGamePause;                                 // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          affectByTimeDilation;                              // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ULTweener*                              tweener;                                           // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FLGUIDelegateHandleWrapper RegisterOnComplete(const TDelegate<void()>& InDelegate);
	struct FLGUIDelegateHandleWrapper RegisterOnCycleComplete(const TDelegate<void(int32 InCycleCompleteCount)>& InDelegate);
	void Start();
	void Stop();
	void UnregisterOnComplete(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	void UnregisterOnCycleComplete(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);

	class ULTweener* GetTweener() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPlayTween">();
	}
	static class ULGUIPlayTween* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPlayTween>();
	}
};
static_assert(alignof(ULGUIPlayTween) == 0x000008, "Wrong alignment on ULGUIPlayTween");
static_assert(sizeof(ULGUIPlayTween) == 0x0000E8, "Wrong size on ULGUIPlayTween");
static_assert(offsetof(ULGUIPlayTween, loopType) == 0x000028, "Member 'ULGUIPlayTween::loopType' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween, LoopCount) == 0x00002C, "Member 'ULGUIPlayTween::LoopCount' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween, easetype) == 0x000030, "Member 'ULGUIPlayTween::easetype' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween, easeCurve) == 0x000038, "Member 'ULGUIPlayTween::easeCurve' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween, Duration) == 0x000040, "Member 'ULGUIPlayTween::Duration' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween, StartDelay) == 0x000044, "Member 'ULGUIPlayTween::StartDelay' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween, OnStart) == 0x000048, "Member 'ULGUIPlayTween::OnStart' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween, onUpdateProgress) == 0x000060, "Member 'ULGUIPlayTween::onUpdateProgress' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween, OnComplete) == 0x000078, "Member 'ULGUIPlayTween::OnComplete' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween, OnCycleComplete) == 0x000090, "Member 'ULGUIPlayTween::OnCycleComplete' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween, affectByGamePause) == 0x0000A8, "Member 'ULGUIPlayTween::affectByGamePause' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween, affectByTimeDilation) == 0x0000A9, "Member 'ULGUIPlayTween::affectByTimeDilation' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween, tweener) == 0x0000B0, "Member 'ULGUIPlayTween::tweener' has a wrong offset!");

// Class LGUI.LGUIPlayTween_Color
// 0x0020 (0x0108 - 0x00E8)
class ULGUIPlayTween_Color final : public ULGUIPlayTween
{
public:
	struct FColor                                 From;                                              // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 To;                                                // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLGUIEventDelegate                     onUpdateValue;                                     // 0x00F0(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPlayTween_Color">();
	}
	static class ULGUIPlayTween_Color* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPlayTween_Color>();
	}
};
static_assert(alignof(ULGUIPlayTween_Color) == 0x000008, "Wrong alignment on ULGUIPlayTween_Color");
static_assert(sizeof(ULGUIPlayTween_Color) == 0x000108, "Wrong size on ULGUIPlayTween_Color");
static_assert(offsetof(ULGUIPlayTween_Color, From) == 0x0000E8, "Member 'ULGUIPlayTween_Color::From' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Color, To) == 0x0000EC, "Member 'ULGUIPlayTween_Color::To' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Color, onUpdateValue) == 0x0000F0, "Member 'ULGUIPlayTween_Color::onUpdateValue' has a wrong offset!");

// Class LGUI.LGUIEventSystemActor
// 0x0008 (0x0298 - 0x0290)
class ALGUIEventSystemActor final : public AActor
{
public:
	class ULGUIEventSystem*                       EventSystem;                                       // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIEventSystemActor">();
	}
	static class ALGUIEventSystemActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALGUIEventSystemActor>();
	}
};
static_assert(alignof(ALGUIEventSystemActor) == 0x000008, "Wrong alignment on ALGUIEventSystemActor");
static_assert(sizeof(ALGUIEventSystemActor) == 0x000298, "Wrong size on ALGUIEventSystemActor");
static_assert(offsetof(ALGUIEventSystemActor, EventSystem) == 0x000290, "Member 'ALGUIEventSystemActor::EventSystem' has a wrong offset!");

// Class LGUI.UIFlexibleGridLayoutElement
// 0x0020 (0x0100 - 0x00E0)
class UUIFlexibleGridLayoutElement final : public ULGUILifeCycleUIBehaviour
{
public:
	int32                                         RowIndex;                                          // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RowCount;                                          // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ColumnIndex;                                       // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ColumnCount;                                       // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreLayout;                                     // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIFlexibleGridLayout*                  ParentLayout;                                      // 0x00F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetColumnCount(int32 Value);
	void SetColumnIndex(int32 Value);
	void SetIgnoreLayout(bool Value);
	void SetRowCount(int32 Value);
	void SetRowIndex(int32 Value);

	int32 GetColumnCount() const;
	int32 GetColumnIndex() const;
	bool GetIgnoreLayout() const;
	int32 GetRowCount() const;
	int32 GetRowIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFlexibleGridLayoutElement">();
	}
	static class UUIFlexibleGridLayoutElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFlexibleGridLayoutElement>();
	}
};
static_assert(alignof(UUIFlexibleGridLayoutElement) == 0x000008, "Wrong alignment on UUIFlexibleGridLayoutElement");
static_assert(sizeof(UUIFlexibleGridLayoutElement) == 0x000100, "Wrong size on UUIFlexibleGridLayoutElement");
static_assert(offsetof(UUIFlexibleGridLayoutElement, RowIndex) == 0x0000E0, "Member 'UUIFlexibleGridLayoutElement::RowIndex' has a wrong offset!");
static_assert(offsetof(UUIFlexibleGridLayoutElement, RowCount) == 0x0000E4, "Member 'UUIFlexibleGridLayoutElement::RowCount' has a wrong offset!");
static_assert(offsetof(UUIFlexibleGridLayoutElement, ColumnIndex) == 0x0000E8, "Member 'UUIFlexibleGridLayoutElement::ColumnIndex' has a wrong offset!");
static_assert(offsetof(UUIFlexibleGridLayoutElement, ColumnCount) == 0x0000EC, "Member 'UUIFlexibleGridLayoutElement::ColumnCount' has a wrong offset!");
static_assert(offsetof(UUIFlexibleGridLayoutElement, bIgnoreLayout) == 0x0000F0, "Member 'UUIFlexibleGridLayoutElement::bIgnoreLayout' has a wrong offset!");
static_assert(offsetof(UUIFlexibleGridLayoutElement, ParentLayout) == 0x0000F8, "Member 'UUIFlexibleGridLayoutElement::ParentLayout' has a wrong offset!");

// Class LGUI.LGUIFontData_BaseObject
// 0x0000 (0x0028 - 0x0028)
class ULGUIFontData_BaseObject : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIFontData_BaseObject">();
	}
	static class ULGUIFontData_BaseObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIFontData_BaseObject>();
	}
};
static_assert(alignof(ULGUIFontData_BaseObject) == 0x000008, "Wrong alignment on ULGUIFontData_BaseObject");
static_assert(sizeof(ULGUIFontData_BaseObject) == 0x000028, "Wrong size on ULGUIFontData_BaseObject");

// Class LGUI.LGUINavigationInterface
// 0x0000 (0x0000 - 0x0000)
class ILGUINavigationInterface final
{
public:
	bool OnNavigate(ELGUINavigationDirection Direction, TScriptInterface<class ILGUINavigationInterface>* Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUINavigationInterface">();
	}
	static class ILGUINavigationInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILGUINavigationInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILGUINavigationInterface) == 0x000001, "Wrong alignment on ILGUINavigationInterface");
static_assert(sizeof(ILGUINavigationInterface) == 0x000001, "Wrong size on ILGUINavigationInterface");

// Class LGUI.LGUIFreeTypeRenderFontData
// 0x00E8 (0x0110 - 0x0028)
class ULGUIFreeTypeRenderFontData : public ULGUIFontData_BaseObject
{
public:
	ELGUIDynamicFontDataType                      fontType;                                          // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 fontFilePath;                                      // 0x0030(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          useRelativeFilePath;                               // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          useExternalFileOrEmbedInToUAsset;                  // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UFontFace*                              unrealFont;                                        // 0x0048(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FontFace;                                          // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELGUIDynamicFontLineHeightType                lineHeightType;                                    // 0x0054(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          hasKerning;                                        // 0x0055(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELGUIAtlasTextureSizeType                     initialSize;                                       // 0x0056(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_57[0x1];                                       // 0x0057(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         rectPackCellSize;                                  // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Texture;                                           // 0x0060(0x0008)(Edit, ZeroConstructor, Transient, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ULGUIFreeTypeRenderFontData*>    fallbackFontArray;                                 // 0x0068(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class UUIText>>         renderTextArray;                                   // 0x0078(0x0010)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<uint8>                                 fontBinaryArray;                                   // 0x0088(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0x78];                                      // 0x0098(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIFreeTypeRenderFontData">();
	}
	static class ULGUIFreeTypeRenderFontData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIFreeTypeRenderFontData>();
	}
};
static_assert(alignof(ULGUIFreeTypeRenderFontData) == 0x000008, "Wrong alignment on ULGUIFreeTypeRenderFontData");
static_assert(sizeof(ULGUIFreeTypeRenderFontData) == 0x000110, "Wrong size on ULGUIFreeTypeRenderFontData");
static_assert(offsetof(ULGUIFreeTypeRenderFontData, fontType) == 0x000028, "Member 'ULGUIFreeTypeRenderFontData::fontType' has a wrong offset!");
static_assert(offsetof(ULGUIFreeTypeRenderFontData, fontFilePath) == 0x000030, "Member 'ULGUIFreeTypeRenderFontData::fontFilePath' has a wrong offset!");
static_assert(offsetof(ULGUIFreeTypeRenderFontData, useRelativeFilePath) == 0x000040, "Member 'ULGUIFreeTypeRenderFontData::useRelativeFilePath' has a wrong offset!");
static_assert(offsetof(ULGUIFreeTypeRenderFontData, useExternalFileOrEmbedInToUAsset) == 0x000041, "Member 'ULGUIFreeTypeRenderFontData::useExternalFileOrEmbedInToUAsset' has a wrong offset!");
static_assert(offsetof(ULGUIFreeTypeRenderFontData, unrealFont) == 0x000048, "Member 'ULGUIFreeTypeRenderFontData::unrealFont' has a wrong offset!");
static_assert(offsetof(ULGUIFreeTypeRenderFontData, FontFace) == 0x000050, "Member 'ULGUIFreeTypeRenderFontData::FontFace' has a wrong offset!");
static_assert(offsetof(ULGUIFreeTypeRenderFontData, lineHeightType) == 0x000054, "Member 'ULGUIFreeTypeRenderFontData::lineHeightType' has a wrong offset!");
static_assert(offsetof(ULGUIFreeTypeRenderFontData, hasKerning) == 0x000055, "Member 'ULGUIFreeTypeRenderFontData::hasKerning' has a wrong offset!");
static_assert(offsetof(ULGUIFreeTypeRenderFontData, initialSize) == 0x000056, "Member 'ULGUIFreeTypeRenderFontData::initialSize' has a wrong offset!");
static_assert(offsetof(ULGUIFreeTypeRenderFontData, rectPackCellSize) == 0x000058, "Member 'ULGUIFreeTypeRenderFontData::rectPackCellSize' has a wrong offset!");
static_assert(offsetof(ULGUIFreeTypeRenderFontData, Texture) == 0x000060, "Member 'ULGUIFreeTypeRenderFontData::Texture' has a wrong offset!");
static_assert(offsetof(ULGUIFreeTypeRenderFontData, fallbackFontArray) == 0x000068, "Member 'ULGUIFreeTypeRenderFontData::fallbackFontArray' has a wrong offset!");
static_assert(offsetof(ULGUIFreeTypeRenderFontData, renderTextArray) == 0x000078, "Member 'ULGUIFreeTypeRenderFontData::renderTextArray' has a wrong offset!");
static_assert(offsetof(ULGUIFreeTypeRenderFontData, fontBinaryArray) == 0x000088, "Member 'ULGUIFreeTypeRenderFontData::fontBinaryArray' has a wrong offset!");

// Class LGUI.UIPanelLayoutSlotBase
// 0x0018 (0x0040 - 0x0028)
class UUIPanelLayoutSlotBase : public UObject
{
public:
	struct FVector2D                              DesiredSize;                                       // 0x0028(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreLayout;                                     // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDesiredSize(const struct FVector2D& Value);
	void SetIgnoreLayout(bool Value);

	struct FVector2D GetDesiredSize() const;
	bool GetIgnoreLayout() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPanelLayoutSlotBase">();
	}
	static class UUIPanelLayoutSlotBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPanelLayoutSlotBase>();
	}
};
static_assert(alignof(UUIPanelLayoutSlotBase) == 0x000008, "Wrong alignment on UUIPanelLayoutSlotBase");
static_assert(sizeof(UUIPanelLayoutSlotBase) == 0x000040, "Wrong size on UUIPanelLayoutSlotBase");
static_assert(offsetof(UUIPanelLayoutSlotBase, DesiredSize) == 0x000028, "Member 'UUIPanelLayoutSlotBase::DesiredSize' has a wrong offset!");
static_assert(offsetof(UUIPanelLayoutSlotBase, bIgnoreLayout) == 0x000038, "Member 'UUIPanelLayoutSlotBase::bIgnoreLayout' has a wrong offset!");

// Class LGUI.LGUIFontData
// 0x0060 (0x0170 - 0x0110)
class ULGUIFontData final : public ULGUIFreeTypeRenderFontData
{
public:
	float                                         italicAngle;                                       // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         boldRatio;                                         // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_118[0x58];                                     // 0x0118(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIFontData">();
	}
	static class ULGUIFontData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIFontData>();
	}
};
static_assert(alignof(ULGUIFontData) == 0x000008, "Wrong alignment on ULGUIFontData");
static_assert(sizeof(ULGUIFontData) == 0x000170, "Wrong size on ULGUIFontData");
static_assert(offsetof(ULGUIFontData, italicAngle) == 0x000110, "Member 'ULGUIFontData::italicAngle' has a wrong offset!");
static_assert(offsetof(ULGUIFontData, boldRatio) == 0x000114, "Member 'ULGUIFontData::boldRatio' has a wrong offset!");

// Class LGUI.LGUIImageSequencePlayer
// 0x0028 (0x00C8 - 0x00A0)
class ULGUIImageSequencePlayer : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FPS;                                               // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Loop;                                              // 0x00AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          playOnStart;                                       // 0x00AD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          affectByGamePause;                                 // 0x00AE(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          affectByTimeDilation;                              // 0x00AF(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0x18];                                      // 0x00B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Pause();
	void Play();
	void SeekFrame(int32 FrameNumber);
	void SeekTime(float Time);
	void SetFps(float Value);
	void SetLoop(bool Value);
	void Stop();

	float GetDuration() const;
	float GetFps() const;
	bool GetIsPlaying() const;
	bool GetLoop() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIImageSequencePlayer">();
	}
	static class ULGUIImageSequencePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIImageSequencePlayer>();
	}
};
static_assert(alignof(ULGUIImageSequencePlayer) == 0x000008, "Wrong alignment on ULGUIImageSequencePlayer");
static_assert(sizeof(ULGUIImageSequencePlayer) == 0x0000C8, "Wrong size on ULGUIImageSequencePlayer");
static_assert(offsetof(ULGUIImageSequencePlayer, FPS) == 0x0000A8, "Member 'ULGUIImageSequencePlayer::FPS' has a wrong offset!");
static_assert(offsetof(ULGUIImageSequencePlayer, Loop) == 0x0000AC, "Member 'ULGUIImageSequencePlayer::Loop' has a wrong offset!");
static_assert(offsetof(ULGUIImageSequencePlayer, playOnStart) == 0x0000AD, "Member 'ULGUIImageSequencePlayer::playOnStart' has a wrong offset!");
static_assert(offsetof(ULGUIImageSequencePlayer, affectByGamePause) == 0x0000AE, "Member 'ULGUIImageSequencePlayer::affectByGamePause' has a wrong offset!");
static_assert(offsetof(ULGUIImageSequencePlayer, affectByTimeDilation) == 0x0000AF, "Member 'ULGUIImageSequencePlayer::affectByTimeDilation' has a wrong offset!");

// Class LGUI.UILayoutWithAnimation
// 0x0028 (0x0118 - 0x00F0)
class UUILayoutWithAnimation : public UUILayoutBase
{
public:
	EUILayoutAnimationType                        AnimationType;                                     // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimationDuration;                                 // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUILayoutWithAnimation_CustomAnimation* CustomAnimation;                                   // 0x00F8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ULTweener*>                      TweenerArray;                                      // 0x0100(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_110[0x8];                                      // 0x0110(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelAllAnimations(bool callComplete);
	void SetAnimationDuration(float Value);
	void SetAnimationType(EUILayoutAnimationType Value);
	void SetCustomAnimation(class UUILayoutWithAnimation_CustomAnimation* Value);

	float GetAnimationDuration() const;
	EUILayoutAnimationType GetAnimationType() const;
	class UUILayoutWithAnimation_CustomAnimation* GetCustomAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILayoutWithAnimation">();
	}
	static class UUILayoutWithAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILayoutWithAnimation>();
	}
};
static_assert(alignof(UUILayoutWithAnimation) == 0x000008, "Wrong alignment on UUILayoutWithAnimation");
static_assert(sizeof(UUILayoutWithAnimation) == 0x000118, "Wrong size on UUILayoutWithAnimation");
static_assert(offsetof(UUILayoutWithAnimation, AnimationType) == 0x0000F0, "Member 'UUILayoutWithAnimation::AnimationType' has a wrong offset!");
static_assert(offsetof(UUILayoutWithAnimation, AnimationDuration) == 0x0000F4, "Member 'UUILayoutWithAnimation::AnimationDuration' has a wrong offset!");
static_assert(offsetof(UUILayoutWithAnimation, CustomAnimation) == 0x0000F8, "Member 'UUILayoutWithAnimation::CustomAnimation' has a wrong offset!");
static_assert(offsetof(UUILayoutWithAnimation, TweenerArray) == 0x000100, "Member 'UUILayoutWithAnimation::TweenerArray' has a wrong offset!");

// Class LGUI.UILayoutWithChildren
// 0x0018 (0x0130 - 0x0118)
class UUILayoutWithChildren : public UUILayoutWithAnimation
{
public:
	uint8                                         Pad_118[0x18];                                     // 0x0118(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILayoutWithChildren">();
	}
	static class UUILayoutWithChildren* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILayoutWithChildren>();
	}
};
static_assert(alignof(UUILayoutWithChildren) == 0x000008, "Wrong alignment on UUILayoutWithChildren");
static_assert(sizeof(UUILayoutWithChildren) == 0x000130, "Wrong size on UUILayoutWithChildren");

// Class LGUI.UIGridLayout
// 0x0050 (0x0180 - 0x0130)
class UUIGridLayout final : public UUILayoutWithChildren
{
public:
	struct FMargin                                Padding;                                           // 0x0130(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              Spacing;                                           // 0x0140(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELGUILayoutAlignmentType                      Align;                                             // 0x0150(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          LastLineCanAlign;                                  // 0x0151(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          HorizontalOrVertical;                              // 0x0152(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DependOnSizeOrCount;                               // 0x0153(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ExpendChildSize;                                   // 0x0154(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_155[0x3];                                      // 0x0155(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              CellSize;                                          // 0x0158(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        LineCount;                                         // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          WidthFitToChildren;                                // 0x016C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          HeightFitToChildren;                               // 0x016D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16E[0x12];                                     // 0x016E(0x0012)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAlign(ELGUILayoutAlignmentType Value);
	void SetCellSize(const struct FVector2D& Value);
	void SetDependOnSizeOrCount(bool Value);
	void SetExpendChildSize(bool Value);
	void SetHeightFitToChildren(bool Value);
	void SetHorizontalOrVertical(bool Value);
	void SetLastLineCanAlign(bool Value);
	void SetMaxItemCountInOneLine(int32 Value);
	void SetPadding(const struct FMargin& Value);
	void SetSpacing(const struct FVector2D& Value);
	void SetWidthFitToChildren(bool Value);

	struct FVector2D GetActuralRange() const;
	ELGUILayoutAlignmentType GetAlign() const;
	struct FVector2D GetCellSize() const;
	bool GetDependOnSizeOrCount() const;
	bool GetExpendChildSize() const;
	bool GetHeightFitToChildren() const;
	bool GetHorizontalOrVertical() const;
	bool GetLastLineCanAlign() const;
	int32 GetMaxItemCountInOneLine() const;
	struct FMargin GetPadding() const;
	struct FVector2D GetSpacing() const;
	bool GetWidthFitToChildren() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGridLayout">();
	}
	static class UUIGridLayout* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGridLayout>();
	}
};
static_assert(alignof(UUIGridLayout) == 0x000008, "Wrong alignment on UUIGridLayout");
static_assert(sizeof(UUIGridLayout) == 0x000180, "Wrong size on UUIGridLayout");
static_assert(offsetof(UUIGridLayout, Padding) == 0x000130, "Member 'UUIGridLayout::Padding' has a wrong offset!");
static_assert(offsetof(UUIGridLayout, Spacing) == 0x000140, "Member 'UUIGridLayout::Spacing' has a wrong offset!");
static_assert(offsetof(UUIGridLayout, Align) == 0x000150, "Member 'UUIGridLayout::Align' has a wrong offset!");
static_assert(offsetof(UUIGridLayout, LastLineCanAlign) == 0x000151, "Member 'UUIGridLayout::LastLineCanAlign' has a wrong offset!");
static_assert(offsetof(UUIGridLayout, HorizontalOrVertical) == 0x000152, "Member 'UUIGridLayout::HorizontalOrVertical' has a wrong offset!");
static_assert(offsetof(UUIGridLayout, DependOnSizeOrCount) == 0x000153, "Member 'UUIGridLayout::DependOnSizeOrCount' has a wrong offset!");
static_assert(offsetof(UUIGridLayout, ExpendChildSize) == 0x000154, "Member 'UUIGridLayout::ExpendChildSize' has a wrong offset!");
static_assert(offsetof(UUIGridLayout, CellSize) == 0x000158, "Member 'UUIGridLayout::CellSize' has a wrong offset!");
static_assert(offsetof(UUIGridLayout, LineCount) == 0x000168, "Member 'UUIGridLayout::LineCount' has a wrong offset!");
static_assert(offsetof(UUIGridLayout, WidthFitToChildren) == 0x00016C, "Member 'UUIGridLayout::WidthFitToChildren' has a wrong offset!");
static_assert(offsetof(UUIGridLayout, HeightFitToChildren) == 0x00016D, "Member 'UUIGridLayout::HeightFitToChildren' has a wrong offset!");

// Class LGUI.LGUIPlayTween_Float
// 0x0020 (0x0108 - 0x00E8)
class ULGUIPlayTween_Float final : public ULGUIPlayTween
{
public:
	float                                         From;                                              // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         To;                                                // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLGUIEventDelegate                     onUpdateValue;                                     // 0x00F0(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPlayTween_Float">();
	}
	static class ULGUIPlayTween_Float* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPlayTween_Float>();
	}
};
static_assert(alignof(ULGUIPlayTween_Float) == 0x000008, "Wrong alignment on ULGUIPlayTween_Float");
static_assert(sizeof(ULGUIPlayTween_Float) == 0x000108, "Wrong size on ULGUIPlayTween_Float");
static_assert(offsetof(ULGUIPlayTween_Float, From) == 0x0000E8, "Member 'ULGUIPlayTween_Float::From' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Float, To) == 0x0000EC, "Member 'ULGUIPlayTween_Float::To' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Float, onUpdateValue) == 0x0000F0, "Member 'ULGUIPlayTween_Float::onUpdateValue' has a wrong offset!");

// Class LGUI.LGUIEditorManagerObject
// 0x0008 (0x0030 - 0x0028)
class ULGUIEditorManagerObject final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIEditorManagerObject">();
	}
	static class ULGUIEditorManagerObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIEditorManagerObject>();
	}
};
static_assert(alignof(ULGUIEditorManagerObject) == 0x000008, "Wrong alignment on ULGUIEditorManagerObject");
static_assert(sizeof(ULGUIEditorManagerObject) == 0x000030, "Wrong size on ULGUIEditorManagerObject");

// Class LGUI.LGUIManagerWorldSubsystem
// 0x0150 (0x0190 - 0x0040)
class ULGUIManagerWorldSubsystem final : public UTickableWorldSubsystem
{
public:
	TArray<TWeakObjectPtr<class UUIItem>>         AllRootUIItemArray;                                // 0x0040(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ULGUICanvas>>     ScreenSpaceCanvasArray;                            // 0x0050(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ULGUICanvas>>     WorldSpaceUECanvasArray;                           // 0x0060(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ULGUICanvas>>     WorldSpaceLGUICanvasArray;                         // 0x0070(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ULGUICanvas>>     RenderTargetSpaceLGUICanvasArray;                  // 0x0080(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ULGUIBaseRaycaster>> AllRaycasterArray;                              // 0x0090(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ULGUIBaseInputModule>    CurrentInputModule;                                // 0x00A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class UUISelectableComponent>> AllSelectableArray;                         // 0x00A8(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class UObject>>         AllLayoutArray;                                    // 0x00B8(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class UObject>>         AllCultureChangedArray;                            // 0x00C8(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class ULGUILifeCycleBehaviour>> LGUILifeCycleBehavioursForUpdate;          // 0x00E0(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ULGUILifeCycleBehaviour>> LGUILifeCycleBehavioursForStart;           // 0x00F0(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x90];                                     // 0x0100(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ForceUpdateLayout(class UObject* WorldContextObject);
	static void RebuildLayout(class UUIItem* InItem);
	static void RegisterLGUICultureChangedEvent(TScriptInterface<class ILGUICultureChangedInterface> InItem);
	static void RegisterLGUILayout(TScriptInterface<class ILGUILayoutInterface> InItem);
	static void UnregisterLGUICultureChangedEvent(TScriptInterface<class ILGUICultureChangedInterface> InItem);
	static void UnregisterLGUILayout(TScriptInterface<class ILGUILayoutInterface> InItem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIManagerWorldSubsystem">();
	}
	static class ULGUIManagerWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIManagerWorldSubsystem>();
	}
};
static_assert(alignof(ULGUIManagerWorldSubsystem) == 0x000008, "Wrong alignment on ULGUIManagerWorldSubsystem");
static_assert(sizeof(ULGUIManagerWorldSubsystem) == 0x000190, "Wrong size on ULGUIManagerWorldSubsystem");
static_assert(offsetof(ULGUIManagerWorldSubsystem, AllRootUIItemArray) == 0x000040, "Member 'ULGUIManagerWorldSubsystem::AllRootUIItemArray' has a wrong offset!");
static_assert(offsetof(ULGUIManagerWorldSubsystem, ScreenSpaceCanvasArray) == 0x000050, "Member 'ULGUIManagerWorldSubsystem::ScreenSpaceCanvasArray' has a wrong offset!");
static_assert(offsetof(ULGUIManagerWorldSubsystem, WorldSpaceUECanvasArray) == 0x000060, "Member 'ULGUIManagerWorldSubsystem::WorldSpaceUECanvasArray' has a wrong offset!");
static_assert(offsetof(ULGUIManagerWorldSubsystem, WorldSpaceLGUICanvasArray) == 0x000070, "Member 'ULGUIManagerWorldSubsystem::WorldSpaceLGUICanvasArray' has a wrong offset!");
static_assert(offsetof(ULGUIManagerWorldSubsystem, RenderTargetSpaceLGUICanvasArray) == 0x000080, "Member 'ULGUIManagerWorldSubsystem::RenderTargetSpaceLGUICanvasArray' has a wrong offset!");
static_assert(offsetof(ULGUIManagerWorldSubsystem, AllRaycasterArray) == 0x000090, "Member 'ULGUIManagerWorldSubsystem::AllRaycasterArray' has a wrong offset!");
static_assert(offsetof(ULGUIManagerWorldSubsystem, CurrentInputModule) == 0x0000A0, "Member 'ULGUIManagerWorldSubsystem::CurrentInputModule' has a wrong offset!");
static_assert(offsetof(ULGUIManagerWorldSubsystem, AllSelectableArray) == 0x0000A8, "Member 'ULGUIManagerWorldSubsystem::AllSelectableArray' has a wrong offset!");
static_assert(offsetof(ULGUIManagerWorldSubsystem, AllLayoutArray) == 0x0000B8, "Member 'ULGUIManagerWorldSubsystem::AllLayoutArray' has a wrong offset!");
static_assert(offsetof(ULGUIManagerWorldSubsystem, AllCultureChangedArray) == 0x0000C8, "Member 'ULGUIManagerWorldSubsystem::AllCultureChangedArray' has a wrong offset!");
static_assert(offsetof(ULGUIManagerWorldSubsystem, LGUILifeCycleBehavioursForUpdate) == 0x0000E0, "Member 'ULGUIManagerWorldSubsystem::LGUILifeCycleBehavioursForUpdate' has a wrong offset!");
static_assert(offsetof(ULGUIManagerWorldSubsystem, LGUILifeCycleBehavioursForStart) == 0x0000F0, "Member 'ULGUIManagerWorldSubsystem::LGUILifeCycleBehavioursForStart' has a wrong offset!");

// Class LGUI.LGUIMeshComponent
// 0x0050 (0x05A0 - 0x0550)
class ULGUIMeshComponent final : public UMeshComponent
{
public:
	uint8                                         Pad_550[0x50];                                     // 0x0550(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIMeshComponent">();
	}
	static class ULGUIMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIMeshComponent>();
	}
};
static_assert(alignof(ULGUIMeshComponent) == 0x000010, "Wrong alignment on ULGUIMeshComponent");
static_assert(sizeof(ULGUIMeshComponent) == 0x0005A0, "Wrong size on ULGUIMeshComponent");

// Class LGUI.LGUIPlayTweenComponent
// 0x0018 (0x00B8 - 0x00A0)
class ULGUIPlayTweenComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          playOnStart;                                       // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULGUIPlayTween*                         playTween;                                         // 0x00B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Play();
	void Stop();

	class ULGUIPlayTween* GetPlayTween() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPlayTweenComponent">();
	}
	static class ULGUIPlayTweenComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPlayTweenComponent>();
	}
};
static_assert(alignof(ULGUIPlayTweenComponent) == 0x000008, "Wrong alignment on ULGUIPlayTweenComponent");
static_assert(sizeof(ULGUIPlayTweenComponent) == 0x0000B8, "Wrong size on ULGUIPlayTweenComponent");
static_assert(offsetof(ULGUIPlayTweenComponent, playOnStart) == 0x0000A8, "Member 'ULGUIPlayTweenComponent::playOnStart' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTweenComponent, playTween) == 0x0000B0, "Member 'ULGUIPlayTweenComponent::playTween' has a wrong offset!");

// Class LGUI.LGUIPlayTweenSequenceComponent
// 0x0060 (0x0100 - 0x00A0)
class ULGUIPlayTweenSequenceComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          playOnStart;                                       // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayNextWhenCycleComplete;                        // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULGUIPlayTween*>                 playTweenArray;                                    // 0x00B0(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FLGUIEventDelegate                     OnComplete;                                        // 0x00C0(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x28];                                      // 0x00D8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Play();
	struct FLGUIDelegateHandleWrapper RegisterOnComplete(const TDelegate<void()>& InDelegate);
	void Stop();
	void UnregisterOnComplete(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPlayTweenSequenceComponent">();
	}
	static class ULGUIPlayTweenSequenceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPlayTweenSequenceComponent>();
	}
};
static_assert(alignof(ULGUIPlayTweenSequenceComponent) == 0x000008, "Wrong alignment on ULGUIPlayTweenSequenceComponent");
static_assert(sizeof(ULGUIPlayTweenSequenceComponent) == 0x000100, "Wrong size on ULGUIPlayTweenSequenceComponent");
static_assert(offsetof(ULGUIPlayTweenSequenceComponent, playOnStart) == 0x0000A8, "Member 'ULGUIPlayTweenSequenceComponent::playOnStart' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTweenSequenceComponent, bPlayNextWhenCycleComplete) == 0x0000A9, "Member 'ULGUIPlayTweenSequenceComponent::bPlayNextWhenCycleComplete' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTweenSequenceComponent, playTweenArray) == 0x0000B0, "Member 'ULGUIPlayTweenSequenceComponent::playTweenArray' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTweenSequenceComponent, OnComplete) == 0x0000C0, "Member 'ULGUIPlayTweenSequenceComponent::OnComplete' has a wrong offset!");

// Class LGUI.LGUIPlayTween_Double
// 0x0028 (0x0110 - 0x00E8)
class ULGUIPlayTween_Double final : public ULGUIPlayTween
{
public:
	double                                        From;                                              // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        To;                                                // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLGUIEventDelegate                     onUpdateValue;                                     // 0x00F8(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPlayTween_Double">();
	}
	static class ULGUIPlayTween_Double* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPlayTween_Double>();
	}
};
static_assert(alignof(ULGUIPlayTween_Double) == 0x000008, "Wrong alignment on ULGUIPlayTween_Double");
static_assert(sizeof(ULGUIPlayTween_Double) == 0x000110, "Wrong size on ULGUIPlayTween_Double");
static_assert(offsetof(ULGUIPlayTween_Double, From) == 0x0000E8, "Member 'ULGUIPlayTween_Double::From' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Double, To) == 0x0000F0, "Member 'ULGUIPlayTween_Double::To' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Double, onUpdateValue) == 0x0000F8, "Member 'ULGUIPlayTween_Double::onUpdateValue' has a wrong offset!");

// Class LGUI.LGUIPlayTween_Int
// 0x0020 (0x0108 - 0x00E8)
class ULGUIPlayTween_Int final : public ULGUIPlayTween
{
public:
	int32                                         From;                                              // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         To;                                                // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLGUIEventDelegate                     onUpdateValue;                                     // 0x00F0(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPlayTween_Int">();
	}
	static class ULGUIPlayTween_Int* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPlayTween_Int>();
	}
};
static_assert(alignof(ULGUIPlayTween_Int) == 0x000008, "Wrong alignment on ULGUIPlayTween_Int");
static_assert(sizeof(ULGUIPlayTween_Int) == 0x000108, "Wrong size on ULGUIPlayTween_Int");
static_assert(offsetof(ULGUIPlayTween_Int, From) == 0x0000E8, "Member 'ULGUIPlayTween_Int::From' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Int, To) == 0x0000EC, "Member 'ULGUIPlayTween_Int::To' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Int, onUpdateValue) == 0x0000F0, "Member 'ULGUIPlayTween_Int::onUpdateValue' has a wrong offset!");

// Class LGUI.LGUIPlayTween_LinearColor
// 0x0038 (0x0120 - 0x00E8)
class ULGUIPlayTween_LinearColor final : public ULGUIPlayTween
{
public:
	struct FLinearColor                           From;                                              // 0x00E8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           To;                                                // 0x00F8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLGUIEventDelegate                     onUpdateValue;                                     // 0x0108(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPlayTween_LinearColor">();
	}
	static class ULGUIPlayTween_LinearColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPlayTween_LinearColor>();
	}
};
static_assert(alignof(ULGUIPlayTween_LinearColor) == 0x000008, "Wrong alignment on ULGUIPlayTween_LinearColor");
static_assert(sizeof(ULGUIPlayTween_LinearColor) == 0x000120, "Wrong size on ULGUIPlayTween_LinearColor");
static_assert(offsetof(ULGUIPlayTween_LinearColor, From) == 0x0000E8, "Member 'ULGUIPlayTween_LinearColor::From' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_LinearColor, To) == 0x0000F8, "Member 'ULGUIPlayTween_LinearColor::To' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_LinearColor, onUpdateValue) == 0x000108, "Member 'ULGUIPlayTween_LinearColor::onUpdateValue' has a wrong offset!");

// Class LGUI.LGUIPlayTween_Quaternion
// 0x0068 (0x0150 - 0x00E8)
class ULGUIPlayTween_Quaternion final : public ULGUIPlayTween
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  From;                                              // 0x00F0(0x0020)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FQuat                                  To;                                                // 0x0110(0x0020)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLGUIEventDelegate                     onUpdateValue;                                     // 0x0130(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPlayTween_Quaternion">();
	}
	static class ULGUIPlayTween_Quaternion* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPlayTween_Quaternion>();
	}
};
static_assert(alignof(ULGUIPlayTween_Quaternion) == 0x000010, "Wrong alignment on ULGUIPlayTween_Quaternion");
static_assert(sizeof(ULGUIPlayTween_Quaternion) == 0x000150, "Wrong size on ULGUIPlayTween_Quaternion");
static_assert(offsetof(ULGUIPlayTween_Quaternion, From) == 0x0000F0, "Member 'ULGUIPlayTween_Quaternion::From' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Quaternion, To) == 0x000110, "Member 'ULGUIPlayTween_Quaternion::To' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Quaternion, onUpdateValue) == 0x000130, "Member 'ULGUIPlayTween_Quaternion::onUpdateValue' has a wrong offset!");

// Class LGUI.LGUIPlayTween_Rotator
// 0x0048 (0x0130 - 0x00E8)
class ULGUIPlayTween_Rotator final : public ULGUIPlayTween
{
public:
	struct FRotator                               From;                                              // 0x00E8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               To;                                                // 0x0100(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLGUIEventDelegate                     onUpdateValue;                                     // 0x0118(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPlayTween_Rotator">();
	}
	static class ULGUIPlayTween_Rotator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPlayTween_Rotator>();
	}
};
static_assert(alignof(ULGUIPlayTween_Rotator) == 0x000008, "Wrong alignment on ULGUIPlayTween_Rotator");
static_assert(sizeof(ULGUIPlayTween_Rotator) == 0x000130, "Wrong size on ULGUIPlayTween_Rotator");
static_assert(offsetof(ULGUIPlayTween_Rotator, From) == 0x0000E8, "Member 'ULGUIPlayTween_Rotator::From' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Rotator, To) == 0x000100, "Member 'ULGUIPlayTween_Rotator::To' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Rotator, onUpdateValue) == 0x000118, "Member 'ULGUIPlayTween_Rotator::onUpdateValue' has a wrong offset!");

// Class LGUI.LGUIPlayTween_Vector2
// 0x0038 (0x0120 - 0x00E8)
class ULGUIPlayTween_Vector2 final : public ULGUIPlayTween
{
public:
	struct FVector2D                              From;                                              // 0x00E8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              To;                                                // 0x00F8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLGUIEventDelegate                     onUpdateValue;                                     // 0x0108(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPlayTween_Vector2">();
	}
	static class ULGUIPlayTween_Vector2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPlayTween_Vector2>();
	}
};
static_assert(alignof(ULGUIPlayTween_Vector2) == 0x000008, "Wrong alignment on ULGUIPlayTween_Vector2");
static_assert(sizeof(ULGUIPlayTween_Vector2) == 0x000120, "Wrong size on ULGUIPlayTween_Vector2");
static_assert(offsetof(ULGUIPlayTween_Vector2, From) == 0x0000E8, "Member 'ULGUIPlayTween_Vector2::From' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Vector2, To) == 0x0000F8, "Member 'ULGUIPlayTween_Vector2::To' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Vector2, onUpdateValue) == 0x000108, "Member 'ULGUIPlayTween_Vector2::onUpdateValue' has a wrong offset!");

// Class LGUI.LGUIPlayTween_Vector3
// 0x0048 (0x0130 - 0x00E8)
class ULGUIPlayTween_Vector3 final : public ULGUIPlayTween
{
public:
	struct FVector                                From;                                              // 0x00E8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                To;                                                // 0x0100(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLGUIEventDelegate                     onUpdateValue;                                     // 0x0118(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPlayTween_Vector3">();
	}
	static class ULGUIPlayTween_Vector3* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPlayTween_Vector3>();
	}
};
static_assert(alignof(ULGUIPlayTween_Vector3) == 0x000008, "Wrong alignment on ULGUIPlayTween_Vector3");
static_assert(sizeof(ULGUIPlayTween_Vector3) == 0x000130, "Wrong size on ULGUIPlayTween_Vector3");
static_assert(offsetof(ULGUIPlayTween_Vector3, From) == 0x0000E8, "Member 'ULGUIPlayTween_Vector3::From' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Vector3, To) == 0x000100, "Member 'ULGUIPlayTween_Vector3::To' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Vector3, onUpdateValue) == 0x000118, "Member 'ULGUIPlayTween_Vector3::onUpdateValue' has a wrong offset!");

// Class LGUI.LGUIPlayTween_Vector4
// 0x0068 (0x0150 - 0x00E8)
class ULGUIPlayTween_Vector4 final : public ULGUIPlayTween
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               From;                                              // 0x00F0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector4                               To;                                                // 0x0110(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLGUIEventDelegate                     onUpdateValue;                                     // 0x0130(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPlayTween_Vector4">();
	}
	static class ULGUIPlayTween_Vector4* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPlayTween_Vector4>();
	}
};
static_assert(alignof(ULGUIPlayTween_Vector4) == 0x000010, "Wrong alignment on ULGUIPlayTween_Vector4");
static_assert(sizeof(ULGUIPlayTween_Vector4) == 0x000150, "Wrong size on ULGUIPlayTween_Vector4");
static_assert(offsetof(ULGUIPlayTween_Vector4, From) == 0x0000F0, "Member 'ULGUIPlayTween_Vector4::From' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Vector4, To) == 0x000110, "Member 'ULGUIPlayTween_Vector4::To' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Vector4, onUpdateValue) == 0x000130, "Member 'ULGUIPlayTween_Vector4::onUpdateValue' has a wrong offset!");

// Class LGUI.LGUIPointerClickInterface
// 0x0000 (0x0000 - 0x0000)
class ILGUIPointerClickInterface final
{
public:
	bool OnPointerClick(class ULGUIPointerEventData* EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPointerClickInterface">();
	}
	static class ILGUIPointerClickInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILGUIPointerClickInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILGUIPointerClickInterface) == 0x000001, "Wrong alignment on ILGUIPointerClickInterface");
static_assert(sizeof(ILGUIPointerClickInterface) == 0x000001, "Wrong size on ILGUIPointerClickInterface");

// Class LGUI.LGUIPointerDownUpInterface
// 0x0000 (0x0000 - 0x0000)
class ILGUIPointerDownUpInterface final
{
public:
	bool OnPointerDown(class ULGUIPointerEventData* EventData);
	bool OnPointerUp(class ULGUIPointerEventData* EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPointerDownUpInterface">();
	}
	static class ILGUIPointerDownUpInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILGUIPointerDownUpInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILGUIPointerDownUpInterface) == 0x000001, "Wrong alignment on ILGUIPointerDownUpInterface");
static_assert(sizeof(ILGUIPointerDownUpInterface) == 0x000001, "Wrong size on ILGUIPointerDownUpInterface");

// Class LGUI.LGUIPointerDragDropInterface
// 0x0000 (0x0000 - 0x0000)
class ILGUIPointerDragDropInterface final
{
public:
	bool OnPointerDragDrop(class ULGUIPointerEventData* EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPointerDragDropInterface">();
	}
	static class ILGUIPointerDragDropInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILGUIPointerDragDropInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILGUIPointerDragDropInterface) == 0x000001, "Wrong alignment on ILGUIPointerDragDropInterface");
static_assert(sizeof(ILGUIPointerDragDropInterface) == 0x000001, "Wrong size on ILGUIPointerDragDropInterface");

// Class LGUI.LGUIPointerDragInterface
// 0x0000 (0x0000 - 0x0000)
class ILGUIPointerDragInterface final
{
public:
	bool OnPointerBeginDrag(class ULGUIPointerEventData* EventData);
	bool OnPointerDrag(class ULGUIPointerEventData* EventData);
	bool OnPointerEndDrag(class ULGUIPointerEventData* EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPointerDragInterface">();
	}
	static class ILGUIPointerDragInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILGUIPointerDragInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILGUIPointerDragInterface) == 0x000001, "Wrong alignment on ILGUIPointerDragInterface");
static_assert(sizeof(ILGUIPointerDragInterface) == 0x000001, "Wrong size on ILGUIPointerDragInterface");

// Class LGUI.LGUIPointerEnterExitInterface
// 0x0000 (0x0000 - 0x0000)
class ILGUIPointerEnterExitInterface final
{
public:
	bool OnPointerEnter(class ULGUIPointerEventData* EventData);
	bool OnPointerExit(class ULGUIPointerEventData* EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPointerEnterExitInterface">();
	}
	static class ILGUIPointerEnterExitInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILGUIPointerEnterExitInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILGUIPointerEnterExitInterface) == 0x000001, "Wrong alignment on ILGUIPointerEnterExitInterface");
static_assert(sizeof(ILGUIPointerEnterExitInterface) == 0x000001, "Wrong size on ILGUIPointerEnterExitInterface");

// Class LGUI.LGUIPointerEventData
// 0x01D8 (0x0210 - 0x0038)
class ULGUIPointerEventData final : public ULGUIBaseEventData
{
public:
	ELGUIPointerInputType                         InputType;                                         // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         pointerID;                                         // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                pointerPosition;                                   // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                pressPointerPosition;                              // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        enterComponent;                                    // 0x0070(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                enterComponentStack;                               // 0x0078(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                hoverComponentArray;                               // 0x0088(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FVector                                worldPoint;                                        // 0x0098(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldNormal;                                       // 0x00B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FaceIndex;                                         // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              scrollAxisValue;                                   // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULGUIBaseRaycaster*                     raycaster;                                         // 0x00E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMouseButtonType                              mouseButtonType;                                   // 0x00E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        pressComponent;                                    // 0x00F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                pressWorldPoint;                                   // 0x00F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                pressWorldNormal;                                  // 0x0110(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         pressDistance;                                     // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                pressRayOrigin;                                    // 0x0130(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                pressRayDirection;                                 // 0x0148(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             pressWorldToLocalTransform;                        // 0x0160(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULGUIBaseRaycaster*                     pressRaycaster;                                    // 0x01C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        clickTime;                                         // 0x01C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        ReleaseTime;                                       // 0x01D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        pressTime;                                         // 0x01D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isDragging;                                        // 0x01E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E1[0x7];                                      // 0x01E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        dragComponent;                                     // 0x01E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F0[0x20];                                     // 0x01F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsPointerOverUI();
	void SetHighlightedComponentForNavigation(class USceneComponent* InComp);

	struct FVector GetCumulativeMoveDelta() const;
	struct FVector GetDragRayDirection() const;
	struct FVector GetDragRayOrigin() const;
	class USceneComponent* GetHighlightedComponentForNavigation() const;
	struct FVector GetLocalPointInPlane() const;
	struct FVector GetWorldPointInPlane() const;
	struct FVector GetWorldPointSpherical() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPointerEventData">();
	}
	static class ULGUIPointerEventData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPointerEventData>();
	}
};
static_assert(alignof(ULGUIPointerEventData) == 0x000010, "Wrong alignment on ULGUIPointerEventData");
static_assert(sizeof(ULGUIPointerEventData) == 0x000210, "Wrong size on ULGUIPointerEventData");
static_assert(offsetof(ULGUIPointerEventData, InputType) == 0x000038, "Member 'ULGUIPointerEventData::InputType' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, pointerID) == 0x00003C, "Member 'ULGUIPointerEventData::pointerID' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, pointerPosition) == 0x000040, "Member 'ULGUIPointerEventData::pointerPosition' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, pressPointerPosition) == 0x000058, "Member 'ULGUIPointerEventData::pressPointerPosition' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, enterComponent) == 0x000070, "Member 'ULGUIPointerEventData::enterComponent' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, enterComponentStack) == 0x000078, "Member 'ULGUIPointerEventData::enterComponentStack' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, hoverComponentArray) == 0x000088, "Member 'ULGUIPointerEventData::hoverComponentArray' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, worldPoint) == 0x000098, "Member 'ULGUIPointerEventData::worldPoint' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, WorldNormal) == 0x0000B0, "Member 'ULGUIPointerEventData::WorldNormal' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, FaceIndex) == 0x0000C8, "Member 'ULGUIPointerEventData::FaceIndex' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, scrollAxisValue) == 0x0000D0, "Member 'ULGUIPointerEventData::scrollAxisValue' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, raycaster) == 0x0000E0, "Member 'ULGUIPointerEventData::raycaster' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, mouseButtonType) == 0x0000E8, "Member 'ULGUIPointerEventData::mouseButtonType' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, pressComponent) == 0x0000F0, "Member 'ULGUIPointerEventData::pressComponent' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, pressWorldPoint) == 0x0000F8, "Member 'ULGUIPointerEventData::pressWorldPoint' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, pressWorldNormal) == 0x000110, "Member 'ULGUIPointerEventData::pressWorldNormal' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, pressDistance) == 0x000128, "Member 'ULGUIPointerEventData::pressDistance' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, pressRayOrigin) == 0x000130, "Member 'ULGUIPointerEventData::pressRayOrigin' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, pressRayDirection) == 0x000148, "Member 'ULGUIPointerEventData::pressRayDirection' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, pressWorldToLocalTransform) == 0x000160, "Member 'ULGUIPointerEventData::pressWorldToLocalTransform' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, pressRaycaster) == 0x0001C0, "Member 'ULGUIPointerEventData::pressRaycaster' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, clickTime) == 0x0001C8, "Member 'ULGUIPointerEventData::clickTime' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, ReleaseTime) == 0x0001D0, "Member 'ULGUIPointerEventData::ReleaseTime' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, pressTime) == 0x0001D8, "Member 'ULGUIPointerEventData::pressTime' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, isDragging) == 0x0001E0, "Member 'ULGUIPointerEventData::isDragging' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, dragComponent) == 0x0001E8, "Member 'ULGUIPointerEventData::dragComponent' has a wrong offset!");

// Class LGUI.LGUIPointerScrollInterface
// 0x0000 (0x0000 - 0x0000)
class ILGUIPointerScrollInterface final
{
public:
	bool OnPointerScroll(class ULGUIPointerEventData* EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPointerScrollInterface">();
	}
	static class ILGUIPointerScrollInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILGUIPointerScrollInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILGUIPointerScrollInterface) == 0x000001, "Wrong alignment on ILGUIPointerScrollInterface");
static_assert(sizeof(ILGUIPointerScrollInterface) == 0x000001, "Wrong size on ILGUIPointerScrollInterface");

// Class LGUI.LGUIPointerSelectDeselectInterface
// 0x0000 (0x0000 - 0x0000)
class ILGUIPointerSelectDeselectInterface final
{
public:
	bool OnPointerDeselect(class ULGUIBaseEventData* EventData);
	bool OnPointerSelect(class ULGUIBaseEventData* EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPointerSelectDeselectInterface">();
	}
	static class ILGUIPointerSelectDeselectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILGUIPointerSelectDeselectInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILGUIPointerSelectDeselectInterface) == 0x000001, "Wrong alignment on ILGUIPointerSelectDeselectInterface");
static_assert(sizeof(ILGUIPointerSelectDeselectInterface) == 0x000001, "Wrong size on ILGUIPointerSelectDeselectInterface");

// Class LGUI.LGUIPrefab
// 0x0060 (0x0088 - 0x0028)
class ULGUIPrefab final : public UObject
{
public:
	uint16                                        PrefabVersion;                                     // 0x0028(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        EngineMajorVersion;                                // 0x002A(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        EngineMinorVersion;                                // 0x002C(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        EnginePatchVersion;                                // 0x002E(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArchiveVersion_ForBuild;                           // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArchiveVersionUE5_ForBuild;                        // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArchiveLicenseeVer_ForBuild;                       // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ArEngineNetVer_ForBuild;                           // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ArGameNetVer_ForBuild;                             // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        ReferenceAssetListForBuild;                        // 0x0048(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UObject>>            ReferenceClassListForBuild;                        // 0x0058(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class FName>                           ReferenceNameListForBuild;                         // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 BinaryDataForBuild;                                // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	class AActor* LoadPrefab(class UObject* WorldContextObject, class USceneComponent* InParent, const TDelegate<void(class AActor* LoadedRootActor)>& InCallbackBeforeAwake, bool SetRelativeTransformToIdentity);
	class AActor* LoadPrefabWithReplacement(class UObject* WorldContextObject, class USceneComponent* InParent, const TMap<class UObject*, class UObject*>& InReplaceAssetMap, const TMap<class UClass*, class UClass*>& InReplaceClassMap, const TDelegate<void(class AActor* LoadedRootActor)>& InCallbackBeforeAwake);
	class AActor* LoadPrefabWithTransform(class UObject* WorldContextObject, class USceneComponent* InParent, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, const TDelegate<void(class AActor* LoadedRootActor)>& InCallbackBeforeAwake);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPrefab">();
	}
	static class ULGUIPrefab* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPrefab>();
	}
};
static_assert(alignof(ULGUIPrefab) == 0x000008, "Wrong alignment on ULGUIPrefab");
static_assert(sizeof(ULGUIPrefab) == 0x000088, "Wrong size on ULGUIPrefab");
static_assert(offsetof(ULGUIPrefab, PrefabVersion) == 0x000028, "Member 'ULGUIPrefab::PrefabVersion' has a wrong offset!");
static_assert(offsetof(ULGUIPrefab, EngineMajorVersion) == 0x00002A, "Member 'ULGUIPrefab::EngineMajorVersion' has a wrong offset!");
static_assert(offsetof(ULGUIPrefab, EngineMinorVersion) == 0x00002C, "Member 'ULGUIPrefab::EngineMinorVersion' has a wrong offset!");
static_assert(offsetof(ULGUIPrefab, EnginePatchVersion) == 0x00002E, "Member 'ULGUIPrefab::EnginePatchVersion' has a wrong offset!");
static_assert(offsetof(ULGUIPrefab, ArchiveVersion_ForBuild) == 0x000030, "Member 'ULGUIPrefab::ArchiveVersion_ForBuild' has a wrong offset!");
static_assert(offsetof(ULGUIPrefab, ArchiveVersionUE5_ForBuild) == 0x000034, "Member 'ULGUIPrefab::ArchiveVersionUE5_ForBuild' has a wrong offset!");
static_assert(offsetof(ULGUIPrefab, ArchiveLicenseeVer_ForBuild) == 0x000038, "Member 'ULGUIPrefab::ArchiveLicenseeVer_ForBuild' has a wrong offset!");
static_assert(offsetof(ULGUIPrefab, ArEngineNetVer_ForBuild) == 0x00003C, "Member 'ULGUIPrefab::ArEngineNetVer_ForBuild' has a wrong offset!");
static_assert(offsetof(ULGUIPrefab, ArGameNetVer_ForBuild) == 0x000040, "Member 'ULGUIPrefab::ArGameNetVer_ForBuild' has a wrong offset!");
static_assert(offsetof(ULGUIPrefab, ReferenceAssetListForBuild) == 0x000048, "Member 'ULGUIPrefab::ReferenceAssetListForBuild' has a wrong offset!");
static_assert(offsetof(ULGUIPrefab, ReferenceClassListForBuild) == 0x000058, "Member 'ULGUIPrefab::ReferenceClassListForBuild' has a wrong offset!");
static_assert(offsetof(ULGUIPrefab, ReferenceNameListForBuild) == 0x000068, "Member 'ULGUIPrefab::ReferenceNameListForBuild' has a wrong offset!");
static_assert(offsetof(ULGUIPrefab, BinaryDataForBuild) == 0x000078, "Member 'ULGUIPrefab::BinaryDataForBuild' has a wrong offset!");

// Class LGUI.LGUIPrefabLevelManagerActor
// 0x0000 (0x0290 - 0x0290)
class ALGUIPrefabLevelManagerActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPrefabLevelManagerActor">();
	}
	static class ALGUIPrefabLevelManagerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALGUIPrefabLevelManagerActor>();
	}
};
static_assert(alignof(ALGUIPrefabLevelManagerActor) == 0x000008, "Wrong alignment on ALGUIPrefabLevelManagerActor");
static_assert(sizeof(ALGUIPrefabLevelManagerActor) == 0x000290, "Wrong size on ALGUIPrefabLevelManagerActor");

// Class LGUI.LGUIPrefabManagerObject
// 0x0008 (0x0030 - 0x0028)
class ULGUIPrefabManagerObject final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPrefabManagerObject">();
	}
	static class ULGUIPrefabManagerObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPrefabManagerObject>();
	}
};
static_assert(alignof(ULGUIPrefabManagerObject) == 0x000008, "Wrong alignment on ULGUIPrefabManagerObject");
static_assert(sizeof(ULGUIPrefabManagerObject) == 0x000030, "Wrong size on ULGUIPrefabManagerObject");

// Class LGUI.LGUIPrefabWorldSubsystem
// 0x0080 (0x00B0 - 0x0030)
class ULGUIPrefabWorldSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x30];                                      // 0x0030(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AActor*, struct FGuid>             AllActors_PrefabSystemProcessing;                  // 0x0060(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)

public:
	static bool IsLGUIPrefabSystemProcessingActor(class AActor* InActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPrefabWorldSubsystem">();
	}
	static class ULGUIPrefabWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPrefabWorldSubsystem>();
	}
};
static_assert(alignof(ULGUIPrefabWorldSubsystem) == 0x000008, "Wrong alignment on ULGUIPrefabWorldSubsystem");
static_assert(sizeof(ULGUIPrefabWorldSubsystem) == 0x0000B0, "Wrong size on ULGUIPrefabWorldSubsystem");
static_assert(offsetof(ULGUIPrefabWorldSubsystem, AllActors_PrefabSystemProcessing) == 0x000060, "Member 'ULGUIPrefabWorldSubsystem::AllActors_PrefabSystemProcessing' has a wrong offset!");

// Class LGUI.LGUIPrefabSequence
// 0x0038 (0x00A0 - 0x0068)
class ULGUIPrefabSequence final : public UMovieSceneSequence
{
public:
	class UMovieScene*                            MovieScene;                                        // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLGUIPrefabSequenceObjectReferenceMap  ObjectReferences;                                  // 0x0070(0x0020)(NativeAccessSpecifierPrivate)
	class FString                                 DisplayNameString;                                 // 0x0090(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPrefabSequence">();
	}
	static class ULGUIPrefabSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPrefabSequence>();
	}
};
static_assert(alignof(ULGUIPrefabSequence) == 0x000008, "Wrong alignment on ULGUIPrefabSequence");
static_assert(sizeof(ULGUIPrefabSequence) == 0x0000A0, "Wrong size on ULGUIPrefabSequence");
static_assert(offsetof(ULGUIPrefabSequence, MovieScene) == 0x000068, "Member 'ULGUIPrefabSequence::MovieScene' has a wrong offset!");
static_assert(offsetof(ULGUIPrefabSequence, ObjectReferences) == 0x000070, "Member 'ULGUIPrefabSequence::ObjectReferences' has a wrong offset!");
static_assert(offsetof(ULGUIPrefabSequence, DisplayNameString) == 0x000090, "Member 'ULGUIPrefabSequence::DisplayNameString' has a wrong offset!");

// Class LGUI.LGUIPrefabSequenceComponent
// 0x0070 (0x0110 - 0x00A0)
class ULGUIPrefabSequenceComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMovieSceneSequencePlaybackSettings    PlaybackSettings;                                  // 0x00A8(0x0028)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<class ULGUIPrefabSequence*>            SequenceArray;                                     // 0x00D0(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	int32                                         CurrentSequenceIndex;                              // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIComponentReference                SequenceEventHandler;                              // 0x00E8(0x0020)(NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class ULGUIPrefabSequencePlayer*              SequencePlayer;                                    // 0x0108(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitSequencePlayer();
	void SetSequenceByDisplayName(const class FString& InName);
	void SetSequenceByIndex(int32 InIndex);
	void SetSequenceByName(class FName InName);

	class ULGUIPrefabSequence* GetCurrentSequence() const;
	int32 GetCurrentSequenceIndex() const;
	const TArray<class ULGUIPrefabSequence*> GetSequenceArray() const;
	class ULGUIPrefabSequence* GetSequenceByDisplayName(const class FString& InName) const;
	class ULGUIPrefabSequence* GetSequenceByIndex(int32 InIndex) const;
	class ULGUIPrefabSequence* GetSequenceByName(class FName InName) const;
	class ULGUIPrefabSequencePlayer* GetSequencePlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPrefabSequenceComponent">();
	}
	static class ULGUIPrefabSequenceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPrefabSequenceComponent>();
	}
};
static_assert(alignof(ULGUIPrefabSequenceComponent) == 0x000008, "Wrong alignment on ULGUIPrefabSequenceComponent");
static_assert(sizeof(ULGUIPrefabSequenceComponent) == 0x000110, "Wrong size on ULGUIPrefabSequenceComponent");
static_assert(offsetof(ULGUIPrefabSequenceComponent, PlaybackSettings) == 0x0000A8, "Member 'ULGUIPrefabSequenceComponent::PlaybackSettings' has a wrong offset!");
static_assert(offsetof(ULGUIPrefabSequenceComponent, SequenceArray) == 0x0000D0, "Member 'ULGUIPrefabSequenceComponent::SequenceArray' has a wrong offset!");
static_assert(offsetof(ULGUIPrefabSequenceComponent, CurrentSequenceIndex) == 0x0000E0, "Member 'ULGUIPrefabSequenceComponent::CurrentSequenceIndex' has a wrong offset!");
static_assert(offsetof(ULGUIPrefabSequenceComponent, SequenceEventHandler) == 0x0000E8, "Member 'ULGUIPrefabSequenceComponent::SequenceEventHandler' has a wrong offset!");
static_assert(offsetof(ULGUIPrefabSequenceComponent, SequencePlayer) == 0x000108, "Member 'ULGUIPrefabSequenceComponent::SequencePlayer' has a wrong offset!");

// Class LGUI.LGUIPrefabSettings
// 0x0008 (0x0030 - 0x0028)
class ULGUIPrefabSettings final : public UObject
{
public:
	bool                                          bLogPrefabLoadTime;                                // 0x0028(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPrefabSettings">();
	}
	static class ULGUIPrefabSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPrefabSettings>();
	}
};
static_assert(alignof(ULGUIPrefabSettings) == 0x000008, "Wrong alignment on ULGUIPrefabSettings");
static_assert(sizeof(ULGUIPrefabSettings) == 0x000030, "Wrong size on ULGUIPrefabSettings");
static_assert(offsetof(ULGUIPrefabSettings, bLogPrefabLoadTime) == 0x000028, "Member 'ULGUIPrefabSettings::bLogPrefabLoadTime' has a wrong offset!");

// Class LGUI.LGUIRenderTargetGeometrySource
// 0x00A0 (0x05F0 - 0x0550)
class ULGUIRenderTargetGeometrySource final : public UMeshComponent
{
public:
	uint8                                         Pad_550[0x10];                                     // 0x0550(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIComponentReference                TargetCanvas;                                      // 0x0560(0x0020)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	ELGUIRenderTargetGeometryMode                 GeometryMode;                                      // 0x0580(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_581[0x7];                                      // 0x0581(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Pivot;                                             // 0x0588(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CylinderArcAngle;                                  // 0x0598(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideStaticMeshMaterial;                       // 0x059C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEnableInteractOnBackside;                         // 0x059D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFlipVerticalOnGLES;                               // 0x059E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_59F[0x11];                                     // 0x059F(0x0011)(Fixing Size After Last Property [ Dumper-7 ])
	class UBodySetup*                             BodySetup;                                         // 0x05B0(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               MaterialInstance;                                  // 0x05B8(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C0[0x30];                                     // 0x05C0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCanvas(class ULGUICanvas* Value);
	void SetCylinderArcAngle(float Value);
	void SetEnableInteractOnBackside(bool Value);
	void SetFlipVerticalOnGLES(bool Value);
	void SetGeometryMode(ELGUIRenderTargetGeometryMode Value);
	void SetPivot(const struct FVector2D& Value);

	class ULGUICanvas* GetCanvas() const;
	float GetCylinderArcAngle() const;
	bool GetEnableInteractOnBackside() const;
	bool GetFlipVerticalOnGLES() const;
	ELGUIRenderTargetGeometryMode GetGeometryMode() const;
	class UMaterialInstanceDynamic* GetMaterialInstance() const;
	bool GetOverrideStaticMeshMaterial() const;
	struct FVector2D GetPivot() const;
	class UTextureRenderTarget2D* GetRenderTarget() const;
	struct FIntPoint GetRenderTargetSize() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIRenderTargetGeometrySource">();
	}
	static class ULGUIRenderTargetGeometrySource* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIRenderTargetGeometrySource>();
	}
};
static_assert(alignof(ULGUIRenderTargetGeometrySource) == 0x000010, "Wrong alignment on ULGUIRenderTargetGeometrySource");
static_assert(sizeof(ULGUIRenderTargetGeometrySource) == 0x0005F0, "Wrong size on ULGUIRenderTargetGeometrySource");
static_assert(offsetof(ULGUIRenderTargetGeometrySource, TargetCanvas) == 0x000560, "Member 'ULGUIRenderTargetGeometrySource::TargetCanvas' has a wrong offset!");
static_assert(offsetof(ULGUIRenderTargetGeometrySource, GeometryMode) == 0x000580, "Member 'ULGUIRenderTargetGeometrySource::GeometryMode' has a wrong offset!");
static_assert(offsetof(ULGUIRenderTargetGeometrySource, Pivot) == 0x000588, "Member 'ULGUIRenderTargetGeometrySource::Pivot' has a wrong offset!");
static_assert(offsetof(ULGUIRenderTargetGeometrySource, CylinderArcAngle) == 0x000598, "Member 'ULGUIRenderTargetGeometrySource::CylinderArcAngle' has a wrong offset!");
static_assert(offsetof(ULGUIRenderTargetGeometrySource, bOverrideStaticMeshMaterial) == 0x00059C, "Member 'ULGUIRenderTargetGeometrySource::bOverrideStaticMeshMaterial' has a wrong offset!");
static_assert(offsetof(ULGUIRenderTargetGeometrySource, bEnableInteractOnBackside) == 0x00059D, "Member 'ULGUIRenderTargetGeometrySource::bEnableInteractOnBackside' has a wrong offset!");
static_assert(offsetof(ULGUIRenderTargetGeometrySource, bFlipVerticalOnGLES) == 0x00059E, "Member 'ULGUIRenderTargetGeometrySource::bFlipVerticalOnGLES' has a wrong offset!");
static_assert(offsetof(ULGUIRenderTargetGeometrySource, BodySetup) == 0x0005B0, "Member 'ULGUIRenderTargetGeometrySource::BodySetup' has a wrong offset!");
static_assert(offsetof(ULGUIRenderTargetGeometrySource, MaterialInstance) == 0x0005B8, "Member 'ULGUIRenderTargetGeometrySource::MaterialInstance' has a wrong offset!");

// Class LGUI.LGUIRenderTargetInteractionSourceInterface
// 0x0000 (0x0000 - 0x0000)
class ILGUIRenderTargetInteractionSourceInterface final
{
public:
	bool PerformLineTrace(const int32& InHitFaceIndex, const struct FVector& InHitPoint, const struct FVector& InLineStart, const struct FVector& InLineEnd, struct FVector2D* OutHitUV);

	class ULGUICanvas* GetTargetCanvas() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIRenderTargetInteractionSourceInterface">();
	}
	static class ILGUIRenderTargetInteractionSourceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILGUIRenderTargetInteractionSourceInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILGUIRenderTargetInteractionSourceInterface) == 0x000001, "Wrong alignment on ILGUIRenderTargetInteractionSourceInterface");
static_assert(sizeof(ILGUIRenderTargetInteractionSourceInterface) == 0x000001, "Wrong size on ILGUIRenderTargetInteractionSourceInterface");

// Class LGUI.LGUIRenderTargetInteraction
// 0x0050 (0x02F0 - 0x02A0)
class ULGUIRenderTargetInteraction final : public ULGUIBaseRaycaster
{
public:
	uint8                                         Pad_2A0[0x18];                                     // 0x02A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAllowEventBubbleUp;                               // 0x02B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B9[0x3];                                      // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ULGUICanvas>             TargetCanvas;                                      // 0x02BC(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                LineTraceSource;                                   // 0x02C8(0x0008)(Edit, ZeroConstructor, Transient, EditConst, NoDestructor, AdvancedDisplay, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULGUIPointerEventData*                  pointerEventData;                                  // 0x02D0(0x0008)(Edit, ZeroConstructor, Transient, EditConst, NoDestructor, AdvancedDisplay, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0x18];                                     // 0x02D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIRenderTargetInteraction">();
	}
	static class ULGUIRenderTargetInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIRenderTargetInteraction>();
	}
};
static_assert(alignof(ULGUIRenderTargetInteraction) == 0x000010, "Wrong alignment on ULGUIRenderTargetInteraction");
static_assert(sizeof(ULGUIRenderTargetInteraction) == 0x0002F0, "Wrong size on ULGUIRenderTargetInteraction");
static_assert(offsetof(ULGUIRenderTargetInteraction, bAllowEventBubbleUp) == 0x0002B8, "Member 'ULGUIRenderTargetInteraction::bAllowEventBubbleUp' has a wrong offset!");
static_assert(offsetof(ULGUIRenderTargetInteraction, TargetCanvas) == 0x0002BC, "Member 'ULGUIRenderTargetInteraction::TargetCanvas' has a wrong offset!");
static_assert(offsetof(ULGUIRenderTargetInteraction, LineTraceSource) == 0x0002C8, "Member 'ULGUIRenderTargetInteraction::LineTraceSource' has a wrong offset!");
static_assert(offsetof(ULGUIRenderTargetInteraction, pointerEventData) == 0x0002D0, "Member 'ULGUIRenderTargetInteraction::pointerEventData' has a wrong offset!");

// Class LGUI.LGUIRichTextCustomStyleData
// 0x0068 (0x0090 - 0x0028)
class ULGUIRichTextCustomStyleData final : public UObject
{
public:
	TMap<class FName, struct FLGUIRichTextCustomStyleItemData> DataMap;                              // 0x0028(0x0050)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x18];                                      // 0x0078(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const TMap<class FName, struct FLGUIRichTextCustomStyleItemData> GetDataMap() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIRichTextCustomStyleData">();
	}
	static class ULGUIRichTextCustomStyleData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIRichTextCustomStyleData>();
	}
};
static_assert(alignof(ULGUIRichTextCustomStyleData) == 0x000008, "Wrong alignment on ULGUIRichTextCustomStyleData");
static_assert(sizeof(ULGUIRichTextCustomStyleData) == 0x000090, "Wrong size on ULGUIRichTextCustomStyleData");
static_assert(offsetof(ULGUIRichTextCustomStyleData, DataMap) == 0x000028, "Member 'ULGUIRichTextCustomStyleData::DataMap' has a wrong offset!");

// Class LGUI.LGUIRichTextImageData_BaseObject
// 0x0018 (0x0040 - 0x0028)
class ULGUIRichTextImageData_BaseObject : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIRichTextImageData_BaseObject">();
	}
	static class ULGUIRichTextImageData_BaseObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIRichTextImageData_BaseObject>();
	}
};
static_assert(alignof(ULGUIRichTextImageData_BaseObject) == 0x000008, "Wrong alignment on ULGUIRichTextImageData_BaseObject");
static_assert(sizeof(ULGUIRichTextImageData_BaseObject) == 0x000040, "Wrong size on ULGUIRichTextImageData_BaseObject");

// Class LGUI.LGUIRichTextImageData
// 0x0058 (0x0098 - 0x0040)
class ULGUIRichTextImageData final : public ULGUIRichTextImageData_BaseObject
{
public:
	TMap<class FName, struct FLGUIRichTextImageItemData> imageMap;                                   // 0x0040(0x0050)(Edit, NativeAccessSpecifierPrivate)
	float                                         animationFps;                                      // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastOnDataChange();
	TMap<class FName, struct FLGUIRichTextImageItemData> GetMutableImageMap();
	void SetAnimationFps(float Value);
	void SetImageMap(const TMap<class FName, struct FLGUIRichTextImageItemData>& Value);

	float GetAnimationFps() const;
	const TMap<class FName, struct FLGUIRichTextImageItemData> GetImageMap() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIRichTextImageData">();
	}
	static class ULGUIRichTextImageData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIRichTextImageData>();
	}
};
static_assert(alignof(ULGUIRichTextImageData) == 0x000008, "Wrong alignment on ULGUIRichTextImageData");
static_assert(sizeof(ULGUIRichTextImageData) == 0x000098, "Wrong size on ULGUIRichTextImageData");
static_assert(offsetof(ULGUIRichTextImageData, imageMap) == 0x000040, "Member 'ULGUIRichTextImageData::imageMap' has a wrong offset!");
static_assert(offsetof(ULGUIRichTextImageData, animationFps) == 0x000090, "Member 'ULGUIRichTextImageData::animationFps' has a wrong offset!");

// Class LGUI.LGUIScreenSpaceRaycaster
// 0x0020 (0x02C0 - 0x02A0)
class ULGUIScreenSpaceRaycaster final : public ULGUIBaseRaycaster
{
public:
	uint8                                         Pad_2A0[0x20];                                     // 0x02A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIScreenSpaceRaycaster">();
	}
	static class ULGUIScreenSpaceRaycaster* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIScreenSpaceRaycaster>();
	}
};
static_assert(alignof(ULGUIScreenSpaceRaycaster) == 0x000010, "Wrong alignment on ULGUIScreenSpaceRaycaster");
static_assert(sizeof(ULGUIScreenSpaceRaycaster) == 0x0002C0, "Wrong size on ULGUIScreenSpaceRaycaster");

// Class LGUI.LGUISDFFontData
// 0x00E0 (0x01F0 - 0x0110)
class ULGUISDFFontData final : public ULGUIFreeTypeRenderFontData
{
public:
	class UMaterialInterface*                     SDFDefaultMaterials[0x3];                          // 0x0110(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         FontSize;                                          // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SDFRadius;                                         // 0x012C(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         italicAngle;                                       // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         boldRatio;                                         // 0x0134(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LineHeight;                                        // 0x0138(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         VerticalOffset;                                    // 0x013C(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_140[0xB0];                                     // 0x0140(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUISDFFontData">();
	}
	static class ULGUISDFFontData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUISDFFontData>();
	}
};
static_assert(alignof(ULGUISDFFontData) == 0x000008, "Wrong alignment on ULGUISDFFontData");
static_assert(sizeof(ULGUISDFFontData) == 0x0001F0, "Wrong size on ULGUISDFFontData");
static_assert(offsetof(ULGUISDFFontData, SDFDefaultMaterials) == 0x000110, "Member 'ULGUISDFFontData::SDFDefaultMaterials' has a wrong offset!");
static_assert(offsetof(ULGUISDFFontData, FontSize) == 0x000128, "Member 'ULGUISDFFontData::FontSize' has a wrong offset!");
static_assert(offsetof(ULGUISDFFontData, SDFRadius) == 0x00012C, "Member 'ULGUISDFFontData::SDFRadius' has a wrong offset!");
static_assert(offsetof(ULGUISDFFontData, italicAngle) == 0x000130, "Member 'ULGUISDFFontData::italicAngle' has a wrong offset!");
static_assert(offsetof(ULGUISDFFontData, boldRatio) == 0x000134, "Member 'ULGUISDFFontData::boldRatio' has a wrong offset!");
static_assert(offsetof(ULGUISDFFontData, LineHeight) == 0x000138, "Member 'ULGUISDFFontData::LineHeight' has a wrong offset!");
static_assert(offsetof(ULGUISDFFontData, VerticalOffset) == 0x00013C, "Member 'ULGUISDFFontData::VerticalOffset' has a wrong offset!");

// Class LGUI.LGUISettings
// 0x0068 (0x0090 - 0x0028)
class ULGUISettings final : public UObject
{
public:
	struct FLGUIAtlasSettings                     defaultAtlasSetting;                               // 0x0028(0x0008)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FLGUIAtlasSettings>  atlasSettingForSpecificPackingTag;                 // 0x0030(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	int32                                         PriorityInSceneViewExtension;                      // 0x0080(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoBatchThreshold;                                // 0x0084(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFrustumCulling;                                   // 0x0088(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScreenSpaceUIAffectByGamePause;                   // 0x0089(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScreenSpaceUIAffectByTimeDilation;                // 0x008A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWorldSpaceUIAffectByGamePause;                    // 0x008B(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWorldSpaceUIAffectByTimeDilation;                 // 0x008C(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELGUIRendererAntiAliasingMethod               AntiAliasingMothod;                                // 0x008D(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELGUIRendererMSAASampleCount                  MSAASampleCount;                                   // 0x008E(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8F[0x1];                                       // 0x008F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUISettings">();
	}
	static class ULGUISettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUISettings>();
	}
};
static_assert(alignof(ULGUISettings) == 0x000008, "Wrong alignment on ULGUISettings");
static_assert(sizeof(ULGUISettings) == 0x000090, "Wrong size on ULGUISettings");
static_assert(offsetof(ULGUISettings, defaultAtlasSetting) == 0x000028, "Member 'ULGUISettings::defaultAtlasSetting' has a wrong offset!");
static_assert(offsetof(ULGUISettings, atlasSettingForSpecificPackingTag) == 0x000030, "Member 'ULGUISettings::atlasSettingForSpecificPackingTag' has a wrong offset!");
static_assert(offsetof(ULGUISettings, PriorityInSceneViewExtension) == 0x000080, "Member 'ULGUISettings::PriorityInSceneViewExtension' has a wrong offset!");
static_assert(offsetof(ULGUISettings, AutoBatchThreshold) == 0x000084, "Member 'ULGUISettings::AutoBatchThreshold' has a wrong offset!");
static_assert(offsetof(ULGUISettings, bFrustumCulling) == 0x000088, "Member 'ULGUISettings::bFrustumCulling' has a wrong offset!");
static_assert(offsetof(ULGUISettings, bScreenSpaceUIAffectByGamePause) == 0x000089, "Member 'ULGUISettings::bScreenSpaceUIAffectByGamePause' has a wrong offset!");
static_assert(offsetof(ULGUISettings, bScreenSpaceUIAffectByTimeDilation) == 0x00008A, "Member 'ULGUISettings::bScreenSpaceUIAffectByTimeDilation' has a wrong offset!");
static_assert(offsetof(ULGUISettings, bWorldSpaceUIAffectByGamePause) == 0x00008B, "Member 'ULGUISettings::bWorldSpaceUIAffectByGamePause' has a wrong offset!");
static_assert(offsetof(ULGUISettings, bWorldSpaceUIAffectByTimeDilation) == 0x00008C, "Member 'ULGUISettings::bWorldSpaceUIAffectByTimeDilation' has a wrong offset!");
static_assert(offsetof(ULGUISettings, AntiAliasingMothod) == 0x00008D, "Member 'ULGUISettings::AntiAliasingMothod' has a wrong offset!");
static_assert(offsetof(ULGUISettings, MSAASampleCount) == 0x00008E, "Member 'ULGUISettings::MSAASampleCount' has a wrong offset!");

// Class LGUI.LGUIEditorSettings
// 0x0000 (0x0028 - 0x0028)
class ULGUIEditorSettings final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIEditorSettings">();
	}
	static class ULGUIEditorSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIEditorSettings>();
	}
};
static_assert(alignof(ULGUIEditorSettings) == 0x000008, "Wrong alignment on ULGUIEditorSettings");
static_assert(sizeof(ULGUIEditorSettings) == 0x000028, "Wrong size on ULGUIEditorSettings");

// Class LGUI.LGUISpriteData_BaseObject
// 0x0000 (0x0028 - 0x0028)
class ULGUISpriteData_BaseObject : public UObject
{
public:
	class UTexture2D* GetAtlasTexture();
	const struct FLGUISpriteInfo GetSpriteInfo();

	bool IsIndividual() const;
	bool ReadPixel(const struct FVector2D& InUV, struct FColor* OutPixel) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUISpriteData_BaseObject">();
	}
	static class ULGUISpriteData_BaseObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUISpriteData_BaseObject>();
	}
};
static_assert(alignof(ULGUISpriteData_BaseObject) == 0x000008, "Wrong alignment on ULGUISpriteData_BaseObject");
static_assert(sizeof(ULGUISpriteData_BaseObject) == 0x000028, "Wrong size on ULGUISpriteData_BaseObject");

// Class LGUI.LGUISpriteData
// 0x0060 (0x0088 - 0x0028)
class ULGUISpriteData final : public ULGUISpriteData_BaseObject
{
public:
	class UTexture2D*                             SpriteTexture;                                     // 0x0028(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLGUISpriteInfo                        SpriteInfo;                                        // 0x0030(0x0034)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULGUIStaticSpriteAtlasData*             packingAtlas;                                      // 0x0068(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   packingTag;                                        // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          useEdgePixelPadding;                               // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             atlasTexture;                                      // 0x0080(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class ULGUISpriteData* CreateLGUISpriteData(class UObject* Outer_0, class UTexture2D* inSpriteTexture, const struct FVector2D& inHorizontalBorder, const struct FVector2D& inVerticalBorder, class FName inPackingTag);

	const class FName GetPackingTag() const;
	class UTexture2D* GetSpriteTexture() const;
	bool HavePackingTag() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUISpriteData">();
	}
	static class ULGUISpriteData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUISpriteData>();
	}
};
static_assert(alignof(ULGUISpriteData) == 0x000008, "Wrong alignment on ULGUISpriteData");
static_assert(sizeof(ULGUISpriteData) == 0x000088, "Wrong size on ULGUISpriteData");
static_assert(offsetof(ULGUISpriteData, SpriteTexture) == 0x000028, "Member 'ULGUISpriteData::SpriteTexture' has a wrong offset!");
static_assert(offsetof(ULGUISpriteData, SpriteInfo) == 0x000030, "Member 'ULGUISpriteData::SpriteInfo' has a wrong offset!");
static_assert(offsetof(ULGUISpriteData, packingAtlas) == 0x000068, "Member 'ULGUISpriteData::packingAtlas' has a wrong offset!");
static_assert(offsetof(ULGUISpriteData, packingTag) == 0x000070, "Member 'ULGUISpriteData::packingTag' has a wrong offset!");
static_assert(offsetof(ULGUISpriteData, useEdgePixelPadding) == 0x000078, "Member 'ULGUISpriteData::useEdgePixelPadding' has a wrong offset!");
static_assert(offsetof(ULGUISpriteData, atlasTexture) == 0x000080, "Member 'ULGUISpriteData::atlasTexture' has a wrong offset!");

// Class LGUI.LGUIStaticSpriteAtlasData
// 0x0038 (0x0060 - 0x0028)
class ULGUIStaticSpriteAtlasData final : public UObject
{
public:
	bool                                          atlasTextureUseSRGB;                               // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETextureFilter                                atlasTextureFilter;                                // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             atlasTexture;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ULGUISpriteData*>                spriteArray;                                       // 0x0038(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<uint8>                                 textureMipData;                                    // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint32                                        TextureSize;                                       // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UTexture2D* GetAtlasTexture();
	bool ReadPixel(const struct FVector2D& InUV, struct FColor* OutPixel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIStaticSpriteAtlasData">();
	}
	static class ULGUIStaticSpriteAtlasData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIStaticSpriteAtlasData>();
	}
};
static_assert(alignof(ULGUIStaticSpriteAtlasData) == 0x000008, "Wrong alignment on ULGUIStaticSpriteAtlasData");
static_assert(sizeof(ULGUIStaticSpriteAtlasData) == 0x000060, "Wrong size on ULGUIStaticSpriteAtlasData");
static_assert(offsetof(ULGUIStaticSpriteAtlasData, atlasTextureUseSRGB) == 0x000028, "Member 'ULGUIStaticSpriteAtlasData::atlasTextureUseSRGB' has a wrong offset!");
static_assert(offsetof(ULGUIStaticSpriteAtlasData, atlasTextureFilter) == 0x000029, "Member 'ULGUIStaticSpriteAtlasData::atlasTextureFilter' has a wrong offset!");
static_assert(offsetof(ULGUIStaticSpriteAtlasData, atlasTexture) == 0x000030, "Member 'ULGUIStaticSpriteAtlasData::atlasTexture' has a wrong offset!");
static_assert(offsetof(ULGUIStaticSpriteAtlasData, spriteArray) == 0x000038, "Member 'ULGUIStaticSpriteAtlasData::spriteArray' has a wrong offset!");
static_assert(offsetof(ULGUIStaticSpriteAtlasData, textureMipData) == 0x000048, "Member 'ULGUIStaticSpriteAtlasData::textureMipData' has a wrong offset!");
static_assert(offsetof(ULGUIStaticSpriteAtlasData, TextureSize) == 0x000058, "Member 'ULGUIStaticSpriteAtlasData::TextureSize' has a wrong offset!");

// Class LGUI.LGUIWorldSpaceRaycasterSource
// 0x0008 (0x0030 - 0x0028)
class ULGUIWorldSpaceRaycasterSource : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ReceiveGenerateRay(class ULGUIPointerEventData* InPointerEventData, struct FVector* OutRayOrigin, struct FVector* OutRayDirection);
	void ReceiveInit(class ULGUIBaseRaycaster* InRaycaster);
	bool ReceiveShouldStartDrag(class ULGUIPointerEventData* InPointerEventData);

	class ULGUIBaseRaycaster* GetRaycasterObject() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIWorldSpaceRaycasterSource">();
	}
	static class ULGUIWorldSpaceRaycasterSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIWorldSpaceRaycasterSource>();
	}
};
static_assert(alignof(ULGUIWorldSpaceRaycasterSource) == 0x000008, "Wrong alignment on ULGUIWorldSpaceRaycasterSource");
static_assert(sizeof(ULGUIWorldSpaceRaycasterSource) == 0x000030, "Wrong size on ULGUIWorldSpaceRaycasterSource");

// Class LGUI.LGUIWorldSpaceRaycaster
// 0x0020 (0x02C0 - 0x02A0)
class ULGUIWorldSpaceRaycaster final : public ULGUIBaseRaycaster
{
public:
	ELGUIInteractionTarget                        interactionTarget;                                 // 0x02A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequireFaceIndex;                                 // 0x02A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A2[0x6];                                      // 0x02A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ULGUIWorldSpaceRaycasterSource*         RaycasterSourceObject;                             // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B0[0x10];                                     // 0x02B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetRaycasterSourceObject(class ULGUIWorldSpaceRaycasterSource* NewSource);

	class ULGUIWorldSpaceRaycasterSource* GetRaycasterSourceObject() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIWorldSpaceRaycaster">();
	}
	static class ULGUIWorldSpaceRaycaster* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIWorldSpaceRaycaster>();
	}
};
static_assert(alignof(ULGUIWorldSpaceRaycaster) == 0x000010, "Wrong alignment on ULGUIWorldSpaceRaycaster");
static_assert(sizeof(ULGUIWorldSpaceRaycaster) == 0x0002C0, "Wrong size on ULGUIWorldSpaceRaycaster");
static_assert(offsetof(ULGUIWorldSpaceRaycaster, interactionTarget) == 0x0002A0, "Member 'ULGUIWorldSpaceRaycaster::interactionTarget' has a wrong offset!");
static_assert(offsetof(ULGUIWorldSpaceRaycaster, bRequireFaceIndex) == 0x0002A1, "Member 'ULGUIWorldSpaceRaycaster::bRequireFaceIndex' has a wrong offset!");
static_assert(offsetof(ULGUIWorldSpaceRaycaster, RaycasterSourceObject) == 0x0002A8, "Member 'ULGUIWorldSpaceRaycaster::RaycasterSourceObject' has a wrong offset!");

// Class LGUI.LGUIWorldSpaceRaycasterSource_CenterScreen
// 0x0000 (0x0030 - 0x0030)
class ULGUIWorldSpaceRaycasterSource_CenterScreen final : public ULGUIWorldSpaceRaycasterSource
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIWorldSpaceRaycasterSource_CenterScreen">();
	}
	static class ULGUIWorldSpaceRaycasterSource_CenterScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIWorldSpaceRaycasterSource_CenterScreen>();
	}
};
static_assert(alignof(ULGUIWorldSpaceRaycasterSource_CenterScreen) == 0x000008, "Wrong alignment on ULGUIWorldSpaceRaycasterSource_CenterScreen");
static_assert(sizeof(ULGUIWorldSpaceRaycasterSource_CenterScreen) == 0x000030, "Wrong size on ULGUIWorldSpaceRaycasterSource_CenterScreen");

// Class LGUI.LGUIWorldSpaceRaycasterSource_Mouse
// 0x0000 (0x0030 - 0x0030)
class ULGUIWorldSpaceRaycasterSource_Mouse final : public ULGUIWorldSpaceRaycasterSource
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIWorldSpaceRaycasterSource_Mouse">();
	}
	static class ULGUIWorldSpaceRaycasterSource_Mouse* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIWorldSpaceRaycasterSource_Mouse>();
	}
};
static_assert(alignof(ULGUIWorldSpaceRaycasterSource_Mouse) == 0x000008, "Wrong alignment on ULGUIWorldSpaceRaycasterSource_Mouse");
static_assert(sizeof(ULGUIWorldSpaceRaycasterSource_Mouse) == 0x000030, "Wrong size on ULGUIWorldSpaceRaycasterSource_Mouse");

// Class LGUI.LGUIWorldSpaceRaycasterSource_World
// 0x0008 (0x0038 - 0x0030)
class ULGUIWorldSpaceRaycasterSource_World final : public ULGUIWorldSpaceRaycasterSource
{
public:
	ELGUISceneComponentDirection                  RayDirectionType;                                  // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          clickThresholdRelateToRayDistance;                 // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         rayDistanceMultiply;                               // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIWorldSpaceRaycasterSource_World">();
	}
	static class ULGUIWorldSpaceRaycasterSource_World* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIWorldSpaceRaycasterSource_World>();
	}
};
static_assert(alignof(ULGUIWorldSpaceRaycasterSource_World) == 0x000008, "Wrong alignment on ULGUIWorldSpaceRaycasterSource_World");
static_assert(sizeof(ULGUIWorldSpaceRaycasterSource_World) == 0x000038, "Wrong size on ULGUIWorldSpaceRaycasterSource_World");
static_assert(offsetof(ULGUIWorldSpaceRaycasterSource_World, RayDirectionType) == 0x000030, "Member 'ULGUIWorldSpaceRaycasterSource_World::RayDirectionType' has a wrong offset!");
static_assert(offsetof(ULGUIWorldSpaceRaycasterSource_World, clickThresholdRelateToRayDistance) == 0x000031, "Member 'ULGUIWorldSpaceRaycasterSource_World::clickThresholdRelateToRayDistance' has a wrong offset!");
static_assert(offsetof(ULGUIWorldSpaceRaycasterSource_World, rayDistanceMultiply) == 0x000034, "Member 'ULGUIWorldSpaceRaycasterSource_World::rayDistanceMultiply' has a wrong offset!");

// Class LGUI.LGUI_PointerInputModule
// 0x0018 (0x00B8 - 0x00A0)
class ULGUI_PointerInputModule : public ULGUIBaseInputModule
{
public:
	class ULGUIEventSystem*                       EventSystem;                                       // 0x00A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InputNavigation(ELGUINavigationDirection Direction, bool pressOrRelease, int32 pointerID);
	void InputTriggerForNavigation(bool triggerPress, int32 pointerID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUI_PointerInputModule">();
	}
	static class ULGUI_PointerInputModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUI_PointerInputModule>();
	}
};
static_assert(alignof(ULGUI_PointerInputModule) == 0x000008, "Wrong alignment on ULGUI_PointerInputModule");
static_assert(sizeof(ULGUI_PointerInputModule) == 0x0000B8, "Wrong size on ULGUI_PointerInputModule");
static_assert(offsetof(ULGUI_PointerInputModule, EventSystem) == 0x0000A0, "Member 'ULGUI_PointerInputModule::EventSystem' has a wrong offset!");

// Class LGUI.LGUI_StandaloneInputModule
// 0x0028 (0x00E0 - 0x00B8)
class ULGUI_StandaloneInputModule final : public ULGUI_PointerInputModule
{
public:
	bool                                          bOverrideMousePosition;                            // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x27];                                      // 0x00B9(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InputOverrideMousePosition(const struct FVector2D& inMousePosition);
	void InputScroll(const struct FVector2D& inAxisValue);
	void InputTrigger(bool inTriggerPress, EMouseButtonType inMouseButtonType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUI_StandaloneInputModule">();
	}
	static class ULGUI_StandaloneInputModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUI_StandaloneInputModule>();
	}
};
static_assert(alignof(ULGUI_StandaloneInputModule) == 0x000008, "Wrong alignment on ULGUI_StandaloneInputModule");
static_assert(sizeof(ULGUI_StandaloneInputModule) == 0x0000E0, "Wrong size on ULGUI_StandaloneInputModule");
static_assert(offsetof(ULGUI_StandaloneInputModule, bOverrideMousePosition) == 0x0000B8, "Member 'ULGUI_StandaloneInputModule::bOverrideMousePosition' has a wrong offset!");

// Class LGUI.LGUI_TouchInputModule
// 0x0000 (0x00B8 - 0x00B8)
class ULGUI_TouchInputModule final : public ULGUI_PointerInputModule
{
public:
	void InputScroll(const struct FVector2D& inAxisValue);
	void InputTouchMoved(int32 inTouchID, const struct FVector& inTouchPointPosition);
	void InputTouchTrigger(bool inTouchPress, int32 inTouchID, const struct FVector& inTouchPointPosition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUI_TouchInputModule">();
	}
	static class ULGUI_TouchInputModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUI_TouchInputModule>();
	}
};
static_assert(alignof(ULGUI_TouchInputModule) == 0x000008, "Wrong alignment on ULGUI_TouchInputModule");
static_assert(sizeof(ULGUI_TouchInputModule) == 0x0000B8, "Wrong size on ULGUI_TouchInputModule");

// Class LGUI.MovieSceneLGUIMaterialTrack
// 0x0020 (0x00D0 - 0x00B0)
class UMovieSceneLGUIMaterialTrack final : public UMovieSceneMaterialTrack
{
public:
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PropertyName;                                      // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   TrackName;                                         // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneLGUIMaterialTrack">();
	}
	static class UMovieSceneLGUIMaterialTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneLGUIMaterialTrack>();
	}
};
static_assert(alignof(UMovieSceneLGUIMaterialTrack) == 0x000008, "Wrong alignment on UMovieSceneLGUIMaterialTrack");
static_assert(sizeof(UMovieSceneLGUIMaterialTrack) == 0x0000D0, "Wrong size on UMovieSceneLGUIMaterialTrack");
static_assert(offsetof(UMovieSceneLGUIMaterialTrack, PropertyName) == 0x0000C0, "Member 'UMovieSceneLGUIMaterialTrack::PropertyName' has a wrong offset!");
static_assert(offsetof(UMovieSceneLGUIMaterialTrack, TrackName) == 0x0000C8, "Member 'UMovieSceneLGUIMaterialTrack::TrackName' has a wrong offset!");

// Class LGUI.UIItem
// 0x01E0 (0x0410 - 0x0230)
class UUIItem : public USceneComponent
{
public:
	uint8                                         Pad_230[0xE8];                                     // 0x0230(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUIAnchorData                          AnchorData;                                        // 0x0318(0x0050)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UUIItem>                 ParentUIItem;                                      // 0x0368(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_370[0x8];                                      // 0x0370(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIItem*>                        UIChildren;                                        // 0x0378(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_388[0x24];                                     // 0x0388(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UUICanvasGroup>          CanvasGroup;                                       // 0x03AC(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B4[0x16];                                     // 0x03B4(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsUIActive;                                       // 0x03CA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3CB[0x1D];                                     // 0x03CB(0x001D)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         hierarchyIndex;                                    // 0x03E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         flattenHierarchyIndex;                             // 0x03EC(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DisplayName;                                       // 0x03F0(0x0010)(Edit, ZeroConstructor, EditConst, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRaycastTarget;                                    // 0x0400(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETraceTypeQuery                               TraceChannel;                                      // 0x0401(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_402[0x2];                                      // 0x0402(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ULGUICanvas>             RenderCanvas;                                      // 0x0404(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsCanvasUIItem : 1;                               // 0x040C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_40D[0x3];                                      // 0x040D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ULTweener* AnchorBottomTo(float endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* AnchoredPositionTo(const struct FVector2D& endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* AnchorLeftTo(float endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* AnchorRightTo(float endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* AnchorTopTo(float endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* HeightTo(float endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* HorizontalAnchoredPositionTo(float endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* PivotTo(const struct FVector2D& endValue, float Duration, float Delay, ELTweenEase Ease);
	void SetAnchorBottom(float Value);
	void SetAnchorData(const struct FUIAnchorData& Value);
	void SetAnchoredPosition(const struct FVector2D& Value);
	void SetAnchorLeft(float Value);
	void SetAnchorMax(const struct FVector2D& Value);
	void SetAnchorMin(const struct FVector2D& Value);
	void SetAnchorRight(float Value);
	void SetAnchorTop(float Value);
	void SetAsFirstHierarchy();
	void SetAsLastHierarchy();
	void SetDisplayName(const class FString& InName);
	void SetHeight(float Value);
	void SetHierarchyIndex(int32 inInt);
	void SetHorizontalAnchoredPosition(float Value);
	void SetHorizontalAnchorMinMax(const struct FVector2D& Value, bool bKeepSize, bool bKeepRelativeLocation);
	void SetHorizontalAndVerticalAnchorMinMax(const struct FVector2D& MinValue, const struct FVector2D& MaxValue, bool bKeepSize, bool bKeepRelativeLocation);
	void SetIsUIActive(bool Active);
	void SetPivot(const struct FVector2D& Value);
	void SetRaycastTarget(bool newBool);
	void SetSizeDelta(const struct FVector2D& Value);
	void SetTraceChannel(ETraceTypeQuery InTraceChannel);
	void SetVerticalAnchoredPosition(float Value);
	void SetVerticalAnchorMinMax(const struct FVector2D& Value, bool bKeepSize, bool bKeepRelativeLocation);
	void SetWidth(float Value);
	class ULTweener* VerticalAnchoredPositionTo(float endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* WidthTo(float endValue, float Duration, float Delay, ELTweenEase Ease);

	TArray<class UUIItem*> FindChildArrayByDisplayName(const class FString& InName, bool IncludeChildren) const;
	class UUIItem* FindChildByDisplayName(const class FString& InName, bool IncludeChildren) const;
	float GetAnchorBottom() const;
	const struct FUIAnchorData GetAnchorData() const;
	struct FVector2D GetAnchoredPosition() const;
	float GetAnchorLeft() const;
	struct FVector2D GetAnchorMax() const;
	struct FVector2D GetAnchorMin() const;
	float GetAnchorRight() const;
	float GetAnchorTop() const;
	class UUIItem* GetAttachUIChild(int32 Index_0) const;
	const TArray<class UUIItem*> GetAttachUIChildren() const;
	class UUICanvasGroup* GetCanvasGroup() const;
	class ULGUICanvasScaler* GetCanvasScaler() const;
	class FString GetDisplayName() const;
	int32 GetFlattenHierarchyIndex() const;
	float GetHeight() const;
	int32 GetHierarchyIndex() const;
	float GetHorizontalAnchoredPosition() const;
	bool GetIsUIActiveInHierarchy() const;
	bool GetIsUIActiveSelf() const;
	float GetLocalSpaceBottom() const;
	struct FVector2D GetLocalSpaceCenter() const;
	float GetLocalSpaceLeft() const;
	struct FVector2D GetLocalSpaceLeftBottomPoint() const;
	float GetLocalSpaceRight() const;
	struct FVector2D GetLocalSpaceRightTopPoint() const;
	float GetLocalSpaceTop() const;
	class UUIItem* GetParentUIItem() const;
	struct FVector2D GetPivot() const;
	class ULGUICanvas* GetRenderCanvas() const;
	class ULGUICanvas* GetRootCanvas() const;
	class UUIItem* GetRootUIItemInHierarchy() const;
	struct FVector2D GetSizeDelta() const;
	ETraceTypeQuery GetTraceChannel() const;
	float GetVerticalAnchoredPosition() const;
	float GetWidth() const;
	bool IsRaycastTarget() const;
	bool IsRenderTargetUI() const;
	bool IsScreenSpaceOverlayUI() const;
	bool IsWorldSpaceUI() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItem">();
	}
	static class UUIItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItem>();
	}
};
static_assert(alignof(UUIItem) == 0x000010, "Wrong alignment on UUIItem");
static_assert(sizeof(UUIItem) == 0x000410, "Wrong size on UUIItem");
static_assert(offsetof(UUIItem, AnchorData) == 0x000318, "Member 'UUIItem::AnchorData' has a wrong offset!");
static_assert(offsetof(UUIItem, ParentUIItem) == 0x000368, "Member 'UUIItem::ParentUIItem' has a wrong offset!");
static_assert(offsetof(UUIItem, UIChildren) == 0x000378, "Member 'UUIItem::UIChildren' has a wrong offset!");
static_assert(offsetof(UUIItem, CanvasGroup) == 0x0003AC, "Member 'UUIItem::CanvasGroup' has a wrong offset!");
static_assert(offsetof(UUIItem, bIsUIActive) == 0x0003CA, "Member 'UUIItem::bIsUIActive' has a wrong offset!");
static_assert(offsetof(UUIItem, hierarchyIndex) == 0x0003E8, "Member 'UUIItem::hierarchyIndex' has a wrong offset!");
static_assert(offsetof(UUIItem, flattenHierarchyIndex) == 0x0003EC, "Member 'UUIItem::flattenHierarchyIndex' has a wrong offset!");
static_assert(offsetof(UUIItem, DisplayName) == 0x0003F0, "Member 'UUIItem::DisplayName' has a wrong offset!");
static_assert(offsetof(UUIItem, bRaycastTarget) == 0x000400, "Member 'UUIItem::bRaycastTarget' has a wrong offset!");
static_assert(offsetof(UUIItem, TraceChannel) == 0x000401, "Member 'UUIItem::TraceChannel' has a wrong offset!");
static_assert(offsetof(UUIItem, RenderCanvas) == 0x000404, "Member 'UUIItem::RenderCanvas' has a wrong offset!");

// Class LGUI.UIBaseRenderable
// 0x0040 (0x0450 - 0x0410)
class UUIBaseRenderable : public UUIItem
{
public:
	uint8                                         Pad_410[0x4];                                      // 0x0410(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 Color;                                             // 0x0414(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIRenderableRaycastType                      RaycastType;                                       // 0x0418(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_419[0x7];                                      // 0x0419(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIRenderableCustomRaycast*             CustomRaycastObject;                               // 0x0420(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VisiblePixelThreadhold;                            // 0x0428(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_42C[0x24];                                     // 0x042C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ULTweener* AlphaFrom(float StartValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* AlphaTo(float endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* ColorFrom(const struct FColor& StartValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* ColorTo(const struct FColor& endValue, float Duration, float Delay, ELTweenEase Ease);
	void SetAlpha(float Value);
	void SetColor(const struct FColor& Value);
	void SetCustomRaycastObject(class UUIRenderableCustomRaycast* Value);
	void SetRaycastType(EUIRenderableRaycastType Value);

	float GetAlpha() const;
	struct FColor GetColor() const;
	class UUIRenderableCustomRaycast* GetCustomRaycastObject() const;
	float GetFinalAlpha01() const;
	struct FColor GetFinalColor() const;
	EUIRenderableRaycastType GetRaycastType() const;
	EUIRenderableType GetUIRenderableType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBaseRenderable">();
	}
	static class UUIBaseRenderable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBaseRenderable>();
	}
};
static_assert(alignof(UUIBaseRenderable) == 0x000010, "Wrong alignment on UUIBaseRenderable");
static_assert(sizeof(UUIBaseRenderable) == 0x000450, "Wrong size on UUIBaseRenderable");
static_assert(offsetof(UUIBaseRenderable, Color) == 0x000414, "Member 'UUIBaseRenderable::Color' has a wrong offset!");
static_assert(offsetof(UUIBaseRenderable, RaycastType) == 0x000418, "Member 'UUIBaseRenderable::RaycastType' has a wrong offset!");
static_assert(offsetof(UUIBaseRenderable, CustomRaycastObject) == 0x000420, "Member 'UUIBaseRenderable::CustomRaycastObject' has a wrong offset!");
static_assert(offsetof(UUIBaseRenderable, VisiblePixelThreadhold) == 0x000428, "Member 'UUIBaseRenderable::VisiblePixelThreadhold' has a wrong offset!");

// Class LGUI.UIBatchMeshRenderable
// 0x0110 (0x0560 - 0x0450)
class UUIBatchMeshRenderable : public UUIBaseRenderable
{
public:
	uint8                                         Pad_450[0xD8];                                     // 0x0450(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     CustomUIMaterial;                                  // 0x0528(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_530[0x28];                                     // 0x0530(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class ULGUIGeometryHelper*                    GeometryHelper;                                    // 0x0558(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void MarkVerticesDirty();
	class UMaterialInterface* ReceiveGetMaterialToCreateGeometry();
	class UTexture* ReceiveGetTextureToCreateGeometry();
	void ReceiveOnBeforeCreateOrUpdateGeometry();
	void ReceiveOnUpdateGeometry(class ULGUIGeometryHelper* InGeometryHelper, bool InTriangleChanged, bool InVertexPositionChanged, bool InVertexUVChanged, bool InVertexColorChanged);
	void SetCustomUIMaterial(class UMaterialInterface* InMat);

	class UMaterialInterface* GetCustomUIMaterial() const;
	class UMaterialInstanceDynamic* GetMaterialInstanceDynamic() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBatchMeshRenderable">();
	}
	static class UUIBatchMeshRenderable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBatchMeshRenderable>();
	}
};
static_assert(alignof(UUIBatchMeshRenderable) == 0x000010, "Wrong alignment on UUIBatchMeshRenderable");
static_assert(sizeof(UUIBatchMeshRenderable) == 0x000560, "Wrong size on UUIBatchMeshRenderable");
static_assert(offsetof(UUIBatchMeshRenderable, CustomUIMaterial) == 0x000528, "Member 'UUIBatchMeshRenderable::CustomUIMaterial' has a wrong offset!");
static_assert(offsetof(UUIBatchMeshRenderable, GeometryHelper) == 0x000558, "Member 'UUIBatchMeshRenderable::GeometryHelper' has a wrong offset!");

// Class LGUI.UISpriteBase
// 0x0020 (0x0580 - 0x0560)
#pragma pack(push, 0x1)
class alignas(0x10) UUISpriteBase : public UUIBatchMeshRenderable
{
public:
	uint8                                         Pad_560[0x8];                                      // 0x0560(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULGUISpriteData_BaseObject*             Sprite;                                            // 0x0568(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_570[0x8];                                      // 0x0570(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSizeFromSpriteData();
	void SetSprite(class ULGUISpriteData_BaseObject* NewSprite, bool SetSize);

	class ULGUISpriteData_BaseObject* GetSprite() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISpriteBase">();
	}
	static class UUISpriteBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISpriteBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(UUISpriteBase) == 0x000010, "Wrong alignment on UUISpriteBase");
static_assert(sizeof(UUISpriteBase) == 0x000580, "Wrong size on UUISpriteBase");
static_assert(offsetof(UUISpriteBase, Sprite) == 0x000568, "Member 'UUISpriteBase::Sprite' has a wrong offset!");

// Class LGUI.UI2DLineRendererBase
// 0x0010 (0x0590 - 0x0580)
#pragma pack(push, 0x1)
class alignas(0x10) UUI2DLineRendererBase : public UUISpriteBase
{
public:
	float                                         LineWidth;                                         // 0x0578(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUI2DLineRenderer_EndType                     EndType;                                           // 0x057C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEndCapSizeAffectByLineWidth;                      // 0x057D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_57E[0x2];                                      // 0x057E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LineWidthOffset;                                   // 0x0580(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_584[0x4];                                      // 0x0584(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ULTweener* LineWidthTo(float endValue, float Duration, float Delay, ELTweenEase easetype);
	void SetEndType(EUI2DLineRenderer_EndType NewValue);
	void SetLineWidth(float NewValue);
	void SetLineWidthOffset(float NewValue);

	EUI2DLineRenderer_EndType GetEndType() const;
	float GetLineWidth() const;
	float GetLineWidthOffset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI2DLineRendererBase">();
	}
	static class UUI2DLineRendererBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI2DLineRendererBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(UUI2DLineRendererBase) == 0x000010, "Wrong alignment on UUI2DLineRendererBase");
static_assert(sizeof(UUI2DLineRendererBase) == 0x000590, "Wrong size on UUI2DLineRendererBase");
static_assert(offsetof(UUI2DLineRendererBase, LineWidth) == 0x000578, "Member 'UUI2DLineRendererBase::LineWidth' has a wrong offset!");
static_assert(offsetof(UUI2DLineRendererBase, EndType) == 0x00057C, "Member 'UUI2DLineRendererBase::EndType' has a wrong offset!");
static_assert(offsetof(UUI2DLineRendererBase, bEndCapSizeAffectByLineWidth) == 0x00057D, "Member 'UUI2DLineRendererBase::bEndCapSizeAffectByLineWidth' has a wrong offset!");
static_assert(offsetof(UUI2DLineRendererBase, LineWidthOffset) == 0x000580, "Member 'UUI2DLineRendererBase::LineWidthOffset' has a wrong offset!");

// Class LGUI.UI2DLineChildrenAsPoints
// 0x0010 (0x05A0 - 0x0590)
class UUI2DLineChildrenAsPoints final : public UUI2DLineRendererBase
{
public:
	TArray<struct FVector2D>                      CurrentPointArray;                                 // 0x0588(0x0010)(Edit, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_598[0x8];                                      // 0x0598(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI2DLineChildrenAsPoints">();
	}
	static class UUI2DLineChildrenAsPoints* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI2DLineChildrenAsPoints>();
	}
};
static_assert(alignof(UUI2DLineChildrenAsPoints) == 0x000010, "Wrong alignment on UUI2DLineChildrenAsPoints");
static_assert(sizeof(UUI2DLineChildrenAsPoints) == 0x0005A0, "Wrong size on UUI2DLineChildrenAsPoints");
static_assert(offsetof(UUI2DLineChildrenAsPoints, CurrentPointArray) == 0x000588, "Member 'UUI2DLineChildrenAsPoints::CurrentPointArray' has a wrong offset!");

// Class LGUI.UI2DLineChildrenAsPointsActor
// 0x0008 (0x0298 - 0x0290)
class AUI2DLineChildrenAsPointsActor final : public AUIBaseRenderableActor
{
public:
	class UUI2DLineChildrenAsPoints*              UIElement;                                         // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UUI2DLineChildrenAsPoints* Get2DLineChildrenAsPoints() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI2DLineChildrenAsPointsActor">();
	}
	static class AUI2DLineChildrenAsPointsActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUI2DLineChildrenAsPointsActor>();
	}
};
static_assert(alignof(AUI2DLineChildrenAsPointsActor) == 0x000008, "Wrong alignment on AUI2DLineChildrenAsPointsActor");
static_assert(sizeof(AUI2DLineChildrenAsPointsActor) == 0x000298, "Wrong size on AUI2DLineChildrenAsPointsActor");
static_assert(offsetof(AUI2DLineChildrenAsPointsActor, UIElement) == 0x000290, "Member 'AUI2DLineChildrenAsPointsActor::UIElement' has a wrong offset!");

// Class LGUI.UI2DLineRaw
// 0x0010 (0x05A0 - 0x0590)
class UUI2DLineRaw final : public UUI2DLineRendererBase
{
public:
	TArray<struct FVector2D>                      PointArray;                                        // 0x0588(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_598[0x8];                                      // 0x0598(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetPoints(const TArray<struct FVector2D>& InPoints);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI2DLineRaw">();
	}
	static class UUI2DLineRaw* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI2DLineRaw>();
	}
};
static_assert(alignof(UUI2DLineRaw) == 0x000010, "Wrong alignment on UUI2DLineRaw");
static_assert(sizeof(UUI2DLineRaw) == 0x0005A0, "Wrong size on UUI2DLineRaw");
static_assert(offsetof(UUI2DLineRaw, PointArray) == 0x000588, "Member 'UUI2DLineRaw::PointArray' has a wrong offset!");

// Class LGUI.UI2DLineActor
// 0x0008 (0x0298 - 0x0290)
class AUI2DLineActor final : public AUIBaseRenderableActor
{
public:
	class UUI2DLineRaw*                           UIElement;                                         // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UUI2DLineRaw* Get2DLineRaw() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI2DLineActor">();
	}
	static class AUI2DLineActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUI2DLineActor>();
	}
};
static_assert(alignof(AUI2DLineActor) == 0x000008, "Wrong alignment on AUI2DLineActor");
static_assert(sizeof(AUI2DLineActor) == 0x000298, "Wrong size on AUI2DLineActor");
static_assert(offsetof(AUI2DLineActor, UIElement) == 0x000290, "Member 'AUI2DLineActor::UIElement' has a wrong offset!");

// Class LGUI.UIPostProcessRenderable
// 0x00C0 (0x0510 - 0x0450)
#pragma pack(push, 0x1)
class alignas(0x10) UUIPostProcessRenderable : public UUIBaseRenderable
{
public:
	uint8                                         Pad_450[0x18];                                     // 0x0450(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             maskTexture;                                       // 0x0468(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIPostProcessMaskTextureType                 MaskTextureType;                                   // 0x0470(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_471[0x3];                                      // 0x0471(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUISpriteInfo                        MaskTextureSpriteInfo;                             // 0x0474(0x0034)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A8[0x8];                                      // 0x04A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               MaskTextureUVRect;                                 // 0x04B0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D0[0x38];                                     // 0x04D0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMaskTexture(class UTexture2D* NewValue);
	void SetMaskTextureSpriteInfo(const struct FLGUISpriteInfo& Value);
	void SetMaskTextureType(EUIPostProcessMaskTextureType Value);
	void SetMaskTextureUVRect(const struct FVector4& Value);

	class UTexture2D* GetMaskTexture() const;
	const struct FLGUISpriteInfo GetMaskTextureSpriteInfo() const;
	EUIPostProcessMaskTextureType GetMaskTextureType() const;
	const struct FVector4 GetMaskTextureUVRect() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPostProcessRenderable">();
	}
	static class UUIPostProcessRenderable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPostProcessRenderable>();
	}
};
#pragma pack(pop)
static_assert(alignof(UUIPostProcessRenderable) == 0x000010, "Wrong alignment on UUIPostProcessRenderable");
static_assert(sizeof(UUIPostProcessRenderable) == 0x000510, "Wrong size on UUIPostProcessRenderable");
static_assert(offsetof(UUIPostProcessRenderable, maskTexture) == 0x000468, "Member 'UUIPostProcessRenderable::maskTexture' has a wrong offset!");
static_assert(offsetof(UUIPostProcessRenderable, MaskTextureType) == 0x000470, "Member 'UUIPostProcessRenderable::MaskTextureType' has a wrong offset!");
static_assert(offsetof(UUIPostProcessRenderable, MaskTextureSpriteInfo) == 0x000474, "Member 'UUIPostProcessRenderable::MaskTextureSpriteInfo' has a wrong offset!");
static_assert(offsetof(UUIPostProcessRenderable, MaskTextureUVRect) == 0x0004B0, "Member 'UUIPostProcessRenderable::MaskTextureUVRect' has a wrong offset!");

// Class LGUI.UIBackgroundBlur
// 0x0020 (0x0530 - 0x0510)
class UUIBackgroundBlur final : public UUIPostProcessRenderable
{
public:
	float                                         BlurStrength;                                      // 0x0508(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          applyAlphaToBlur;                                  // 0x050C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50D[0x3];                                      // 0x050D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         maxDownSampleLevel;                                // 0x0510(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_514[0x4];                                      // 0x0514(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             strengthTexture;                                   // 0x0518(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_520[0x10];                                     // 0x0520(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetApplyAlphaToBlur(bool NewValue);
	void SetBlurStrength(float NewValue);
	void SetMaxDownSampleLevel(int32 NewValue);
	void SetStrengthTexture(class UTexture2D* NewValue);

	bool GetApplyAlphaToBlur() const;
	float GetBlurStrength() const;
	int32 GetMaxDownSampleLevel() const;
	class UTexture2D* GetStrengthTexture() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBackgroundBlur">();
	}
	static class UUIBackgroundBlur* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBackgroundBlur>();
	}
};
static_assert(alignof(UUIBackgroundBlur) == 0x000010, "Wrong alignment on UUIBackgroundBlur");
static_assert(sizeof(UUIBackgroundBlur) == 0x000530, "Wrong size on UUIBackgroundBlur");
static_assert(offsetof(UUIBackgroundBlur, BlurStrength) == 0x000508, "Member 'UUIBackgroundBlur::BlurStrength' has a wrong offset!");
static_assert(offsetof(UUIBackgroundBlur, applyAlphaToBlur) == 0x00050C, "Member 'UUIBackgroundBlur::applyAlphaToBlur' has a wrong offset!");
static_assert(offsetof(UUIBackgroundBlur, maxDownSampleLevel) == 0x000510, "Member 'UUIBackgroundBlur::maxDownSampleLevel' has a wrong offset!");
static_assert(offsetof(UUIBackgroundBlur, strengthTexture) == 0x000518, "Member 'UUIBackgroundBlur::strengthTexture' has a wrong offset!");

// Class LGUI.UIBackgroundBlurActor
// 0x0008 (0x0298 - 0x0290)
class AUIBackgroundBlurActor final : public AUIBasePostProcessActor
{
public:
	class UUIBackgroundBlur*                      UIBackgroundBlur;                                  // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UUIBackgroundBlur* GetUIBackgroundBlur() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBackgroundBlurActor">();
	}
	static class AUIBackgroundBlurActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIBackgroundBlurActor>();
	}
};
static_assert(alignof(AUIBackgroundBlurActor) == 0x000008, "Wrong alignment on AUIBackgroundBlurActor");
static_assert(sizeof(AUIBackgroundBlurActor) == 0x000298, "Wrong size on AUIBackgroundBlurActor");
static_assert(offsetof(AUIBackgroundBlurActor, UIBackgroundBlur) == 0x000290, "Member 'AUIBackgroundBlurActor::UIBackgroundBlur' has a wrong offset!");

// Class LGUI.UIBackgroundPixelate
// 0x0000 (0x0510 - 0x0510)
class UUIBackgroundPixelate final : public UUIPostProcessRenderable
{
public:
	float                                         pixelateStrength;                                  // 0x0508(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          applyAlphaToStrength;                              // 0x050C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50D[0x3];                                      // 0x050D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetApplyAlphaToStrength(bool NewValue);
	void SetPixelateStrength(float NewValue);

	bool GetApplyAlphaToStrength() const;
	float GetPixelateStrength() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBackgroundPixelate">();
	}
	static class UUIBackgroundPixelate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBackgroundPixelate>();
	}
};
static_assert(alignof(UUIBackgroundPixelate) == 0x000010, "Wrong alignment on UUIBackgroundPixelate");
static_assert(sizeof(UUIBackgroundPixelate) == 0x000510, "Wrong size on UUIBackgroundPixelate");
static_assert(offsetof(UUIBackgroundPixelate, pixelateStrength) == 0x000508, "Member 'UUIBackgroundPixelate::pixelateStrength' has a wrong offset!");
static_assert(offsetof(UUIBackgroundPixelate, applyAlphaToStrength) == 0x00050C, "Member 'UUIBackgroundPixelate::applyAlphaToStrength' has a wrong offset!");

// Class LGUI.UIBackgroundPixelateActor
// 0x0008 (0x0298 - 0x0290)
class AUIBackgroundPixelateActor final : public AUIBasePostProcessActor
{
public:
	class UUIBackgroundPixelate*                  UIBackgroundPixelate;                              // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UUIBackgroundPixelate* GetUIBackgroundPixelate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBackgroundPixelateActor">();
	}
	static class AUIBackgroundPixelateActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIBackgroundPixelateActor>();
	}
};
static_assert(alignof(AUIBackgroundPixelateActor) == 0x000008, "Wrong alignment on AUIBackgroundPixelateActor");
static_assert(sizeof(AUIBackgroundPixelateActor) == 0x000298, "Wrong size on AUIBackgroundPixelateActor");
static_assert(offsetof(AUIBackgroundPixelateActor, UIBackgroundPixelate) == 0x000290, "Member 'AUIBackgroundPixelateActor::UIBackgroundPixelate' has a wrong offset!");

// Class LGUI.UIRenderableCustomRaycast
// 0x0000 (0x0028 - 0x0028)
class UUIRenderableCustomRaycast : public UObject
{
public:
	static bool GetRaycastPixelFromUIBatchMeshRenderable(class UUIBatchMeshRenderable* InUIRenderable, const struct FVector& InLocalSpaceRayStart, const struct FVector& InLocalSpaceRayEnd, struct FVector2D* OutUV, struct FColor* OutPixel, struct FVector* OutHitPoint, struct FVector* OutHitNormal);

	bool ReceiveRaycast(class UUIBaseRenderable* InUIRenderable, const struct FVector& InLocalSpaceRayStart, const struct FVector& InLocalSpaceRayEnd, struct FVector* OutHitPoint, struct FVector* OutHitNormal);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRenderableCustomRaycast">();
	}
	static class UUIRenderableCustomRaycast* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIRenderableCustomRaycast>();
	}
};
static_assert(alignof(UUIRenderableCustomRaycast) == 0x000008, "Wrong alignment on UUIRenderableCustomRaycast");
static_assert(sizeof(UUIRenderableCustomRaycast) == 0x000028, "Wrong size on UUIRenderableCustomRaycast");

// Class LGUI.UISelectableComponent
// 0x0168 (0x0248 - 0x00E0)
class UUISelectableComponent : public ULGUILifeCycleUIBehaviour
{
public:
	uint8                                         Pad_E0[0x20];                                      // 0x00E0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AUIBaseRenderableActor>  TransitionActor;                                   // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          AllowEventBubbleUp;                                // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInteractable;                                     // 0x0109(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUISelectableTransitionType                   Transition;                                        // 0x010A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10B[0x5];                                      // 0x010B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class ULTweener*                              TransitionTweener;                                 // 0x0110(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 NormalColor;                                       // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 HighlightedColor;                                  // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 PressedColor;                                      // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 DisabledColor;                                     // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeDuration;                                      // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULGUISpriteData_BaseObject*             NormalSprite;                                      // 0x0130(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULGUISpriteData_BaseObject*             HighlightedSprite;                                 // 0x0138(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULGUISpriteData_BaseObject*             PressedSprite;                                     // 0x0140(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULGUISpriteData_BaseObject*             DisabledSprite;                                    // 0x0148(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_150[0x4];                                      // 0x0150(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UUISelectableTransitionComponent> TransitionComp;                           // 0x0154(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanNavigateHere;                                  // 0x015C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUISelectableNavigationMode                   NavigationLeft;                                    // 0x015D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15E[0x2];                                      // 0x015E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIComponentReference                NavigationLeftSpecific;                            // 0x0160(0x0020)(Edit, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EUISelectableNavigationMode                   NavigationRight;                                   // 0x0180(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIComponentReference                NavigationRightSpecific;                           // 0x0188(0x0020)(Edit, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EUISelectableNavigationMode                   NavigationUp;                                      // 0x01A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIComponentReference                NavigationUpSpecific;                              // 0x01B0(0x0020)(Edit, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EUISelectableNavigationMode                   NavigationDown;                                    // 0x01D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D1[0x7];                                      // 0x01D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIComponentReference                NavigationDownSpecific;                            // 0x01D8(0x0020)(Edit, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EUISelectableNavigationMode                   NavigationNext;                                    // 0x01F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIComponentReference                NavigationNextSpecific;                            // 0x0200(0x0020)(Edit, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EUISelectableNavigationMode                   NavigationPrev;                                    // 0x0220(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_221[0x7];                                      // 0x0221(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIComponentReference                NavigationPrevSpecific;                            // 0x0228(0x0020)(Edit, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void SetCanNavigateHere(bool Value);
	void SetDisabledColor(const struct FColor& NewColor);
	void SetDisabledSprite(class ULGUISpriteData_BaseObject* NewSprite);
	void SetHighlightedColor(const struct FColor& NewColor);
	void SetHighlightedSprite(class ULGUISpriteData_BaseObject* NewSprite);
	void SetNavigationDown(EUISelectableNavigationMode Value);
	void SetNavigationDownExplicit(class UUISelectableComponent* Value);
	void SetNavigationLeft(EUISelectableNavigationMode Value);
	void SetNavigationLeftExplicit(class UUISelectableComponent* Value);
	void SetNavigationNext(EUISelectableNavigationMode Value);
	void SetNavigationNextExplicit(class UUISelectableComponent* Value);
	void SetNavigationPrev(EUISelectableNavigationMode Value);
	void SetNavigationPrevExplicit(class UUISelectableComponent* Value);
	void SetNavigationRight(EUISelectableNavigationMode Value);
	void SetNavigationRightExplicit(class UUISelectableComponent* Value);
	void SetNavigationUp(EUISelectableNavigationMode Value);
	void SetNavigationUpExplicit(class UUISelectableComponent* Value);
	void SetNormalColor(const struct FColor& NewColor);
	void SetNormalSprite(class ULGUISpriteData_BaseObject* NewSprite);
	void SetPressedColor(const struct FColor& NewColor);
	void SetPressedSprite(class ULGUISpriteData_BaseObject* NewSprite);
	void SetSelectionState(EUISelectableSelectionState NewState);
	void SetTransitionTarget(class AUIBaseRenderableActor* Value);

	bool GetCanNavigateHere() const;
	struct FColor GetDisabledColor() const;
	class ULGUISpriteData_BaseObject* GetDisabledSprite() const;
	struct FColor GetHighlightedColor() const;
	class ULGUISpriteData_BaseObject* GetHighlightedSprite() const;
	EUISelectableNavigationMode GetNavigationDown() const;
	class UUISelectableComponent* GetNavigationDownExplicit() const;
	EUISelectableNavigationMode GetNavigationLeft() const;
	class UUISelectableComponent* GetNavigationLeftExplicit() const;
	EUISelectableNavigationMode GetNavigationNext() const;
	class UUISelectableComponent* GetNavigationNextExplicit() const;
	EUISelectableNavigationMode GetNavigationPrev() const;
	class UUISelectableComponent* GetNavigationPrevExplicit() const;
	EUISelectableNavigationMode GetNavigationRight() const;
	class UUISelectableComponent* GetNavigationRightExplicit() const;
	EUISelectableNavigationMode GetNavigationUp() const;
	class UUISelectableComponent* GetNavigationUpExplicit() const;
	struct FColor GetNormalColor() const;
	class ULGUISpriteData_BaseObject* GetNormalSprite() const;
	struct FColor GetPressedColor() const;
	class ULGUISpriteData_BaseObject* GetPressedSprite() const;
	EUISelectableSelectionState GetSelectionState() const;
	class AUIBaseRenderableActor* GetTransitionTarget() const;
	bool IsInteractable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISelectableComponent">();
	}
	static class UUISelectableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISelectableComponent>();
	}
};
static_assert(alignof(UUISelectableComponent) == 0x000008, "Wrong alignment on UUISelectableComponent");
static_assert(sizeof(UUISelectableComponent) == 0x000248, "Wrong size on UUISelectableComponent");
static_assert(offsetof(UUISelectableComponent, TransitionActor) == 0x000100, "Member 'UUISelectableComponent::TransitionActor' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, AllowEventBubbleUp) == 0x000108, "Member 'UUISelectableComponent::AllowEventBubbleUp' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, bInteractable) == 0x000109, "Member 'UUISelectableComponent::bInteractable' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, Transition) == 0x00010A, "Member 'UUISelectableComponent::Transition' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, TransitionTweener) == 0x000110, "Member 'UUISelectableComponent::TransitionTweener' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NormalColor) == 0x000118, "Member 'UUISelectableComponent::NormalColor' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, HighlightedColor) == 0x00011C, "Member 'UUISelectableComponent::HighlightedColor' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, PressedColor) == 0x000120, "Member 'UUISelectableComponent::PressedColor' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, DisabledColor) == 0x000124, "Member 'UUISelectableComponent::DisabledColor' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, FadeDuration) == 0x000128, "Member 'UUISelectableComponent::FadeDuration' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NormalSprite) == 0x000130, "Member 'UUISelectableComponent::NormalSprite' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, HighlightedSprite) == 0x000138, "Member 'UUISelectableComponent::HighlightedSprite' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, PressedSprite) == 0x000140, "Member 'UUISelectableComponent::PressedSprite' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, DisabledSprite) == 0x000148, "Member 'UUISelectableComponent::DisabledSprite' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, TransitionComp) == 0x000154, "Member 'UUISelectableComponent::TransitionComp' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, bCanNavigateHere) == 0x00015C, "Member 'UUISelectableComponent::bCanNavigateHere' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NavigationLeft) == 0x00015D, "Member 'UUISelectableComponent::NavigationLeft' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NavigationLeftSpecific) == 0x000160, "Member 'UUISelectableComponent::NavigationLeftSpecific' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NavigationRight) == 0x000180, "Member 'UUISelectableComponent::NavigationRight' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NavigationRightSpecific) == 0x000188, "Member 'UUISelectableComponent::NavigationRightSpecific' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NavigationUp) == 0x0001A8, "Member 'UUISelectableComponent::NavigationUp' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NavigationUpSpecific) == 0x0001B0, "Member 'UUISelectableComponent::NavigationUpSpecific' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NavigationDown) == 0x0001D0, "Member 'UUISelectableComponent::NavigationDown' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NavigationDownSpecific) == 0x0001D8, "Member 'UUISelectableComponent::NavigationDownSpecific' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NavigationNext) == 0x0001F8, "Member 'UUISelectableComponent::NavigationNext' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NavigationNextSpecific) == 0x000200, "Member 'UUISelectableComponent::NavigationNextSpecific' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NavigationPrev) == 0x000220, "Member 'UUISelectableComponent::NavigationPrev' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NavigationPrevSpecific) == 0x000228, "Member 'UUISelectableComponent::NavigationPrevSpecific' has a wrong offset!");

// Class LGUI.UIButtonComponent
// 0x0038 (0x0280 - 0x0248)
class UUIButtonComponent final : public UUISelectableComponent
{
public:
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIEventDelegate                     OnClick;                                           // 0x0250(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_268[0x18];                                     // 0x0268(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FLGUIDelegateHandleWrapper RegisterClickEvent(const TDelegate<void()>& InDelegate);
	void UnregisterClickEvent(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIButtonComponent">();
	}
	static class UUIButtonComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIButtonComponent>();
	}
};
static_assert(alignof(UUIButtonComponent) == 0x000008, "Wrong alignment on UUIButtonComponent");
static_assert(sizeof(UUIButtonComponent) == 0x000280, "Wrong size on UUIButtonComponent");
static_assert(offsetof(UUIButtonComponent, OnClick) == 0x000250, "Member 'UUIButtonComponent::OnClick' has a wrong offset!");

// Class LGUI.UICanvasGroup
// 0x0068 (0x0108 - 0x00A0)
class UUICanvasGroup final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Alpha;                                             // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInteractable;                                     // 0x00AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRestrictNavigationArea;                           // 0x00AD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreParentGroup;                                // 0x00AE(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AF[0x59];                                      // 0x00AF(0x0059)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ULTweener* AlphaFrom(float StartValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* AlphaTo(float endValue, float Duration, float Delay, ELTweenEase Ease);
	void SetAlpha(float Value);
	void SetIgnoreParentGroup(bool Value);
	void SetInteractable(bool Value);

	float GetAlpha() const;
	float GetFinalAlpha() const;
	bool GetFinalInteractable() const;
	bool GetIgnoreParentGroup() const;
	bool GetInteractable() const;
	bool GetRestrictNavigationArea() const;
	const class UUICanvasGroup* GetRestrictNavigationAreaCanvasGroup() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICanvasGroup">();
	}
	static class UUICanvasGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICanvasGroup>();
	}
};
static_assert(alignof(UUICanvasGroup) == 0x000008, "Wrong alignment on UUICanvasGroup");
static_assert(sizeof(UUICanvasGroup) == 0x000108, "Wrong size on UUICanvasGroup");
static_assert(offsetof(UUICanvasGroup, Alpha) == 0x0000A8, "Member 'UUICanvasGroup::Alpha' has a wrong offset!");
static_assert(offsetof(UUICanvasGroup, bInteractable) == 0x0000AC, "Member 'UUICanvasGroup::bInteractable' has a wrong offset!");
static_assert(offsetof(UUICanvasGroup, bRestrictNavigationArea) == 0x0000AD, "Member 'UUICanvasGroup::bRestrictNavigationArea' has a wrong offset!");
static_assert(offsetof(UUICanvasGroup, bIgnoreParentGroup) == 0x0000AE, "Member 'UUICanvasGroup::bIgnoreParentGroup' has a wrong offset!");

// Class LGUI.UIContainerActor
// 0x0008 (0x0298 - 0x0290)
class AUIContainerActor : public AUIBaseActor
{
public:
	class UUIItem*                                UIItem;                                            // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIContainerActor">();
	}
	static class AUIContainerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIContainerActor>();
	}
};
static_assert(alignof(AUIContainerActor) == 0x000008, "Wrong alignment on AUIContainerActor");
static_assert(sizeof(AUIContainerActor) == 0x000298, "Wrong size on AUIContainerActor");
static_assert(offsetof(AUIContainerActor, UIItem) == 0x000290, "Member 'AUIContainerActor::UIItem' has a wrong offset!");

// Class LGUI.UICustomMesh
// 0x0010 (0x0570 - 0x0560)
class UUICustomMesh : public UUIBatchMeshRenderable
{
public:
	class ULGUICustomMesh*                        CustomMesh;                                        // 0x0560(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_568[0x8];                                      // 0x0568(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCustomMesh(class ULGUICustomMesh* Value);

	class ULGUICustomMesh* GetCustomMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICustomMesh">();
	}
	static class UUICustomMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICustomMesh>();
	}
};
static_assert(alignof(UUICustomMesh) == 0x000010, "Wrong alignment on UUICustomMesh");
static_assert(sizeof(UUICustomMesh) == 0x000570, "Wrong size on UUICustomMesh");
static_assert(offsetof(UUICustomMesh, CustomMesh) == 0x000560, "Member 'UUICustomMesh::CustomMesh' has a wrong offset!");

// Class LGUI.UICustomMeshActor
// 0x0008 (0x0298 - 0x0290)
class AUICustomMeshActor final : public AUIBaseRenderableActor
{
public:
	class UUICustomMesh*                          UICustomMesh;                                      // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UUICustomMesh* GetUICustomMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICustomMeshActor">();
	}
	static class AUICustomMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUICustomMeshActor>();
	}
};
static_assert(alignof(AUICustomMeshActor) == 0x000008, "Wrong alignment on AUICustomMeshActor");
static_assert(sizeof(AUICustomMeshActor) == 0x000298, "Wrong size on AUICustomMeshActor");
static_assert(offsetof(AUICustomMeshActor, UICustomMesh) == 0x000290, "Member 'AUICustomMeshActor::UICustomMesh' has a wrong offset!");

// Class LGUI.UIDirectMeshRenderable
// 0x0000 (0x0450 - 0x0450)
class UUIDirectMeshRenderable : public UUIBaseRenderable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDirectMeshRenderable">();
	}
	static class UUIDirectMeshRenderable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDirectMeshRenderable>();
	}
};
static_assert(alignof(UUIDirectMeshRenderable) == 0x000010, "Wrong alignment on UUIDirectMeshRenderable");
static_assert(sizeof(UUIDirectMeshRenderable) == 0x000450, "Wrong size on UUIDirectMeshRenderable");

// Class LGUI.UIDropdownComponent
// 0x00C8 (0x0310 - 0x0248)
class UUIDropdownComponent final : public UUISelectableComponent
{
public:
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AUIBaseActor>            ListRoot;                                          // 0x0250(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_258[0x8];                                      // 0x0258(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AUITextActor>            CaptionText;                                       // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AUISpriteActor>          CaptionSprite;                                     // 0x0268(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLGUIComponentReference                ItemTemplate;                                      // 0x0270(0x0020)(Edit, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EUIDropdownVerticalPosition                   VerticalPosition;                                  // 0x0290(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          VerticalOverlap;                                   // 0x0291(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIDropdownHorizontalPosition                 HorizontalPosition;                                // 0x0292(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_293[0x1];                                      // 0x0293(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value;                                             // 0x0294(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FUIDropdownOptionData>          Options;                                           // 0x0298(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         MaxHeight;                                         // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseInteractionBlock;                              // 0x02AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AD[0x13];                                     // 0x02AD(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UUIDropdownItemComponent>> CreatedItemArray;                         // 0x02C0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D0[0x18];                                     // 0x02D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIEventDelegate                     OnSelectionChange;                                 // 0x02E8(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_300[0x10];                                     // 0x0300(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddOptions(const TArray<struct FUIDropdownOptionData>& InOptions);
	void ClearItemCustomDataFunction();
	void Hide();
	void MarkRecreateList();
	struct FLGUIDelegateHandleWrapper RegisterSelectionChangeEvent(const TDelegate<void(int32 InSelectIndex)>& InDelegate);
	void SetHorizontalPosition(EUIDropdownHorizontalPosition InValue);
	void SetItemCustomDataFunction(const TDelegate<void(int32 InItemIndex, class UUIDropdownItemComponent* InItemScript, class AActor* InItemActor)>& InFunction);
	void SetMaxHeight(float NewValue);
	void SetOptions(const TArray<struct FUIDropdownOptionData>& InOptions);
	void SetUseInteractionBlock(bool NewValue);
	void SetValue(int32 NewValue, bool fireEvent);
	void SetVerticalOverlap(bool NewValue);
	void SetVerticalPosition(EUIDropdownVerticalPosition InValue);
	void Show();
	void UnregisterSelectionChangeEvent(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);

	struct FUIDropdownOptionData GetCurrentOption() const;
	EUIDropdownHorizontalPosition GetHorizontalPosition() const;
	class AUIBaseActor* GetListRoot() const;
	float GetMaxHeight() const;
	struct FUIDropdownOptionData GetOption(int32 Index_0) const;
	const TArray<struct FUIDropdownOptionData> GetOptions() const;
	bool GetUseInteractionBlock() const;
	int32 GetValue() const;
	bool GetVerticalOverlap() const;
	EUIDropdownVerticalPosition GetVerticalPosition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDropdownComponent">();
	}
	static class UUIDropdownComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDropdownComponent>();
	}
};
static_assert(alignof(UUIDropdownComponent) == 0x000008, "Wrong alignment on UUIDropdownComponent");
static_assert(sizeof(UUIDropdownComponent) == 0x000310, "Wrong size on UUIDropdownComponent");
static_assert(offsetof(UUIDropdownComponent, ListRoot) == 0x000250, "Member 'UUIDropdownComponent::ListRoot' has a wrong offset!");
static_assert(offsetof(UUIDropdownComponent, CaptionText) == 0x000260, "Member 'UUIDropdownComponent::CaptionText' has a wrong offset!");
static_assert(offsetof(UUIDropdownComponent, CaptionSprite) == 0x000268, "Member 'UUIDropdownComponent::CaptionSprite' has a wrong offset!");
static_assert(offsetof(UUIDropdownComponent, ItemTemplate) == 0x000270, "Member 'UUIDropdownComponent::ItemTemplate' has a wrong offset!");
static_assert(offsetof(UUIDropdownComponent, VerticalPosition) == 0x000290, "Member 'UUIDropdownComponent::VerticalPosition' has a wrong offset!");
static_assert(offsetof(UUIDropdownComponent, VerticalOverlap) == 0x000291, "Member 'UUIDropdownComponent::VerticalOverlap' has a wrong offset!");
static_assert(offsetof(UUIDropdownComponent, HorizontalPosition) == 0x000292, "Member 'UUIDropdownComponent::HorizontalPosition' has a wrong offset!");
static_assert(offsetof(UUIDropdownComponent, Value) == 0x000294, "Member 'UUIDropdownComponent::Value' has a wrong offset!");
static_assert(offsetof(UUIDropdownComponent, Options) == 0x000298, "Member 'UUIDropdownComponent::Options' has a wrong offset!");
static_assert(offsetof(UUIDropdownComponent, MaxHeight) == 0x0002A8, "Member 'UUIDropdownComponent::MaxHeight' has a wrong offset!");
static_assert(offsetof(UUIDropdownComponent, bUseInteractionBlock) == 0x0002AC, "Member 'UUIDropdownComponent::bUseInteractionBlock' has a wrong offset!");
static_assert(offsetof(UUIDropdownComponent, CreatedItemArray) == 0x0002C0, "Member 'UUIDropdownComponent::CreatedItemArray' has a wrong offset!");
static_assert(offsetof(UUIDropdownComponent, OnSelectionChange) == 0x0002E8, "Member 'UUIDropdownComponent::OnSelectionChange' has a wrong offset!");

// Class LGUI.UIDropdownItemComponent
// 0x0058 (0x0120 - 0x00C8)
class UUIDropdownItemComponent final : public ULGUILifeCycleBehaviour
{
public:
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AUITextActor>            TextActor;                                         // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AUISpriteActor>          SpriteActor;                                       // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLGUIComponentReference                Toggle;                                            // 0x00E0(0x0020)(Edit, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_100[0x10];                                     // 0x0100(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             OnSelectDynamic;                                   // 0x0110(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DynamicDelegate_OnSelect();
	void ReceiveInit(int32 Index_0, const struct FUIDropdownOptionData& Data, const TDelegate<void()>& OnSelectCallback);
	void ReceiveSetSelectionState(bool InSelect);

	class AUISpriteActor* GetSpriteActor() const;
	class AUITextActor* GetTextActor() const;
	class UUIToggleComponent* GetToggle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDropdownItemComponent">();
	}
	static class UUIDropdownItemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDropdownItemComponent>();
	}
};
static_assert(alignof(UUIDropdownItemComponent) == 0x000008, "Wrong alignment on UUIDropdownItemComponent");
static_assert(sizeof(UUIDropdownItemComponent) == 0x000120, "Wrong size on UUIDropdownItemComponent");
static_assert(offsetof(UUIDropdownItemComponent, TextActor) == 0x0000D0, "Member 'UUIDropdownItemComponent::TextActor' has a wrong offset!");
static_assert(offsetof(UUIDropdownItemComponent, SpriteActor) == 0x0000D8, "Member 'UUIDropdownItemComponent::SpriteActor' has a wrong offset!");
static_assert(offsetof(UUIDropdownItemComponent, Toggle) == 0x0000E0, "Member 'UUIDropdownItemComponent::Toggle' has a wrong offset!");
static_assert(offsetof(UUIDropdownItemComponent, OnSelectDynamic) == 0x000110, "Member 'UUIDropdownItemComponent::OnSelectDynamic' has a wrong offset!");

// Class LGUI.UIGeometryModifierBase
// 0x0018 (0x00B8 - 0x00A0)
class UUIGeometryModifierBase : public UActorComponent
{
public:
	bool                                          bEnable;                                           // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         executeOrder;                                      // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULGUIGeometryModifierHelper*            GeometryModifierHelper;                            // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ReceiveModifyUIGeometry(class ULGUIGeometryModifierHelper* InGeometryModifierHelper);
	void SetEnable(bool Value);
	void SetExecuteOrder();

	bool GetEnable() const;
	int32 GetExecuteOrder() const;
	class UUIBatchMeshRenderable* GetRenderableUIItem() const;
	class UUIBatchMeshRenderable* GetUIRenderable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGeometryModifierBase">();
	}
	static class UUIGeometryModifierBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGeometryModifierBase>();
	}
};
static_assert(alignof(UUIGeometryModifierBase) == 0x000008, "Wrong alignment on UUIGeometryModifierBase");
static_assert(sizeof(UUIGeometryModifierBase) == 0x0000B8, "Wrong size on UUIGeometryModifierBase");
static_assert(offsetof(UUIGeometryModifierBase, bEnable) == 0x0000A0, "Member 'UUIGeometryModifierBase::bEnable' has a wrong offset!");
static_assert(offsetof(UUIGeometryModifierBase, executeOrder) == 0x0000A4, "Member 'UUIGeometryModifierBase::executeOrder' has a wrong offset!");
static_assert(offsetof(UUIGeometryModifierBase, GeometryModifierHelper) == 0x0000B0, "Member 'UUIGeometryModifierBase::GeometryModifierHelper' has a wrong offset!");

// Class LGUI.UIEffectGradientColor
// 0x0018 (0x00D0 - 0x00B8)
class UUIEffectGradientColor final : public UUIGeometryModifierBase
{
public:
	EUIEffectGradientColorDirection               directionType;                                     // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          multiplySourceAlpha;                               // 0x00B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BA[0x2];                                       // 0x00BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 Color1;                                            // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 Color2;                                            // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 Color3;                                            // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 color4;                                            // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectGradientColor">();
	}
	static class UUIEffectGradientColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectGradientColor>();
	}
};
static_assert(alignof(UUIEffectGradientColor) == 0x000008, "Wrong alignment on UUIEffectGradientColor");
static_assert(sizeof(UUIEffectGradientColor) == 0x0000D0, "Wrong size on UUIEffectGradientColor");
static_assert(offsetof(UUIEffectGradientColor, directionType) == 0x0000B8, "Member 'UUIEffectGradientColor::directionType' has a wrong offset!");
static_assert(offsetof(UUIEffectGradientColor, multiplySourceAlpha) == 0x0000B9, "Member 'UUIEffectGradientColor::multiplySourceAlpha' has a wrong offset!");
static_assert(offsetof(UUIEffectGradientColor, Color1) == 0x0000BC, "Member 'UUIEffectGradientColor::Color1' has a wrong offset!");
static_assert(offsetof(UUIEffectGradientColor, Color2) == 0x0000C0, "Member 'UUIEffectGradientColor::Color2' has a wrong offset!");
static_assert(offsetof(UUIEffectGradientColor, Color3) == 0x0000C4, "Member 'UUIEffectGradientColor::Color3' has a wrong offset!");
static_assert(offsetof(UUIEffectGradientColor, color4) == 0x0000C8, "Member 'UUIEffectGradientColor::color4' has a wrong offset!");

// Class LGUI.UIEffectLongShadow
// 0x0030 (0x00E8 - 0x00B8)
class UUIEffectLongShadow final : public UUIGeometryModifierBase
{
public:
	struct FColor                                 ShadowColor;                                       // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                shadowSize;                                        // 0x00C0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         shadowSegment;                                     // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          useGradientColor;                                  // 0x00D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DA[0x2];                                       // 0x00DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 gradientColor;                                     // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          multiplySourceAlpha;                               // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetGradientColor(const struct FColor& NewColor);
	void SetShadowColor(const struct FColor& NewColor);
	void SetShadowSegment(uint8 newSegment);
	void SetShadowSize(const struct FVector& NewSize);
	void SetUseGradientColor(bool newBool);

	struct FColor GetGradientColor() const;
	struct FColor GetShadowColor() const;
	uint8 GetShadowSegments() const;
	struct FVector GetShadowSize() const;
	bool GetUseGradientColor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectLongShadow">();
	}
	static class UUIEffectLongShadow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectLongShadow>();
	}
};
static_assert(alignof(UUIEffectLongShadow) == 0x000008, "Wrong alignment on UUIEffectLongShadow");
static_assert(sizeof(UUIEffectLongShadow) == 0x0000E8, "Wrong size on UUIEffectLongShadow");
static_assert(offsetof(UUIEffectLongShadow, ShadowColor) == 0x0000B8, "Member 'UUIEffectLongShadow::ShadowColor' has a wrong offset!");
static_assert(offsetof(UUIEffectLongShadow, shadowSize) == 0x0000C0, "Member 'UUIEffectLongShadow::shadowSize' has a wrong offset!");
static_assert(offsetof(UUIEffectLongShadow, shadowSegment) == 0x0000D8, "Member 'UUIEffectLongShadow::shadowSegment' has a wrong offset!");
static_assert(offsetof(UUIEffectLongShadow, useGradientColor) == 0x0000D9, "Member 'UUIEffectLongShadow::useGradientColor' has a wrong offset!");
static_assert(offsetof(UUIEffectLongShadow, gradientColor) == 0x0000DC, "Member 'UUIEffectLongShadow::gradientColor' has a wrong offset!");
static_assert(offsetof(UUIEffectLongShadow, multiplySourceAlpha) == 0x0000E0, "Member 'UUIEffectLongShadow::multiplySourceAlpha' has a wrong offset!");

// Class LGUI.UIEffectOutline
// 0x0020 (0x00D8 - 0x00B8)
class UUIEffectOutline final : public UUIGeometryModifierBase
{
public:
	struct FColor                                 OutlineColor;                                      // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              OutlineSize;                                       // 0x00C0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          multiplySourceAlpha;                               // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          use8Direction;                                     // 0x00D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D2[0x6];                                       // 0x00D2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetOutlineColor(const struct FColor& NewColor);
	void SetOutlineSize(const struct FVector2D& NewSize);
	void SetUse8Direction(bool NewValue);

	struct FColor GetOutlineColor() const;
	struct FVector2D GetOutlineSize() const;
	bool GetUse8Direction() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectOutline">();
	}
	static class UUIEffectOutline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectOutline>();
	}
};
static_assert(alignof(UUIEffectOutline) == 0x000008, "Wrong alignment on UUIEffectOutline");
static_assert(sizeof(UUIEffectOutline) == 0x0000D8, "Wrong size on UUIEffectOutline");
static_assert(offsetof(UUIEffectOutline, OutlineColor) == 0x0000B8, "Member 'UUIEffectOutline::OutlineColor' has a wrong offset!");
static_assert(offsetof(UUIEffectOutline, OutlineSize) == 0x0000C0, "Member 'UUIEffectOutline::OutlineSize' has a wrong offset!");
static_assert(offsetof(UUIEffectOutline, multiplySourceAlpha) == 0x0000D0, "Member 'UUIEffectOutline::multiplySourceAlpha' has a wrong offset!");
static_assert(offsetof(UUIEffectOutline, use8Direction) == 0x0000D1, "Member 'UUIEffectOutline::use8Direction' has a wrong offset!");

// Class LGUI.UIEffectPositionAsUV
// 0x0008 (0x00C0 - 0x00B8)
class UUIEffectPositionAsUV final : public UUIGeometryModifierBase
{
public:
	uint8                                         UVChannel;                                         // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectPositionAsUV">();
	}
	static class UUIEffectPositionAsUV* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectPositionAsUV>();
	}
};
static_assert(alignof(UUIEffectPositionAsUV) == 0x000008, "Wrong alignment on UUIEffectPositionAsUV");
static_assert(sizeof(UUIEffectPositionAsUV) == 0x0000C0, "Wrong size on UUIEffectPositionAsUV");
static_assert(offsetof(UUIEffectPositionAsUV, UVChannel) == 0x0000B8, "Member 'UUIEffectPositionAsUV::UVChannel' has a wrong offset!");

// Class LGUI.UIEffectShadow
// 0x0018 (0x00D0 - 0x00B8)
class UUIEffectShadow final : public UUIGeometryModifierBase
{
public:
	struct FColor                                 ShadowColor;                                       // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          multiplySourceAlpha;                               // 0x00BC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ShadowOffset;                                      // 0x00C0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetShadowColor(const struct FColor& NewColor);
	void SetShadowOffset(const struct FVector2D& newOffset);

	struct FColor GetShadowColor() const;
	struct FVector2D GetShadowOffset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectShadow">();
	}
	static class UUIEffectShadow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectShadow>();
	}
};
static_assert(alignof(UUIEffectShadow) == 0x000008, "Wrong alignment on UUIEffectShadow");
static_assert(sizeof(UUIEffectShadow) == 0x0000D0, "Wrong size on UUIEffectShadow");
static_assert(offsetof(UUIEffectShadow, ShadowColor) == 0x0000B8, "Member 'UUIEffectShadow::ShadowColor' has a wrong offset!");
static_assert(offsetof(UUIEffectShadow, multiplySourceAlpha) == 0x0000BC, "Member 'UUIEffectShadow::multiplySourceAlpha' has a wrong offset!");
static_assert(offsetof(UUIEffectShadow, ShadowOffset) == 0x0000C0, "Member 'UUIEffectShadow::ShadowOffset' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation
// 0x0040 (0x00F8 - 0x00B8)
class UUIEffectTextAnimation final : public UUIGeometryModifierBase
{
public:
	class UUIEffectTextAnimation_Selector*        selector;                                          // 0x00B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIEffectTextAnimation_Property*> Properties;                                       // 0x00C0(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         selectorOffset;                                    // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIText*                                UIText;                                            // 0x00D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x18];                                      // 0x00E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetProperties(const TArray<class UUIEffectTextAnimation_Property*>& Value);
	void SetProperty(int32 Index_0, class UUIEffectTextAnimation_Property* Value);
	void SetSelector(class UUIEffectTextAnimation_Selector* Value);
	void SetSelectorOffset(float Value);

	const TArray<class UUIEffectTextAnimation_Property*> GetProperties() const;
	class UUIEffectTextAnimation_Property* GetProperty(int32 Index_0) const;
	class UUIEffectTextAnimation_Selector* GetSelector() const;
	float GetSelectorOffset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation">();
	}
	static class UUIEffectTextAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation>();
	}
};
static_assert(alignof(UUIEffectTextAnimation) == 0x000008, "Wrong alignment on UUIEffectTextAnimation");
static_assert(sizeof(UUIEffectTextAnimation) == 0x0000F8, "Wrong size on UUIEffectTextAnimation");
static_assert(offsetof(UUIEffectTextAnimation, selector) == 0x0000B8, "Member 'UUIEffectTextAnimation::selector' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation, Properties) == 0x0000C0, "Member 'UUIEffectTextAnimation::Properties' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation, selectorOffset) == 0x0000D0, "Member 'UUIEffectTextAnimation::selectorOffset' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation, UIText) == 0x0000D8, "Member 'UUIEffectTextAnimation::UIText' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_PositionProperty
// 0x0018 (0x0060 - 0x0048)
class UUIEffectTextAnimation_PositionProperty final : public UUIEffectTextAnimation_PropertyWithEase
{
public:
	struct FVector                                position;                                          // 0x0048(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetPosition(const struct FVector& Value);

	struct FVector GetPosition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_PositionProperty">();
	}
	static class UUIEffectTextAnimation_PositionProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_PositionProperty>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_PositionProperty) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_PositionProperty");
static_assert(sizeof(UUIEffectTextAnimation_PositionProperty) == 0x000060, "Wrong size on UUIEffectTextAnimation_PositionProperty");
static_assert(offsetof(UUIEffectTextAnimation_PositionProperty, position) == 0x000048, "Member 'UUIEffectTextAnimation_PositionProperty::position' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_PositionRandomProperty
// 0x0038 (0x0080 - 0x0048)
class UUIEffectTextAnimation_PositionRandomProperty final : public UUIEffectTextAnimation_PropertyWithEase
{
public:
	int32                                         Seed;                                              // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                min_0;                                             // 0x0050(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                max_0;                                             // 0x0068(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetMax(const struct FVector& Value);
	void SetMin(const struct FVector& Value);
	void SetSeed(int32 Value);

	struct FVector GetMax() const;
	struct FVector GetMin() const;
	int32 GetSeed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_PositionRandomProperty">();
	}
	static class UUIEffectTextAnimation_PositionRandomProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_PositionRandomProperty>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_PositionRandomProperty) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_PositionRandomProperty");
static_assert(sizeof(UUIEffectTextAnimation_PositionRandomProperty) == 0x000080, "Wrong size on UUIEffectTextAnimation_PositionRandomProperty");
static_assert(offsetof(UUIEffectTextAnimation_PositionRandomProperty, Seed) == 0x000048, "Member 'UUIEffectTextAnimation_PositionRandomProperty::Seed' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_PositionRandomProperty, min_0) == 0x000050, "Member 'UUIEffectTextAnimation_PositionRandomProperty::min_0' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_PositionRandomProperty, max_0) == 0x000068, "Member 'UUIEffectTextAnimation_PositionRandomProperty::max_0' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_RotationProperty
// 0x0018 (0x0060 - 0x0048)
class UUIEffectTextAnimation_RotationProperty final : public UUIEffectTextAnimation_PropertyWithEase
{
public:
	struct FRotator                               Rotator;                                           // 0x0048(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void SetRotator(const struct FRotator& Value);

	struct FRotator GetRotator() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_RotationProperty">();
	}
	static class UUIEffectTextAnimation_RotationProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_RotationProperty>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_RotationProperty) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_RotationProperty");
static_assert(sizeof(UUIEffectTextAnimation_RotationProperty) == 0x000060, "Wrong size on UUIEffectTextAnimation_RotationProperty");
static_assert(offsetof(UUIEffectTextAnimation_RotationProperty, Rotator) == 0x000048, "Member 'UUIEffectTextAnimation_RotationProperty::Rotator' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_RotationRandomProperty
// 0x0038 (0x0080 - 0x0048)
class UUIEffectTextAnimation_RotationRandomProperty final : public UUIEffectTextAnimation_PropertyWithEase
{
public:
	int32                                         Seed;                                              // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               min_0;                                             // 0x0050(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               max_0;                                             // 0x0068(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void SetMax(const struct FRotator& Value);
	void SetMin(const struct FRotator& Value);
	void SetSeed(int32 Value);

	struct FRotator GetMax() const;
	struct FRotator GetMin() const;
	int32 GetSeed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_RotationRandomProperty">();
	}
	static class UUIEffectTextAnimation_RotationRandomProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_RotationRandomProperty>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_RotationRandomProperty) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_RotationRandomProperty");
static_assert(sizeof(UUIEffectTextAnimation_RotationRandomProperty) == 0x000080, "Wrong size on UUIEffectTextAnimation_RotationRandomProperty");
static_assert(offsetof(UUIEffectTextAnimation_RotationRandomProperty, Seed) == 0x000048, "Member 'UUIEffectTextAnimation_RotationRandomProperty::Seed' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_RotationRandomProperty, min_0) == 0x000050, "Member 'UUIEffectTextAnimation_RotationRandomProperty::min_0' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_RotationRandomProperty, max_0) == 0x000068, "Member 'UUIEffectTextAnimation_RotationRandomProperty::max_0' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_ScaleRandomProperty
// 0x0038 (0x0080 - 0x0048)
class UUIEffectTextAnimation_ScaleRandomProperty final : public UUIEffectTextAnimation_PropertyWithEase
{
public:
	int32                                         Seed;                                              // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                min_0;                                             // 0x0050(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                max_0;                                             // 0x0068(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetMax(const struct FVector& Value);
	void SetMin(const struct FVector& Value);
	void SetSeed(int32 Value);

	struct FVector GetMax() const;
	struct FVector GetMin() const;
	int32 GetSeed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_ScaleRandomProperty">();
	}
	static class UUIEffectTextAnimation_ScaleRandomProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_ScaleRandomProperty>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_ScaleRandomProperty) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_ScaleRandomProperty");
static_assert(sizeof(UUIEffectTextAnimation_ScaleRandomProperty) == 0x000080, "Wrong size on UUIEffectTextAnimation_ScaleRandomProperty");
static_assert(offsetof(UUIEffectTextAnimation_ScaleRandomProperty, Seed) == 0x000048, "Member 'UUIEffectTextAnimation_ScaleRandomProperty::Seed' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_ScaleRandomProperty, min_0) == 0x000050, "Member 'UUIEffectTextAnimation_ScaleRandomProperty::min_0' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_ScaleRandomProperty, max_0) == 0x000068, "Member 'UUIEffectTextAnimation_ScaleRandomProperty::max_0' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_ColorProperty
// 0x0008 (0x0050 - 0x0048)
class UUIEffectTextAnimation_ColorProperty final : public UUIEffectTextAnimation_PropertyWithEase
{
public:
	struct FColor                                 Color;                                             // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          useHSV;                                            // 0x004C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetColor(const struct FColor& Value);
	void SetUseHSV(bool Value);

	struct FColor GetColor() const;
	bool GetUseHSV() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_ColorProperty">();
	}
	static class UUIEffectTextAnimation_ColorProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_ColorProperty>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_ColorProperty) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_ColorProperty");
static_assert(sizeof(UUIEffectTextAnimation_ColorProperty) == 0x000050, "Wrong size on UUIEffectTextAnimation_ColorProperty");
static_assert(offsetof(UUIEffectTextAnimation_ColorProperty, Color) == 0x000048, "Member 'UUIEffectTextAnimation_ColorProperty::Color' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_ColorProperty, useHSV) == 0x00004C, "Member 'UUIEffectTextAnimation_ColorProperty::useHSV' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_RotationWaveProperty
// 0x0018 (0x0060 - 0x0048)
class UUIEffectTextAnimation_RotationWaveProperty final : public UUIEffectTextAnimation_PropertyWithWave
{
public:
	struct FRotator                               Rotator;                                           // 0x0048(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void SetRotator(const struct FRotator& Value);

	struct FRotator GetRotator() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_RotationWaveProperty">();
	}
	static class UUIEffectTextAnimation_RotationWaveProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_RotationWaveProperty>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_RotationWaveProperty) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_RotationWaveProperty");
static_assert(sizeof(UUIEffectTextAnimation_RotationWaveProperty) == 0x000060, "Wrong size on UUIEffectTextAnimation_RotationWaveProperty");
static_assert(offsetof(UUIEffectTextAnimation_RotationWaveProperty, Rotator) == 0x000048, "Member 'UUIEffectTextAnimation_RotationWaveProperty::Rotator' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_RangeSelector
// 0x0010 (0x0048 - 0x0038)
class UUIEffectTextAnimation_RangeSelector final : public UUIEffectTextAnimation_Selector
{
public:
	float                                         Range;                                             // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          flipDirection;                                     // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Start;                                             // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         End;                                               // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetEnd(float Value);
	void SetFlipDirection(bool Value);
	void SetRange(float Value);
	void SetStart(float Value);

	float GetEnd() const;
	bool GetFlipDirection() const;
	float GetRange() const;
	float GetStart() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_RangeSelector">();
	}
	static class UUIEffectTextAnimation_RangeSelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_RangeSelector>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_RangeSelector) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_RangeSelector");
static_assert(sizeof(UUIEffectTextAnimation_RangeSelector) == 0x000048, "Wrong size on UUIEffectTextAnimation_RangeSelector");
static_assert(offsetof(UUIEffectTextAnimation_RangeSelector, Range) == 0x000038, "Member 'UUIEffectTextAnimation_RangeSelector::Range' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_RangeSelector, flipDirection) == 0x00003C, "Member 'UUIEffectTextAnimation_RangeSelector::flipDirection' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_RangeSelector, Start) == 0x000040, "Member 'UUIEffectTextAnimation_RangeSelector::Start' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_RangeSelector, End) == 0x000044, "Member 'UUIEffectTextAnimation_RangeSelector::End' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_RichTextTagSelector
// 0x0010 (0x0048 - 0x0038)
class UUIEffectTextAnimation_RichTextTagSelector final : public UUIEffectTextAnimation_Selector
{
public:
	float                                         Range;                                             // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   TagName;                                           // 0x003C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          flipDirection;                                     // 0x0044(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFlipDirection(bool Value);
	void SetRange(float Value);
	void SetTagName(const class FName& Value);

	bool GetFlipDirection() const;
	float GetRange() const;
	const class FName GetTagName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_RichTextTagSelector">();
	}
	static class UUIEffectTextAnimation_RichTextTagSelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_RichTextTagSelector>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_RichTextTagSelector) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_RichTextTagSelector");
static_assert(sizeof(UUIEffectTextAnimation_RichTextTagSelector) == 0x000048, "Wrong size on UUIEffectTextAnimation_RichTextTagSelector");
static_assert(offsetof(UUIEffectTextAnimation_RichTextTagSelector, Range) == 0x000038, "Member 'UUIEffectTextAnimation_RichTextTagSelector::Range' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_RichTextTagSelector, TagName) == 0x00003C, "Member 'UUIEffectTextAnimation_RichTextTagSelector::TagName' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_RichTextTagSelector, flipDirection) == 0x000044, "Member 'UUIEffectTextAnimation_RichTextTagSelector::flipDirection' has a wrong offset!");

// Class LGUI.UIEventTriggerComponent
// 0x0280 (0x0320 - 0x00A0)
class UUIEventTriggerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x38];                                      // 0x00A0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          AllowEventBubbleUp;                                // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIEventDelegate                     OnPointerEnter;                                    // 0x00E0(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FLGUIEventDelegate                     OnPointerExit;                                     // 0x00F8(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FLGUIEventDelegate                     OnPointerDown;                                     // 0x0110(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FLGUIEventDelegate                     OnPointerUp;                                       // 0x0128(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FLGUIEventDelegate                     OnPointerClick;                                    // 0x0140(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FLGUIEventDelegate                     OnPointerBeginDrag;                                // 0x0158(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FLGUIEventDelegate                     OnPointerDrag;                                     // 0x0170(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FLGUIEventDelegate                     OnPointerEndDrag;                                  // 0x0188(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FLGUIEventDelegate                     OnPointerDragDrop;                                 // 0x01A0(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FLGUIEventDelegate                     OnPointerScroll;                                   // 0x01B8(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FLGUIEventDelegate                     OnPointerSelect;                                   // 0x01D0(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FLGUIEventDelegate                     OnPointerDeselect;                                 // 0x01E8(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_200[0x120];                                    // 0x0200(0x0120)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FLGUIDelegateHandleWrapper RegisterOnPointerBeginDrag(const TDelegate<void(class ULGUIPointerEventData* pointerEventData)>& InDelegate);
	struct FLGUIDelegateHandleWrapper RegisterOnPointerClick(const TDelegate<void(class ULGUIPointerEventData* pointerEventData)>& InDelegate);
	struct FLGUIDelegateHandleWrapper RegisterOnPointerDeselect(const TDelegate<void(class ULGUIBaseEventData* EventData)>& InDelegate);
	struct FLGUIDelegateHandleWrapper RegisterOnPointerDown(const TDelegate<void(class ULGUIPointerEventData* pointerEventData)>& InDelegate);
	struct FLGUIDelegateHandleWrapper RegisterOnPointerDrag(const TDelegate<void(class ULGUIPointerEventData* pointerEventData)>& InDelegate);
	struct FLGUIDelegateHandleWrapper RegisterOnPointerDragDrop(const TDelegate<void(class ULGUIPointerEventData* pointerEventData)>& InDelegate);
	struct FLGUIDelegateHandleWrapper RegisterOnPointerEndDrag(const TDelegate<void(class ULGUIPointerEventData* pointerEventData)>& InDelegate);
	struct FLGUIDelegateHandleWrapper RegisterOnPointerEnter(const TDelegate<void(class ULGUIPointerEventData* pointerEventData)>& InDelegate);
	struct FLGUIDelegateHandleWrapper RegisterOnPointerExit(const TDelegate<void(class ULGUIPointerEventData* pointerEventData)>& InDelegate);
	struct FLGUIDelegateHandleWrapper RegisterOnPointerScroll(const TDelegate<void(class ULGUIPointerEventData* pointerEventData)>& InDelegate);
	struct FLGUIDelegateHandleWrapper RegisterOnPointerSelect(const TDelegate<void(class ULGUIBaseEventData* EventData)>& InDelegate);
	struct FLGUIDelegateHandleWrapper RegisterOnPointerUp(const TDelegate<void(class ULGUIPointerEventData* pointerEventData)>& InDelegate);
	void UnregisterOnPointerBeginDrag(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	void UnregisterOnPointerClick(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	void UnregisterOnPointerDeselect(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	void UnregisterOnPointerDown(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	void UnregisterOnPointerDrag(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	void UnregisterOnPointerDragDrop(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	void UnregisterOnPointerEndDrag(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	void UnregisterOnPointerEnter(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	void UnregisterOnPointerExit(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	void UnregisterOnPointerScroll(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	void UnregisterOnPointerSelect(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	void UnregisterOnPointerUp(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEventTriggerComponent">();
	}
	static class UUIEventTriggerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEventTriggerComponent>();
	}
};
static_assert(alignof(UUIEventTriggerComponent) == 0x000008, "Wrong alignment on UUIEventTriggerComponent");
static_assert(sizeof(UUIEventTriggerComponent) == 0x000320, "Wrong size on UUIEventTriggerComponent");
static_assert(offsetof(UUIEventTriggerComponent, AllowEventBubbleUp) == 0x0000D8, "Member 'UUIEventTriggerComponent::AllowEventBubbleUp' has a wrong offset!");
static_assert(offsetof(UUIEventTriggerComponent, OnPointerEnter) == 0x0000E0, "Member 'UUIEventTriggerComponent::OnPointerEnter' has a wrong offset!");
static_assert(offsetof(UUIEventTriggerComponent, OnPointerExit) == 0x0000F8, "Member 'UUIEventTriggerComponent::OnPointerExit' has a wrong offset!");
static_assert(offsetof(UUIEventTriggerComponent, OnPointerDown) == 0x000110, "Member 'UUIEventTriggerComponent::OnPointerDown' has a wrong offset!");
static_assert(offsetof(UUIEventTriggerComponent, OnPointerUp) == 0x000128, "Member 'UUIEventTriggerComponent::OnPointerUp' has a wrong offset!");
static_assert(offsetof(UUIEventTriggerComponent, OnPointerClick) == 0x000140, "Member 'UUIEventTriggerComponent::OnPointerClick' has a wrong offset!");
static_assert(offsetof(UUIEventTriggerComponent, OnPointerBeginDrag) == 0x000158, "Member 'UUIEventTriggerComponent::OnPointerBeginDrag' has a wrong offset!");
static_assert(offsetof(UUIEventTriggerComponent, OnPointerDrag) == 0x000170, "Member 'UUIEventTriggerComponent::OnPointerDrag' has a wrong offset!");
static_assert(offsetof(UUIEventTriggerComponent, OnPointerEndDrag) == 0x000188, "Member 'UUIEventTriggerComponent::OnPointerEndDrag' has a wrong offset!");
static_assert(offsetof(UUIEventTriggerComponent, OnPointerDragDrop) == 0x0001A0, "Member 'UUIEventTriggerComponent::OnPointerDragDrop' has a wrong offset!");
static_assert(offsetof(UUIEventTriggerComponent, OnPointerScroll) == 0x0001B8, "Member 'UUIEventTriggerComponent::OnPointerScroll' has a wrong offset!");
static_assert(offsetof(UUIEventTriggerComponent, OnPointerSelect) == 0x0001D0, "Member 'UUIEventTriggerComponent::OnPointerSelect' has a wrong offset!");
static_assert(offsetof(UUIEventTriggerComponent, OnPointerDeselect) == 0x0001E8, "Member 'UUIEventTriggerComponent::OnPointerDeselect' has a wrong offset!");

// Class LGUI.UIFlexibleGridLayout
// 0x0040 (0x0170 - 0x0130)
class UUIFlexibleGridLayout final : public UUILayoutWithChildren
{
public:
	struct FMargin                                Padding;                                           // 0x0130(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              Spacing;                                           // 0x0140(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FUIFlexibleGridLayoutCellData>  Columns;                                           // 0x0150(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FUIFlexibleGridLayoutCellData>  Rows;                                              // 0x0160(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void SetColumns(const TArray<struct FUIFlexibleGridLayoutCellData>& Value);
	void SetPadding(const struct FMargin& Value);
	void SetRows(const TArray<struct FUIFlexibleGridLayoutCellData>& Value);
	void SetSpacing(const struct FVector2D& Value);

	int32 GetColumnCount() const;
	const TArray<struct FUIFlexibleGridLayoutCellData> GetColumns() const;
	struct FMargin GetPadding() const;
	int32 GetRowCount() const;
	const TArray<struct FUIFlexibleGridLayoutCellData> GetRows() const;
	struct FVector2D GetSpacing() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFlexibleGridLayout">();
	}
	static class UUIFlexibleGridLayout* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFlexibleGridLayout>();
	}
};
static_assert(alignof(UUIFlexibleGridLayout) == 0x000008, "Wrong alignment on UUIFlexibleGridLayout");
static_assert(sizeof(UUIFlexibleGridLayout) == 0x000170, "Wrong size on UUIFlexibleGridLayout");
static_assert(offsetof(UUIFlexibleGridLayout, Padding) == 0x000130, "Member 'UUIFlexibleGridLayout::Padding' has a wrong offset!");
static_assert(offsetof(UUIFlexibleGridLayout, Spacing) == 0x000140, "Member 'UUIFlexibleGridLayout::Spacing' has a wrong offset!");
static_assert(offsetof(UUIFlexibleGridLayout, Columns) == 0x000150, "Member 'UUIFlexibleGridLayout::Columns' has a wrong offset!");
static_assert(offsetof(UUIFlexibleGridLayout, Rows) == 0x000160, "Member 'UUIFlexibleGridLayout::Rows' has a wrong offset!");

// Class LGUI.UIFrameCapture
// 0x0030 (0x0540 - 0x0510)
class UUIFrameCapture final : public UUIPostProcessRenderable
{
public:
	bool                                          bCaptureFullScreen;                                // 0x0508(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_509[0x7];                                      // 0x0509(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 CapturedFrame;                                     // 0x0510(0x0008)(Edit, ZeroConstructor, Transient, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_518[0x28];                                     // 0x0518(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoCapture(const TDelegate<void(class UTextureRenderTarget2D* CapturedFrame)>& InDelegate);

	class UTextureRenderTarget2D* GetCapturedFrame() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFrameCapture">();
	}
	static class UUIFrameCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFrameCapture>();
	}
};
static_assert(alignof(UUIFrameCapture) == 0x000010, "Wrong alignment on UUIFrameCapture");
static_assert(sizeof(UUIFrameCapture) == 0x000540, "Wrong size on UUIFrameCapture");
static_assert(offsetof(UUIFrameCapture, bCaptureFullScreen) == 0x000508, "Member 'UUIFrameCapture::bCaptureFullScreen' has a wrong offset!");
static_assert(offsetof(UUIFrameCapture, CapturedFrame) == 0x000510, "Member 'UUIFrameCapture::CapturedFrame' has a wrong offset!");

// Class LGUI.LGUIGeometryModifierHelper
// 0x0000 (0x0030 - 0x0030)
class ULGUIGeometryModifierHelper final : public ULGUIGeometryHelper
{
public:
	void UITextHelperFunction_ModifyCharGeometry_Alpha(class UUIText* InUIText, int32 InCharIndex, const float& InAlpha);
	void UITextHelperFunction_ModifyCharGeometry_Color(class UUIText* InUIText, int32 InCharIndex, const struct FColor& InColor);
	void UITextHelperFunction_ModifyCharGeometry_Position(class UUIText* InUIText, int32 InCharIndex, const struct FVector& InPosition, ELGUIGeometryModifierHelper_UITextModifyPositionType InPositionType);
	void UITextHelperFunction_ModifyCharGeometry_Rotate(class UUIText* InUIText, int32 InCharIndex, const struct FRotator& InRotator);
	void UITextHelperFunction_ModifyCharGeometry_Scale(class UUIText* InUIText, int32 InCharIndex, const struct FVector& InScale);
	void UITextHelperFunction_ModifyCharGeometry_Transform(class UUIText* InUIText, int32 InCharIndex, ELGUIGeometryModifierHelper_UITextModifyPositionType InPositionType, const struct FVector& InPosition, const struct FRotator& InRotator, const struct FVector& InScale);

	void UITextHelperFunction_GetCharGeometry_AbsolutePosition(class UUIText* InUIText, int32 InCharIndex, struct FVector* OutPosition) const;
	float UITextHelperFunction_GetCharHorizontalPositionRatio01(class UUIText* InUIText, int32 InCharIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIGeometryModifierHelper">();
	}
	static class ULGUIGeometryModifierHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIGeometryModifierHelper>();
	}
};
static_assert(alignof(ULGUIGeometryModifierHelper) == 0x000008, "Wrong alignment on ULGUIGeometryModifierHelper");
static_assert(sizeof(ULGUIGeometryModifierHelper) == 0x000030, "Wrong size on ULGUIGeometryModifierHelper");

// Class LGUI.UIHorizontalLayout
// 0x0038 (0x0168 - 0x0130)
class UUIHorizontalLayout final : public UUILayoutWithChildren
{
public:
	struct FMargin                                Padding;                                           // 0x0130(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         Spacing;                                           // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELGUILayoutAlignmentType                      Align;                                             // 0x0144(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ControlChildWidth;                                 // 0x0145(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ControlChildHeight;                                // 0x0146(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ExpandChildWidthArea;                              // 0x0147(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ExpandChildHeightArea;                             // 0x0148(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          WidthFitToChildren;                                // 0x0149(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          HeightFitToChildren;                               // 0x014A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14B[0x1];                                      // 0x014B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeightFitToChildrenFromMinToMax;                   // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseChildScaleOnWidth;                              // 0x0150(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_151[0x17];                                     // 0x0151(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAlign(ELGUILayoutAlignmentType Value);
	void SetControlChildHeight(bool Value);
	void SetControlChildWidth(bool Value);
	void SetExpandChildHeightArea(bool Value);
	void SetExpandChildWidthArea(bool Value);
	void SetExpendChildrenHeight(bool Value);
	void SetExpendChildrenWidth(bool Value);
	void SetHeightFitToChildren(bool Value);
	void SetHeightFitToChildrenFromMinToMax(float Value);
	void SetPadding(const struct FMargin& Value);
	void SetSpacing(float Value);
	void SetUseChildScaleOnWidth(bool Value);
	void SetWidthFitToChildren(bool Value);

	float GetActuralRange() const;
	ELGUILayoutAlignmentType GetAlign() const;
	bool GetControlChildHeight() const;
	bool GetControlChildWidth() const;
	bool GetExpandChildHeightArea() const;
	bool GetExpandChildWidthArea() const;
	bool GetExpendChildrenHeight() const;
	bool GetExpendChildrenWidth() const;
	bool GetHeightFitToChildren() const;
	float GetHeightFitToChildrenFromMinToMax() const;
	struct FMargin GetPadding() const;
	float GetSpacing() const;
	bool GetUseChildScaleOnWidth() const;
	bool GetWidthFitToChildren() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIHorizontalLayout">();
	}
	static class UUIHorizontalLayout* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIHorizontalLayout>();
	}
};
static_assert(alignof(UUIHorizontalLayout) == 0x000008, "Wrong alignment on UUIHorizontalLayout");
static_assert(sizeof(UUIHorizontalLayout) == 0x000168, "Wrong size on UUIHorizontalLayout");
static_assert(offsetof(UUIHorizontalLayout, Padding) == 0x000130, "Member 'UUIHorizontalLayout::Padding' has a wrong offset!");
static_assert(offsetof(UUIHorizontalLayout, Spacing) == 0x000140, "Member 'UUIHorizontalLayout::Spacing' has a wrong offset!");
static_assert(offsetof(UUIHorizontalLayout, Align) == 0x000144, "Member 'UUIHorizontalLayout::Align' has a wrong offset!");
static_assert(offsetof(UUIHorizontalLayout, ControlChildWidth) == 0x000145, "Member 'UUIHorizontalLayout::ControlChildWidth' has a wrong offset!");
static_assert(offsetof(UUIHorizontalLayout, ControlChildHeight) == 0x000146, "Member 'UUIHorizontalLayout::ControlChildHeight' has a wrong offset!");
static_assert(offsetof(UUIHorizontalLayout, ExpandChildWidthArea) == 0x000147, "Member 'UUIHorizontalLayout::ExpandChildWidthArea' has a wrong offset!");
static_assert(offsetof(UUIHorizontalLayout, ExpandChildHeightArea) == 0x000148, "Member 'UUIHorizontalLayout::ExpandChildHeightArea' has a wrong offset!");
static_assert(offsetof(UUIHorizontalLayout, WidthFitToChildren) == 0x000149, "Member 'UUIHorizontalLayout::WidthFitToChildren' has a wrong offset!");
static_assert(offsetof(UUIHorizontalLayout, HeightFitToChildren) == 0x00014A, "Member 'UUIHorizontalLayout::HeightFitToChildren' has a wrong offset!");
static_assert(offsetof(UUIHorizontalLayout, HeightFitToChildrenFromMinToMax) == 0x00014C, "Member 'UUIHorizontalLayout::HeightFitToChildrenFromMinToMax' has a wrong offset!");
static_assert(offsetof(UUIHorizontalLayout, UseChildScaleOnWidth) == 0x000150, "Member 'UUIHorizontalLayout::UseChildScaleOnWidth' has a wrong offset!");

// Class LGUI.UIItemEditorHelperComp
// 0x0010 (0x0530 - 0x0520)
class UUIItemEditorHelperComp final : public UPrimitiveComponent
{
public:
	class UUIItem*                                Parent;                                            // 0x0518(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBodySetup*                             BodySetup;                                         // 0x0520(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_528[0x8];                                      // 0x0528(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemEditorHelperComp">();
	}
	static class UUIItemEditorHelperComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemEditorHelperComp>();
	}
};
static_assert(alignof(UUIItemEditorHelperComp) == 0x000010, "Wrong alignment on UUIItemEditorHelperComp");
static_assert(sizeof(UUIItemEditorHelperComp) == 0x000530, "Wrong size on UUIItemEditorHelperComp");
static_assert(offsetof(UUIItemEditorHelperComp, Parent) == 0x000518, "Member 'UUIItemEditorHelperComp::Parent' has a wrong offset!");
static_assert(offsetof(UUIItemEditorHelperComp, BodySetup) == 0x000520, "Member 'UUIItemEditorHelperComp::BodySetup' has a wrong offset!");

// Class LGUI.UILayoutElement
// 0x0020 (0x0100 - 0x00E0)
class UUILayoutElement final : public ULGUILifeCycleUIBehaviour
{
public:
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUILayoutWithChildren*                  ParentLayout;                                      // 0x00E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELayoutElementType                            LayoutElementType;                                 // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EUILayoutElement_ConstantSizeType             ConstantSizeType;                                  // 0x00F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F2[0x2];                                       // 0x00F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConstantSize;                                      // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RatioSize;                                         // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetConstantSize(float Value);
	void SetConstantSizeType(EUILayoutElement_ConstantSizeType Value);
	void SetLayoutType(ELayoutElementType InType);
	void SetRatioSize(float Value);

	EUILayoutElement_ConstantSizeType GetConstantSizeType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILayoutElement">();
	}
	static class UUILayoutElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILayoutElement>();
	}
};
static_assert(alignof(UUILayoutElement) == 0x000008, "Wrong alignment on UUILayoutElement");
static_assert(sizeof(UUILayoutElement) == 0x000100, "Wrong size on UUILayoutElement");
static_assert(offsetof(UUILayoutElement, ParentLayout) == 0x0000E8, "Member 'UUILayoutElement::ParentLayout' has a wrong offset!");
static_assert(offsetof(UUILayoutElement, LayoutElementType) == 0x0000F0, "Member 'UUILayoutElement::LayoutElementType' has a wrong offset!");
static_assert(offsetof(UUILayoutElement, ConstantSizeType) == 0x0000F1, "Member 'UUILayoutElement::ConstantSizeType' has a wrong offset!");
static_assert(offsetof(UUILayoutElement, ConstantSize) == 0x0000F4, "Member 'UUILayoutElement::ConstantSize' has a wrong offset!");
static_assert(offsetof(UUILayoutElement, RatioSize) == 0x0000F8, "Member 'UUILayoutElement::RatioSize' has a wrong offset!");

// Class LGUI.UILayoutWithAnimation_CustomAnimation
// 0x0008 (0x0030 - 0x0028)
class UUILayoutWithAnimation_CustomAnimation final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReceiveApplyAnchoredPositionAnimation(const struct FVector2D& Value, class UUIItem* Target);
	void ReceiveApplyHeightAnimation(float Value, class UUIItem* Target);
	void ReceiveApplyRotatorAnimation(const struct FRotator& Value, class UUIItem* Target);
	void ReceiveApplySizeDeltaAnimation(const struct FVector2D& Value, class UUIItem* Target);
	void ReceiveApplyWidthAnimation(float Value, class UUIItem* Target);
	void ReceiveBeginSetupAnimations();
	void ReceiveEndSetupAnimations();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILayoutWithAnimation_CustomAnimation">();
	}
	static class UUILayoutWithAnimation_CustomAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILayoutWithAnimation_CustomAnimation>();
	}
};
static_assert(alignof(UUILayoutWithAnimation_CustomAnimation) == 0x000008, "Wrong alignment on UUILayoutWithAnimation_CustomAnimation");
static_assert(sizeof(UUILayoutWithAnimation_CustomAnimation) == 0x000030, "Wrong size on UUILayoutWithAnimation_CustomAnimation");

// Class LGUI.UIPanelLayoutBase
// 0x0050 (0x0180 - 0x0130)
class UUIPanelLayoutBase : public UUILayoutWithChildren
{
public:
	TMap<class UUIItem*, class UUIPanelLayoutSlotBase*> MapChildToSlot;                              // 0x0130(0x0050)(Edit, ExportObject, EditConst, ContainsInstancedReference, AdvancedDisplay, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPanelLayoutBase">();
	}
	static class UUIPanelLayoutBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPanelLayoutBase>();
	}
};
static_assert(alignof(UUIPanelLayoutBase) == 0x000008, "Wrong alignment on UUIPanelLayoutBase");
static_assert(sizeof(UUIPanelLayoutBase) == 0x000180, "Wrong size on UUIPanelLayoutBase");
static_assert(offsetof(UUIPanelLayoutBase, MapChildToSlot) == 0x000130, "Member 'UUIPanelLayoutBase::MapChildToSlot' has a wrong offset!");

// Class LGUI.UIPanelLayoutWithOverrideOrder
// 0x0000 (0x0180 - 0x0180)
class UUIPanelLayoutWithOverrideOrder : public UUIPanelLayoutBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPanelLayoutWithOverrideOrder">();
	}
	static class UUIPanelLayoutWithOverrideOrder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPanelLayoutWithOverrideOrder>();
	}
};
static_assert(alignof(UUIPanelLayoutWithOverrideOrder) == 0x000008, "Wrong alignment on UUIPanelLayoutWithOverrideOrder");
static_assert(sizeof(UUIPanelLayoutWithOverrideOrder) == 0x000180, "Wrong size on UUIPanelLayoutWithOverrideOrder");

// Class LGUI.UIPanelLayoutSlotWithOverrideOrder
// 0x0008 (0x0048 - 0x0040)
class UUIPanelLayoutSlotWithOverrideOrder : public UUIPanelLayoutSlotBase
{
public:
	int32                                         OverrideLayoutOrder;                               // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetOverrideLayoutOrder(int32 Value);

	int32 GetOverrideLayoutOrder() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPanelLayoutSlotWithOverrideOrder">();
	}
	static class UUIPanelLayoutSlotWithOverrideOrder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPanelLayoutSlotWithOverrideOrder>();
	}
};
static_assert(alignof(UUIPanelLayoutSlotWithOverrideOrder) == 0x000008, "Wrong alignment on UUIPanelLayoutSlotWithOverrideOrder");
static_assert(sizeof(UUIPanelLayoutSlotWithOverrideOrder) == 0x000048, "Wrong size on UUIPanelLayoutSlotWithOverrideOrder");
static_assert(offsetof(UUIPanelLayoutSlotWithOverrideOrder, OverrideLayoutOrder) == 0x000040, "Member 'UUIPanelLayoutSlotWithOverrideOrder::OverrideLayoutOrder' has a wrong offset!");

// Class LGUI.UIPanelLayout_FlexibleGrid
// 0x0020 (0x01A0 - 0x0180)
class UUIPanelLayout_FlexibleGrid final : public UUIPanelLayoutBase
{
public:
	TArray<struct FUIPanelLayout_FlexibleGridSize> Columns;                                          // 0x0180(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FUIPanelLayout_FlexibleGridSize> Rows;                                             // 0x0190(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void SetColumns(const TArray<struct FUIPanelLayout_FlexibleGridSize>& Value);
	void SetRows(const TArray<struct FUIPanelLayout_FlexibleGridSize>& Value);

	const TArray<struct FUIPanelLayout_FlexibleGridSize> GetColumns() const;
	const TArray<struct FUIPanelLayout_FlexibleGridSize> GetRows() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPanelLayout_FlexibleGrid">();
	}
	static class UUIPanelLayout_FlexibleGrid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPanelLayout_FlexibleGrid>();
	}
};
static_assert(alignof(UUIPanelLayout_FlexibleGrid) == 0x000008, "Wrong alignment on UUIPanelLayout_FlexibleGrid");
static_assert(sizeof(UUIPanelLayout_FlexibleGrid) == 0x0001A0, "Wrong size on UUIPanelLayout_FlexibleGrid");
static_assert(offsetof(UUIPanelLayout_FlexibleGrid, Columns) == 0x000180, "Member 'UUIPanelLayout_FlexibleGrid::Columns' has a wrong offset!");
static_assert(offsetof(UUIPanelLayout_FlexibleGrid, Rows) == 0x000190, "Member 'UUIPanelLayout_FlexibleGrid::Rows' has a wrong offset!");

// Class LGUI.UIPanelLayout_FlexibleGrid_Slot
// 0x0028 (0x0068 - 0x0040)
class UUIPanelLayout_FlexibleGrid_Slot final : public UUIPanelLayoutSlotBase
{
public:
	struct FMargin                                Padding;                                           // 0x0040(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0051(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_52[0x2];                                       // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Column;                                            // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ColumnSpan;                                        // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Row;                                               // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RowSpan;                                           // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetColumn(int32 Value);
	void SetColumnSpan(int32 Value);
	void SetHorizontalAlignment(EHorizontalAlignment Value);
	void SetPadding(const struct FMargin& Value);
	void SetRow(int32 Value);
	void SetRowSpan(int32 Value);
	void SetVerticalAlignment(EVerticalAlignment Value);

	int32 GetColumn() const;
	int32 GetColumnSpan() const;
	EHorizontalAlignment GetHorizontalAlignment() const;
	const struct FMargin GetPadding() const;
	int32 GetRow() const;
	int32 GetRowSpan() const;
	EVerticalAlignment GetVerticalAlignment() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPanelLayout_FlexibleGrid_Slot">();
	}
	static class UUIPanelLayout_FlexibleGrid_Slot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPanelLayout_FlexibleGrid_Slot>();
	}
};
static_assert(alignof(UUIPanelLayout_FlexibleGrid_Slot) == 0x000008, "Wrong alignment on UUIPanelLayout_FlexibleGrid_Slot");
static_assert(sizeof(UUIPanelLayout_FlexibleGrid_Slot) == 0x000068, "Wrong size on UUIPanelLayout_FlexibleGrid_Slot");
static_assert(offsetof(UUIPanelLayout_FlexibleGrid_Slot, Padding) == 0x000040, "Member 'UUIPanelLayout_FlexibleGrid_Slot::Padding' has a wrong offset!");
static_assert(offsetof(UUIPanelLayout_FlexibleGrid_Slot, HorizontalAlignment) == 0x000050, "Member 'UUIPanelLayout_FlexibleGrid_Slot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UUIPanelLayout_FlexibleGrid_Slot, VerticalAlignment) == 0x000051, "Member 'UUIPanelLayout_FlexibleGrid_Slot::VerticalAlignment' has a wrong offset!");
static_assert(offsetof(UUIPanelLayout_FlexibleGrid_Slot, Column) == 0x000054, "Member 'UUIPanelLayout_FlexibleGrid_Slot::Column' has a wrong offset!");
static_assert(offsetof(UUIPanelLayout_FlexibleGrid_Slot, ColumnSpan) == 0x000058, "Member 'UUIPanelLayout_FlexibleGrid_Slot::ColumnSpan' has a wrong offset!");
static_assert(offsetof(UUIPanelLayout_FlexibleGrid_Slot, Row) == 0x00005C, "Member 'UUIPanelLayout_FlexibleGrid_Slot::Row' has a wrong offset!");
static_assert(offsetof(UUIPanelLayout_FlexibleGrid_Slot, RowSpan) == 0x000060, "Member 'UUIPanelLayout_FlexibleGrid_Slot::RowSpan' has a wrong offset!");

// Class LGUI.UIPanelLayout_HorizontalBox
// 0x0008 (0x0188 - 0x0180)
class UUIPanelLayout_HorizontalBox final : public UUIPanelLayoutWithOverrideOrder
{
public:
	bool                                          bWidthFitToChildren;                               // 0x0180(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHeightFitToChildren;                              // 0x0181(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_182[0x2];                                      // 0x0182(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeightFitToChildrenFromMinToMax;                   // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetHeightFitToChildren(bool Value);
	void SetHeightFitToChildrenFromMinToMax(float Value);
	void SetWidthFitToChildren(bool Value);

	bool GetHeightFitToChildren() const;
	float GetHeightFitToChildrenFromMinToMax() const;
	bool GetWidthFitToChildren() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPanelLayout_HorizontalBox">();
	}
	static class UUIPanelLayout_HorizontalBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPanelLayout_HorizontalBox>();
	}
};
static_assert(alignof(UUIPanelLayout_HorizontalBox) == 0x000008, "Wrong alignment on UUIPanelLayout_HorizontalBox");
static_assert(sizeof(UUIPanelLayout_HorizontalBox) == 0x000188, "Wrong size on UUIPanelLayout_HorizontalBox");
static_assert(offsetof(UUIPanelLayout_HorizontalBox, bWidthFitToChildren) == 0x000180, "Member 'UUIPanelLayout_HorizontalBox::bWidthFitToChildren' has a wrong offset!");
static_assert(offsetof(UUIPanelLayout_HorizontalBox, bHeightFitToChildren) == 0x000181, "Member 'UUIPanelLayout_HorizontalBox::bHeightFitToChildren' has a wrong offset!");
static_assert(offsetof(UUIPanelLayout_HorizontalBox, HeightFitToChildrenFromMinToMax) == 0x000184, "Member 'UUIPanelLayout_HorizontalBox::HeightFitToChildrenFromMinToMax' has a wrong offset!");

// Class LGUI.UIPanelLayout_HorizontalBox_Slot
// 0x0020 (0x0068 - 0x0048)
class UUIPanelLayout_HorizontalBox_Slot final : public UUIPanelLayoutSlotWithOverrideOrder
{
public:
	struct FMargin                                Padding;                                           // 0x0048(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSlateChildSize                        SizeRule;                                          // 0x0058(0x0008)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0061(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_62[0x6];                                       // 0x0062(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHorizontalAlignment(EHorizontalAlignment Value);
	void SetPadding(const struct FMargin& Value);
	void SetSizeRule(const struct FSlateChildSize& Value);
	void SetVerticalAlignment(EVerticalAlignment Value);

	EHorizontalAlignment GetHorizontalAlignment() const;
	const struct FMargin GetPadding() const;
	const struct FSlateChildSize GetSizeRule() const;
	EVerticalAlignment GetVerticalAlignment() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPanelLayout_HorizontalBox_Slot">();
	}
	static class UUIPanelLayout_HorizontalBox_Slot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPanelLayout_HorizontalBox_Slot>();
	}
};
static_assert(alignof(UUIPanelLayout_HorizontalBox_Slot) == 0x000008, "Wrong alignment on UUIPanelLayout_HorizontalBox_Slot");
static_assert(sizeof(UUIPanelLayout_HorizontalBox_Slot) == 0x000068, "Wrong size on UUIPanelLayout_HorizontalBox_Slot");
static_assert(offsetof(UUIPanelLayout_HorizontalBox_Slot, Padding) == 0x000048, "Member 'UUIPanelLayout_HorizontalBox_Slot::Padding' has a wrong offset!");
static_assert(offsetof(UUIPanelLayout_HorizontalBox_Slot, SizeRule) == 0x000058, "Member 'UUIPanelLayout_HorizontalBox_Slot::SizeRule' has a wrong offset!");
static_assert(offsetof(UUIPanelLayout_HorizontalBox_Slot, HorizontalAlignment) == 0x000060, "Member 'UUIPanelLayout_HorizontalBox_Slot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UUIPanelLayout_HorizontalBox_Slot, VerticalAlignment) == 0x000061, "Member 'UUIPanelLayout_HorizontalBox_Slot::VerticalAlignment' has a wrong offset!");

// Class LGUI.UIPanelLayout_UniformGrid
// 0x0010 (0x0190 - 0x0180)
class UUIPanelLayout_UniformGrid final : public UUIPanelLayoutBase
{
public:
	bool                                          bWidthFitToChildren;                               // 0x0180(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_181[0x3];                                      // 0x0181(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WidthFitToChildrenFromMinToMax;                    // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHeightFitToChildren;                              // 0x0188(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_189[0x3];                                      // 0x0189(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeightFitToChildrenFromMinToMax;                   // 0x018C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetHeightFitToChildren(bool Value);
	void SetHeightFitToChildrenFromMinToMax(float Value);
	void SetWidthFitToChildren(bool Value);
	void SetWidthFitToChildrenFromMinToMax(float Value);

	bool GetHeightFitToChildren() const;
	float GetHeightFitToChildrenFromMinToMax() const;
	bool GetWidthFitToChildren() const;
	float GetWidthFitToChildrenFromMinToMax() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPanelLayout_UniformGrid">();
	}
	static class UUIPanelLayout_UniformGrid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPanelLayout_UniformGrid>();
	}
};
static_assert(alignof(UUIPanelLayout_UniformGrid) == 0x000008, "Wrong alignment on UUIPanelLayout_UniformGrid");
static_assert(sizeof(UUIPanelLayout_UniformGrid) == 0x000190, "Wrong size on UUIPanelLayout_UniformGrid");
static_assert(offsetof(UUIPanelLayout_UniformGrid, bWidthFitToChildren) == 0x000180, "Member 'UUIPanelLayout_UniformGrid::bWidthFitToChildren' has a wrong offset!");
static_assert(offsetof(UUIPanelLayout_UniformGrid, WidthFitToChildrenFromMinToMax) == 0x000184, "Member 'UUIPanelLayout_UniformGrid::WidthFitToChildrenFromMinToMax' has a wrong offset!");
static_assert(offsetof(UUIPanelLayout_UniformGrid, bHeightFitToChildren) == 0x000188, "Member 'UUIPanelLayout_UniformGrid::bHeightFitToChildren' has a wrong offset!");
static_assert(offsetof(UUIPanelLayout_UniformGrid, HeightFitToChildrenFromMinToMax) == 0x00018C, "Member 'UUIPanelLayout_UniformGrid::HeightFitToChildrenFromMinToMax' has a wrong offset!");

// Class LGUI.UIPanelLayout_UniformGrid_Slot
// 0x0020 (0x0060 - 0x0040)
class UUIPanelLayout_UniformGrid_Slot final : public UUIPanelLayoutSlotBase
{
public:
	struct FMargin                                Padding;                                           // 0x0040(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0051(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_52[0x2];                                       // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Column;                                            // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Row;                                               // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetColumn(int32 Value);
	void SetHorizontalAlignment(EHorizontalAlignment Value);
	void SetPadding(const struct FMargin& Value);
	void SetRow(int32 Value);
	void SetVerticalAlignment(EVerticalAlignment Value);

	int32 GetColumn() const;
	EHorizontalAlignment GetHorizontalAlignment() const;
	const struct FMargin GetPadding() const;
	int32 GetRow() const;
	EVerticalAlignment GetVerticalAlignment() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPanelLayout_UniformGrid_Slot">();
	}
	static class UUIPanelLayout_UniformGrid_Slot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPanelLayout_UniformGrid_Slot>();
	}
};
static_assert(alignof(UUIPanelLayout_UniformGrid_Slot) == 0x000008, "Wrong alignment on UUIPanelLayout_UniformGrid_Slot");
static_assert(sizeof(UUIPanelLayout_UniformGrid_Slot) == 0x000060, "Wrong size on UUIPanelLayout_UniformGrid_Slot");
static_assert(offsetof(UUIPanelLayout_UniformGrid_Slot, Padding) == 0x000040, "Member 'UUIPanelLayout_UniformGrid_Slot::Padding' has a wrong offset!");
static_assert(offsetof(UUIPanelLayout_UniformGrid_Slot, HorizontalAlignment) == 0x000050, "Member 'UUIPanelLayout_UniformGrid_Slot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UUIPanelLayout_UniformGrid_Slot, VerticalAlignment) == 0x000051, "Member 'UUIPanelLayout_UniformGrid_Slot::VerticalAlignment' has a wrong offset!");
static_assert(offsetof(UUIPanelLayout_UniformGrid_Slot, Column) == 0x000054, "Member 'UUIPanelLayout_UniformGrid_Slot::Column' has a wrong offset!");
static_assert(offsetof(UUIPanelLayout_UniformGrid_Slot, Row) == 0x000058, "Member 'UUIPanelLayout_UniformGrid_Slot::Row' has a wrong offset!");

// Class LGUI.UIPanelLayout_VerticalBox
// 0x0010 (0x0190 - 0x0180)
class UUIPanelLayout_VerticalBox final : public UUIPanelLayoutWithOverrideOrder
{
public:
	bool                                          bWidthFitToChildren;                               // 0x0180(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_181[0x3];                                      // 0x0181(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WidthFitToChildrenFromMinToMax;                    // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHeightFitToChildren;                              // 0x0188(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHeightFitToChildren(bool Value);
	void SetWidthFitToChildren(bool Value);
	void SetWidthFitToChildrenFromMinToMax(float Value);

	bool GetHeightFitToChildren() const;
	bool GetWidthFitToChildren() const;
	float GetWidthFitToChildrenFromMinToMax() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPanelLayout_VerticalBox">();
	}
	static class UUIPanelLayout_VerticalBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPanelLayout_VerticalBox>();
	}
};
static_assert(alignof(UUIPanelLayout_VerticalBox) == 0x000008, "Wrong alignment on UUIPanelLayout_VerticalBox");
static_assert(sizeof(UUIPanelLayout_VerticalBox) == 0x000190, "Wrong size on UUIPanelLayout_VerticalBox");
static_assert(offsetof(UUIPanelLayout_VerticalBox, bWidthFitToChildren) == 0x000180, "Member 'UUIPanelLayout_VerticalBox::bWidthFitToChildren' has a wrong offset!");
static_assert(offsetof(UUIPanelLayout_VerticalBox, WidthFitToChildrenFromMinToMax) == 0x000184, "Member 'UUIPanelLayout_VerticalBox::WidthFitToChildrenFromMinToMax' has a wrong offset!");
static_assert(offsetof(UUIPanelLayout_VerticalBox, bHeightFitToChildren) == 0x000188, "Member 'UUIPanelLayout_VerticalBox::bHeightFitToChildren' has a wrong offset!");

// Class LGUI.UIPanelLayout_VerticalBox_Slot
// 0x0020 (0x0068 - 0x0048)
class UUIPanelLayout_VerticalBox_Slot final : public UUIPanelLayoutSlotWithOverrideOrder
{
public:
	struct FMargin                                Padding;                                           // 0x0048(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSlateChildSize                        SizeRule;                                          // 0x0058(0x0008)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0061(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_62[0x6];                                       // 0x0062(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHorizontalAlignment(EHorizontalAlignment Value);
	void SetPadding(const struct FMargin& Value);
	void SetSizeRule(const struct FSlateChildSize& Value);
	void SetVerticalAlignment(EVerticalAlignment Value);

	EHorizontalAlignment GetHorizontalAlignment() const;
	const struct FMargin GetPadding() const;
	const struct FSlateChildSize GetSizeRule() const;
	EVerticalAlignment GetVerticalAlignment() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPanelLayout_VerticalBox_Slot">();
	}
	static class UUIPanelLayout_VerticalBox_Slot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPanelLayout_VerticalBox_Slot>();
	}
};
static_assert(alignof(UUIPanelLayout_VerticalBox_Slot) == 0x000008, "Wrong alignment on UUIPanelLayout_VerticalBox_Slot");
static_assert(sizeof(UUIPanelLayout_VerticalBox_Slot) == 0x000068, "Wrong size on UUIPanelLayout_VerticalBox_Slot");
static_assert(offsetof(UUIPanelLayout_VerticalBox_Slot, Padding) == 0x000048, "Member 'UUIPanelLayout_VerticalBox_Slot::Padding' has a wrong offset!");
static_assert(offsetof(UUIPanelLayout_VerticalBox_Slot, SizeRule) == 0x000058, "Member 'UUIPanelLayout_VerticalBox_Slot::SizeRule' has a wrong offset!");
static_assert(offsetof(UUIPanelLayout_VerticalBox_Slot, HorizontalAlignment) == 0x000060, "Member 'UUIPanelLayout_VerticalBox_Slot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UUIPanelLayout_VerticalBox_Slot, VerticalAlignment) == 0x000061, "Member 'UUIPanelLayout_VerticalBox_Slot::VerticalAlignment' has a wrong offset!");

// Class LGUI.UIPolygon
// 0x0020 (0x05A0 - 0x0580)
class UUIPolygon final : public UUISpriteBase
{
public:
	bool                                          FullCycle;                                         // 0x0578(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_579[0x3];                                      // 0x0579(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartAngle;                                        // 0x057C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndAngle;                                          // 0x0580(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Sides;                                             // 0x0584(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIPolygonUVType                              UVType;                                            // 0x0588(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_589[0x7];                                      // 0x0589(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 VertexOffsetArray;                                 // 0x0590(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	class ULTweener* EndAngleTo(float endValue, float Duration, float Delay, ELTweenEase easetype);
	void SetEndAngle(float Value);
	void SetFullCycle(bool Value);
	void SetSides(int32 Value);
	void SetStartAngle(float Value);
	void SetUVType(EUIPolygonUVType Value);
	void SetVertexOffsetArray(const TArray<float>& Value);
	class ULTweener* StartAngleTo(float endValue, float Duration, float Delay, ELTweenEase easetype);

	float GetEndAngle() const;
	bool GetFullCycle() const;
	int32 GetSides() const;
	float GetStartAngle() const;
	EUIPolygonUVType GetUVType() const;
	const TArray<float> GetVertexOffsetArray() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPolygon">();
	}
	static class UUIPolygon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPolygon>();
	}
};
static_assert(alignof(UUIPolygon) == 0x000010, "Wrong alignment on UUIPolygon");
static_assert(sizeof(UUIPolygon) == 0x0005A0, "Wrong size on UUIPolygon");
static_assert(offsetof(UUIPolygon, FullCycle) == 0x000578, "Member 'UUIPolygon::FullCycle' has a wrong offset!");
static_assert(offsetof(UUIPolygon, StartAngle) == 0x00057C, "Member 'UUIPolygon::StartAngle' has a wrong offset!");
static_assert(offsetof(UUIPolygon, EndAngle) == 0x000580, "Member 'UUIPolygon::EndAngle' has a wrong offset!");
static_assert(offsetof(UUIPolygon, Sides) == 0x000584, "Member 'UUIPolygon::Sides' has a wrong offset!");
static_assert(offsetof(UUIPolygon, UVType) == 0x000588, "Member 'UUIPolygon::UVType' has a wrong offset!");
static_assert(offsetof(UUIPolygon, VertexOffsetArray) == 0x000590, "Member 'UUIPolygon::VertexOffsetArray' has a wrong offset!");

// Class LGUI.UIPolygonActor
// 0x0008 (0x0298 - 0x0290)
class AUIPolygonActor final : public AUIBaseRenderableActor
{
public:
	class UUIPolygon*                             UIPolygon;                                         // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UUIPolygon* GetUIPolygon() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPolygonActor">();
	}
	static class AUIPolygonActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIPolygonActor>();
	}
};
static_assert(alignof(AUIPolygonActor) == 0x000008, "Wrong alignment on AUIPolygonActor");
static_assert(sizeof(AUIPolygonActor) == 0x000298, "Wrong size on AUIPolygonActor");
static_assert(offsetof(AUIPolygonActor, UIPolygon) == 0x000290, "Member 'AUIPolygonActor::UIPolygon' has a wrong offset!");

// Class LGUI.UIPolygonLine
// 0x0030 (0x05C0 - 0x0590)
class UUIPolygonLine final : public UUI2DLineRendererBase
{
public:
	bool                                          FullCycle;                                         // 0x0588(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_589[0x3];                                      // 0x0589(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartAngle;                                        // 0x058C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndAngle;                                          // 0x0590(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Sides;                                             // 0x0594(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 VertexOffsetArray;                                 // 0x0598(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FVector2D>                      CurrentPointArray;                                 // 0x05A8(0x0010)(Edit, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ULTweener* EndAngleTo(float endValue, float Duration, float Delay, ELTweenEase easetype);
	void SetEndAngle(float Value);
	void SetFullCycle(bool Value);
	void SetSides(int32 Value);
	void SetStartAngle(float Value);
	void SetVertexOffsetArray(const TArray<float>& Value);
	class ULTweener* StartAngleTo(float endValue, float Duration, float Delay, ELTweenEase easetype);

	float GetEndAngle() const;
	bool GetFullCycle() const;
	int32 GetSides() const;
	float GetStartAngle() const;
	const TArray<float> GetVertexOffsetArray() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPolygonLine">();
	}
	static class UUIPolygonLine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPolygonLine>();
	}
};
static_assert(alignof(UUIPolygonLine) == 0x000010, "Wrong alignment on UUIPolygonLine");
static_assert(sizeof(UUIPolygonLine) == 0x0005C0, "Wrong size on UUIPolygonLine");
static_assert(offsetof(UUIPolygonLine, FullCycle) == 0x000588, "Member 'UUIPolygonLine::FullCycle' has a wrong offset!");
static_assert(offsetof(UUIPolygonLine, StartAngle) == 0x00058C, "Member 'UUIPolygonLine::StartAngle' has a wrong offset!");
static_assert(offsetof(UUIPolygonLine, EndAngle) == 0x000590, "Member 'UUIPolygonLine::EndAngle' has a wrong offset!");
static_assert(offsetof(UUIPolygonLine, Sides) == 0x000594, "Member 'UUIPolygonLine::Sides' has a wrong offset!");
static_assert(offsetof(UUIPolygonLine, VertexOffsetArray) == 0x000598, "Member 'UUIPolygonLine::VertexOffsetArray' has a wrong offset!");
static_assert(offsetof(UUIPolygonLine, CurrentPointArray) == 0x0005A8, "Member 'UUIPolygonLine::CurrentPointArray' has a wrong offset!");

// Class LGUI.UIPolygonLineActor
// 0x0008 (0x0298 - 0x0290)
class AUIPolygonLineActor final : public AUIBaseRenderableActor
{
public:
	class UUIPolygonLine*                         UIPolygonLine;                                     // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UUIPolygonLine* GetUIPolygonLine() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPolygonLineActor">();
	}
	static class AUIPolygonLineActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIPolygonLineActor>();
	}
};
static_assert(alignof(AUIPolygonLineActor) == 0x000008, "Wrong alignment on AUIPolygonLineActor");
static_assert(sizeof(AUIPolygonLineActor) == 0x000298, "Wrong size on AUIPolygonLineActor");
static_assert(offsetof(AUIPolygonLineActor, UIPolygonLine) == 0x000290, "Member 'AUIPolygonLineActor::UIPolygonLine' has a wrong offset!");

// Class LGUI.UIProceduralRect
// 0x0120 (0x0680 - 0x0560)
class UUIProceduralRect final : public UUIBatchMeshRenderable
{
public:
	uint8                                         Pad_560[0x10];                                     // 0x0560(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4f                              CornerRadius;                                      // 0x0570(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIProceduralRectUnitMode                     CornerRadiusUnitMode;                              // 0x0580(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSoftEdge;                                         // 0x0581(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableBody;                                       // 0x0582(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_583[0x1];                                      // 0x0583(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 BodyColor;                                         // 0x0584(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIProceduralBodyTextureMode                  BodyTextureMode;                                   // 0x0588(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_589[0x7];                                      // 0x0589(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               BodyTexture;                                       // 0x0590(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULGUISpriteData_BaseObject*             BodySpriteTexture;                                 // 0x0598(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIProceduralRectTextureScaleMode             BodyTextureScaleMode;                              // 0x05A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableBodyGradient;                               // 0x05A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A2[0x2];                                      // 0x05A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 BodyGradientColor;                                 // 0x05A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2f                              BodyGradientCenter;                                // 0x05A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIProceduralRectUnitMode                     BodyGradientCenterUnitMode;                        // 0x05B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B1[0x3];                                      // 0x05B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2f                              BodyGradientRadius;                                // 0x05B4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIProceduralRectUnitMode                     BodyGradientRadiusUnitMode;                        // 0x05BC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5BD[0x3];                                      // 0x05BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BodyGradientRotation;                              // 0x05C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableBorder;                                     // 0x05C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C5[0x3];                                      // 0x05C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BorderWidth;                                       // 0x05C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIProceduralRectUnitMode                     BorderWidthUnitMode;                               // 0x05CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5CD[0x3];                                      // 0x05CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 BorderColor;                                       // 0x05D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableBorderGradient;                             // 0x05D4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D5[0x3];                                      // 0x05D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 BorderGradientColor;                               // 0x05D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2f                              BorderGradientCenter;                              // 0x05DC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIProceduralRectUnitMode                     BorderGradientCenterUnitMode;                      // 0x05E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E5[0x3];                                      // 0x05E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2f                              BorderGradientRadius;                              // 0x05E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIProceduralRectUnitMode                     BorderGradientRadiusUnitMode;                      // 0x05F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F1[0x3];                                      // 0x05F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BorderGradientRotation;                            // 0x05F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableInnerShadow;                                // 0x05F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F9[0x3];                                      // 0x05F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 InnerShadowColor;                                  // 0x05FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InnerShadowSize;                                   // 0x0600(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIProceduralRectUnitMode                     InnerShadowSizeUnitMode;                           // 0x0604(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_605[0x3];                                      // 0x0605(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InnerShadowBlur;                                   // 0x0608(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIProceduralRectUnitMode                     InnerShadowBlurUnitMode;                           // 0x060C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_60D[0x3];                                      // 0x060D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InnerShadowAngle;                                  // 0x0610(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InnerShadowDistance;                               // 0x0614(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIProceduralRectUnitMode                     InnerShadowDistanceUnitMode;                       // 0x0618(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableRadialFill;                                 // 0x0619(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61A[0x2];                                      // 0x061A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2f                              RadialFillCenter;                                  // 0x061C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIProceduralRectUnitMode                     RadialFillCenterUnitMode;                          // 0x0624(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_625[0x3];                                      // 0x0625(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RadialFillRotation;                                // 0x0628(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RadialFillAngle;                                   // 0x062C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableOuterShadow;                                // 0x0630(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_631[0x3];                                      // 0x0631(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 OuterShadowColor;                                  // 0x0634(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OuterShadowSize;                                   // 0x0638(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIProceduralRectUnitMode                     OuterShadowSizeUnitMode;                           // 0x063C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_63D[0x3];                                      // 0x063D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OuterShadowBlur;                                   // 0x0640(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIProceduralRectUnitMode                     OuterShadowBlurUnitMode;                           // 0x0644(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_645[0x3];                                      // 0x0645(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OuterShadowAngle;                                  // 0x0648(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OuterShadowDistance;                               // 0x064C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIProceduralRectUnitMode                     OuterShadowDistanceUnitMode;                       // 0x0650(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_651[0x7];                                      // 0x0651(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULGUIProceduralRectData*                ProceduralRectData;                                // 0x0658(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, AdvancedDisplay, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRaycastSupportCornerRadius;                       // 0x0660(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_661[0x1F];                                     // 0x0661(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ULTweener* BodyAlphaTo(float endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* BodyColorTo(const struct FColor& endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* BodyGradientAlphaTo(float endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* BodyGradientCenterTo(const struct FVector2D& endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* BodyGradientColorTo(const struct FColor& endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* BodyGradientRadiusTo(const struct FVector2D& endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* BodyGradientRotationTo(float endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* BorderAlphaTo(float endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* BorderColorTo(const struct FColor& endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* BorderGradientAlphaTo(float endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* BorderGradientCenterTo(const struct FVector2D& endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* BorderGradientColorTo(const struct FColor& endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* BorderGradientRadiusTo(const struct FVector2D& endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* BorderGradientRotationTo(float endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* BorderWidthTo(float endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* CornerRadiusTo(const struct FVector4& endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* InnerShadowAlphaTo(float endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* InnerShadowAngleTo(float endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* InnerShadowBlurTo(float endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* InnerShadowColorTo(const struct FColor& endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* InnerShadowDistanceTo(float endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* InnerShadowSizeTo(float endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* OuterShadowAlphaTo(float endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* OuterShadowAngleTo(float endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* OuterShadowBlurTo(float endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* OuterShadowColorTo(const struct FColor& endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* OuterShadowDistanceTo(float endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* OuterShadowSizeTo(float endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* RadialFillAngleTo(float endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* RadialFillCenterTo(const struct FVector2D& endValue, float Duration, float Delay, ELTweenEase Ease);
	class ULTweener* RadialFillRotationTo(float endValue, float Duration, float Delay, ELTweenEase Ease);
	void SetBodyColor(const struct FColor& Value);
	void SetBodyGradientCenter(const struct FVector2D& Value);
	void SetBodyGradientCenterUnitMode(EUIProceduralRectUnitMode Value);
	void SetBodyGradientColor(const struct FColor& Value);
	void SetBodyGradientRadius(const struct FVector2D& Value);
	void SetBodyGradientRadiusUnitMode(EUIProceduralRectUnitMode Value);
	void SetBodyGradientRotation(float Value);
	void SetBodySpriteTexture(class ULGUISpriteData_BaseObject* Value);
	void SetBodyTexture(class UTexture* Value);
	void SetBodyTextureMode(EUIProceduralBodyTextureMode Value);
	void SetBodyTextureScaleMode(EUIProceduralRectTextureScaleMode Value);
	void SetBorderColor(const struct FColor& Value);
	void SetBorderGradientCenter(const struct FVector2D& Value);
	void SetBorderGradientCenterUnitMode(EUIProceduralRectUnitMode Value);
	void SetBorderGradientColor(const struct FColor& Value);
	void SetBorderGradientRadius(const struct FVector2D& Value);
	void SetBorderGradientRadiusUnitMode(EUIProceduralRectUnitMode Value);
	void SetBorderGradientRotation(float Value);
	void SetBorderWidth(float Value);
	void SetBorderWidthUnitMode(EUIProceduralRectUnitMode Value);
	void SetCornerRadius(const struct FVector4& Value);
	void SetCornerRadiusUnitMode(EUIProceduralRectUnitMode Value);
	void SetEnableBody(bool Value);
	void SetEnableBodyGradient(bool Value);
	void SetEnableBorder(bool Value);
	void SetEnableBorderGradient(bool Value);
	void SetEnableInnerShadow(bool Value);
	void SetEnableOuterShadow(bool Value);
	void SetEnableRadialFill(bool Value);
	void SetInnerShadowAngle(float Value);
	void SetInnerShadowBlur(float Value);
	void SetInnerShadowBlurUnitMode(EUIProceduralRectUnitMode Value);
	void SetInnerShadowColor(const struct FColor& Value);
	void SetInnerShadowDistance(float Value);
	void SetInnerShadowDistanceUnitMode(EUIProceduralRectUnitMode Value);
	void SetInnerShadowSize(float Value);
	void SetInnerShadowSizeUnitMode(EUIProceduralRectUnitMode Value);
	void SetOuterShadowAngle(float Value);
	void SetOuterShadowBlur(float Value);
	void SetOuterShadowBlurUnitMode(EUIProceduralRectUnitMode Value);
	void SetOuterShadowColor(const struct FColor& Value);
	void SetOuterShadowDistance(float Value);
	void SetOuterShadowDistanceUnitMode(EUIProceduralRectUnitMode Value);
	void SetOuterShadowSize(float Value);
	void SetOuterShadowSizeUnitMode(EUIProceduralRectUnitMode Value);
	void SetRadialFillAngle(float Value);
	void SetRadialFillCenter(const struct FVector2D& Value);
	void SetRadialFillCenterUnitMode(EUIProceduralRectUnitMode Value);
	void SetRadialFillRotation(float Value);
	void SetRaycastSupportCornerRadius(bool Value);
	void SetSizeFromBodyTexture();
	void SetSoftEdge(bool Value);

	const struct FColor GetBodyColor() const;
	const struct FVector2f GetBodyGradientCenter() const;
	EUIProceduralRectUnitMode GetBodyGradientCenterUnitMode() const;
	const struct FColor GetBodyGradientColor() const;
	const struct FVector2f GetBodyGradientRadius() const;
	EUIProceduralRectUnitMode GetBodyGradientRadiusUnitMode() const;
	float GetBodyGradientRotation() const;
	class ULGUISpriteData_BaseObject* GetBodySpriteTexture() const;
	class UTexture* GetBodyTexture() const;
	EUIProceduralBodyTextureMode GetBodyTextureMode() const;
	EUIProceduralRectTextureScaleMode GetBodyTextureScaleMode() const;
	const struct FColor GetBorderColor() const;
	const struct FVector2f GetBorderGradientCenter() const;
	EUIProceduralRectUnitMode GetBorderGradientCenterUnitMode() const;
	const struct FColor GetBorderGradientColor() const;
	const struct FVector2f GetBorderGradientRadius() const;
	EUIProceduralRectUnitMode GetBorderGradientRadiusUnitMode() const;
	float GetBorderGradientRotation() const;
	float GetBorderWidth() const;
	EUIProceduralRectUnitMode GetBorderWidthUnitMode() const;
	const struct FVector4f GetCornerRadius() const;
	EUIProceduralRectUnitMode GetCornerRadiusUnitMode() const;
	bool GetEnableBody() const;
	bool GetEnableBodyGradient() const;
	bool GetEnableBorder() const;
	bool GetEnableBorderGradient() const;
	bool GetEnableInnerShadow() const;
	bool GetEnableOuterShadow() const;
	bool GetEnableRadialFill() const;
	float GetInnerShadowAngle() const;
	float GetInnerShadowBlur() const;
	EUIProceduralRectUnitMode GetInnerShadowBlurUnitMode() const;
	const struct FColor GetInnerShadowColor() const;
	float GetInnerShadowDistance() const;
	EUIProceduralRectUnitMode GetInnerShadowDistanceUnitMode() const;
	float GetInnerShadowSize() const;
	EUIProceduralRectUnitMode GetInnerShadowSizeUnitMode() const;
	float GetOuterShadowAngle() const;
	float GetOuterShadowBlur() const;
	EUIProceduralRectUnitMode GetOuterShadowBlurUnitMode() const;
	const struct FColor GetOuterShadowColor() const;
	float GetOuterShadowDistance() const;
	EUIProceduralRectUnitMode GetOuterShadowDistanceUnitMode() const;
	float GetOuterShadowSize() const;
	EUIProceduralRectUnitMode GetOuterShadowSizeUnitMode() const;
	float GetRadialFillAngle() const;
	const struct FVector2f GetRadialFillCenter() const;
	EUIProceduralRectUnitMode GetRadialFillCenterUnitMode() const;
	float GetRadialFillRotation() const;
	bool GetRaycastSupportCornerRadius() const;
	bool GetSoftEdge() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIProceduralRect">();
	}
	static class UUIProceduralRect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIProceduralRect>();
	}
};
static_assert(alignof(UUIProceduralRect) == 0x000010, "Wrong alignment on UUIProceduralRect");
static_assert(sizeof(UUIProceduralRect) == 0x000680, "Wrong size on UUIProceduralRect");
static_assert(offsetof(UUIProceduralRect, CornerRadius) == 0x000570, "Member 'UUIProceduralRect::CornerRadius' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, CornerRadiusUnitMode) == 0x000580, "Member 'UUIProceduralRect::CornerRadiusUnitMode' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, bSoftEdge) == 0x000581, "Member 'UUIProceduralRect::bSoftEdge' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, bEnableBody) == 0x000582, "Member 'UUIProceduralRect::bEnableBody' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, BodyColor) == 0x000584, "Member 'UUIProceduralRect::BodyColor' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, BodyTextureMode) == 0x000588, "Member 'UUIProceduralRect::BodyTextureMode' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, BodyTexture) == 0x000590, "Member 'UUIProceduralRect::BodyTexture' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, BodySpriteTexture) == 0x000598, "Member 'UUIProceduralRect::BodySpriteTexture' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, BodyTextureScaleMode) == 0x0005A0, "Member 'UUIProceduralRect::BodyTextureScaleMode' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, bEnableBodyGradient) == 0x0005A1, "Member 'UUIProceduralRect::bEnableBodyGradient' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, BodyGradientColor) == 0x0005A4, "Member 'UUIProceduralRect::BodyGradientColor' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, BodyGradientCenter) == 0x0005A8, "Member 'UUIProceduralRect::BodyGradientCenter' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, BodyGradientCenterUnitMode) == 0x0005B0, "Member 'UUIProceduralRect::BodyGradientCenterUnitMode' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, BodyGradientRadius) == 0x0005B4, "Member 'UUIProceduralRect::BodyGradientRadius' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, BodyGradientRadiusUnitMode) == 0x0005BC, "Member 'UUIProceduralRect::BodyGradientRadiusUnitMode' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, BodyGradientRotation) == 0x0005C0, "Member 'UUIProceduralRect::BodyGradientRotation' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, bEnableBorder) == 0x0005C4, "Member 'UUIProceduralRect::bEnableBorder' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, BorderWidth) == 0x0005C8, "Member 'UUIProceduralRect::BorderWidth' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, BorderWidthUnitMode) == 0x0005CC, "Member 'UUIProceduralRect::BorderWidthUnitMode' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, BorderColor) == 0x0005D0, "Member 'UUIProceduralRect::BorderColor' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, bEnableBorderGradient) == 0x0005D4, "Member 'UUIProceduralRect::bEnableBorderGradient' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, BorderGradientColor) == 0x0005D8, "Member 'UUIProceduralRect::BorderGradientColor' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, BorderGradientCenter) == 0x0005DC, "Member 'UUIProceduralRect::BorderGradientCenter' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, BorderGradientCenterUnitMode) == 0x0005E4, "Member 'UUIProceduralRect::BorderGradientCenterUnitMode' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, BorderGradientRadius) == 0x0005E8, "Member 'UUIProceduralRect::BorderGradientRadius' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, BorderGradientRadiusUnitMode) == 0x0005F0, "Member 'UUIProceduralRect::BorderGradientRadiusUnitMode' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, BorderGradientRotation) == 0x0005F4, "Member 'UUIProceduralRect::BorderGradientRotation' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, bEnableInnerShadow) == 0x0005F8, "Member 'UUIProceduralRect::bEnableInnerShadow' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, InnerShadowColor) == 0x0005FC, "Member 'UUIProceduralRect::InnerShadowColor' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, InnerShadowSize) == 0x000600, "Member 'UUIProceduralRect::InnerShadowSize' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, InnerShadowSizeUnitMode) == 0x000604, "Member 'UUIProceduralRect::InnerShadowSizeUnitMode' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, InnerShadowBlur) == 0x000608, "Member 'UUIProceduralRect::InnerShadowBlur' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, InnerShadowBlurUnitMode) == 0x00060C, "Member 'UUIProceduralRect::InnerShadowBlurUnitMode' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, InnerShadowAngle) == 0x000610, "Member 'UUIProceduralRect::InnerShadowAngle' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, InnerShadowDistance) == 0x000614, "Member 'UUIProceduralRect::InnerShadowDistance' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, InnerShadowDistanceUnitMode) == 0x000618, "Member 'UUIProceduralRect::InnerShadowDistanceUnitMode' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, bEnableRadialFill) == 0x000619, "Member 'UUIProceduralRect::bEnableRadialFill' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, RadialFillCenter) == 0x00061C, "Member 'UUIProceduralRect::RadialFillCenter' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, RadialFillCenterUnitMode) == 0x000624, "Member 'UUIProceduralRect::RadialFillCenterUnitMode' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, RadialFillRotation) == 0x000628, "Member 'UUIProceduralRect::RadialFillRotation' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, RadialFillAngle) == 0x00062C, "Member 'UUIProceduralRect::RadialFillAngle' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, bEnableOuterShadow) == 0x000630, "Member 'UUIProceduralRect::bEnableOuterShadow' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, OuterShadowColor) == 0x000634, "Member 'UUIProceduralRect::OuterShadowColor' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, OuterShadowSize) == 0x000638, "Member 'UUIProceduralRect::OuterShadowSize' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, OuterShadowSizeUnitMode) == 0x00063C, "Member 'UUIProceduralRect::OuterShadowSizeUnitMode' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, OuterShadowBlur) == 0x000640, "Member 'UUIProceduralRect::OuterShadowBlur' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, OuterShadowBlurUnitMode) == 0x000644, "Member 'UUIProceduralRect::OuterShadowBlurUnitMode' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, OuterShadowAngle) == 0x000648, "Member 'UUIProceduralRect::OuterShadowAngle' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, OuterShadowDistance) == 0x00064C, "Member 'UUIProceduralRect::OuterShadowDistance' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, OuterShadowDistanceUnitMode) == 0x000650, "Member 'UUIProceduralRect::OuterShadowDistanceUnitMode' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, ProceduralRectData) == 0x000658, "Member 'UUIProceduralRect::ProceduralRectData' has a wrong offset!");
static_assert(offsetof(UUIProceduralRect, bRaycastSupportCornerRadius) == 0x000660, "Member 'UUIProceduralRect::bRaycastSupportCornerRadius' has a wrong offset!");

// Class LGUI.UIProceduralRectActor
// 0x0008 (0x0298 - 0x0290)
class AUIProceduralRectActor final : public AUIBaseRenderableActor
{
public:
	class UUIProceduralRect*                      UIProceduralRect;                                  // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UUIProceduralRect* GetUIProceduralRect() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIProceduralRectActor">();
	}
	static class AUIProceduralRectActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIProceduralRectActor>();
	}
};
static_assert(alignof(AUIProceduralRectActor) == 0x000008, "Wrong alignment on AUIProceduralRectActor");
static_assert(sizeof(AUIProceduralRectActor) == 0x000298, "Wrong size on AUIProceduralRectActor");
static_assert(offsetof(AUIProceduralRectActor, UIProceduralRect) == 0x000290, "Member 'AUIProceduralRectActor::UIProceduralRect' has a wrong offset!");

// Class LGUI.UIRecyclableScrollViewCell
// 0x0000 (0x0000 - 0x0000)
class IUIRecyclableScrollViewCell final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRecyclableScrollViewCell">();
	}
	static class IUIRecyclableScrollViewCell* GetDefaultObj()
	{
		return GetDefaultObjImpl<IUIRecyclableScrollViewCell>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IUIRecyclableScrollViewCell) == 0x000001, "Wrong alignment on IUIRecyclableScrollViewCell");
static_assert(sizeof(IUIRecyclableScrollViewCell) == 0x000001, "Wrong size on IUIRecyclableScrollViewCell");

// Class LGUI.UIRecyclableScrollViewDataSource
// 0x0000 (0x0000 - 0x0000)
class IUIRecyclableScrollViewDataSource final
{
public:
	void AfterSetCell();
	void BeforeSetCell();
	int32 GetItemCount();
	void InitOnCreate(class UActorComponent* Component);
	void SetCell(class UActorComponent* Component, int32 Index_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRecyclableScrollViewDataSource">();
	}
	static class IUIRecyclableScrollViewDataSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<IUIRecyclableScrollViewDataSource>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IUIRecyclableScrollViewDataSource) == 0x000001, "Wrong alignment on IUIRecyclableScrollViewDataSource");
static_assert(sizeof(IUIRecyclableScrollViewDataSource) == 0x000001, "Wrong size on IUIRecyclableScrollViewDataSource");

// Class LGUI.UIScrollViewComponent
// 0x00D8 (0x01B8 - 0x00E0)
class UUIScrollViewComponent : public ULGUILifeCycleUIBehaviour
{
public:
	uint8                                         Pad_E0[0x10];                                      // 0x00E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AUIBaseActor>            Content;                                           // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Horizontal;                                        // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Vertical;                                          // 0x00F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          OnlyOneDirection;                                  // 0x00FA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FB[0x1];                                       // 0x00FB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScrollSensitivity;                                 // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CanScrollInSmallSize;                              // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlipDirectionInSmallSize;                          // 0x0101(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_102[0x2];                                      // 0x0102(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DecelerateRate;                                    // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          RestrictRectArea;                                  // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OutOfRangeDamper;                                  // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          AllowEventBubbleUp;                                // 0x0110(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          KeepProgress;                                      // 0x0111(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_112[0x6];                                      // 0x0112(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Progress;                                          // 0x0118(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_128[0x4];                                      // 0x0128(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UUIItem>                 ContentUIItem;                                     // 0x012C(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UUIItem>                 ContentParentUIItem;                               // 0x0134(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13C[0x64];                                     // 0x013C(0x0064)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIEventDelegate                     OnScroll;                                          // 0x01A0(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	void RectRangeChanged();
	struct FLGUIDelegateHandleWrapper RegisterScrollEvent(const TDelegate<void(const struct FVector2D& InVector2)>& InDelegate);
	void ScrollTo(class UUIItem* InChild, bool InEaseAnimation, float InAnimationDuration);
	void SetCanScrollInSmallSize(bool Value);
	void SetDecelerateRate(float Value);
	void SetHorizontal(bool Value);
	void SetOnlyOneDirection(bool Value);
	void SetOutOfRangeDamper(float Value);
	void SetRestrictRectArea(bool Value);
	void SetScrollDelta(const struct FVector2D& Value);
	void SetScrollProgress(const struct FVector2D& Value);
	void SetScrollSensitivity(float Value);
	void SetScrollValue(const struct FVector2D& Value);
	void SetVelocity(const struct FVector2D& Value);
	void SetVertical(bool Value);
	void UnregisterScrollEvent(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);

	bool GetCanScrollInSmallSize() const;
	class AUIBaseActor* GetContent() const;
	float GetDecelerateRate() const;
	bool GetHorizontal() const;
	struct FVector2D GetHorizontalRange() const;
	bool GetOnlyOneDirection() const;
	float GetOutOfRangeDamper() const;
	bool GetRestrictRectArea() const;
	struct FVector2D GetScrollProgress() const;
	float GetScrollSensitivity() const;
	struct FVector2D GetVelocity() const;
	bool GetVertical() const;
	struct FVector2D GetVerticalRange() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIScrollViewComponent">();
	}
	static class UUIScrollViewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIScrollViewComponent>();
	}
};
static_assert(alignof(UUIScrollViewComponent) == 0x000008, "Wrong alignment on UUIScrollViewComponent");
static_assert(sizeof(UUIScrollViewComponent) == 0x0001B8, "Wrong size on UUIScrollViewComponent");
static_assert(offsetof(UUIScrollViewComponent, Content) == 0x0000F0, "Member 'UUIScrollViewComponent::Content' has a wrong offset!");
static_assert(offsetof(UUIScrollViewComponent, Horizontal) == 0x0000F8, "Member 'UUIScrollViewComponent::Horizontal' has a wrong offset!");
static_assert(offsetof(UUIScrollViewComponent, Vertical) == 0x0000F9, "Member 'UUIScrollViewComponent::Vertical' has a wrong offset!");
static_assert(offsetof(UUIScrollViewComponent, OnlyOneDirection) == 0x0000FA, "Member 'UUIScrollViewComponent::OnlyOneDirection' has a wrong offset!");
static_assert(offsetof(UUIScrollViewComponent, ScrollSensitivity) == 0x0000FC, "Member 'UUIScrollViewComponent::ScrollSensitivity' has a wrong offset!");
static_assert(offsetof(UUIScrollViewComponent, CanScrollInSmallSize) == 0x000100, "Member 'UUIScrollViewComponent::CanScrollInSmallSize' has a wrong offset!");
static_assert(offsetof(UUIScrollViewComponent, FlipDirectionInSmallSize) == 0x000101, "Member 'UUIScrollViewComponent::FlipDirectionInSmallSize' has a wrong offset!");
static_assert(offsetof(UUIScrollViewComponent, DecelerateRate) == 0x000104, "Member 'UUIScrollViewComponent::DecelerateRate' has a wrong offset!");
static_assert(offsetof(UUIScrollViewComponent, RestrictRectArea) == 0x000108, "Member 'UUIScrollViewComponent::RestrictRectArea' has a wrong offset!");
static_assert(offsetof(UUIScrollViewComponent, OutOfRangeDamper) == 0x00010C, "Member 'UUIScrollViewComponent::OutOfRangeDamper' has a wrong offset!");
static_assert(offsetof(UUIScrollViewComponent, AllowEventBubbleUp) == 0x000110, "Member 'UUIScrollViewComponent::AllowEventBubbleUp' has a wrong offset!");
static_assert(offsetof(UUIScrollViewComponent, KeepProgress) == 0x000111, "Member 'UUIScrollViewComponent::KeepProgress' has a wrong offset!");
static_assert(offsetof(UUIScrollViewComponent, Progress) == 0x000118, "Member 'UUIScrollViewComponent::Progress' has a wrong offset!");
static_assert(offsetof(UUIScrollViewComponent, ContentUIItem) == 0x00012C, "Member 'UUIScrollViewComponent::ContentUIItem' has a wrong offset!");
static_assert(offsetof(UUIScrollViewComponent, ContentParentUIItem) == 0x000134, "Member 'UUIScrollViewComponent::ContentParentUIItem' has a wrong offset!");
static_assert(offsetof(UUIScrollViewComponent, OnScroll) == 0x0001A0, "Member 'UUIScrollViewComponent::OnScroll' has a wrong offset!");

// Class LGUI.UIScrollViewWithScrollbarComponent
// 0x0040 (0x01F8 - 0x01B8)
class UUIScrollViewWithScrollbarComponent : public UUIScrollViewComponent
{
public:
	uint8                                         Pad_1B8[0x8];                                      // 0x01B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AUIBaseActor>            Viewport;                                          // 0x01C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AUIBaseActor>            HorizontalScrollbar;                               // 0x01C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EScrollViewScrollbarVisibility                HorizontalScrollbarVisibility;                     // 0x01D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D1[0x3];                                      // 0x01D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AUIBaseActor>            VerticalScrollbar;                                 // 0x01D4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EScrollViewScrollbarVisibility                VerticalScrollbarVisibility;                       // 0x01DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DD[0x3];                                      // 0x01DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UUIScrollbarComponent>   HorizontalScrollbarComp;                           // 0x01E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UUIScrollbarComponent>   VerticalScrollbarComp;                             // 0x01E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F0[0x8];                                      // 0x01F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHorizontalScrollbarVisibility(EScrollViewScrollbarVisibility Value);
	void SetVerticalScrollbarVisibility(EScrollViewScrollbarVisibility Value);

	class AUIBaseActor* GetHorizontalScrollbar() const;
	EScrollViewScrollbarVisibility GetHorizontalScrollbarVisibility() const;
	class AUIBaseActor* GetVerticalScrollbar() const;
	EScrollViewScrollbarVisibility GetVerticalScrollbarVisibility() const;
	class AUIBaseActor* GetViewport() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIScrollViewWithScrollbarComponent">();
	}
	static class UUIScrollViewWithScrollbarComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIScrollViewWithScrollbarComponent>();
	}
};
static_assert(alignof(UUIScrollViewWithScrollbarComponent) == 0x000008, "Wrong alignment on UUIScrollViewWithScrollbarComponent");
static_assert(sizeof(UUIScrollViewWithScrollbarComponent) == 0x0001F8, "Wrong size on UUIScrollViewWithScrollbarComponent");
static_assert(offsetof(UUIScrollViewWithScrollbarComponent, Viewport) == 0x0001C0, "Member 'UUIScrollViewWithScrollbarComponent::Viewport' has a wrong offset!");
static_assert(offsetof(UUIScrollViewWithScrollbarComponent, HorizontalScrollbar) == 0x0001C8, "Member 'UUIScrollViewWithScrollbarComponent::HorizontalScrollbar' has a wrong offset!");
static_assert(offsetof(UUIScrollViewWithScrollbarComponent, HorizontalScrollbarVisibility) == 0x0001D0, "Member 'UUIScrollViewWithScrollbarComponent::HorizontalScrollbarVisibility' has a wrong offset!");
static_assert(offsetof(UUIScrollViewWithScrollbarComponent, VerticalScrollbar) == 0x0001D4, "Member 'UUIScrollViewWithScrollbarComponent::VerticalScrollbar' has a wrong offset!");
static_assert(offsetof(UUIScrollViewWithScrollbarComponent, VerticalScrollbarVisibility) == 0x0001DC, "Member 'UUIScrollViewWithScrollbarComponent::VerticalScrollbarVisibility' has a wrong offset!");
static_assert(offsetof(UUIScrollViewWithScrollbarComponent, HorizontalScrollbarComp) == 0x0001E0, "Member 'UUIScrollViewWithScrollbarComponent::HorizontalScrollbarComp' has a wrong offset!");
static_assert(offsetof(UUIScrollViewWithScrollbarComponent, VerticalScrollbarComp) == 0x0001E8, "Member 'UUIScrollViewWithScrollbarComponent::VerticalScrollbarComp' has a wrong offset!");

// Class LGUI.UIRecyclableScrollViewComponent
// 0x00C0 (0x02B8 - 0x01F8)
class UUIRecyclableScrollViewComponent final : public UUIScrollViewWithScrollbarComponent
{
public:
	class UObject*                                DataSource;                                        // 0x01F8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIRecyclableScrollViewCellTemplateType       CellTemplateType;                                  // 0x0200(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_201[0x7];                                      // 0x0201(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AUIBaseActor*                           CellTemplate;                                      // 0x0208(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULGUIPrefab*                            CellTemplatePrefab;                                // 0x0210(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint16                                        Rows;                                              // 0x0218(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint16                                        Columns;                                           // 0x021A(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInfiniteLoop;                                     // 0x021C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21D[0x3];                                      // 0x021D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMargin                                Padding;                                           // 0x0220(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              Space;                                             // 0x0230(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FUIRecyclableScrollViewCellContainer> CacheCellList;                               // 0x0240(0x0010)(Edit, ZeroConstructor, Transient, EditConst, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPrivate)
	uint8                                         Pad_250[0x68];                                     // 0x0250(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearAllCells();
	void RecreateList();
	void ScrollToByDataIndex(int32 InDataIndex, bool InEaseAnimation, float InAnimationDuration);
	void SetCellTemplate(class AUIBaseActor* Value);
	void SetCellTemplatePrefab(class ULGUIPrefab* Value);
	void SetColumns(int32 Value);
	void SetDataSource(TScriptInterface<class IUIRecyclableScrollViewDataSource> InDataSource);
	void SetInfiniteLoop(bool Value);
	void SetPadding(const struct FMargin& Value);
	void SetRows(int32 Value);
	void SetSpace(const struct FVector2D& Value);
	void UpdateCellData();
	void UpdateWithDataSource();

	const TArray<struct FUIRecyclableScrollViewCellContainer> GetCacheCellList() const;
	bool GetCellItemByDataIndex(int32 Index_0, struct FUIRecyclableScrollViewCellContainer* OutResult) const;
	class AUIBaseActor* GetCellTemplate() const;
	class ULGUIPrefab* GetCellTemplatePrefab() const;
	EUIRecyclableScrollViewCellTemplateType GetCellTemplateType() const;
	int32 GetColumns() const;
	TScriptInterface<class IUIRecyclableScrollViewDataSource> GetDataSource() const;
	bool GetInfiniteLoop() const;
	const struct FMargin GetPadding() const;
	int32 GetRows() const;
	const struct FVector2D GetSpace() const;
	void GetUserFriendlyCacheCellList(TArray<struct FUIRecyclableScrollViewCellContainer>* OutResult) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRecyclableScrollViewComponent">();
	}
	static class UUIRecyclableScrollViewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIRecyclableScrollViewComponent>();
	}
};
static_assert(alignof(UUIRecyclableScrollViewComponent) == 0x000008, "Wrong alignment on UUIRecyclableScrollViewComponent");
static_assert(sizeof(UUIRecyclableScrollViewComponent) == 0x0002B8, "Wrong size on UUIRecyclableScrollViewComponent");
static_assert(offsetof(UUIRecyclableScrollViewComponent, DataSource) == 0x0001F8, "Member 'UUIRecyclableScrollViewComponent::DataSource' has a wrong offset!");
static_assert(offsetof(UUIRecyclableScrollViewComponent, CellTemplateType) == 0x000200, "Member 'UUIRecyclableScrollViewComponent::CellTemplateType' has a wrong offset!");
static_assert(offsetof(UUIRecyclableScrollViewComponent, CellTemplate) == 0x000208, "Member 'UUIRecyclableScrollViewComponent::CellTemplate' has a wrong offset!");
static_assert(offsetof(UUIRecyclableScrollViewComponent, CellTemplatePrefab) == 0x000210, "Member 'UUIRecyclableScrollViewComponent::CellTemplatePrefab' has a wrong offset!");
static_assert(offsetof(UUIRecyclableScrollViewComponent, Rows) == 0x000218, "Member 'UUIRecyclableScrollViewComponent::Rows' has a wrong offset!");
static_assert(offsetof(UUIRecyclableScrollViewComponent, Columns) == 0x00021A, "Member 'UUIRecyclableScrollViewComponent::Columns' has a wrong offset!");
static_assert(offsetof(UUIRecyclableScrollViewComponent, bInfiniteLoop) == 0x00021C, "Member 'UUIRecyclableScrollViewComponent::bInfiniteLoop' has a wrong offset!");
static_assert(offsetof(UUIRecyclableScrollViewComponent, Padding) == 0x000220, "Member 'UUIRecyclableScrollViewComponent::Padding' has a wrong offset!");
static_assert(offsetof(UUIRecyclableScrollViewComponent, Space) == 0x000230, "Member 'UUIRecyclableScrollViewComponent::Space' has a wrong offset!");
static_assert(offsetof(UUIRecyclableScrollViewComponent, CacheCellList) == 0x000240, "Member 'UUIRecyclableScrollViewComponent::CacheCellList' has a wrong offset!");

// Class LGUI.UIRenderableCustomRaycast_VisiblePixel
// 0x0008 (0x0030 - 0x0028)
class UUIRenderableCustomRaycast_VisiblePixel final : public UUIRenderableCustomRaycast
{
public:
	float                                         VisibilityThreshold;                               // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         PixelChannel;                                      // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetPixelChannel(uint8 Value);
	void SetVisibilityThreshold(float Value);

	uint8 GetPixelChannel() const;
	float GetVisibilityThreshold() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRenderableCustomRaycast_VisiblePixel">();
	}
	static class UUIRenderableCustomRaycast_VisiblePixel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIRenderableCustomRaycast_VisiblePixel>();
	}
};
static_assert(alignof(UUIRenderableCustomRaycast_VisiblePixel) == 0x000008, "Wrong alignment on UUIRenderableCustomRaycast_VisiblePixel");
static_assert(sizeof(UUIRenderableCustomRaycast_VisiblePixel) == 0x000030, "Wrong size on UUIRenderableCustomRaycast_VisiblePixel");
static_assert(offsetof(UUIRenderableCustomRaycast_VisiblePixel, VisibilityThreshold) == 0x000028, "Member 'UUIRenderableCustomRaycast_VisiblePixel::VisibilityThreshold' has a wrong offset!");
static_assert(offsetof(UUIRenderableCustomRaycast_VisiblePixel, PixelChannel) == 0x00002C, "Member 'UUIRenderableCustomRaycast_VisiblePixel::PixelChannel' has a wrong offset!");

// Class LGUI.UIRenderTarget
// 0x0030 (0x05A0 - 0x0570)
class UUIRenderTarget final : public UUICustomMesh
{
public:
	uint8                                         Pad_570[0x8];                                      // 0x0570(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIComponentReference                TargetCanvas;                                      // 0x0578(0x0020)(Edit, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_598[0x8];                                      // 0x0598(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCanvas(class ULGUICanvas* Value);

	class ULGUICanvas* GetCanvas() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRenderTarget">();
	}
	static class UUIRenderTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIRenderTarget>();
	}
};
static_assert(alignof(UUIRenderTarget) == 0x000010, "Wrong alignment on UUIRenderTarget");
static_assert(sizeof(UUIRenderTarget) == 0x0005A0, "Wrong size on UUIRenderTarget");
static_assert(offsetof(UUIRenderTarget, TargetCanvas) == 0x000578, "Member 'UUIRenderTarget::TargetCanvas' has a wrong offset!");

// Class LGUI.UIRenderTargetActor
// 0x0008 (0x0298 - 0x0290)
class AUIRenderTargetActor final : public AUIBaseRenderableActor
{
public:
	class UUIRenderTarget*                        UIRenderTarget;                                    // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UUIRenderTarget* Get2DLineRing() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRenderTargetActor">();
	}
	static class AUIRenderTargetActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIRenderTargetActor>();
	}
};
static_assert(alignof(AUIRenderTargetActor) == 0x000008, "Wrong alignment on AUIRenderTargetActor");
static_assert(sizeof(AUIRenderTargetActor) == 0x000298, "Wrong size on AUIRenderTargetActor");
static_assert(offsetof(AUIRenderTargetActor, UIRenderTarget) == 0x000290, "Member 'AUIRenderTargetActor::UIRenderTarget' has a wrong offset!");

// Class LGUI.UIRing
// 0x0020 (0x05B0 - 0x0590)
class UUIRing final : public UUI2DLineRendererBase
{
public:
	float                                         StartAngle;                                        // 0x0588(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndAngle;                                          // 0x058C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Segment;                                           // 0x0590(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_594[0x4];                                      // 0x0594(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector2D>                      CurrentPointArray;                                 // 0x0598(0x0010)(Edit, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A8[0x8];                                      // 0x05A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ULTweener* EndAngleTo(float endValue, float Duration, float Delay, ELTweenEase easetype);
	void SetEndAngle(float NewValue);
	void SetSegment(int32 NewValue);
	void SetStartAngle(float NewValue);
	class ULTweener* StartAngleTo(float endValue, float Duration, float Delay, ELTweenEase easetype);

	float GetEndAngle() const;
	int32 GetSegment() const;
	float GetStartAngle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRing">();
	}
	static class UUIRing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIRing>();
	}
};
static_assert(alignof(UUIRing) == 0x000010, "Wrong alignment on UUIRing");
static_assert(sizeof(UUIRing) == 0x0005B0, "Wrong size on UUIRing");
static_assert(offsetof(UUIRing, StartAngle) == 0x000588, "Member 'UUIRing::StartAngle' has a wrong offset!");
static_assert(offsetof(UUIRing, EndAngle) == 0x00058C, "Member 'UUIRing::EndAngle' has a wrong offset!");
static_assert(offsetof(UUIRing, Segment) == 0x000590, "Member 'UUIRing::Segment' has a wrong offset!");
static_assert(offsetof(UUIRing, CurrentPointArray) == 0x000598, "Member 'UUIRing::CurrentPointArray' has a wrong offset!");

// Class LGUI.UIRingActor
// 0x0008 (0x0298 - 0x0290)
class AUIRingActor final : public AUIBaseRenderableActor
{
public:
	class UUIRing*                                UIElement;                                         // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UUIRing* Get2DLineRing() const;
	class UUIRing* GetUIRing() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRingActor">();
	}
	static class AUIRingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIRingActor>();
	}
};
static_assert(alignof(AUIRingActor) == 0x000008, "Wrong alignment on AUIRingActor");
static_assert(sizeof(AUIRingActor) == 0x000298, "Wrong size on AUIRingActor");
static_assert(offsetof(AUIRingActor, UIElement) == 0x000290, "Member 'AUIRingActor::UIElement' has a wrong offset!");

// Class LGUI.UIRoundedLayout
// 0x0010 (0x0140 - 0x0130)
class UUIRoundedLayout final : public UUILayoutWithChildren
{
public:
	float                                         Radius;                                            // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartAngle;                                        // 0x0134(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndAngle;                                          // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSetChildAngle;                                    // 0x013C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13D[0x3];                                      // 0x013D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRoundedLayout">();
	}
	static class UUIRoundedLayout* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIRoundedLayout>();
	}
};
static_assert(alignof(UUIRoundedLayout) == 0x000008, "Wrong alignment on UUIRoundedLayout");
static_assert(sizeof(UUIRoundedLayout) == 0x000140, "Wrong size on UUIRoundedLayout");
static_assert(offsetof(UUIRoundedLayout, Radius) == 0x000130, "Member 'UUIRoundedLayout::Radius' has a wrong offset!");
static_assert(offsetof(UUIRoundedLayout, StartAngle) == 0x000134, "Member 'UUIRoundedLayout::StartAngle' has a wrong offset!");
static_assert(offsetof(UUIRoundedLayout, EndAngle) == 0x000138, "Member 'UUIRoundedLayout::EndAngle' has a wrong offset!");
static_assert(offsetof(UUIRoundedLayout, bSetChildAngle) == 0x00013C, "Member 'UUIRoundedLayout::bSetChildAngle' has a wrong offset!");

// Class LGUI.UIScrollbarComponent
// 0x0068 (0x02B0 - 0x0248)
class UUIScrollbarComponent final : public UUISelectableComponent
{
public:
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Size;                                              // 0x0254(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AUIBaseActor>            HandleActor;                                       // 0x0258(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIScrollbarDirectionType                     directionType;                                     // 0x0260(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_261[0x3];                                      // 0x0261(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NavigationChangeInterval;                          // 0x0264(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UUIItem>                 Handle;                                            // 0x0268(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UUIItem>                 HandleArea;                                        // 0x0270(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_278[0x18];                                     // 0x0278(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIEventDelegate                     OnValueChange;                                     // 0x0290(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FLGUIDelegateHandleWrapper RegisterSlideEvent(const TDelegate<void(float InFloat)>& InDelegate);
	void SetNavigationChangeInterval(float InValue);
	void SetSize(float InSize);
	void SetValue(float InValue, bool fireEvent);
	void SetValueAndSize(float InValue, float InSize, bool fireEvent);
	void UnregisterSlideEvent(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);

	EUIScrollbarDirectionType GetDirectionType() const;
	class AUIBaseActor* GetHandleActor() const;
	float GetNavigationChangeInterval() const;
	float GetSize() const;
	float GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIScrollbarComponent">();
	}
	static class UUIScrollbarComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIScrollbarComponent>();
	}
};
static_assert(alignof(UUIScrollbarComponent) == 0x000008, "Wrong alignment on UUIScrollbarComponent");
static_assert(sizeof(UUIScrollbarComponent) == 0x0002B0, "Wrong size on UUIScrollbarComponent");
static_assert(offsetof(UUIScrollbarComponent, Value) == 0x000250, "Member 'UUIScrollbarComponent::Value' has a wrong offset!");
static_assert(offsetof(UUIScrollbarComponent, Size) == 0x000254, "Member 'UUIScrollbarComponent::Size' has a wrong offset!");
static_assert(offsetof(UUIScrollbarComponent, HandleActor) == 0x000258, "Member 'UUIScrollbarComponent::HandleActor' has a wrong offset!");
static_assert(offsetof(UUIScrollbarComponent, directionType) == 0x000260, "Member 'UUIScrollbarComponent::directionType' has a wrong offset!");
static_assert(offsetof(UUIScrollbarComponent, NavigationChangeInterval) == 0x000264, "Member 'UUIScrollbarComponent::NavigationChangeInterval' has a wrong offset!");
static_assert(offsetof(UUIScrollbarComponent, Handle) == 0x000268, "Member 'UUIScrollbarComponent::Handle' has a wrong offset!");
static_assert(offsetof(UUIScrollbarComponent, HandleArea) == 0x000270, "Member 'UUIScrollbarComponent::HandleArea' has a wrong offset!");
static_assert(offsetof(UUIScrollbarComponent, OnValueChange) == 0x000290, "Member 'UUIScrollbarComponent::OnValueChange' has a wrong offset!");

// Class LGUI.UIScrollViewHelper
// 0x0008 (0x00E8 - 0x00E0)
class UUIScrollViewHelper final : public ULGUILifeCycleUIBehaviour
{
public:
	TWeakObjectPtr<class UUIScrollViewComponent>  TargetComp;                                        // 0x00E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIScrollViewHelper">();
	}
	static class UUIScrollViewHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIScrollViewHelper>();
	}
};
static_assert(alignof(UUIScrollViewHelper) == 0x000008, "Wrong alignment on UUIScrollViewHelper");
static_assert(sizeof(UUIScrollViewHelper) == 0x0000E8, "Wrong size on UUIScrollViewHelper");
static_assert(offsetof(UUIScrollViewHelper, TargetComp) == 0x0000E0, "Member 'UUIScrollViewHelper::TargetComp' has a wrong offset!");

// Class LGUI.UISelectableTransitionComponent
// 0x0010 (0x00F0 - 0x00E0)
class UUISelectableTransitionComponent final : public ULGUILifeCycleUIBehaviour
{
public:
	TArray<class ULTweener*>                      TweenerCollection;                                 // 0x00E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void CollectTweener(class ULTweener* InItem);
	void CollectTweeners(const TSet<class ULTweener*>& InItems);
	void ReceiveOnDisabled(bool InImmediateSet);
	void ReceiveOnHighlighted(bool InImmediateSet);
	void ReceiveOnNormal(bool InImmediateSet);
	void ReceiveOnPressed(bool InImmediateSet);
	void ReceiveOnStartCustomTransition(class FName InTransitionName, bool InImmediateSet);
	void StopTransition();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISelectableTransitionComponent">();
	}
	static class UUISelectableTransitionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISelectableTransitionComponent>();
	}
};
static_assert(alignof(UUISelectableTransitionComponent) == 0x000008, "Wrong alignment on UUISelectableTransitionComponent");
static_assert(sizeof(UUISelectableTransitionComponent) == 0x0000F0, "Wrong size on UUISelectableTransitionComponent");
static_assert(offsetof(UUISelectableTransitionComponent, TweenerCollection) == 0x0000E0, "Member 'UUISelectableTransitionComponent::TweenerCollection' has a wrong offset!");

// Class LGUI.UISizeControlByAspectRatio
// 0x0008 (0x0120 - 0x0118)
class UUISizeControlByAspectRatio final : public UUILayoutWithAnimation
{
public:
	EUISizeControlByAspectRatioMode               ControlMode;                                       // 0x0118(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AspectRatio;                                       // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetAspectRatio(float Value);
	void SetControlMode(EUISizeControlByAspectRatioMode Value);

	float GetAspectRatio() const;
	EUISizeControlByAspectRatioMode GetControlMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISizeControlByAspectRatio">();
	}
	static class UUISizeControlByAspectRatio* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISizeControlByAspectRatio>();
	}
};
static_assert(alignof(UUISizeControlByAspectRatio) == 0x000008, "Wrong alignment on UUISizeControlByAspectRatio");
static_assert(sizeof(UUISizeControlByAspectRatio) == 0x000120, "Wrong size on UUISizeControlByAspectRatio");
static_assert(offsetof(UUISizeControlByAspectRatio, ControlMode) == 0x000118, "Member 'UUISizeControlByAspectRatio::ControlMode' has a wrong offset!");
static_assert(offsetof(UUISizeControlByAspectRatio, AspectRatio) == 0x00011C, "Member 'UUISizeControlByAspectRatio::AspectRatio' has a wrong offset!");

// Class LGUI.UISizeControlByChildren
// 0x0010 (0x0140 - 0x0130)
class UUISizeControlByChildren final : public UUILayoutWithChildren
{
public:
	bool                                          bWidthFitToChildren;                               // 0x0130(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_131[0x3];                                      // 0x0131(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdditionalWidth;                                   // 0x0134(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHeightFitToChildren;                              // 0x0138(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_139[0x3];                                      // 0x0139(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdditionalHeight;                                  // 0x013C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetAdditionalHeight(float Value);
	void SetAdditionalWidth(float Value);
	void SetHeightFitToChildren(bool Value);
	void SetWidthFitToChildren(bool Value);

	float GetAdditionalHeight() const;
	float GetAdditionalWidth() const;
	float GetHeightFitToChildren() const;
	bool GetWidthFitToChildren() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISizeControlByChildren">();
	}
	static class UUISizeControlByChildren* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISizeControlByChildren>();
	}
};
static_assert(alignof(UUISizeControlByChildren) == 0x000008, "Wrong alignment on UUISizeControlByChildren");
static_assert(sizeof(UUISizeControlByChildren) == 0x000140, "Wrong size on UUISizeControlByChildren");
static_assert(offsetof(UUISizeControlByChildren, bWidthFitToChildren) == 0x000130, "Member 'UUISizeControlByChildren::bWidthFitToChildren' has a wrong offset!");
static_assert(offsetof(UUISizeControlByChildren, AdditionalWidth) == 0x000134, "Member 'UUISizeControlByChildren::AdditionalWidth' has a wrong offset!");
static_assert(offsetof(UUISizeControlByChildren, bHeightFitToChildren) == 0x000138, "Member 'UUISizeControlByChildren::bHeightFitToChildren' has a wrong offset!");
static_assert(offsetof(UUISizeControlByChildren, AdditionalHeight) == 0x00013C, "Member 'UUISizeControlByChildren::AdditionalHeight' has a wrong offset!");

// Class LGUI.UISizeControlByOtherHelper
// 0x0008 (0x00E8 - 0x00E0)
class UUISizeControlByOtherHelper final : public ULGUILifeCycleUIBehaviour
{
public:
	TWeakObjectPtr<class UUISizeControlByOther>   TargetComp;                                        // 0x00E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISizeControlByOtherHelper">();
	}
	static class UUISizeControlByOtherHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISizeControlByOtherHelper>();
	}
};
static_assert(alignof(UUISizeControlByOtherHelper) == 0x000008, "Wrong alignment on UUISizeControlByOtherHelper");
static_assert(sizeof(UUISizeControlByOtherHelper) == 0x0000E8, "Wrong size on UUISizeControlByOtherHelper");
static_assert(offsetof(UUISizeControlByOtherHelper, TargetComp) == 0x0000E0, "Member 'UUISizeControlByOtherHelper::TargetComp' has a wrong offset!");

// Class LGUI.UISizeControlByOther
// 0x0028 (0x0140 - 0x0118)
class UUISizeControlByOther final : public UUILayoutWithAnimation
{
public:
	TWeakObjectPtr<class AUIBaseActor>            TargetActor;                                       // 0x0118(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ControlWidth;                                      // 0x0120(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_121[0x3];                                      // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdditionalWidth;                                   // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ControlHeight;                                     // 0x0128(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_129[0x3];                                      // 0x0129(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdditionalHeight;                                  // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UUIItem>                 TargetUIItem;                                      // 0x0130(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UUISizeControlByOtherHelper> HelperComp;                                    // 0x0138(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetAdditionalHeight(float Value);
	void SetAdditionalWidth(float Value);
	void SetControlHeight(bool Value);
	void SetControlWidth(bool Value);
	void SetTargetActor(class AUIBaseActor* Value);

	float GetAdditionalHeight() const;
	float GetAdditionalWidth() const;
	bool GetControlHeight() const;
	bool GetControlWidth() const;
	class AUIBaseActor* GetTargetActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISizeControlByOther">();
	}
	static class UUISizeControlByOther* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISizeControlByOther>();
	}
};
static_assert(alignof(UUISizeControlByOther) == 0x000008, "Wrong alignment on UUISizeControlByOther");
static_assert(sizeof(UUISizeControlByOther) == 0x000140, "Wrong size on UUISizeControlByOther");
static_assert(offsetof(UUISizeControlByOther, TargetActor) == 0x000118, "Member 'UUISizeControlByOther::TargetActor' has a wrong offset!");
static_assert(offsetof(UUISizeControlByOther, ControlWidth) == 0x000120, "Member 'UUISizeControlByOther::ControlWidth' has a wrong offset!");
static_assert(offsetof(UUISizeControlByOther, AdditionalWidth) == 0x000124, "Member 'UUISizeControlByOther::AdditionalWidth' has a wrong offset!");
static_assert(offsetof(UUISizeControlByOther, ControlHeight) == 0x000128, "Member 'UUISizeControlByOther::ControlHeight' has a wrong offset!");
static_assert(offsetof(UUISizeControlByOther, AdditionalHeight) == 0x00012C, "Member 'UUISizeControlByOther::AdditionalHeight' has a wrong offset!");
static_assert(offsetof(UUISizeControlByOther, TargetUIItem) == 0x000130, "Member 'UUISizeControlByOther::TargetUIItem' has a wrong offset!");
static_assert(offsetof(UUISizeControlByOther, HelperComp) == 0x000138, "Member 'UUISizeControlByOther::HelperComp' has a wrong offset!");

// Class LGUI.UISliderComponent
// 0x0080 (0x02C8 - 0x0248)
class UUISliderComponent final : public UUISelectableComponent
{
public:
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinValue;                                          // 0x0254(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxValue;                                          // 0x0258(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          WholeNumbers;                                      // 0x025C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25D[0x3];                                      // 0x025D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AUIBaseActor>            FillActor;                                         // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AUIBaseActor>            HandleActor;                                       // 0x0268(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUISliderDirectionType                        directionType;                                     // 0x0270(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_271[0x3];                                      // 0x0271(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NavigationChangeInterval;                          // 0x0274(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UUIItem>                 Fill;                                              // 0x0278(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UUIItem>                 FillArea;                                          // 0x0280(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UUIItem>                 Handle;                                            // 0x0288(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UUIItem>                 HandleArea;                                        // 0x0290(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_298[0x18];                                     // 0x0298(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIEventDelegate                     OnValueChange;                                     // 0x02B0(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	struct FLGUIDelegateHandleWrapper RegisterSlideEvent(const TDelegate<void(float InFloat)>& InDelegate);
	void SetMaxValue(float InMaxValue, bool KeepRelativeValue, bool fireEvent);
	void SetMinValue(float InMinValue, bool KeepRelativeValue, bool fireEvent);
	void SetNavigationChangeInterval(float InValue);
	void SetValue(float InValue, bool fireEvent);
	void UnregisterSlideEvent(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);

	EUISliderDirectionType GetDirectionType() const;
	class AUIBaseActor* GetFillActor() const;
	class AUIBaseActor* GetHandleActor() const;
	float GetMaxValue() const;
	float GetMinValue() const;
	float GetNavigationChangeInterval() const;
	float GetValue() const;
	bool GetWholeNumber() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISliderComponent">();
	}
	static class UUISliderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISliderComponent>();
	}
};
static_assert(alignof(UUISliderComponent) == 0x000008, "Wrong alignment on UUISliderComponent");
static_assert(sizeof(UUISliderComponent) == 0x0002C8, "Wrong size on UUISliderComponent");
static_assert(offsetof(UUISliderComponent, Value) == 0x000250, "Member 'UUISliderComponent::Value' has a wrong offset!");
static_assert(offsetof(UUISliderComponent, MinValue) == 0x000254, "Member 'UUISliderComponent::MinValue' has a wrong offset!");
static_assert(offsetof(UUISliderComponent, MaxValue) == 0x000258, "Member 'UUISliderComponent::MaxValue' has a wrong offset!");
static_assert(offsetof(UUISliderComponent, WholeNumbers) == 0x00025C, "Member 'UUISliderComponent::WholeNumbers' has a wrong offset!");
static_assert(offsetof(UUISliderComponent, FillActor) == 0x000260, "Member 'UUISliderComponent::FillActor' has a wrong offset!");
static_assert(offsetof(UUISliderComponent, HandleActor) == 0x000268, "Member 'UUISliderComponent::HandleActor' has a wrong offset!");
static_assert(offsetof(UUISliderComponent, directionType) == 0x000270, "Member 'UUISliderComponent::directionType' has a wrong offset!");
static_assert(offsetof(UUISliderComponent, NavigationChangeInterval) == 0x000274, "Member 'UUISliderComponent::NavigationChangeInterval' has a wrong offset!");
static_assert(offsetof(UUISliderComponent, Fill) == 0x000278, "Member 'UUISliderComponent::Fill' has a wrong offset!");
static_assert(offsetof(UUISliderComponent, FillArea) == 0x000280, "Member 'UUISliderComponent::FillArea' has a wrong offset!");
static_assert(offsetof(UUISliderComponent, Handle) == 0x000288, "Member 'UUISliderComponent::Handle' has a wrong offset!");
static_assert(offsetof(UUISliderComponent, HandleArea) == 0x000290, "Member 'UUISliderComponent::HandleArea' has a wrong offset!");
static_assert(offsetof(UUISliderComponent, OnValueChange) == 0x0002B0, "Member 'UUISliderComponent::OnValueChange' has a wrong offset!");

// Class LGUI.UISprite
// 0x0010 (0x0590 - 0x0580)
class UUISprite final : public UUISpriteBase
{
public:
	EUISpriteType                                 Type;                                              // 0x0578(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUISpriteFillMethod                           FillMethod;                                        // 0x0579(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         fillOrigin;                                        // 0x057A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          fillDirectionFlip;                                 // 0x057B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         fillAmount;                                        // 0x057C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_580[0x10];                                     // 0x0580(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFillAmount(float NewValue);
	void SetFillDirectionFlip(bool NewValue);
	void SetFillMethod(EUISpriteFillMethod NewValue);
	void SetFillOrigin(uint8 NewValue);
	void SetSpriteType(EUISpriteType NewType);

	float GetFillAmount() const;
	bool GetFillDirectionFlip() const;
	EUISpriteFillMethod GetFillMethod() const;
	uint8 GetFillOrigin() const;
	EUISpriteType GetSpriteType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISprite">();
	}
	static class UUISprite* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISprite>();
	}
};
static_assert(alignof(UUISprite) == 0x000010, "Wrong alignment on UUISprite");
static_assert(sizeof(UUISprite) == 0x000590, "Wrong size on UUISprite");
static_assert(offsetof(UUISprite, Type) == 0x000578, "Member 'UUISprite::Type' has a wrong offset!");
static_assert(offsetof(UUISprite, FillMethod) == 0x000579, "Member 'UUISprite::FillMethod' has a wrong offset!");
static_assert(offsetof(UUISprite, fillOrigin) == 0x00057A, "Member 'UUISprite::fillOrigin' has a wrong offset!");
static_assert(offsetof(UUISprite, fillDirectionFlip) == 0x00057B, "Member 'UUISprite::fillDirectionFlip' has a wrong offset!");
static_assert(offsetof(UUISprite, fillAmount) == 0x00057C, "Member 'UUISprite::fillAmount' has a wrong offset!");

// Class LGUI.UISpriteActor
// 0x0008 (0x0298 - 0x0290)
class AUISpriteActor final : public AUIBaseRenderableActor
{
public:
	class UUISprite*                              UISprite;                                          // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UUISprite* GetUISprite() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISpriteActor">();
	}
	static class AUISpriteActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUISpriteActor>();
	}
};
static_assert(alignof(AUISpriteActor) == 0x000008, "Wrong alignment on AUISpriteActor");
static_assert(sizeof(AUISpriteActor) == 0x000298, "Wrong size on AUISpriteActor");
static_assert(offsetof(AUISpriteActor, UISprite) == 0x000290, "Member 'AUISpriteActor::UISprite' has a wrong offset!");

// Class LGUI.UISpriteSequencePlayer
// 0x0020 (0x00E8 - 0x00C8)
class UUISpriteSequencePlayer final : public ULGUIImageSequencePlayer
{
public:
	TWeakObjectPtr<class UUISpriteBase>           Sprite;                                            // 0x00C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ULGUISpriteData_BaseObject*>     spriteSequence;                                    // 0x00D0(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          snapSpriteSize;                                    // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSnapSpriteSize(bool Value);
	void SetSpriteSequence(const TArray<class ULGUISpriteData_BaseObject*>& Value);

	bool GetSnapSpriteSize() const;
	const TArray<class ULGUISpriteData_BaseObject*> GetSpriteSequence() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISpriteSequencePlayer">();
	}
	static class UUISpriteSequencePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISpriteSequencePlayer>();
	}
};
static_assert(alignof(UUISpriteSequencePlayer) == 0x000008, "Wrong alignment on UUISpriteSequencePlayer");
static_assert(sizeof(UUISpriteSequencePlayer) == 0x0000E8, "Wrong size on UUISpriteSequencePlayer");
static_assert(offsetof(UUISpriteSequencePlayer, Sprite) == 0x0000C8, "Member 'UUISpriteSequencePlayer::Sprite' has a wrong offset!");
static_assert(offsetof(UUISpriteSequencePlayer, spriteSequence) == 0x0000D0, "Member 'UUISpriteSequencePlayer::spriteSequence' has a wrong offset!");
static_assert(offsetof(UUISpriteSequencePlayer, snapSpriteSize) == 0x0000E0, "Member 'UUISpriteSequencePlayer::snapSpriteSize' has a wrong offset!");

// Class LGUI.UISpriteSheetTexturePlayer
// 0x0018 (0x00E0 - 0x00C8)
class UUISpriteSheetTexturePlayer final : public ULGUIImageSequencePlayer
{
public:
	TWeakObjectPtr<class UUITexture>              Texture;                                           // 0x00C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         widthCount;                                        // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         heightCount;                                       // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHeightCount(int32 Value);
	void SetWidthCount(int32 Value);

	int32 GetHeightCount() const;
	int32 GetWidthCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISpriteSheetTexturePlayer">();
	}
	static class UUISpriteSheetTexturePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISpriteSheetTexturePlayer>();
	}
};
static_assert(alignof(UUISpriteSheetTexturePlayer) == 0x000008, "Wrong alignment on UUISpriteSheetTexturePlayer");
static_assert(sizeof(UUISpriteSheetTexturePlayer) == 0x0000E0, "Wrong size on UUISpriteSheetTexturePlayer");
static_assert(offsetof(UUISpriteSheetTexturePlayer, Texture) == 0x0000C8, "Member 'UUISpriteSheetTexturePlayer::Texture' has a wrong offset!");
static_assert(offsetof(UUISpriteSheetTexturePlayer, widthCount) == 0x0000D0, "Member 'UUISpriteSheetTexturePlayer::widthCount' has a wrong offset!");
static_assert(offsetof(UUISpriteSheetTexturePlayer, heightCount) == 0x0000D4, "Member 'UUISpriteSheetTexturePlayer::heightCount' has a wrong offset!");

// Class LGUI.LGUIStaticMeshCacheData
// 0x0028 (0x0050 - 0x0028)
class ULGUIStaticMeshCacheData final : public UObject
{
public:
	TArray<struct FLGUIStaticMeshVertex>          VertexData;                                        // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<uint32>                                IndexData;                                         // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     Material;                                          // 0x0048(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIStaticMeshCacheData">();
	}
	static class ULGUIStaticMeshCacheData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIStaticMeshCacheData>();
	}
};
static_assert(alignof(ULGUIStaticMeshCacheData) == 0x000008, "Wrong alignment on ULGUIStaticMeshCacheData");
static_assert(sizeof(ULGUIStaticMeshCacheData) == 0x000050, "Wrong size on ULGUIStaticMeshCacheData");
static_assert(offsetof(ULGUIStaticMeshCacheData, VertexData) == 0x000028, "Member 'ULGUIStaticMeshCacheData::VertexData' has a wrong offset!");
static_assert(offsetof(ULGUIStaticMeshCacheData, IndexData) == 0x000038, "Member 'ULGUIStaticMeshCacheData::IndexData' has a wrong offset!");
static_assert(offsetof(ULGUIStaticMeshCacheData, Material) == 0x000048, "Member 'ULGUIStaticMeshCacheData::Material' has a wrong offset!");

// Class LGUI.UIStaticMesh
// 0x0020 (0x0470 - 0x0450)
class UUIStaticMesh final : public UUIDirectMeshRenderable
{
public:
	class ULGUIStaticMeshCacheData*               meshCache;                                         // 0x0450(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIStaticMeshVertexColorType                  vertexColorType;                                   // 0x0458(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_459[0x7];                                      // 0x0459(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     ReplaceMaterial;                                   // 0x0460(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_468[0x8];                                      // 0x0468(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UMaterialInstanceDynamic* GetOrCreateDynamicMaterialInstance();
	void SetMesh(class ULGUIStaticMeshCacheData* Value);
	void SetReplaceMaterial(class UMaterialInterface* Value);
	void SetVertexColorType(EUIStaticMeshVertexColorType Value);

	class ULGUIStaticMeshCacheData* GetMeshCache() const;
	class UMaterialInterface* GetRenderMaterial() const;
	class UMaterialInterface* GetReplaceMaterial() const;
	EUIStaticMeshVertexColorType GetVertexColorType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStaticMesh">();
	}
	static class UUIStaticMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStaticMesh>();
	}
};
static_assert(alignof(UUIStaticMesh) == 0x000010, "Wrong alignment on UUIStaticMesh");
static_assert(sizeof(UUIStaticMesh) == 0x000470, "Wrong size on UUIStaticMesh");
static_assert(offsetof(UUIStaticMesh, meshCache) == 0x000450, "Member 'UUIStaticMesh::meshCache' has a wrong offset!");
static_assert(offsetof(UUIStaticMesh, vertexColorType) == 0x000458, "Member 'UUIStaticMesh::vertexColorType' has a wrong offset!");
static_assert(offsetof(UUIStaticMesh, ReplaceMaterial) == 0x000460, "Member 'UUIStaticMesh::ReplaceMaterial' has a wrong offset!");

// Class LGUI.UIStaticMeshActor
// 0x0008 (0x0298 - 0x0290)
class AUIStaticMeshActor final : public AUIBaseRenderableActor
{
public:
	class UUIStaticMesh*                          UIStaticMesh;                                      // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UUIStaticMesh* GetUIStaticMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStaticMeshActor">();
	}
	static class AUIStaticMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIStaticMeshActor>();
	}
};
static_assert(alignof(AUIStaticMeshActor) == 0x000008, "Wrong alignment on AUIStaticMeshActor");
static_assert(sizeof(AUIStaticMeshActor) == 0x000298, "Wrong size on AUIStaticMeshActor");
static_assert(offsetof(AUIStaticMeshActor, UIStaticMesh) == 0x000290, "Member 'AUIStaticMeshActor::UIStaticMesh' has a wrong offset!");

// Class LGUI.UIText
// 0x0170 (0x06D0 - 0x0560)
class UUIText final : public UUIBatchMeshRenderable
{
public:
	uint8                                         Pad_560[0x20];                                     // 0x0560(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class ULGUIFontData_BaseObject*               Font;                                              // 0x0580(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   Text;                                              // 0x0588(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         Size;                                              // 0x0598(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          useKerning;                                        // 0x059C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59D[0x3];                                      // 0x059D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Space;                                             // 0x05A0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUITextParagraphHorizontalAlign               HAlign;                                            // 0x05B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUITextParagraphVerticalAlign                 VAlign;                                            // 0x05B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUITextOverflowType                           overflowType;                                      // 0x05B2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          adjustWidth;                                       // 0x05B3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B4[0x4];                                      // 0x05B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              adjustWidthRange;                                  // 0x05B8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          adjustHeight;                                      // 0x05C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C9[0x7];                                      // 0x05C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              adjustHeightRange;                                 // 0x05D0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         maxHorizontalWidth;                                // 0x05E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUITextFontStyle                              fontStyle;                                         // 0x05E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          richText;                                          // 0x05E5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E6[0x2];                                      // 0x05E6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         richTextTagFilterFlags;                            // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5EC[0x4];                                      // 0x05EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULGUIRichTextCustomStyleData*           richTextCustomStyleData;                           // 0x05F0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULGUIRichTextImageData_BaseObject*      richTextImageData;                                 // 0x05F8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIItem*>                        createdRichTextImageObjectArray;                   // 0x0600(0x0010)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, ContainsInstancedReference, AdvancedDisplay, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_610[0xC0];                                     // 0x0610(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector2D GetRealSize();
	void SetAdjustHeight(bool newAdjustHeight);
	void SetAdjustWidth(bool newAdjustWidth);
	void SetFont(class ULGUIFontData_BaseObject* newFont);
	void SetFontSize(float NewSize);
	void SetFontSpace(const struct FVector2D& NewSpace);
	void SetFontStyle(EUITextFontStyle newFontStyle);
	void SetMaxHorizontalWidth(float Value);
	void SetOverflowType(EUITextOverflowType newOverflowType);
	void SetParagraphHorizontalAlignment(EUITextParagraphHorizontalAlign newHAlign);
	void SetParagraphVerticalAlignment(EUITextParagraphVerticalAlign newVAlign);
	void SetRichText(bool newRichText);
	void SetRichTextCustomStyleData(class ULGUIRichTextCustomStyleData* Value);
	void SetRichTextImageData(class ULGUIRichTextImageData_BaseObject* Value);
	void SetRichTextTagFilterFlags(int32 Value);
	void SetText(const class FText& newText);
	void SetUseKerning(bool Value);

	bool GetAdjustHeight() const;
	struct FVector2D GetAdjustHeightRange() const;
	bool GetAdjustWidth() const;
	struct FVector2D GetAdjustWidthRange() const;
	const TArray<struct FUITextCharProperty> GetCharPropertyArray() const;
	class ULGUIFontData_BaseObject* GetFont() const;
	float GetFontSize() const;
	struct FVector2D GetFontSpace() const;
	EUITextFontStyle GetFontStyle() const;
	float GetMaxHorizontalWidth() const;
	EUITextOverflowType GetOverflowType() const;
	EUITextParagraphHorizontalAlign GetParagraphHorizontalAlignment() const;
	EUITextParagraphVerticalAlign GetParagraphVerticalAlignment() const;
	bool GetRichText() const;
	class ULGUIRichTextCustomStyleData* GetRichTextCustomStyleData() const;
	const TArray<struct FUIText_RichTextCustomTag> GetRichTextCustomTagArray() const;
	class ULGUIRichTextImageData_BaseObject* GetRichTextImageData() const;
	const TArray<struct FUIText_RichTextImageTag> GetRichTextImageTagArray() const;
	int32 GetRichTextTagFilterFlags() const;
	float GetSize() const;
	const class FText GetText() const;
	struct FVector2D GetTextRealSize() const;
	bool GetUseKerning() const;
	int32 GetVisibleCharCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIText">();
	}
	static class UUIText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIText>();
	}
};
static_assert(alignof(UUIText) == 0x000010, "Wrong alignment on UUIText");
static_assert(sizeof(UUIText) == 0x0006D0, "Wrong size on UUIText");
static_assert(offsetof(UUIText, Font) == 0x000580, "Member 'UUIText::Font' has a wrong offset!");
static_assert(offsetof(UUIText, Text) == 0x000588, "Member 'UUIText::Text' has a wrong offset!");
static_assert(offsetof(UUIText, Size) == 0x000598, "Member 'UUIText::Size' has a wrong offset!");
static_assert(offsetof(UUIText, useKerning) == 0x00059C, "Member 'UUIText::useKerning' has a wrong offset!");
static_assert(offsetof(UUIText, Space) == 0x0005A0, "Member 'UUIText::Space' has a wrong offset!");
static_assert(offsetof(UUIText, HAlign) == 0x0005B0, "Member 'UUIText::HAlign' has a wrong offset!");
static_assert(offsetof(UUIText, VAlign) == 0x0005B1, "Member 'UUIText::VAlign' has a wrong offset!");
static_assert(offsetof(UUIText, overflowType) == 0x0005B2, "Member 'UUIText::overflowType' has a wrong offset!");
static_assert(offsetof(UUIText, adjustWidth) == 0x0005B3, "Member 'UUIText::adjustWidth' has a wrong offset!");
static_assert(offsetof(UUIText, adjustWidthRange) == 0x0005B8, "Member 'UUIText::adjustWidthRange' has a wrong offset!");
static_assert(offsetof(UUIText, adjustHeight) == 0x0005C8, "Member 'UUIText::adjustHeight' has a wrong offset!");
static_assert(offsetof(UUIText, adjustHeightRange) == 0x0005D0, "Member 'UUIText::adjustHeightRange' has a wrong offset!");
static_assert(offsetof(UUIText, maxHorizontalWidth) == 0x0005E0, "Member 'UUIText::maxHorizontalWidth' has a wrong offset!");
static_assert(offsetof(UUIText, fontStyle) == 0x0005E4, "Member 'UUIText::fontStyle' has a wrong offset!");
static_assert(offsetof(UUIText, richText) == 0x0005E5, "Member 'UUIText::richText' has a wrong offset!");
static_assert(offsetof(UUIText, richTextTagFilterFlags) == 0x0005E8, "Member 'UUIText::richTextTagFilterFlags' has a wrong offset!");
static_assert(offsetof(UUIText, richTextCustomStyleData) == 0x0005F0, "Member 'UUIText::richTextCustomStyleData' has a wrong offset!");
static_assert(offsetof(UUIText, richTextImageData) == 0x0005F8, "Member 'UUIText::richTextImageData' has a wrong offset!");
static_assert(offsetof(UUIText, createdRichTextImageObjectArray) == 0x000600, "Member 'UUIText::createdRichTextImageObjectArray' has a wrong offset!");

// Class LGUI.UITextActor
// 0x0008 (0x0298 - 0x0290)
class AUITextActor final : public AUIBaseRenderableActor
{
public:
	class UUIText*                                UIText;                                            // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UUIText* GetUIText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITextActor">();
	}
	static class AUITextActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUITextActor>();
	}
};
static_assert(alignof(AUITextActor) == 0x000008, "Wrong alignment on AUITextActor");
static_assert(sizeof(AUITextActor) == 0x000298, "Wrong size on AUITextActor");
static_assert(offsetof(AUITextActor, UIText) == 0x000290, "Member 'AUITextActor::UIText' has a wrong offset!");

// Class LGUI.UITextInputCustomValidation
// 0x0008 (0x0030 - 0x0028)
class UUITextInputCustomValidation final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ReceiveOnValidateInput(class UUITextInputComponent* InTextInput, const class FString& InString, int32 InIndexOfInsertedChar);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITextInputCustomValidation">();
	}
	static class UUITextInputCustomValidation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITextInputCustomValidation>();
	}
};
static_assert(alignof(UUITextInputCustomValidation) == 0x000008, "Wrong alignment on UUITextInputCustomValidation");
static_assert(sizeof(UUITextInputCustomValidation) == 0x000030, "Wrong size on UUITextInputCustomValidation");

// Class LGUI.UITextInputComponent
// 0x0230 (0x0478 - 0x0248)
class UUITextInputComponent final : public UUISelectableComponent
{
public:
	uint8                                         Pad_248[0x10];                                     // 0x0248(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AUITextActor>            TextActor;                                         // 0x0258(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 Text;                                              // 0x0260(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELGUITextInputType                            InputType;                                         // 0x0270(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUITextInputCustomValidation*           CustomValidation;                                  // 0x0278(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELGUITextInputDisplayType                     DisplayType;                                       // 0x0280(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_281[0x7];                                      // 0x0281(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PasswordChar;                                      // 0x0288(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowMultiLine;                                   // 0x0298(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELGUITextInputOverflowType                    overflowType;                                      // 0x0299(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29A[0x2];                                      // 0x029A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxLineCount;                                      // 0x029C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxLineWidth;                                      // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKey>                           MultiLineSubmitFunctionKeys;                       // 0x02A8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AUIBaseActor>            PlaceHolderActor;                                  // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CaretBlinkRate;                                    // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CaretWidth;                                        // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 CaretColor;                                        // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 SelectionColor;                                    // 0x02CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVirtualKeyboardOptions                VirtualKeyboradOptions;                            // 0x02D0(0x0001)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D1[0x7];                                      // 0x02D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKey>                           IgnoreKeys;                                        // 0x02D8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bAutoActivateInputWhenNavigateIn;                  // 0x02E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSelectAllWhenActivateInput;                       // 0x02E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReadOnly;                                         // 0x02EA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EB[0x1D];                                     // 0x02EB(0x001D)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIEventDelegate                     OnValueChange;                                     // 0x0308(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_320[0x18];                                     // 0x0320(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIEventDelegate                     OnSubmit;                                          // 0x0338(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0x18];                                     // 0x0350(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIEventDelegate                     OnInputActivate;                                   // 0x0368(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_380[0x70];                                     // 0x0380(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      PlayerController;                                  // 0x03F0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F8[0xC];                                      // 0x03F8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UUISprite>               CaretObject;                                       // 0x0404(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40C[0x4];                                      // 0x040C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UUISprite>>       SelectionMaskObjectArray;                          // 0x0410(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_420[0x58];                                     // 0x0420(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateInput(class ULGUIPointerEventData* EventData);
	void ClearCustomInputTypeFunction();
	void DeactivateInput(bool InFireEvent);
	struct FLGUIDelegateHandleWrapper RegisterInputActivateEvent(const TDelegate<void(bool InActivate)>& InDelegate);
	struct FLGUIDelegateHandleWrapper RegisterSubmitEvent(const TDelegate<void(const class FString& InString)>& InDelegate);
	struct FLGUIDelegateHandleWrapper RegisterValueChangeEvent(const TDelegate<void(const class FString& InString)>& InDelegate);
	void SetAllowMultiLine(bool Value);
	void SetAutoActivateInputWhenNavigateIn(bool Value);
	void SetCaretBlinkRate(float Value);
	void SetCaretColor(const struct FColor& Value);
	void SetCaretWidth(float Value);
	void SetCustomInputTypeFunction(const TDelegate<void(const class FString& InString, int32 InStartIndex)>& InFunction);
	void SetCustomValidation(class UUITextInputCustomValidation* Value);
	void SetDisplayType(ELGUITextInputDisplayType NewValue);
	void SetIgnoreKeys(const TArray<struct FKey>& Value);
	void SetInputType(ELGUITextInputType NewValue);
	void SetMultiLineSubmitFunctionKeys(const TArray<struct FKey>& Value);
	void SetPasswordChar(const class FString& Value);
	void SetPlaceHolderActor(class AUIBaseActor* Value);
	void SetReadOnly(bool Value);
	void SetSelectionColor(const struct FColor& Value);
	bool SetText(const class FString& InText, bool InFireEvent);
	void SetVirtualKeyboradOptions(const struct FVirtualKeyboardOptions& Value);
	void UnregisterInputActivateEvent(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	void UnregisterSubmitEvent(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	void UnregisterValueChangeEvent(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	bool VerifyAndInsertStringAtCaretPosition(const class FString& Value);

	bool GetAllowMultiLine() const;
	bool GetAutoActivateInputWhenNavigateIn() const;
	float GetCaretBlinkRate() const;
	struct FColor GetCaretColor() const;
	float GetCaretWidth() const;
	class UUITextInputCustomValidation* GetCustomValidation() const;
	ELGUITextInputDisplayType GetDisplayType() const;
	const TArray<struct FKey> GetIgnoreKeys() const;
	ELGUITextInputType GetInputType() const;
	const TArray<struct FKey> GetMultiLineSubmitFunctionKeys() const;
	class FString GetPasswordChar() const;
	class AUIBaseActor* GetPlaceHolderActor() const;
	bool GetReadOnly() const;
	struct FColor GetSelectionColor() const;
	class FString GetText() const;
	class UUIText* GetTextComponent() const;
	struct FVirtualKeyboardOptions GetVirtualKeyboradOptions() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITextInputComponent">();
	}
	static class UUITextInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITextInputComponent>();
	}
};
static_assert(alignof(UUITextInputComponent) == 0x000008, "Wrong alignment on UUITextInputComponent");
static_assert(sizeof(UUITextInputComponent) == 0x000478, "Wrong size on UUITextInputComponent");
static_assert(offsetof(UUITextInputComponent, TextActor) == 0x000258, "Member 'UUITextInputComponent::TextActor' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, Text) == 0x000260, "Member 'UUITextInputComponent::Text' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, InputType) == 0x000270, "Member 'UUITextInputComponent::InputType' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, CustomValidation) == 0x000278, "Member 'UUITextInputComponent::CustomValidation' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, DisplayType) == 0x000280, "Member 'UUITextInputComponent::DisplayType' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, PasswordChar) == 0x000288, "Member 'UUITextInputComponent::PasswordChar' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, bAllowMultiLine) == 0x000298, "Member 'UUITextInputComponent::bAllowMultiLine' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, overflowType) == 0x000299, "Member 'UUITextInputComponent::overflowType' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, MaxLineCount) == 0x00029C, "Member 'UUITextInputComponent::MaxLineCount' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, MaxLineWidth) == 0x0002A0, "Member 'UUITextInputComponent::MaxLineWidth' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, MultiLineSubmitFunctionKeys) == 0x0002A8, "Member 'UUITextInputComponent::MultiLineSubmitFunctionKeys' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, PlaceHolderActor) == 0x0002B8, "Member 'UUITextInputComponent::PlaceHolderActor' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, CaretBlinkRate) == 0x0002C0, "Member 'UUITextInputComponent::CaretBlinkRate' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, CaretWidth) == 0x0002C4, "Member 'UUITextInputComponent::CaretWidth' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, CaretColor) == 0x0002C8, "Member 'UUITextInputComponent::CaretColor' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, SelectionColor) == 0x0002CC, "Member 'UUITextInputComponent::SelectionColor' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, VirtualKeyboradOptions) == 0x0002D0, "Member 'UUITextInputComponent::VirtualKeyboradOptions' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, IgnoreKeys) == 0x0002D8, "Member 'UUITextInputComponent::IgnoreKeys' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, bAutoActivateInputWhenNavigateIn) == 0x0002E8, "Member 'UUITextInputComponent::bAutoActivateInputWhenNavigateIn' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, bSelectAllWhenActivateInput) == 0x0002E9, "Member 'UUITextInputComponent::bSelectAllWhenActivateInput' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, bReadOnly) == 0x0002EA, "Member 'UUITextInputComponent::bReadOnly' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, OnValueChange) == 0x000308, "Member 'UUITextInputComponent::OnValueChange' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, OnSubmit) == 0x000338, "Member 'UUITextInputComponent::OnSubmit' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, OnInputActivate) == 0x000368, "Member 'UUITextInputComponent::OnInputActivate' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, PlayerController) == 0x0003F0, "Member 'UUITextInputComponent::PlayerController' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, CaretObject) == 0x000404, "Member 'UUITextInputComponent::CaretObject' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, SelectionMaskObjectArray) == 0x000410, "Member 'UUITextInputComponent::SelectionMaskObjectArray' has a wrong offset!");

// Class LGUI.UITextureBase
// 0x0010 (0x0570 - 0x0560)
#pragma pack(push, 0x1)
class alignas(0x10) UUITextureBase : public UUIBatchMeshRenderable
{
public:
	class UTexture*                               Texture;                                           // 0x0560(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UTexture* GetDefaultWhiteTexture();

	void SetSizeFromTexture();
	void SetTexture(class UTexture* newTexture);

	class UTexture* GetTexture() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITextureBase">();
	}
	static class UUITextureBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITextureBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(UUITextureBase) == 0x000010, "Wrong alignment on UUITextureBase");
static_assert(sizeof(UUITextureBase) == 0x000570, "Wrong size on UUITextureBase");
static_assert(offsetof(UUITextureBase, Texture) == 0x000560, "Member 'UUITextureBase::Texture' has a wrong offset!");

// Class LGUI.UITexture
// 0x0070 (0x05E0 - 0x0570)
class UUITexture final : public UUITextureBase
{
public:
	EUITextureType                                Type;                                              // 0x0568(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_569[0x3];                                      // 0x0569(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUISpriteInfo                        spriteData;                                        // 0x056C(0x0034)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EUITextureUVRectControlMode                   UVRectControlMode;                                 // 0x05A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A1[0xF];                                      // 0x05A1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               UVRect;                                            // 0x05B0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUISpriteFillMethod                           FillMethod;                                        // 0x05D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         fillOrigin;                                        // 0x05D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          fillDirectionFlip;                                 // 0x05D2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D3[0x1];                                      // 0x05D3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         fillAmount;                                        // 0x05D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D8[0x8];                                      // 0x05D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFillAmount(float NewValue);
	void SetFillDirectionFlip(bool NewValue);
	void SetFillMethod(EUISpriteFillMethod NewValue);
	void SetFillOrigin(uint8 NewValue);
	void SetSpriteData(const struct FLGUISpriteInfo& newSpriteData);
	void SetTextureType(EUITextureType NewType);
	void SetUVRect(const struct FVector4& newUVRect);
	void SetUVRectControlMode(EUITextureUVRectControlMode NewValue);

	float GetFillAmount() const;
	bool GetFillDirectionFlip() const;
	EUISpriteFillMethod GetFillMethod() const;
	uint8 GetFillOrigin() const;
	struct FLGUISpriteInfo GetSpriteData() const;
	EUITextureType GetTextureType() const;
	struct FVector4 GetUVRect() const;
	EUITextureUVRectControlMode GetUVRectControlMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITexture">();
	}
	static class UUITexture* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITexture>();
	}
};
static_assert(alignof(UUITexture) == 0x000010, "Wrong alignment on UUITexture");
static_assert(sizeof(UUITexture) == 0x0005E0, "Wrong size on UUITexture");
static_assert(offsetof(UUITexture, Type) == 0x000568, "Member 'UUITexture::Type' has a wrong offset!");
static_assert(offsetof(UUITexture, spriteData) == 0x00056C, "Member 'UUITexture::spriteData' has a wrong offset!");
static_assert(offsetof(UUITexture, UVRectControlMode) == 0x0005A0, "Member 'UUITexture::UVRectControlMode' has a wrong offset!");
static_assert(offsetof(UUITexture, UVRect) == 0x0005B0, "Member 'UUITexture::UVRect' has a wrong offset!");
static_assert(offsetof(UUITexture, FillMethod) == 0x0005D0, "Member 'UUITexture::FillMethod' has a wrong offset!");
static_assert(offsetof(UUITexture, fillOrigin) == 0x0005D1, "Member 'UUITexture::fillOrigin' has a wrong offset!");
static_assert(offsetof(UUITexture, fillDirectionFlip) == 0x0005D2, "Member 'UUITexture::fillDirectionFlip' has a wrong offset!");
static_assert(offsetof(UUITexture, fillAmount) == 0x0005D4, "Member 'UUITexture::fillAmount' has a wrong offset!");

// Class LGUI.UITextureActor
// 0x0008 (0x0298 - 0x0290)
class AUITextureActor final : public AUIBaseRenderableActor
{
public:
	class UUITexture*                             UITexture;                                         // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UUITexture* GetUITexture() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITextureActor">();
	}
	static class AUITextureActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUITextureActor>();
	}
};
static_assert(alignof(AUITextureActor) == 0x000008, "Wrong alignment on AUITextureActor");
static_assert(sizeof(AUITextureActor) == 0x000298, "Wrong size on AUITextureActor");
static_assert(offsetof(AUITextureActor, UITexture) == 0x000290, "Member 'AUITextureActor::UITexture' has a wrong offset!");

// Class LGUI.UIToggleComponent
// 0x0090 (0x02D8 - 0x0248)
class UUIToggleComponent final : public UUISelectableComponent
{
public:
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AUIBaseRenderableActor>  ToggleActor;                                       // 0x0250(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIToggleTransitionType                       ToggleTransition;                                  // 0x0258(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_259[0x3];                                      // 0x0259(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UUISelectableTransitionComponent> ToggleTransitionComp;                     // 0x025C(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_264[0x4];                                      // 0x0264(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULTweener*                              ToggleTransitionTweener;                           // 0x0268(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OnAlpha;                                           // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OffAlpha;                                          // 0x0274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 OnColor;                                           // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 OffColor;                                          // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ToggleDuration;                                    // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   OnTransitionName;                                  // 0x0284(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   OffTransitionName;                                 // 0x028C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsOn;                                              // 0x0294(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_295[0x3];                                      // 0x0295(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  UIToggleGroupActor;                                // 0x0298(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UUIToggleGroupComponent> GroupComp;                                         // 0x02A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A8[0x18];                                     // 0x02A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIEventDelegate                     OnToggle;                                          // 0x02C0(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	struct FLGUIDelegateHandleWrapper RegisterToggleEvent(const TDelegate<void(bool InBool)>& InDelegate);
	void SetToggleGroup(class UUIToggleGroupComponent* InGroupComp);
	void SetValue(bool NewValue, bool fireEvent);
	void UnregisterToggleEvent(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);

	int32 GetIndexInGroup() const;
	class AActor* GetToggleGroupActor() const;
	bool GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIToggleComponent">();
	}
	static class UUIToggleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIToggleComponent>();
	}
};
static_assert(alignof(UUIToggleComponent) == 0x000008, "Wrong alignment on UUIToggleComponent");
static_assert(sizeof(UUIToggleComponent) == 0x0002D8, "Wrong size on UUIToggleComponent");
static_assert(offsetof(UUIToggleComponent, ToggleActor) == 0x000250, "Member 'UUIToggleComponent::ToggleActor' has a wrong offset!");
static_assert(offsetof(UUIToggleComponent, ToggleTransition) == 0x000258, "Member 'UUIToggleComponent::ToggleTransition' has a wrong offset!");
static_assert(offsetof(UUIToggleComponent, ToggleTransitionComp) == 0x00025C, "Member 'UUIToggleComponent::ToggleTransitionComp' has a wrong offset!");
static_assert(offsetof(UUIToggleComponent, ToggleTransitionTweener) == 0x000268, "Member 'UUIToggleComponent::ToggleTransitionTweener' has a wrong offset!");
static_assert(offsetof(UUIToggleComponent, OnAlpha) == 0x000270, "Member 'UUIToggleComponent::OnAlpha' has a wrong offset!");
static_assert(offsetof(UUIToggleComponent, OffAlpha) == 0x000274, "Member 'UUIToggleComponent::OffAlpha' has a wrong offset!");
static_assert(offsetof(UUIToggleComponent, OnColor) == 0x000278, "Member 'UUIToggleComponent::OnColor' has a wrong offset!");
static_assert(offsetof(UUIToggleComponent, OffColor) == 0x00027C, "Member 'UUIToggleComponent::OffColor' has a wrong offset!");
static_assert(offsetof(UUIToggleComponent, ToggleDuration) == 0x000280, "Member 'UUIToggleComponent::ToggleDuration' has a wrong offset!");
static_assert(offsetof(UUIToggleComponent, OnTransitionName) == 0x000284, "Member 'UUIToggleComponent::OnTransitionName' has a wrong offset!");
static_assert(offsetof(UUIToggleComponent, OffTransitionName) == 0x00028C, "Member 'UUIToggleComponent::OffTransitionName' has a wrong offset!");
static_assert(offsetof(UUIToggleComponent, IsOn) == 0x000294, "Member 'UUIToggleComponent::IsOn' has a wrong offset!");
static_assert(offsetof(UUIToggleComponent, UIToggleGroupActor) == 0x000298, "Member 'UUIToggleComponent::UIToggleGroupActor' has a wrong offset!");
static_assert(offsetof(UUIToggleComponent, GroupComp) == 0x0002A0, "Member 'UUIToggleComponent::GroupComp' has a wrong offset!");
static_assert(offsetof(UUIToggleComponent, OnToggle) == 0x0002C0, "Member 'UUIToggleComponent::OnToggle' has a wrong offset!");

// Class LGUI.UIToggleGroupComponent
// 0x0050 (0x0130 - 0x00E0)
class UUIToggleGroupComponent final : public ULGUILifeCycleUIBehaviour
{
public:
	TWeakObjectPtr<class UUIToggleComponent>      LastSelect;                                        // 0x00E0(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class UUIToggleComponent>> ToggleCollection;                               // 0x00E8(0x0010)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, ContainsInstancedReference, AdvancedDisplay, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x1];                                       // 0x00F8(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAllowNoneSelected;                                // 0x00F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FA[0x1E];                                      // 0x00FA(0x001E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIEventDelegate                     OnToggle;                                          // 0x0118(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	void ClearSelection();
	struct FLGUIDelegateHandleWrapper RegisterToggleEvent(const TDelegate<void(int32 Index)>& InDelegate);
	void SetAllowNoneSelected(bool InBool);
	void SetSelection(class UUIToggleComponent* Target);
	void UnregisterToggleEvent(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);

	bool GetAllowNoneSelected() const;
	class UUIToggleComponent* GetSelectedItem() const;
	class UUIToggleComponent* GetToggleByIndex(int32 InIndex) const;
	int32 GetToggleIndex(const class UUIToggleComponent* InComp) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIToggleGroupComponent">();
	}
	static class UUIToggleGroupComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIToggleGroupComponent>();
	}
};
static_assert(alignof(UUIToggleGroupComponent) == 0x000008, "Wrong alignment on UUIToggleGroupComponent");
static_assert(sizeof(UUIToggleGroupComponent) == 0x000130, "Wrong size on UUIToggleGroupComponent");
static_assert(offsetof(UUIToggleGroupComponent, LastSelect) == 0x0000E0, "Member 'UUIToggleGroupComponent::LastSelect' has a wrong offset!");
static_assert(offsetof(UUIToggleGroupComponent, ToggleCollection) == 0x0000E8, "Member 'UUIToggleGroupComponent::ToggleCollection' has a wrong offset!");
static_assert(offsetof(UUIToggleGroupComponent, bAllowNoneSelected) == 0x0000F9, "Member 'UUIToggleGroupComponent::bAllowNoneSelected' has a wrong offset!");
static_assert(offsetof(UUIToggleGroupComponent, OnToggle) == 0x000118, "Member 'UUIToggleGroupComponent::OnToggle' has a wrong offset!");

// Class LGUI.UIVerticalLayout
// 0x0038 (0x0168 - 0x0130)
class UUIVerticalLayout final : public UUILayoutWithChildren
{
public:
	struct FMargin                                Padding;                                           // 0x0130(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         Spacing;                                           // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELGUILayoutAlignmentType                      Align;                                             // 0x0144(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ControlChildWidth;                                 // 0x0145(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ControlChildHeight;                                // 0x0146(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ExpandChildWidthArea;                              // 0x0147(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ExpandChildHeightArea;                             // 0x0148(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          HeightFitToChildren;                               // 0x0149(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          WidthFitToChildren;                                // 0x014A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14B[0x1];                                      // 0x014B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WidthFitToChildrenFromMinToMax;                    // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseChildScaleOnHeight;                             // 0x0150(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_151[0x17];                                     // 0x0151(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAlign(ELGUILayoutAlignmentType Value);
	void SetControlChildHeight(bool Value);
	void SetControlChildWidth(bool Value);
	void SetExpandChildHeightArea(bool Value);
	void SetExpandChildWidthArea(bool Value);
	void SetExpendChildrenHeight(bool Value);
	void SetExpendChildrenWidth(bool Value);
	void SetHeightFitToChildren(bool Value);
	void SetPadding(const struct FMargin& Value);
	void SetSpacing(float Value);
	void SetUseChildScaleOnHeight(bool Value);
	void SetWidthFitToChildren(bool Value);
	void SetWidthFitToChildrenFromMinToMax(float Value);

	float GetActuralRange() const;
	ELGUILayoutAlignmentType GetAlign() const;
	bool GetControlChildHeight() const;
	bool GetControlChildWidth() const;
	bool GetExpandChildHeightArea() const;
	bool GetExpandChildWidthArea() const;
	bool GetExpendChildrenHeight() const;
	bool GetExpendChildrenWidth() const;
	bool GetHeightFitToChildren() const;
	struct FMargin GetPadding() const;
	float GetSpacing() const;
	bool GetUseChildScaleOnHeight() const;
	bool GetWidthFitToChildren() const;
	float GetWidthFitToChildrenFromMinToMax() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVerticalLayout">();
	}
	static class UUIVerticalLayout* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVerticalLayout>();
	}
};
static_assert(alignof(UUIVerticalLayout) == 0x000008, "Wrong alignment on UUIVerticalLayout");
static_assert(sizeof(UUIVerticalLayout) == 0x000168, "Wrong size on UUIVerticalLayout");
static_assert(offsetof(UUIVerticalLayout, Padding) == 0x000130, "Member 'UUIVerticalLayout::Padding' has a wrong offset!");
static_assert(offsetof(UUIVerticalLayout, Spacing) == 0x000140, "Member 'UUIVerticalLayout::Spacing' has a wrong offset!");
static_assert(offsetof(UUIVerticalLayout, Align) == 0x000144, "Member 'UUIVerticalLayout::Align' has a wrong offset!");
static_assert(offsetof(UUIVerticalLayout, ControlChildWidth) == 0x000145, "Member 'UUIVerticalLayout::ControlChildWidth' has a wrong offset!");
static_assert(offsetof(UUIVerticalLayout, ControlChildHeight) == 0x000146, "Member 'UUIVerticalLayout::ControlChildHeight' has a wrong offset!");
static_assert(offsetof(UUIVerticalLayout, ExpandChildWidthArea) == 0x000147, "Member 'UUIVerticalLayout::ExpandChildWidthArea' has a wrong offset!");
static_assert(offsetof(UUIVerticalLayout, ExpandChildHeightArea) == 0x000148, "Member 'UUIVerticalLayout::ExpandChildHeightArea' has a wrong offset!");
static_assert(offsetof(UUIVerticalLayout, HeightFitToChildren) == 0x000149, "Member 'UUIVerticalLayout::HeightFitToChildren' has a wrong offset!");
static_assert(offsetof(UUIVerticalLayout, WidthFitToChildren) == 0x00014A, "Member 'UUIVerticalLayout::WidthFitToChildren' has a wrong offset!");
static_assert(offsetof(UUIVerticalLayout, WidthFitToChildrenFromMinToMax) == 0x00014C, "Member 'UUIVerticalLayout::WidthFitToChildrenFromMinToMax' has a wrong offset!");
static_assert(offsetof(UUIVerticalLayout, UseChildScaleOnHeight) == 0x000150, "Member 'UUIVerticalLayout::UseChildScaleOnHeight' has a wrong offset!");

// Class LGUI.UIWidget
// 0x00B0 (0x0620 - 0x0570)
class UUIWidget final : public UUICustomMesh
{
public:
	EWidgetTimingPolicy                           TimingPolicy;                                      // 0x0570(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_571[0x7];                                      // 0x0571(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                WidgetClass;                                       // 0x0578(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bManuallyRedraw;                                   // 0x0580(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_581[0x3];                                      // 0x0581(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RedrawTime;                                        // 0x0584(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_588[0x8];                                      // 0x0588(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ResolutionScale;                                   // 0x0590(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_594[0x8];                                      // 0x0594(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bWindowFocusable;                                  // 0x059C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EWindowVisibility                             WindowVisibility;                                  // 0x059D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyGammaCorrection;                             // 0x059E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59F[0x1];                                      // 0x059F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           BackgroundColor;                                   // 0x05A0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          TickWhenOffscreen;                                 // 0x05B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B1[0x7];                                      // 0x05B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x05B8(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETickMode                                     TickMode;                                          // 0x05C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C1[0x2F];                                     // 0x05C1(0x002F)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            Widget;                                            // 0x05F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F8[0x28];                                     // 0x05F8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RequestRenderUpdate();
	void SetBackgroundColor(const struct FLinearColor& NewBackgroundColor);
	void SetManuallyRedraw(bool bUseManualRedraw);
	void SetRedrawTime(float InRedrawTime);
	void SetResolutionScale(float Value);
	void SetTickMode(ETickMode InTickMode);
	void SetTickWhenOffscreen(const bool bWantTickWhenOffscreen);
	void SetWidget(class UUserWidget* Widget_0);
	void SetWindowFocusable(bool bInWindowFocusable);
	void SetWindowVisibility(EWindowVisibility InVisibility);

	struct FVector2D GetCurrentDrawSize() const;
	bool GetManuallyRedraw() const;
	float GetRedrawTime() const;
	class UTextureRenderTarget2D* GetRenderTarget() const;
	float GetResolutionScale() const;
	bool GetTickWhenOffscreen() const;
	class UUserWidget* GetUserWidgetObject() const;
	class UUserWidget* GetWidget() const;
	bool GetWindowFocusable() const;
	EWindowVisibility GetWindowVisiblility() const;
	bool IsWidgetVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWidget">();
	}
	static class UUIWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWidget>();
	}
};
static_assert(alignof(UUIWidget) == 0x000010, "Wrong alignment on UUIWidget");
static_assert(sizeof(UUIWidget) == 0x000620, "Wrong size on UUIWidget");
static_assert(offsetof(UUIWidget, TimingPolicy) == 0x000570, "Member 'UUIWidget::TimingPolicy' has a wrong offset!");
static_assert(offsetof(UUIWidget, WidgetClass) == 0x000578, "Member 'UUIWidget::WidgetClass' has a wrong offset!");
static_assert(offsetof(UUIWidget, bManuallyRedraw) == 0x000580, "Member 'UUIWidget::bManuallyRedraw' has a wrong offset!");
static_assert(offsetof(UUIWidget, RedrawTime) == 0x000584, "Member 'UUIWidget::RedrawTime' has a wrong offset!");
static_assert(offsetof(UUIWidget, ResolutionScale) == 0x000590, "Member 'UUIWidget::ResolutionScale' has a wrong offset!");
static_assert(offsetof(UUIWidget, bWindowFocusable) == 0x00059C, "Member 'UUIWidget::bWindowFocusable' has a wrong offset!");
static_assert(offsetof(UUIWidget, WindowVisibility) == 0x00059D, "Member 'UUIWidget::WindowVisibility' has a wrong offset!");
static_assert(offsetof(UUIWidget, bApplyGammaCorrection) == 0x00059E, "Member 'UUIWidget::bApplyGammaCorrection' has a wrong offset!");
static_assert(offsetof(UUIWidget, BackgroundColor) == 0x0005A0, "Member 'UUIWidget::BackgroundColor' has a wrong offset!");
static_assert(offsetof(UUIWidget, TickWhenOffscreen) == 0x0005B0, "Member 'UUIWidget::TickWhenOffscreen' has a wrong offset!");
static_assert(offsetof(UUIWidget, RenderTarget) == 0x0005B8, "Member 'UUIWidget::RenderTarget' has a wrong offset!");
static_assert(offsetof(UUIWidget, TickMode) == 0x0005C0, "Member 'UUIWidget::TickMode' has a wrong offset!");
static_assert(offsetof(UUIWidget, Widget) == 0x0005F0, "Member 'UUIWidget::Widget' has a wrong offset!");

// Class LGUI.UIWidgetActor
// 0x0008 (0x0298 - 0x0290)
class AUIWidgetActor final : public AUIBaseRenderableActor
{
public:
	class UUIWidget*                              UIWidget;                                          // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UUIWidget* GetUIWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWidgetActor">();
	}
	static class AUIWidgetActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIWidgetActor>();
	}
};
static_assert(alignof(AUIWidgetActor) == 0x000008, "Wrong alignment on AUIWidgetActor");
static_assert(sizeof(AUIWidgetActor) == 0x000298, "Wrong size on AUIWidgetActor");
static_assert(offsetof(AUIWidgetActor, UIWidget) == 0x000290, "Member 'AUIWidgetActor::UIWidget' has a wrong offset!");

// Class LGUI.UIWidgetInteractionManager
// 0x0050 (0x0078 - 0x0028)
class UUIWidgetInteractionManager final : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWidgetInteractionManager">();
	}
	static class UUIWidgetInteractionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWidgetInteractionManager>();
	}
};
static_assert(alignof(UUIWidgetInteractionManager) == 0x000008, "Wrong alignment on UUIWidgetInteractionManager");
static_assert(sizeof(UUIWidgetInteractionManager) == 0x000078, "Wrong size on UUIWidgetInteractionManager");

// Class LGUI.UIWidgetInteraction
// 0x01E8 (0x02B0 - 0x00C8)
class UUIWidgetInteraction final : public ULGUILifeCycleBehaviour
{
public:
	uint8                                         Pad_C8[0x18];                                      // 0x00C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAllowEventBubbleUp;                               // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIWidgetInteractionManager*            Helper;                                            // 0x00E8(0x0008)(Edit, ZeroConstructor, Transient, EditConst, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0x18];                                      // 0x00F0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VirtualUserIndex;                                  // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x7C];                                     // 0x010C(0x007C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             CustomHitResult;                                   // 0x0188(0x00F8)(Transient, IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              LocalHitLocation;                                  // 0x0280(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              LastLocalHitLocation;                              // 0x0290(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIWidget*                              WidgetComponent;                                   // 0x02A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsHoveredWidgetInteractable;                      // 0x02A8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsHoveredWidgetFocusable;                         // 0x02A9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsHoveredWidgetHitTestVisible;                    // 0x02AA(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AB[0x5];                                      // 0x02AB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool PressAndReleaseKey(const struct FKey& Key);
	bool PressKey(const struct FKey& Key, bool bRepeat);
	void PressPointerKey(const struct FKey& Key);
	bool ReleaseKey(const struct FKey& Key);
	void ReleasePointerKey(const struct FKey& Key);
	void ScrollWheel(float ScrollDelta);
	bool SendKeyChar(const class FString& Characters, bool bRepeat);
	void SetCustomHitResult(const struct FHitResult& HitResult);
	void SetFocus(class UWidget* FocusWidget);

	struct FVector2D Get2DHitLocation() const;
	bool IsOverFocusableWidget() const;
	bool IsOverHitTestVisibleWidget() const;
	bool IsOverInteractableWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWidgetInteraction">();
	}
	static class UUIWidgetInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWidgetInteraction>();
	}
};
static_assert(alignof(UUIWidgetInteraction) == 0x000008, "Wrong alignment on UUIWidgetInteraction");
static_assert(sizeof(UUIWidgetInteraction) == 0x0002B0, "Wrong size on UUIWidgetInteraction");
static_assert(offsetof(UUIWidgetInteraction, bAllowEventBubbleUp) == 0x0000E0, "Member 'UUIWidgetInteraction::bAllowEventBubbleUp' has a wrong offset!");
static_assert(offsetof(UUIWidgetInteraction, Helper) == 0x0000E8, "Member 'UUIWidgetInteraction::Helper' has a wrong offset!");
static_assert(offsetof(UUIWidgetInteraction, VirtualUserIndex) == 0x000108, "Member 'UUIWidgetInteraction::VirtualUserIndex' has a wrong offset!");
static_assert(offsetof(UUIWidgetInteraction, CustomHitResult) == 0x000188, "Member 'UUIWidgetInteraction::CustomHitResult' has a wrong offset!");
static_assert(offsetof(UUIWidgetInteraction, LocalHitLocation) == 0x000280, "Member 'UUIWidgetInteraction::LocalHitLocation' has a wrong offset!");
static_assert(offsetof(UUIWidgetInteraction, LastLocalHitLocation) == 0x000290, "Member 'UUIWidgetInteraction::LastLocalHitLocation' has a wrong offset!");
static_assert(offsetof(UUIWidgetInteraction, WidgetComponent) == 0x0002A0, "Member 'UUIWidgetInteraction::WidgetComponent' has a wrong offset!");
static_assert(offsetof(UUIWidgetInteraction, bIsHoveredWidgetInteractable) == 0x0002A8, "Member 'UUIWidgetInteraction::bIsHoveredWidgetInteractable' has a wrong offset!");
static_assert(offsetof(UUIWidgetInteraction, bIsHoveredWidgetFocusable) == 0x0002A9, "Member 'UUIWidgetInteraction::bIsHoveredWidgetFocusable' has a wrong offset!");
static_assert(offsetof(UUIWidgetInteraction, bIsHoveredWidgetHitTestVisible) == 0x0002AA, "Member 'UUIWidgetInteraction::bIsHoveredWidgetHitTestVisible' has a wrong offset!");

// Class LGUI.MovieSceneLGUIMaterialSystem
// 0x0168 (0x01A8 - 0x0040)
class UMovieSceneLGUIMaterialSystem final : public UMovieSceneEntitySystem
{
public:
	uint8                                         Pad_40[0x168];                                     // 0x0040(0x0168)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneLGUIMaterialSystem">();
	}
	static class UMovieSceneLGUIMaterialSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneLGUIMaterialSystem>();
	}
};
static_assert(alignof(UMovieSceneLGUIMaterialSystem) == 0x000008, "Wrong alignment on UMovieSceneLGUIMaterialSystem");
static_assert(sizeof(UMovieSceneLGUIMaterialSystem) == 0x0001A8, "Wrong size on UMovieSceneLGUIMaterialSystem");

}

