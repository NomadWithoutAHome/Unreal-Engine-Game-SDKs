#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_MerchantComponent

#include "Basic.hpp"

#include "FBattleStartParams_structs.hpp"
#include "S_MerchantItemSellData_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// BlueprintGeneratedClass BP_MerchantComponent.BP_MerchantComponent_C
// 0x01C0 (0x0260 - 0x00A0)
class UBP_MerchantComponent_C final : public UActorComponent
{
public:
	class UDataTable*                             Items;                                             // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
	TMap<class FName, struct FS_MerchantItemSellData> AvailableItems;                                // 0x00A8(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	struct FFBattleStartParams                    BattleParameters;                                  // 0x00F8(0x0158)(Edit, BlueprintVisible, ContainsInstancedReference, HasGetValueTypeHash)
	TMulticastInlineDelegate<void(const struct FS_MerchantItemSellData& BoughtItemData, class UBP_ItemInstance_Base_C* PreviousInstance)> OnItemBought; // 0x0250(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)

public:
	void AddItemToInventory(const struct FS_MerchantItemSellData& MerchantItem);
	bool CanStartMerchantBattle();
	bool CheckForErrors(TArray<class FText>& ErrorMessages);
	void CheckIfItemIsConditional(const struct FS_MerchantItemData& MerchantItemData, bool* IsConditional);
	void CheckIfItemIsVisible(const struct FS_MerchantItemData& MerchantItemData, bool* IsAvailable);
	void ComputeAvailableItemsFromTable(class UDataTable* Table);
	void ComputeItemPrice(const struct FS_MerchantItemData& MerchantItem, class UBP_ItemInstance_Base_C* ItemInstance, int32* Price);
	void ComputeItemToSell(class UDataTable* ItemsDataTable, class FName ItemRowName, struct FS_MerchantItemSellData* MerchantItemSellData);
	int32 ComputeMerchantItemLevelForLootContext();
	int32 ComputeMerchantItemLevelWithOverride(const struct FS_MerchantItemData& MerchantItemData);
	void ComputeMerchantState(struct FS_MerchantSaveData* MerchantState);
	void ComputePictoPrice(const class UBP_ItemInstance_Base_C*& ItemInstance, int32* Price);
	void ComputeWeaponPrice(const class UBP_ItemInstance_Base_C*& ItemInstance, int32* Price);
	void CreateItemInstance(const struct FS_MerchantItemData& MerchantItem, class UBP_ItemInstance_Base_C** ItemInstance);
	void GetAvailableItems(TMap<class FName, struct FS_MerchantItemSellData>* AvailableItems_0);
	void GetBuyValueFromScalingTable(class UDataTable* Table, int32 Level, int32* Value);
	void GetConditionDisplayName(const struct FS_MerchantItemData& MerchantItemData, class FText* ConditionDisplayName);
	void GetConditionDisplayTooltip(const struct FS_MerchantItemData& MerchantItemData, class FText* ConditionDisplayTooltip);
	void GetItemFromMerchantItemData(const struct FS_MerchantItemData& MerchantItem, struct FS_jRPG_Item_StaticData* Item);
	void GetItemFromName(const class FName& ItemRowName, struct FS_jRPG_Item_StaticData* Item);
	void GetRemainingQuantityForItem(const class FName& MerchantItemRowName, const struct FS_MerchantItemData& MerchantItem, int32* Quantity);
	void LoadMerchantData(TMap<class FName, struct FS_MerchantItemSellData>* AvailableItems_0);
	void ReadMerchantState(struct FS_MerchantSaveData* State);
	void SaveMerchantState();
	void SetupLevelForItemInstanceGear(const struct FS_MerchantItemData& MerchantItemData, class UBP_ItemInstance_Gear_C* ItemInstance);
	void StartMerchantBattle(TArray<struct FS_jRPG_PartySlot>& BattlePaty);
	bool TryBuyItem(class FName MerchantItemRowName);

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BP_MerchantComponent_C">();
	}
	static class UBP_MerchantComponent_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBP_MerchantComponent_C>();
	}
};
static_assert(alignof(UBP_MerchantComponent_C) == 0x000008, "Wrong alignment on UBP_MerchantComponent_C");
static_assert(sizeof(UBP_MerchantComponent_C) == 0x000260, "Wrong size on UBP_MerchantComponent_C");
static_assert(offsetof(UBP_MerchantComponent_C, Items) == 0x0000A0, "Member 'UBP_MerchantComponent_C::Items' has a wrong offset!");
static_assert(offsetof(UBP_MerchantComponent_C, AvailableItems) == 0x0000A8, "Member 'UBP_MerchantComponent_C::AvailableItems' has a wrong offset!");
static_assert(offsetof(UBP_MerchantComponent_C, BattleParameters) == 0x0000F8, "Member 'UBP_MerchantComponent_C::BattleParameters' has a wrong offset!");
static_assert(offsetof(UBP_MerchantComponent_C, OnItemBought) == 0x000250, "Member 'UBP_MerchantComponent_C::OnItemBought' has a wrong offset!");

}

