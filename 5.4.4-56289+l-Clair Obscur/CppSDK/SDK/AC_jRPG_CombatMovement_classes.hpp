#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: AC_jRPG_CombatMovement

#include "Basic.hpp"

#include "ECharacterTeamSelector_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass AC_jRPG_CombatMovement.AC_jRPG_CombatMovement_C
// 0x0120 (0x01C0 - 0x00A0)
class UAC_jRPG_CombatMovement_C final : public UActorComponent
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x00A0(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	struct FVector                                InitialLocation;                                   // 0x00A8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FRotator                               InitialRotation;                                   // 0x00C0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	struct FRotator                               TargetRotation;                                    // 0x00D8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	double                                        RotationSpeed;                                     // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          RotationActive;                                    // 0x00F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StartLocation;                                     // 0x0100(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                TargetLocation;                                    // 0x0118(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          MovementActive;                                    // 0x0130(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          DEBUG_Verbose;                                     // 0x0131(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_132[0x6];                                      // 0x0132(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           DEBUG_PreviousMontage;                             // 0x0138(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	bool                                          DEBUG_ShowMoveToDebug;                             // 0x0140(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_141[0x7];                                      // 0x0141(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDebugFloatHistory                     DEBUG_CurveHistory;                                // 0x0148(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance)
	double                                        HACK_LinearCurveValue_5_2;                         // 0x0168(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        HACK_CurveProgress_5_2;                            // 0x0170(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TMulticastInlineDelegate<void(class UAC_jRPG_CombatMovement_C* MovementComponent)> OnMovementCompleted; // 0x0178(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	struct FTimerHandle                           MoveToTimeoutTimer;                                // 0x0188(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	bool                                          PreviousPauseAnims;                                // 0x0190(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_191[0x3];                                      // 0x0191(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DEBUG_IncrementalArrows;                           // 0x0194(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UAnimMontage*                           LastPlayedMontage;                                 // 0x0198(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	class USF_BlueprintLatentAction*              ActiveMovementLatentAction;                        // 0x01A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	class FString                                 Debug_CurrentReason;                               // 0x01A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash)
	float                                         LastCurveValue;                                    // 0x01B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

public:
	void UpdateMovementProgression(float CurveValue);
	void CallAndResetMovementLatentAction();
	bool IsMovingTowardsInitialLocation();
	bool IsAtInitialLocation();
	bool IsAtInitialLocationOrAboutToBe();
	void StartMovementToCharacter(class ABP_jRPG_Character_Battle_Base_C* OtherCharacter, class UAnimMontage* MontageToPlay, float PlayRate, double Distance, double Angle, bool AbsoluteAngle, class USF_BlueprintLatentAction* LatentAction, struct FVector* TargetLocation_0);
	float GetCurrentCurveValue();
	void UpdateMovement();
	void QA_CheckExistingMoveToMontage(class UAnimMontage* NewMontage, const class FString& Reason);
	void DoesLocationMatch(bool* Result);
	void DoesRotationMatch(bool* Result);
	void OnNotifyEnd_8640038743EBB9E2014362BE91EB35F9(class FName NotifyName);
	void OnNotifyBegin_8640038743EBB9E2014362BE91EB35F9(class FName NotifyName);
	void OnInterrupted_8640038743EBB9E2014362BE91EB35F9(class FName NotifyName);
	void OnBlendOut_8640038743EBB9E2014362BE91EB35F9(class FName NotifyName);
	void OnCompleted_8640038743EBB9E2014362BE91EB35F9(class FName NotifyName);
	void ReceiveBeginPlay();
	void ReceiveTick(float DeltaSeconds);
	void UpdateInitialTransform();
	void DEBUG_CVarChanged_ShowMoveToDebug(bool NewValue);
	void StartMovement(const struct FVector& TargetLocation_0, class UAnimMontage* MontageToPlay, float PlayRate, class USF_BlueprintLatentAction* LatentAction, const class FString& DebugReason);
	void MovementCompleted();
	void OnMoveTimerExpired();
	void MoveToInitialLocation(class UAnimMontage* MontageToPlay, float PlayRate, class USF_BlueprintLatentAction* LatentAction, const class FString& DebugReason);
	void OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted);
	void ExecuteUbergraph_AC_jRPG_CombatMovement(int32 EntryPoint);

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"AC_jRPG_CombatMovement_C">();
	}
	static class UAC_jRPG_CombatMovement_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAC_jRPG_CombatMovement_C>();
	}
};
static_assert(alignof(UAC_jRPG_CombatMovement_C) == 0x000008, "Wrong alignment on UAC_jRPG_CombatMovement_C");
static_assert(sizeof(UAC_jRPG_CombatMovement_C) == 0x0001C0, "Wrong size on UAC_jRPG_CombatMovement_C");
static_assert(offsetof(UAC_jRPG_CombatMovement_C, UberGraphFrame) == 0x0000A0, "Member 'UAC_jRPG_CombatMovement_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_CombatMovement_C, InitialLocation) == 0x0000A8, "Member 'UAC_jRPG_CombatMovement_C::InitialLocation' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_CombatMovement_C, InitialRotation) == 0x0000C0, "Member 'UAC_jRPG_CombatMovement_C::InitialRotation' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_CombatMovement_C, TargetRotation) == 0x0000D8, "Member 'UAC_jRPG_CombatMovement_C::TargetRotation' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_CombatMovement_C, RotationSpeed) == 0x0000F0, "Member 'UAC_jRPG_CombatMovement_C::RotationSpeed' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_CombatMovement_C, RotationActive) == 0x0000F8, "Member 'UAC_jRPG_CombatMovement_C::RotationActive' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_CombatMovement_C, StartLocation) == 0x000100, "Member 'UAC_jRPG_CombatMovement_C::StartLocation' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_CombatMovement_C, TargetLocation) == 0x000118, "Member 'UAC_jRPG_CombatMovement_C::TargetLocation' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_CombatMovement_C, MovementActive) == 0x000130, "Member 'UAC_jRPG_CombatMovement_C::MovementActive' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_CombatMovement_C, DEBUG_Verbose) == 0x000131, "Member 'UAC_jRPG_CombatMovement_C::DEBUG_Verbose' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_CombatMovement_C, DEBUG_PreviousMontage) == 0x000138, "Member 'UAC_jRPG_CombatMovement_C::DEBUG_PreviousMontage' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_CombatMovement_C, DEBUG_ShowMoveToDebug) == 0x000140, "Member 'UAC_jRPG_CombatMovement_C::DEBUG_ShowMoveToDebug' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_CombatMovement_C, DEBUG_CurveHistory) == 0x000148, "Member 'UAC_jRPG_CombatMovement_C::DEBUG_CurveHistory' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_CombatMovement_C, HACK_LinearCurveValue_5_2) == 0x000168, "Member 'UAC_jRPG_CombatMovement_C::HACK_LinearCurveValue_5_2' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_CombatMovement_C, HACK_CurveProgress_5_2) == 0x000170, "Member 'UAC_jRPG_CombatMovement_C::HACK_CurveProgress_5_2' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_CombatMovement_C, OnMovementCompleted) == 0x000178, "Member 'UAC_jRPG_CombatMovement_C::OnMovementCompleted' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_CombatMovement_C, MoveToTimeoutTimer) == 0x000188, "Member 'UAC_jRPG_CombatMovement_C::MoveToTimeoutTimer' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_CombatMovement_C, PreviousPauseAnims) == 0x000190, "Member 'UAC_jRPG_CombatMovement_C::PreviousPauseAnims' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_CombatMovement_C, DEBUG_IncrementalArrows) == 0x000194, "Member 'UAC_jRPG_CombatMovement_C::DEBUG_IncrementalArrows' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_CombatMovement_C, LastPlayedMontage) == 0x000198, "Member 'UAC_jRPG_CombatMovement_C::LastPlayedMontage' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_CombatMovement_C, ActiveMovementLatentAction) == 0x0001A0, "Member 'UAC_jRPG_CombatMovement_C::ActiveMovementLatentAction' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_CombatMovement_C, Debug_CurrentReason) == 0x0001A8, "Member 'UAC_jRPG_CombatMovement_C::Debug_CurrentReason' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_CombatMovement_C, LastCurveValue) == 0x0001B8, "Member 'UAC_jRPG_CombatMovement_C::LastCurveValue' has a wrong offset!");

}

