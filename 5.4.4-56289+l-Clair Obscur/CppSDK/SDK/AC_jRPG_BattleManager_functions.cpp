#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: AC_jRPG_BattleManager

#include "Basic.hpp"

#include "AC_jRPG_BattleManager_classes.hpp"
#include "AC_jRPG_BattleManager_parameters.hpp"


namespace SDK
{

// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ActivateCharacterCamera
// (Public, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::ActivateCharacterCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ActivateCharacterCamera");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.AdaptSpawnedCharacterLocation
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   BaseLocation                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const TArray<class AActor*>&            ActorsToIgnore                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FVector*                         GroundLocation                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::AdaptSpawnedCharacterLocation(const struct FVector& BaseLocation, const TArray<class AActor*>& ActorsToIgnore, struct FVector* GroundLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "AdaptSpawnedCharacterLocation");

	Params::AC_jRPG_BattleManager_C_AdaptSpawnedCharacterLocation Parms{};

	Parms.BaseLocation = std::move(BaseLocation);
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);

	UObject::ProcessEvent(Func, &Parms);

	if (GroundLocation != nullptr)
		*GroundLocation = std::move(Parms.GroundLocation);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.AddBattleModifierBuff
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_BattleBuffInstance_C*         BuffInstance                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ForcePermanent                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::AddBattleModifierBuff(class UBP_BattleBuffInstance_C* BuffInstance, bool ForcePermanent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "AddBattleModifierBuff");

	Params::AC_jRPG_BattleManager_C_AddBattleModifierBuff Parms{};

	Parms.BuffInstance = BuffInstance;
	Parms.ForcePermanent = ForcePermanent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.AddDefenseSuccessFeedback
// (Public, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::AddDefenseSuccessFeedback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "AddDefenseSuccessFeedback");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.AddDodgeSuccessFeedback
// (Public, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::AddDodgeSuccessFeedback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "AddDodgeSuccessFeedback");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.AddExtraLootItem
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FName                       ItemId                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const int32                             Quantity                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const class FString&                    Reason                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::AddExtraLootItem(const class FName ItemId, const int32 Quantity, const class FString& Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "AddExtraLootItem");

	Params::AC_jRPG_BattleManager_C_AddExtraLootItem Parms{};

	Parms.ItemId = ItemId;
	Parms.Quantity = Quantity;
	Parms.Reason = std::move(Reason);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.AddGlobalDodgeWindowModifier
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Multiplier                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FSF_ModifierStackEntryHandle&    OutModifierHandle                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// const class FString&                    DebugName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::AddGlobalDodgeWindowModifier(float Multiplier, struct FSF_ModifierStackEntryHandle& OutModifierHandle, const class FString& DebugName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "AddGlobalDodgeWindowModifier");

	Params::AC_jRPG_BattleManager_C_AddGlobalDodgeWindowModifier Parms{};

	Parms.Multiplier = Multiplier;
	Parms.OutModifierHandle = std::move(OutModifierHandle);
	Parms.DebugName = std::move(DebugName);

	UObject::ProcessEvent(Func, &Parms);

	OutModifierHandle = std::move(Parms.OutModifierHandle);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.AddGlobalParryWindowModifier
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Multiplier                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FSF_ModifierStackEntryHandle&    OutModifierHandle                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// const class FString&                    DebugName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::AddGlobalParryWindowModifier(float Multiplier, struct FSF_ModifierStackEntryHandle& OutModifierHandle, const class FString& DebugName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "AddGlobalParryWindowModifier");

	Params::AC_jRPG_BattleManager_C_AddGlobalParryWindowModifier Parms{};

	Parms.Multiplier = Multiplier;
	Parms.OutModifierHandle = std::move(OutModifierHandle);
	Parms.DebugName = std::move(DebugName);

	UObject::ProcessEvent(Func, &Parms);

	OutModifierHandle = std::move(Parms.OutModifierHandle);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.AddInitativeToAllCharacters
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::AddInitativeToAllCharacters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "AddInitativeToAllCharacters");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.AddParrySuccessFeedback
// (Public, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::AddParrySuccessFeedback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "AddParrySuccessFeedback");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.AreAllKickedCharacterStateHandleValid
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<struct FGuid>&                   KickedCharacterHandle                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::AreAllKickedCharacterStateHandleValid(TArray<struct FGuid>& KickedCharacterHandle, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "AreAllKickedCharacterStateHandleValid");

	Params::AC_jRPG_BattleManager_C_AreAllKickedCharacterStateHandleValid Parms{};

	Parms.KickedCharacterHandle = std::move(KickedCharacterHandle);

	UObject::ProcessEvent(Func, &Parms);

	KickedCharacterHandle = std::move(Parms.KickedCharacterHandle);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.BattleStart_ProcessNextCharacter_SkillSetup
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::BattleStart_ProcessNextCharacter_SkillSetup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "BattleStart_ProcessNextCharacter_SkillSetup");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.BeginAOECounterAttack
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::BeginAOECounterAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "BeginAOECounterAttack");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.CancelFreeAimFromUI
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::CancelFreeAimFromUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "CancelFreeAimFromUI");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.CanCharactersCounterAttackEnemySkill
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ABP_jRPG_Character_Battle_Base_C* EnemyCharacter                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// TArray<class ABP_jRPG_Character_Battle_Base_C*>&TargetedCharacters                                     (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool*                                   CanCounter                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::CanCharactersCounterAttackEnemySkill(class ABP_jRPG_Character_Battle_Base_C* EnemyCharacter, TArray<class ABP_jRPG_Character_Battle_Base_C*>& TargetedCharacters, bool* CanCounter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "CanCharactersCounterAttackEnemySkill");

	Params::AC_jRPG_BattleManager_C_CanCharactersCounterAttackEnemySkill Parms{};

	Parms.EnemyCharacter = EnemyCharacter;
	Parms.TargetedCharacters = std::move(TargetedCharacters);

	UObject::ProcessEvent(Func, &Parms);

	TargetedCharacters = std::move(Parms.TargetedCharacters);

	if (CanCounter != nullptr)
		*CanCounter = Parms.CanCounter;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.CanFleeCurrentFight
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   FleeImpossible_0                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::CanFleeCurrentFight(bool* FleeImpossible_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "CanFleeCurrentFight");

	Params::AC_jRPG_BattleManager_C_CanFleeCurrentFight Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (FleeImpossible_0 != nullptr)
		*FleeImpossible_0 = Parms.FleeImpossible_0;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.CanPlayReactionBattleLines
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UAC_jRPG_BattleManager_C::CanPlayReactionBattleLines()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "CanPlayReactionBattleLines");

	Params::AC_jRPG_BattleManager_C_CanPlayReactionBattleLines Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.CanResumeBattle
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UAC_jRPG_BattleManager_C::CanResumeBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "CanResumeBattle");

	Params::AC_jRPG_BattleManager_C_CanResumeBattle Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.CanSendReserveTeam
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UAC_jRPG_BattleManager_C::CanSendReserveTeam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "CanSendReserveTeam");

	Params::AC_jRPG_BattleManager_C_CanSendReserveTeam Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ChangeBattleMap
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSoftObjectPtr<class ABP_BattleMap_C>   BattleMapActor                                         (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::ChangeBattleMap(TSoftObjectPtr<class ABP_BattleMap_C> BattleMapActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ChangeBattleMap");

	Params::AC_jRPG_BattleManager_C_ChangeBattleMap Parms{};

	Parms.BattleMapActor = BattleMapActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ChangeTeamMotivation
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Delta                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const class FText&                      ReasonText                                             (BlueprintVisible, BlueprintReadOnly, Parm)

void UAC_jRPG_BattleManager_C::ChangeTeamMotivation(double Delta, const class FText& ReasonText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ChangeTeamMotivation");

	Params::AC_jRPG_BattleManager_C_ChangeTeamMotivation Parms{};

	Parms.Delta = Delta;
	Parms.ReasonText = std::move(ReasonText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.CheckBattleEnd
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   BattleHasEnded                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::CheckBattleEnd(bool* BattleHasEnded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "CheckBattleEnd");

	Params::AC_jRPG_BattleManager_C_CheckBattleEnd Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (BattleHasEnded != nullptr)
		*BattleHasEnded = Parms.BattleHasEnded;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.CheckForGameOver
// (Public, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::CheckForGameOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "CheckForGameOver");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ClearBattleMap
// (Public, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::ClearBattleMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ClearBattleMap");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ComputeCharactersForAOECounterAttack
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UAC_jRPG_CharacterBattleStats_C*>ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference)

TArray<class UAC_jRPG_CharacterBattleStats_C*> UAC_jRPG_BattleManager_C::ComputeCharactersForAOECounterAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ComputeCharactersForAOECounterAttack");

	Params::AC_jRPG_BattleManager_C_ComputeCharactersForAOECounterAttack Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ComputeExtraLootItems
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::ComputeExtraLootItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ComputeExtraLootItems");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ComputeFreeAim3rdPersonTargetLocation
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    DEBUG_ForShoot                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   HasHitCharacter                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_jRPG_Character_Battle_Base_C**CharacterBattle                                        (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         HitLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         StartLocation                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::ComputeFreeAim3rdPersonTargetLocation(bool DEBUG_ForShoot, bool* HasHitCharacter, class ABP_jRPG_Character_Battle_Base_C** CharacterBattle, struct FVector* HitLocation, struct FVector* StartLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ComputeFreeAim3rdPersonTargetLocation");

	Params::AC_jRPG_BattleManager_C_ComputeFreeAim3rdPersonTargetLocation Parms{};

	Parms.DEBUG_ForShoot = DEBUG_ForShoot;

	UObject::ProcessEvent(Func, &Parms);

	if (HasHitCharacter != nullptr)
		*HasHitCharacter = Parms.HasHitCharacter;

	if (CharacterBattle != nullptr)
		*CharacterBattle = Parms.CharacterBattle;

	if (HitLocation != nullptr)
		*HitLocation = std::move(Parms.HitLocation);

	if (StartLocation != nullptr)
		*StartLocation = std::move(Parms.StartLocation);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.CreateBattleEndVictoryScreen
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UBP_CharacterData_C*>&     AllCharacterData                                       (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UAC_jRPG_BattleManager_C::CreateBattleEndVictoryScreen(TArray<class UBP_CharacterData_C*>& AllCharacterData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "CreateBattleEndVictoryScreen");

	Params::AC_jRPG_BattleManager_C_CreateBattleEndVictoryScreen Parms{};

	Parms.AllCharacterData = std::move(AllCharacterData);

	UObject::ProcessEvent(Func, &Parms);

	AllCharacterData = std::move(Parms.AllCharacterData);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.CreateBattleInterface
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::CreateBattleInterface()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "CreateBattleInterface");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.DeactivateAllBattleCBM
// (Public, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::DeactivateAllBattleCBM()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "DeactivateAllBattleCBM");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.DEBUG_CVarChange_BattleLine_SkipRoll
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NewValue                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::DEBUG_CVarChange_BattleLine_SkipRoll(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "DEBUG_CVarChange_BattleLine_SkipRoll");

	Params::AC_jRPG_BattleManager_C_DEBUG_CVarChange_BattleLine_SkipRoll Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.DEBUG_FindPlayerCharacterByName
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    Name_0                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UAC_jRPG_CharacterBattleStats_C** AC_jRPG_CharacterStats                                 (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

bool UAC_jRPG_BattleManager_C::DEBUG_FindPlayerCharacterByName(const class FString& Name_0, class UAC_jRPG_CharacterBattleStats_C** AC_jRPG_CharacterStats)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "DEBUG_FindPlayerCharacterByName");

	Params::AC_jRPG_BattleManager_C_DEBUG_FindPlayerCharacterByName Parms{};

	Parms.Name_0 = std::move(Name_0);

	UObject::ProcessEvent(Func, &Parms);

	if (AC_jRPG_CharacterStats != nullptr)
		*AC_jRPG_CharacterStats = Parms.AC_jRPG_CharacterStats;

	return Parms.ReturnValue;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.DEBUG_GetBattleBuffClassByName
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    _className                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// TSubclassOf<class UBP_BattleBuffInstance_C>*BattleBuffInstanceClass                                (Parm, OutParm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::DEBUG_GetBattleBuffClassByName(const class FString& _className, TSubclassOf<class UBP_BattleBuffInstance_C>* BattleBuffInstanceClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "DEBUG_GetBattleBuffClassByName");

	Params::AC_jRPG_BattleManager_C_DEBUG_GetBattleBuffClassByName Parms{};

	Parms._className = std::move(_className);

	UObject::ProcessEvent(Func, &Parms);

	if (BattleBuffInstanceClass != nullptr)
		*BattleBuffInstanceClass = Parms.BattleBuffInstanceClass;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.Debug_PrintCharacterTurns
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText*                            debugStr                                               (Parm, OutParm)

void UAC_jRPG_BattleManager_C::Debug_PrintCharacterTurns(class FText* debugStr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "Debug_PrintCharacterTurns");

	Params::AC_jRPG_BattleManager_C_Debug_PrintCharacterTurns Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (debugStr != nullptr)
		*debugStr = std::move(Parms.debugStr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.Debug_PrintToCategory
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::Debug_PrintToCategory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "Debug_PrintToCategory");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.Disable Targeting and Input
// (Public, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::Disable_Targeting_and_Input()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "Disable Targeting and Input");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.DisableFreeAimControls
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::DisableFreeAimControls()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "DisableFreeAimControls");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.DispatchEnemiesAlongSpline
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::DispatchEnemiesAlongSpline()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "DispatchEnemiesAlongSpline");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.EnableFreeAimControls
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// EFreeAimType                            FreeAimType                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::EnableFreeAimControls(EFreeAimType FreeAimType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "EnableFreeAimControls");

	Params::AC_jRPG_BattleManager_C_EnableFreeAimControls Parms{};

	Parms.FreeAimType = FreeAimType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.End Character Turn
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  UsedInitiative                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::End_Character_Turn(double UsedInitiative)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "End Character Turn");

	Params::AC_jRPG_BattleManager_C_End_Character_Turn Parms{};

	Parms.UsedInitiative = UsedInitiative;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.EndAOECounterAttack
// (Public, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::EndAOECounterAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "EndAOECounterAttack");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.EventBattleStart
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::EventBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "EventBattleStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ExecuteUbergraph_AC_jRPG_BattleManager
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::ExecuteUbergraph_AC_jRPG_BattleManager(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ExecuteUbergraph_AC_jRPG_BattleManager");

	Params::AC_jRPG_BattleManager_C_ExecuteUbergraph_AC_jRPG_BattleManager Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.FeedbackSuccessfulDefend
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_BattleFeedbackState_C*        DefendInfo                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::FeedbackSuccessfulDefend(class UBP_BattleFeedbackState_C* DefendInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "FeedbackSuccessfulDefend");

	Params::AC_jRPG_BattleManager_C_FeedbackSuccessfulDefend Parms{};

	Parms.DefendInfo = DefendInfo;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.FeedbackSuccessfulDodge
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_BattleFeedbackState_C*        DodgeInfo                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::FeedbackSuccessfulDodge(class UBP_BattleFeedbackState_C* DodgeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "FeedbackSuccessfulDodge");

	Params::AC_jRPG_BattleManager_C_FeedbackSuccessfulDodge Parms{};

	Parms.DodgeInfo = DodgeInfo;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.FeedbackSuccessfulParry
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_BattleFeedbackState_C*        ParryInfo                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::FeedbackSuccessfulParry(class UBP_BattleFeedbackState_C* ParryInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "FeedbackSuccessfulParry");

	Params::AC_jRPG_BattleManager_C_FeedbackSuccessfulParry Parms{};

	Parms.ParryInfo = ParryInfo;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.FindActiveSkillSequenceBP
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_EpicBattleSequenceActor_C**   EpicSequenceBP                                         (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::FindActiveSkillSequenceBP(class ABP_EpicBattleSequenceActor_C** EpicSequenceBP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "FindActiveSkillSequenceBP");

	Params::AC_jRPG_BattleManager_C_FindActiveSkillSequenceBP Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (EpicSequenceBP != nullptr)
		*EpicSequenceBP = Parms.EpicSequenceBP;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.FindBattleModifierBuffByClass
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UClass*                           BuffClass                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// TArray<class UBP_BattleBuffInstanceWrapper_C*>*ActiveBuffInstanceWrappers                             (Parm, OutParm)

void UAC_jRPG_BattleManager_C::FindBattleModifierBuffByClass(class UClass* BuffClass, TArray<class UBP_BattleBuffInstanceWrapper_C*>* ActiveBuffInstanceWrappers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "FindBattleModifierBuffByClass");

	Params::AC_jRPG_BattleManager_C_FindBattleModifierBuffByClass Parms{};

	Parms.BuffClass = BuffClass;

	UObject::ProcessEvent(Func, &Parms);

	if (ActiveBuffInstanceWrappers != nullptr)
		*ActiveBuffInstanceWrappers = std::move(Parms.ActiveBuffInstanceWrappers);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.FindCharacterAtBattleSpot
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// ECharacterTeamSelector                  Team                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   SpotIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_jRPG_Character_Battle_Base_C**Character                                              (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::FindCharacterAtBattleSpot(ECharacterTeamSelector Team, int32 SpotIndex, class ABP_jRPG_Character_Battle_Base_C** Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "FindCharacterAtBattleSpot");

	Params::AC_jRPG_BattleManager_C_FindCharacterAtBattleSpot Parms{};

	Parms.Team = Team;
	Parms.SpotIndex = SpotIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (Character != nullptr)
		*Character = Parms.Character;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.FindCharacterStatsBattleActor
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UAC_jRPG_CharacterBattleStats_C*  CharacterStats                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class ABP_jRPG_Character_Battle_Base_C**BattleCharacterActor                                   (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::FindCharacterStatsBattleActor(class UAC_jRPG_CharacterBattleStats_C* CharacterStats, class ABP_jRPG_Character_Battle_Base_C** BattleCharacterActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "FindCharacterStatsBattleActor");

	Params::AC_jRPG_BattleManager_C_FindCharacterStatsBattleActor Parms{};

	Parms.CharacterStats = CharacterStats;

	UObject::ProcessEvent(Func, &Parms);

	if (BattleCharacterActor != nullptr)
		*BattleCharacterActor = Parms.BattleCharacterActor;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ForceBattleEnd
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// EBattleEndResult                        BattleEndResult                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::ForceBattleEnd(EBattleEndResult BattleEndResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ForceBattleEnd");

	Params::AC_jRPG_BattleManager_C_ForceBattleEnd Parms{};

	Parms.BattleEndResult = BattleEndResult;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.Get Game Director Component
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UBP_GameDirectorComponent_C*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash)

class UBP_GameDirectorComponent_C* UAC_jRPG_BattleManager_C::Get_Game_Director_Component()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "Get Game Director Component");

	Params::AC_jRPG_BattleManager_C_Get_Game_Director_Component Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetActiveCharacter
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_jRPG_Character_Battle_Base_C**CurrentCharacter_0                                     (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::GetActiveCharacter(class ABP_jRPG_Character_Battle_Base_C** CurrentCharacter_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetActiveCharacter");

	Params::AC_jRPG_BattleManager_C_GetActiveCharacter Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CurrentCharacter_0 != nullptr)
		*CurrentCharacter_0 = Parms.CurrentCharacter_0;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetAliveEnemies
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class ABP_jRPG_Character_Battle_Base_C*>ReturnValue                                            (Parm, OutParm, ReturnParm)

TArray<class ABP_jRPG_Character_Battle_Base_C*> UAC_jRPG_BattleManager_C::GetAliveEnemies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetAliveEnemies");

	Params::AC_jRPG_BattleManager_C_GetAliveEnemies Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetAllActiveBattleBuffComponents
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UBP_BattleBuffComponent_C*>*Array                                                  (Parm, OutParm)

void UAC_jRPG_BattleManager_C::GetAllActiveBattleBuffComponents(TArray<class UBP_BattleBuffComponent_C*>* Array)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetAllActiveBattleBuffComponents");

	Params::AC_jRPG_BattleManager_C_GetAllActiveBattleBuffComponents Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Array != nullptr)
		*Array = std::move(Parms.Array);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetAllAliveCharacters
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class ABP_jRPG_Character_Battle_Base_C*>*AllCharacters                                          (Parm, OutParm)

void UAC_jRPG_BattleManager_C::GetAllAliveCharacters(TArray<class ABP_jRPG_Character_Battle_Base_C*>* AllCharacters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetAllAliveCharacters");

	Params::AC_jRPG_BattleManager_C_GetAllAliveCharacters Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (AllCharacters != nullptr)
		*AllCharacters = std::move(Parms.AllCharacters);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetAllAllyCharacters_SortedBySpotIndex
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class ABP_jRPG_Character_Battle_Base_C*>*AllCharacters                                          (Parm, OutParm)

void UAC_jRPG_BattleManager_C::GetAllAllyCharacters_SortedBySpotIndex(TArray<class ABP_jRPG_Character_Battle_Base_C*>* AllCharacters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetAllAllyCharacters_SortedBySpotIndex");

	Params::AC_jRPG_BattleManager_C_GetAllAllyCharacters_SortedBySpotIndex Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (AllCharacters != nullptr)
		*AllCharacters = std::move(Parms.AllCharacters);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetAllCharacters
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class ABP_jRPG_Character_Battle_Base_C*>*AllCharacters                                          (Parm, OutParm)

void UAC_jRPG_BattleManager_C::GetAllCharacters(TArray<class ABP_jRPG_Character_Battle_Base_C*>* AllCharacters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetAllCharacters");

	Params::AC_jRPG_BattleManager_C_GetAllCharacters Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (AllCharacters != nullptr)
		*AllCharacters = std::move(Parms.AllCharacters);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetAllEnemyCharacters_SortedBySpotIndex
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class ABP_jRPG_Character_Battle_Base_C*>*AllEnemies                                             (Parm, OutParm)

void UAC_jRPG_BattleManager_C::GetAllEnemyCharacters_SortedBySpotIndex(TArray<class ABP_jRPG_Character_Battle_Base_C*>* AllEnemies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetAllEnemyCharacters_SortedBySpotIndex");

	Params::AC_jRPG_BattleManager_C_GetAllEnemyCharacters_SortedBySpotIndex Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (AllEnemies != nullptr)
		*AllEnemies = std::move(Parms.AllEnemies);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetAllItemsUsableInBattle
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FS_jRPG_Item_DynamicData>*UsableItem                                             (Parm, OutParm, ContainsInstancedReference)

void UAC_jRPG_BattleManager_C::GetAllItemsUsableInBattle(TArray<struct FS_jRPG_Item_DynamicData>* UsableItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetAllItemsUsableInBattle");

	Params::AC_jRPG_BattleManager_C_GetAllItemsUsableInBattle Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (UsableItem != nullptr)
		*UsableItem = std::move(Parms.UsableItem);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetAllPlayerCharacters
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class ABP_jRPG_Character_Battle_Base_C*>*AllCharacters                                          (Parm, OutParm)

void UAC_jRPG_BattleManager_C::GetAllPlayerCharacters(TArray<class ABP_jRPG_Character_Battle_Base_C*>* AllCharacters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetAllPlayerCharacters");

	Params::AC_jRPG_BattleManager_C_GetAllPlayerCharacters Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (AllCharacters != nullptr)
		*AllCharacters = std::move(Parms.AllCharacters);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetAssetsToLoadForBattle
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<TSoftClassPtr<class UClass>>*    ClassesToLoad                                          (Parm, OutParm)

void UAC_jRPG_BattleManager_C::GetAssetsToLoadForBattle(TArray<TSoftClassPtr<class UClass>>* ClassesToLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetAssetsToLoadForBattle");

	Params::AC_jRPG_BattleManager_C_GetAssetsToLoadForBattle Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ClassesToLoad != nullptr)
		*ClassesToLoad = std::move(Parms.ClassesToLoad);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetBattleEndState
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// EBattleEndResult                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

EBattleEndResult UAC_jRPG_BattleManager_C::GetBattleEndState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetBattleEndState");

	Params::AC_jRPG_BattleManager_C_GetBattleEndState Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetBattleItemSkills
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UBP_DataAsset_Skill_C*>*   ItemSkills                                             (Parm, OutParm)

void UAC_jRPG_BattleManager_C::GetBattleItemSkills(TArray<class UBP_DataAsset_Skill_C*>* ItemSkills)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetBattleItemSkills");

	Params::AC_jRPG_BattleManager_C_GetBattleItemSkills Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ItemSkills != nullptr)
		*ItemSkills = std::move(Parms.ItemSkills);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetBattleItemSkillsScriptClasses
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<TSoftClassPtr<class UClass>>*    ItemSkillScriptSoftClasses                             (Parm, OutParm)

void UAC_jRPG_BattleManager_C::GetBattleItemSkillsScriptClasses(TArray<TSoftClassPtr<class UClass>>* ItemSkillScriptSoftClasses)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetBattleItemSkillsScriptClasses");

	Params::AC_jRPG_BattleManager_C_GetBattleItemSkillsScriptClasses Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ItemSkillScriptSoftClasses != nullptr)
		*ItemSkillScriptSoftClasses = std::move(Parms.ItemSkillScriptSoftClasses);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetCharacterAssetDependencies
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             CharacterId                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<TSoftClassPtr<class UClass>>&    OutClasses                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UAC_jRPG_BattleManager_C::GetCharacterAssetDependencies(class FName CharacterId, TArray<TSoftClassPtr<class UClass>>& OutClasses)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetCharacterAssetDependencies");

	Params::AC_jRPG_BattleManager_C_GetCharacterAssetDependencies Parms{};

	Parms.CharacterId = CharacterId;
	Parms.OutClasses = std::move(OutClasses);

	UObject::ProcessEvent(Func, &Parms);

	OutClasses = std::move(Parms.OutClasses);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetCharacterData
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             CharacterId                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UBP_CharacterData_C**             CharacterData                                          (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::GetCharacterData(class FName CharacterId, class UBP_CharacterData_C** CharacterData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetCharacterData");

	Params::AC_jRPG_BattleManager_C_GetCharacterData Parms{};

	Parms.CharacterId = CharacterId;

	UObject::ProcessEvent(Func, &Parms);

	if (CharacterData != nullptr)
		*CharacterData = Parms.CharacterData;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetCharacterRadiusForPlacement
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ACharacter*                       Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

double UAC_jRPG_BattleManager_C::GetCharacterRadiusForPlacement(class ACharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetCharacterRadiusForPlacement");

	Params::AC_jRPG_BattleManager_C_GetCharacterRadiusForPlacement Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetCharactersState
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class ABP_jRPG_Character_Battle_Base_C*>&Characters                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<double>*                         CharactersInitiative                                   (Parm, OutParm)
// TArray<bool>*                           CharactersEngagementBonus                              (Parm, OutParm)

void UAC_jRPG_BattleManager_C::GetCharactersState(TArray<class ABP_jRPG_Character_Battle_Base_C*>& Characters, TArray<double>* CharactersInitiative, TArray<bool>* CharactersEngagementBonus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetCharactersState");

	Params::AC_jRPG_BattleManager_C_GetCharactersState Parms{};

	Parms.Characters = std::move(Characters);

	UObject::ProcessEvent(Func, &Parms);

	Characters = std::move(Parms.Characters);

	if (CharactersInitiative != nullptr)
		*CharactersInitiative = std::move(Parms.CharactersInitiative);

	if (CharactersEngagementBonus != nullptr)
		*CharactersEngagementBonus = std::move(Parms.CharactersEngagementBonus);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetCharactersWithFormation
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class ABP_jRPG_Character_Battle_Base_C*>&CharactersArray                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// E_jRPG_FormationType                    DesiredFormation                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class ABP_jRPG_Character_Battle_Base_C*>*Result                                                 (Parm, OutParm)

void UAC_jRPG_BattleManager_C::GetCharactersWithFormation(TArray<class ABP_jRPG_Character_Battle_Base_C*>& CharactersArray, E_jRPG_FormationType DesiredFormation, TArray<class ABP_jRPG_Character_Battle_Base_C*>* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetCharactersWithFormation");

	Params::AC_jRPG_BattleManager_C_GetCharactersWithFormation Parms{};

	Parms.CharactersArray = std::move(CharactersArray);
	Parms.DesiredFormation = DesiredFormation;

	UObject::ProcessEvent(Func, &Parms);

	CharactersArray = std::move(Parms.CharactersArray);

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetCharacterWithMaxInitiative
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    DEBUG_Verbose                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_jRPG_Character_Battle_Base_C**Character                                              (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double*                                 TimeToTurn                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::GetCharacterWithMaxInitiative(bool DEBUG_Verbose, bool* Success_, class ABP_jRPG_Character_Battle_Base_C** Character, double* TimeToTurn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetCharacterWithMaxInitiative");

	Params::AC_jRPG_BattleManager_C_GetCharacterWithMaxInitiative Parms{};

	Parms.DEBUG_Verbose = DEBUG_Verbose;

	UObject::ProcessEvent(Func, &Parms);

	if (Success_ != nullptr)
		*Success_ = Parms.Success_;

	if (Character != nullptr)
		*Character = Parms.Character;

	if (TimeToTurn != nullptr)
		*TimeToTurn = Parms.TimeToTurn;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetCharacterWithMaxInitiativeSimulate
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class ABP_jRPG_Character_Battle_Base_C*>&Characters                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<double>&                         CharactersInitiative                                   (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<bool>&                           HasEngagementBonus                                     (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// int32                                   SimulationStep                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    DEBUG_Verbose                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_jRPG_Character_Battle_Base_C**Character                                              (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double*                                 TimeToTurn                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::GetCharacterWithMaxInitiativeSimulate(TArray<class ABP_jRPG_Character_Battle_Base_C*>& Characters, TArray<double>& CharactersInitiative, TArray<bool>& HasEngagementBonus, int32 SimulationStep, bool DEBUG_Verbose, bool* Success_, class ABP_jRPG_Character_Battle_Base_C** Character, double* TimeToTurn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetCharacterWithMaxInitiativeSimulate");

	Params::AC_jRPG_BattleManager_C_GetCharacterWithMaxInitiativeSimulate Parms{};

	Parms.Characters = std::move(Characters);
	Parms.CharactersInitiative = std::move(CharactersInitiative);
	Parms.HasEngagementBonus = std::move(HasEngagementBonus);
	Parms.SimulationStep = SimulationStep;
	Parms.DEBUG_Verbose = DEBUG_Verbose;

	UObject::ProcessEvent(Func, &Parms);

	Characters = std::move(Parms.Characters);
	CharactersInitiative = std::move(Parms.CharactersInitiative);
	HasEngagementBonus = std::move(Parms.HasEngagementBonus);

	if (Success_ != nullptr)
		*Success_ = Parms.Success_;

	if (Character != nullptr)
		*Character = Parms.Character;

	if (TimeToTurn != nullptr)
		*TimeToTurn = Parms.TimeToTurn;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetCurrentBattleDifficulty
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_GameDifficulty                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

E_GameDifficulty UAC_jRPG_BattleManager_C::GetCurrentBattleDifficulty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetCurrentBattleDifficulty");

	Params::AC_jRPG_BattleManager_C_GetCurrentBattleDifficulty Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetCurrentlyCounteringCharacters
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class UAC_jRPG_CharacterBattleStats_C*>ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference)

TArray<class UAC_jRPG_CharacterBattleStats_C*> UAC_jRPG_BattleManager_C::GetCurrentlyCounteringCharacters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetCurrentlyCounteringCharacters");

	Params::AC_jRPG_BattleManager_C_GetCurrentlyCounteringCharacters Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetCurrentlyTargetingSkillState
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_SkillState_C**                SkillState                                             (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::GetCurrentlyTargetingSkillState(class UBP_SkillState_C** SkillState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetCurrentlyTargetingSkillState");

	Params::AC_jRPG_BattleManager_C_GetCurrentlyTargetingSkillState Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SkillState != nullptr)
		*SkillState = Parms.SkillState;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetDummyMiddleCharacter
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ABP_jRPG_Character_Battle_Base_C* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash)

class ABP_jRPG_Character_Battle_Base_C* UAC_jRPG_BattleManager_C::GetDummyMiddleCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetDummyMiddleCharacter");

	Params::AC_jRPG_BattleManager_C_GetDummyMiddleCharacter Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetEquippedCharacterGradientAttacks
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ABP_jRPG_Character_Battle_Base_C* Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// TArray<class UBP_DataAsset_Skill_C*>*   EquippedSkills                                         (Parm, OutParm)

void UAC_jRPG_BattleManager_C::GetEquippedCharacterGradientAttacks(class ABP_jRPG_Character_Battle_Base_C* Character, TArray<class UBP_DataAsset_Skill_C*>* EquippedSkills)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetEquippedCharacterGradientAttacks");

	Params::AC_jRPG_BattleManager_C_GetEquippedCharacterGradientAttacks Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);

	if (EquippedSkills != nullptr)
		*EquippedSkills = std::move(Parms.EquippedSkills);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetEquippedCharacterSkills
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ABP_jRPG_Character_Battle_Base_C* Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// TArray<class UBP_DataAsset_Skill_C*>*   EquippedSkills                                         (Parm, OutParm)

void UAC_jRPG_BattleManager_C::GetEquippedCharacterSkills(class ABP_jRPG_Character_Battle_Base_C* Character, TArray<class UBP_DataAsset_Skill_C*>* EquippedSkills)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetEquippedCharacterSkills");

	Params::AC_jRPG_BattleManager_C_GetEquippedCharacterSkills Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);

	if (EquippedSkills != nullptr)
		*EquippedSkills = std::move(Parms.EquippedSkills);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetExtraLootItems
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TMap<class FName, int32>                ReturnValue                                            (Parm, OutParm, ReturnParm)

TMap<class FName, int32> UAC_jRPG_BattleManager_C::GetExtraLootItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetExtraLootItems");

	Params::AC_jRPG_BattleManager_C_GetExtraLootItems Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetForcedNextCharacters
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class UAC_jRPG_CharacterBattleStats_C*>ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference)

TArray<class UAC_jRPG_CharacterBattleStats_C*> UAC_jRPG_BattleManager_C::GetForcedNextCharacters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetForcedNextCharacters");

	Params::AC_jRPG_BattleManager_C_GetForcedNextCharacters Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetGlobalDodgeWindowModifier
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UModifierStack_Float**            Stack                                                  (Parm, OutParm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::GetGlobalDodgeWindowModifier(class UModifierStack_Float** Stack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetGlobalDodgeWindowModifier");

	Params::AC_jRPG_BattleManager_C_GetGlobalDodgeWindowModifier Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Stack != nullptr)
		*Stack = Parms.Stack;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetGlobalParryWindowModifier
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UModifierStack_Float**            Stack                                                  (Parm, OutParm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::GetGlobalParryWindowModifier(class UModifierStack_Float** Stack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetGlobalParryWindowModifier");

	Params::AC_jRPG_BattleManager_C_GetGlobalParryWindowModifier Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Stack != nullptr)
		*Stack = Parms.Stack;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetJRPGControllerWorld
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ABP_jRPG_Controller_World_C**     JRPG_Controller                                        (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::GetJRPGControllerWorld(class ABP_jRPG_Controller_World_C** JRPG_Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetJRPGControllerWorld");

	Params::AC_jRPG_BattleManager_C_GetJRPGControllerWorld Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (JRPG_Controller != nullptr)
		*JRPG_Controller = Parms.JRPG_Controller;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetKickedCharacterStateFromHandle
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid&                           KickedCharacterHandle                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FFBattleCharacterStoredState*    CharacterState                                         (Parm, OutParm, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::GetKickedCharacterStateFromHandle(struct FGuid& KickedCharacterHandle, bool* Success, struct FFBattleCharacterStoredState* CharacterState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetKickedCharacterStateFromHandle");

	Params::AC_jRPG_BattleManager_C_GetKickedCharacterStateFromHandle Parms{};

	Parms.KickedCharacterHandle = std::move(KickedCharacterHandle);

	UObject::ProcessEvent(Func, &Parms);

	KickedCharacterHandle = std::move(Parms.KickedCharacterHandle);

	if (Success != nullptr)
		*Success = Parms.Success;

	if (CharacterState != nullptr)
		*CharacterState = std::move(Parms.CharacterState);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetLGUIActor_BattleWheels
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ABP_LGUI_UIContainer_BattleWheelRoot_C*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash)

class ABP_LGUI_UIContainer_BattleWheelRoot_C* UAC_jRPG_BattleManager_C::GetLGUIActor_BattleWheels()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetLGUIActor_BattleWheels");

	Params::AC_jRPG_BattleManager_C_GetLGUIActor_BattleWheels Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetPlayerCharacterAtBattleSpot
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   SpotIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_jRPG_Character_Battle_Base_C**Character                                              (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::GetPlayerCharacterAtBattleSpot(int32 SpotIndex, class ABP_jRPG_Character_Battle_Base_C** Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetPlayerCharacterAtBattleSpot");

	Params::AC_jRPG_BattleManager_C_GetPlayerCharacterAtBattleSpot Parms{};

	Parms.SpotIndex = SpotIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (Character != nullptr)
		*Character = Parms.Character;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetProperBattleSpawnPointTransform
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    EnemySpot_                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   SpotIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_jRPG_FormationType                    FormationType                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FTransform*                      BattleSpotTransform                                    (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_jRPG_FormationType*                   BattleSpotFormationType                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::GetProperBattleSpawnPointTransform(bool EnemySpot_, int32 SpotIndex, E_jRPG_FormationType FormationType, struct FTransform* BattleSpotTransform, E_jRPG_FormationType* BattleSpotFormationType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetProperBattleSpawnPointTransform");

	Params::AC_jRPG_BattleManager_C_GetProperBattleSpawnPointTransform Parms{};

	Parms.EnemySpot_ = EnemySpot_;
	Parms.SpotIndex = SpotIndex;
	Parms.FormationType = FormationType;

	UObject::ProcessEvent(Func, &Parms);

	if (BattleSpotTransform != nullptr)
		*BattleSpotTransform = std::move(Parms.BattleSpotTransform);

	if (BattleSpotFormationType != nullptr)
		*BattleSpotFormationType = Parms.BattleSpotFormationType;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetTargetingManager
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UAC_jRPG_TargetingManager_C*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash)

class UAC_jRPG_TargetingManager_C* UAC_jRPG_BattleManager_C::GetTargetingManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetTargetingManager");

	Params::AC_jRPG_BattleManager_C_GetTargetingManager Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetTeamMotivationLevel
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// ETeamMotivationLevelType*               LevelType                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 LevelProgress                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::GetTeamMotivationLevel(ETeamMotivationLevelType* LevelType, double* LevelProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetTeamMotivationLevel");

	Params::AC_jRPG_BattleManager_C_GetTeamMotivationLevel Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (LevelType != nullptr)
		*LevelType = Parms.LevelType;

	if (LevelProgress != nullptr)
		*LevelProgress = Parms.LevelProgress;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetTurnCount
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32*                                  TurnCount_0                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::GetTurnCount(int32* TurnCount_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetTurnCount");

	Params::AC_jRPG_BattleManager_C_GetTurnCount Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (TurnCount_0 != nullptr)
		*TurnCount_0 = Parms.TurnCount_0;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetWorldEnemiesTransforms
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TMap<class FName, struct FTransform>*   EnemiesTransforms                                      (Parm, OutParm)

void UAC_jRPG_BattleManager_C::GetWorldEnemiesTransforms(TMap<class FName, struct FTransform>* EnemiesTransforms)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetWorldEnemiesTransforms");

	Params::AC_jRPG_BattleManager_C_GetWorldEnemiesTransforms Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (EnemiesTransforms != nullptr)
		*EnemiesTransforms = std::move(Parms.EnemiesTransforms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GoBackToExploration
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::GoBackToExploration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GoBackToExploration");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GoBackToExplorationExitFlow_Internal
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::GoBackToExplorationExitFlow_Internal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GoBackToExplorationExitFlow_Internal");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.HasBattleModifierBuffOfClass
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UClass*                           BuffClass                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UAC_jRPG_BattleManager_C::HasBattleModifierBuffOfClass(class UClass* BuffClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "HasBattleModifierBuffOfClass");

	Params::AC_jRPG_BattleManager_C_HasBattleModifierBuffOfClass Parms{};

	Parms.BuffClass = BuffClass;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.Helper_AddRolledLootToMap
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TMap<class FName, struct FS_RolledLootEntry>&RolledLootMap                                          (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FName                             ItemId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Quantity                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   GeneratedLootLevelOffset                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::Helper_AddRolledLootToMap(TMap<class FName, struct FS_RolledLootEntry>& RolledLootMap, class FName ItemId, int32 Quantity, int32 GeneratedLootLevelOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "Helper_AddRolledLootToMap");

	Params::AC_jRPG_BattleManager_C_Helper_AddRolledLootToMap Parms{};

	Parms.RolledLootMap = std::move(RolledLootMap);
	Parms.ItemId = ItemId;
	Parms.Quantity = Quantity;
	Parms.GeneratedLootLevelOffset = GeneratedLootLevelOffset;

	UObject::ProcessEvent(Func, &Parms);

	RolledLootMap = std::move(Parms.RolledLootMap);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.Helper_TryAddRolledLootToMap
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TMap<class FName, struct FS_RolledLootEntry>&RolledBattleLootEntries                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FName                             ItemDefinitionID                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Quantity                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   OffsetLootContext                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FS_LootContext&            LootContext                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::Helper_TryAddRolledLootToMap(const TMap<class FName, struct FS_RolledLootEntry>& RolledBattleLootEntries, class FName ItemDefinitionID, int32 Quantity, int32 OffsetLootContext, const struct FS_LootContext& LootContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "Helper_TryAddRolledLootToMap");

	Params::AC_jRPG_BattleManager_C_Helper_TryAddRolledLootToMap Parms{};

	Parms.RolledBattleLootEntries = std::move(RolledBattleLootEntries);
	Parms.ItemDefinitionID = ItemDefinitionID;
	Parms.Quantity = Quantity;
	Parms.OffsetLootContext = OffsetLootContext;
	Parms.LootContext = std::move(LootContext);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.HideBattleMenuTooltip
// (Public, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::HideBattleMenuTooltip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "HideBattleMenuTooltip");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.InitPlayerCharactersGear
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::InitPlayerCharactersGear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "InitPlayerCharactersGear");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.Internal_MakePlayerCharacterDead
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class ABP_jRPG_Character_Battle_Base_C*&Character                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::Internal_MakePlayerCharacterDead(const class ABP_jRPG_Character_Battle_Base_C*& Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "Internal_MakePlayerCharacterDead");

	Params::AC_jRPG_BattleManager_C_Internal_MakePlayerCharacterDead Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.Is Attacking Heroes
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ABP_jRPG_Enemy_Battle_Base_C*     Enemy                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsAttacking                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class ABP_jRPG_Character_Battle_Base_C*>*TargetedHeroes                                         (Parm, OutParm)

void UAC_jRPG_BattleManager_C::Is_Attacking_Heroes(class ABP_jRPG_Enemy_Battle_Base_C* Enemy, bool* IsAttacking, TArray<class ABP_jRPG_Character_Battle_Base_C*>* TargetedHeroes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "Is Attacking Heroes");

	Params::AC_jRPG_BattleManager_C_Is_Attacking_Heroes Parms{};

	Parms.Enemy = Enemy;

	UObject::ProcessEvent(Func, &Parms);

	if (IsAttacking != nullptr)
		*IsAttacking = Parms.IsAttacking;

	if (TargetedHeroes != nullptr)
		*TargetedHeroes = std::move(Parms.TargetedHeroes);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.IsAFullTeamDead
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UAC_jRPG_BattleManager_C::IsAFullTeamDead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "IsAFullTeamDead");

	Params::AC_jRPG_BattleManager_C_IsAFullTeamDead Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.IsBattleEnding
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UAC_jRPG_BattleManager_C::IsBattleEnding()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "IsBattleEnding");

	Params::AC_jRPG_BattleManager_C_IsBattleEnding Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.IsGradientChargeUnlocked
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UAC_jRPG_BattleManager_C::IsGradientChargeUnlocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "IsGradientChargeUnlocked");

	Params::AC_jRPG_BattleManager_C_IsGradientChargeUnlocked Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.IsKickedCharacterStateHandleValid
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FGuid&                           KickedCharacterHandle                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::IsKickedCharacterStateHandleValid(struct FGuid& KickedCharacterHandle, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "IsKickedCharacterStateHandleValid");

	Params::AC_jRPG_BattleManager_C_IsKickedCharacterStateHandleValid Parms{};

	Parms.KickedCharacterHandle = std::move(KickedCharacterHandle);

	UObject::ProcessEvent(Func, &Parms);

	KickedCharacterHandle = std::move(Parms.KickedCharacterHandle);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.IsLastStandActive
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UAC_jRPG_BattleManager_C::IsLastStandActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "IsLastStandActive");

	Params::AC_jRPG_BattleManager_C_IsLastStandActive Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.IsNarrativeBattle
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UAC_jRPG_BattleManager_C::IsNarrativeBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "IsNarrativeBattle");

	Params::AC_jRPG_BattleManager_C_IsNarrativeBattle Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.IsPlayerTeamCharacterBase
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ABP_jRPG_Character_Battle_Base_C* CharacterBattle                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsPlayerTeam                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::IsPlayerTeamCharacterBase(class ABP_jRPG_Character_Battle_Base_C* CharacterBattle, bool* IsPlayerTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "IsPlayerTeamCharacterBase");

	Params::AC_jRPG_BattleManager_C_IsPlayerTeamCharacterBase Parms{};

	Parms.CharacterBattle = CharacterBattle;

	UObject::ProcessEvent(Func, &Parms);

	if (IsPlayerTeam != nullptr)
		*IsPlayerTeam = Parms.IsPlayerTeam;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.IsPlayerTeamCharacterStats
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UAC_jRPG_CharacterBattleStats_C*  CharacterBattleStats                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsPlayerTeam                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::IsPlayerTeamCharacterStats(class UAC_jRPG_CharacterBattleStats_C* CharacterBattleStats, bool* IsPlayerTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "IsPlayerTeamCharacterStats");

	Params::AC_jRPG_BattleManager_C_IsPlayerTeamCharacterStats Parms{};

	Parms.CharacterBattleStats = CharacterBattleStats;

	UObject::ProcessEvent(Func, &Parms);

	if (IsPlayerTeam != nullptr)
		*IsPlayerTeam = Parms.IsPlayerTeam;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.IsShowingTooltip
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   IsShowingTooltip_0                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::IsShowingTooltip(bool* IsShowingTooltip_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "IsShowingTooltip");

	Params::AC_jRPG_BattleManager_C_IsShowingTooltip Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsShowingTooltip_0 != nullptr)
		*IsShowingTooltip_0 = Parms.IsShowingTooltip_0;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.IsSkipImpossible
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   SkipImpossible                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::IsSkipImpossible(bool* SkipImpossible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "IsSkipImpossible");

	Params::AC_jRPG_BattleManager_C_IsSkipImpossible Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SkipImpossible != nullptr)
		*SkipImpossible = Parms.SkipImpossible;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.KickCharacterFromBattle_Internal
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class ABP_jRPG_Character_Battle_Base_C*&Character                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// struct FGuid*                           KickedCharacterHandle                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::KickCharacterFromBattle_Internal(const class ABP_jRPG_Character_Battle_Base_C*& Character, struct FGuid* KickedCharacterHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "KickCharacterFromBattle_Internal");

	Params::AC_jRPG_BattleManager_C_KickCharacterFromBattle_Internal Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);

	if (KickedCharacterHandle != nullptr)
		*KickedCharacterHandle = std::move(Parms.KickedCharacterHandle);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.LoadEncounterSettings
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::LoadEncounterSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "LoadEncounterSettings");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.LoadParty
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::LoadParty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "LoadParty");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.MoveCharactersBackToTheirSpots
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class USF_BlueprintLatentAction*        LatentAction                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const class FString&                    DebugReason                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::MoveCharactersBackToTheirSpots(class USF_BlueprintLatentAction* LatentAction, const class FString& DebugReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "MoveCharactersBackToTheirSpots");

	Params::AC_jRPG_BattleManager_C_MoveCharactersBackToTheirSpots Parms{};

	Parms.LatentAction = LatentAction;
	Parms.DebugReason = std::move(DebugReason);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.On Character Has Received Damage
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_BattleDamages_C*              BattleDamages                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::On_Character_Has_Received_Damage(class UBP_BattleDamages_C* BattleDamages)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "On Character Has Received Damage");

	Params::AC_jRPG_BattleManager_C_On_Character_Has_Received_Damage Parms{};

	Parms.BattleDamages = BattleDamages;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnAllBattleStartEventsTriggered
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnAllBattleStartEventsTriggered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnAllBattleStartEventsTriggered");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnAllEnemiesKilled
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnAllEnemiesKilled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnAllEnemiesKilled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnAllEnemiesKilledInternal
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnAllEnemiesKilledInternal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnAllEnemiesKilledInternal");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnAllHeroesKilled
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnAllHeroesKilled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnAllHeroesKilled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnAllLastStandsCompleted_Internal
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnAllLastStandsCompleted_Internal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnAllLastStandsCompleted_Internal");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnBackupTeamLoaded
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnBackupTeamLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnBackupTeamLoaded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnBattleDependenciesFullyLoaded
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnBattleDependenciesFullyLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnBattleDependenciesFullyLoaded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnBattleEndBlockerLifted
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    _isActive                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::OnBattleEndBlockerLifted(bool _isActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnBattleEndBlockerLifted");

	Params::AC_jRPG_BattleManager_C_OnBattleEndBlockerLifted Parms{};

	Parms._isActive = _isActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnBattleEndVictory
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnBattleEndVictory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnBattleEndVictory");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnBattleMapReady
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnBattleMapReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnBattleMapReady");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnCancelTargeting
// (Public, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnCancelTargeting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnCancelTargeting");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnCharacterActionFinished
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_jRPG_Character_Battle_Base_C* Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::OnCharacterActionFinished(class ABP_jRPG_Character_Battle_Base_C* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnCharacterActionFinished");

	Params::AC_jRPG_BattleManager_C_OnCharacterActionFinished Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnCharacterDashBackComplete
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_jRPG_Character_Battle_Base_C* CharacterBase                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::OnCharacterDashBackComplete(class ABP_jRPG_Character_Battle_Base_C* CharacterBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnCharacterDashBackComplete");

	Params::AC_jRPG_BattleManager_C_OnCharacterDashBackComplete Parms{};

	Parms.CharacterBase = CharacterBase;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnCharacterDashBackCompleteComponent
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAC_jRPG_CombatMovement_C*        MovementComponent                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::OnCharacterDashBackCompleteComponent(class UAC_jRPG_CombatMovement_C* MovementComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnCharacterDashBackCompleteComponent");

	Params::AC_jRPG_BattleManager_C_OnCharacterDashBackCompleteComponent Parms{};

	Parms.MovementComponent = MovementComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnCharacterLastStandEnded
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAC_jRPG_CharacterBattleStats_C*  CharacterStats                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::OnCharacterLastStandEnded(class UAC_jRPG_CharacterBattleStats_C* CharacterStats)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnCharacterLastStandEnded");

	Params::AC_jRPG_BattleManager_C_OnCharacterLastStandEnded Parms{};

	Parms.CharacterStats = CharacterStats;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnCharacterLastStandStarted
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAC_jRPG_CharacterBattleStats_C*  CharacterStats                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::OnCharacterLastStandStarted(class UAC_jRPG_CharacterBattleStats_C* CharacterStats)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnCharacterLastStandStarted");

	Params::AC_jRPG_BattleManager_C_OnCharacterLastStandStarted Parms{};

	Parms.CharacterStats = CharacterStats;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnCharacterReceivedDamages
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAC_jRPG_CharacterBattleStats_C*  TargetCharacterStats                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// double                                  Damages                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UAC_jRPG_CharacterBattleStats_C*  SourceCharacterStats                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UBP_BattleDamages_C*              BattleDamages                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::OnCharacterReceivedDamages(class UAC_jRPG_CharacterBattleStats_C* TargetCharacterStats, double Damages, class UAC_jRPG_CharacterBattleStats_C* SourceCharacterStats, class UBP_BattleDamages_C* BattleDamages)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnCharacterReceivedDamages");

	Params::AC_jRPG_BattleManager_C_OnCharacterReceivedDamages Parms{};

	Parms.TargetCharacterStats = TargetCharacterStats;
	Parms.Damages = Damages;
	Parms.SourceCharacterStats = SourceCharacterStats;
	Parms.BattleDamages = BattleDamages;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnComboPressed
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnComboPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnComboPressed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnCounterAttackFinished
// (Public, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnCounterAttackFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnCounterAttackFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnDataLayersActivated
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnDataLayersActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnDataLayersActivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnDefendStart
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnDefendStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnDefendStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnDefendStop
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnDefendStop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnDefendStop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnDefendSuccess
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_jRPG_Character_Battle_Base_C* Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class ABP_jRPG_Character_Battle_Base_C* Enemy                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::OnDefendSuccess(class ABP_jRPG_Character_Battle_Base_C* Character, class ABP_jRPG_Character_Battle_Base_C* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnDefendSuccess");

	Params::AC_jRPG_BattleManager_C_OnDefendSuccess Parms{};

	Parms.Character = Character;
	Parms.Enemy = Enemy;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnDodgeAction
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnDodgeAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnDodgeAction");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnDodgeSuccess
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_jRPG_Character_Battle_Base_C* Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class ABP_jRPG_Character_Battle_Base_C* Enemy                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::OnDodgeSuccess(class ABP_jRPG_Character_Battle_Base_C* Character, class ABP_jRPG_Character_Battle_Base_C* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnDodgeSuccess");

	Params::AC_jRPG_BattleManager_C_OnDodgeSuccess Parms{};

	Parms.Character = Character;
	Parms.Enemy = Enemy;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnEnemyKilled
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_jRPG_Character_Battle_Base_C* Enemy                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::OnEnemyKilled(class ABP_jRPG_Character_Battle_Base_C* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnEnemyKilled");

	Params::AC_jRPG_BattleManager_C_OnEnemyKilled Parms{};

	Parms.Enemy = Enemy;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnFinished_2D0A3697490DFAD752C11F89FD2218CA
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnFinished_2D0A3697490DFAD752C11F89FD2218CA()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnFinished_2D0A3697490DFAD752C11F89FD2218CA");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnFinished_3B9680914EC52C5987B913AB52568CD9
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnFinished_3B9680914EC52C5987B913AB52568CD9()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnFinished_3B9680914EC52C5987B913AB52568CD9");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnFinished_58BC12074BE00B90B5CACAAD8F0606F4
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnFinished_58BC12074BE00B90B5CACAAD8F0606F4()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnFinished_58BC12074BE00B90B5CACAAD8F0606F4");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnFinished_58BC12074BE00B90B5CACAAD978D45F2
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnFinished_58BC12074BE00B90B5CACAAD978D45F2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnFinished_58BC12074BE00B90B5CACAAD978D45F2");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnFinished_58BC12074BE00B90B5CACAADC430CF2B
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnFinished_58BC12074BE00B90B5CACAADC430CF2B()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnFinished_58BC12074BE00B90B5CACAADC430CF2B");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnFinished_6D90D4DD4291EFA19FD1D188BD270CC6
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnFinished_6D90D4DD4291EFA19FD1D188BD270CC6()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnFinished_6D90D4DD4291EFA19FD1D188BD270CC6");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnFinished_7574233641EBEE55E33399A458B6A201
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnFinished_7574233641EBEE55E33399A458B6A201()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnFinished_7574233641EBEE55E33399A458B6A201");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnFinished_81711B71411E4D69320D38B39A03F19F
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnFinished_81711B71411E4D69320D38B39A03F19F()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnFinished_81711B71411E4D69320D38B39A03F19F");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnFinished_846FEEF2465960CA826606AD5416E647
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnFinished_846FEEF2465960CA826606AD5416E647()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnFinished_846FEEF2465960CA826606AD5416E647");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnFinished_87FC6BA24FD98A8FD85B999AF19DF012
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnFinished_87FC6BA24FD98A8FD85B999AF19DF012()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnFinished_87FC6BA24FD98A8FD85B999AF19DF012");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnFinished_AA7B24BA438CCF872213CCB429A957E8
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnFinished_AA7B24BA438CCF872213CCB429A957E8()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnFinished_AA7B24BA438CCF872213CCB429A957E8");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnFinished_BACC7CD44396AB29EC64CAA6E6A2885D
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnFinished_BACC7CD44396AB29EC64CAA6E6A2885D()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnFinished_BACC7CD44396AB29EC64CAA6E6A2885D");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnFinished_D23A3CB34350BC4B7F58FA81A8CA41AF
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnFinished_D23A3CB34350BC4B7F58FA81A8CA41AF()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnFinished_D23A3CB34350BC4B7F58FA81A8CA41AF");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnFinished_FDED7E8741285BACE8169884161F56D8
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnFinished_FDED7E8741285BACE8169884161F56D8()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnFinished_FDED7E8741285BACE8169884161F56D8");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnGameOverScreenClosed
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnGameOverScreenClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnGameOverScreenClosed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnGradientCounterAction
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnGradientCounterAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnGradientCounterAction");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnGradientCounterSuccess
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnGradientCounterSuccess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnGradientCounterSuccess");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnJumpAction
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnJumpAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnJumpAction");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnJumpShot
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnJumpShot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnJumpShot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnLastStandDuringFreeAimFinishedFlow
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnLastStandDuringFreeAimFinishedFlow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnLastStandDuringFreeAimFinishedFlow");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnLastStandFinished
// (Public, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnLastStandFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnLastStandFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnLoaded_F58B7C71485B149C4ED04FB5D95BEB82
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Loaded                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::OnLoaded_F58B7C71485B149C4ED04FB5D95BEB82(class UObject* Loaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnLoaded_F58B7C71485B149C4ED04FB5D95BEB82");

	Params::AC_jRPG_BattleManager_C_OnLoaded_F58B7C71485B149C4ED04FB5D95BEB82 Parms{};

	Parms.Loaded = Loaded;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnParryAction
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnParryAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnParryAction");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnParrySuccess
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_jRPG_Character_Battle_Base_C* Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class ABP_jRPG_Character_Battle_Base_C* Enemy                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::OnParrySuccess(class ABP_jRPG_Character_Battle_Base_C* Character, class ABP_jRPG_Character_Battle_Base_C* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnParrySuccess");

	Params::AC_jRPG_BattleManager_C_OnParrySuccess Parms{};

	Parms.Character = Character;
	Parms.Enemy = Enemy;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnPlayerCharacterKilled
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_jRPG_Character_Battle_Base_C* PlayerCharacter                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::OnPlayerCharacterKilled(class ABP_jRPG_Character_Battle_Base_C* PlayerCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnPlayerCharacterKilled");

	Params::AC_jRPG_BattleManager_C_OnPlayerCharacterKilled Parms{};

	Parms.PlayerCharacter = PlayerCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnPlayerCharacterResurrected
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_jRPG_Character_Battle_Base_C* PlayerCharacter                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::OnPlayerCharacterResurrected(class ABP_jRPG_Character_Battle_Base_C* PlayerCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnPlayerCharacterResurrected");

	Params::AC_jRPG_BattleManager_C_OnPlayerCharacterResurrected Parms{};

	Parms.PlayerCharacter = PlayerCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnPlayerCharacterTurnStart
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnPlayerCharacterTurnStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnPlayerCharacterTurnStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnPlayerTurnPreStart
// (Public, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnPlayerTurnPreStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnPlayerTurnPreStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnRequestDone_8C2416AD4A8AC40CBFE10886B5BA038C
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnRequestDone_8C2416AD4A8AC40CBFE10886B5BA038C()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnRequestDone_8C2416AD4A8AC40CBFE10886B5BA038C");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnReserveTeamResponse
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ShouldSendReserve                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::OnReserveTeamResponse(bool ShouldSendReserve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnReserveTeamResponse");

	Params::AC_jRPG_BattleManager_C_OnReserveTeamResponse Parms{};

	Parms.ShouldSendReserve = ShouldSendReserve;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnSelectFlee
// (Public, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnSelectFlee()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnSelectFlee");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnSelectSkillMenu
// (Public, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnSelectSkillMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnSelectSkillMenu");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnSelectSkip
// (Public, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnSelectSkip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnSelectSkip");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnSkillSelectionClosed
// (Public, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnSkillSelectionClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnSkillSelectionClosed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnStartTargeting
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnStartTargeting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnStartTargeting");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnStopTargeting
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    WasPreTargeting                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::OnStopTargeting(bool WasPreTargeting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnStopTargeting");

	Params::AC_jRPG_BattleManager_C_OnStopTargeting Parms{};

	Parms.WasPreTargeting = WasPreTargeting;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnTargetChanged
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnTargetChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnTargetChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnTargetingUpdate
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnTargetingUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnTargetingUpdate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnTurnEndEventBegin
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_jRPG_Character_Battle_Base_C* Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::OnTurnEndEventBegin(class ABP_jRPG_Character_Battle_Base_C* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnTurnEndEventBegin");

	Params::AC_jRPG_BattleManager_C_OnTurnEndEventBegin Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnTurnEndEventEnd
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnTurnEndEventEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnTurnEndEventEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnTurnSkipped
// (Public, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnTurnSkipped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnTurnSkipped");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.OnVictoryScreenClosedFlow
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::OnVictoryScreenClosedFlow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "OnVictoryScreenClosedFlow");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.PerformFlee
// (Public, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::PerformFlee()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "PerformFlee");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.PerformLastStandFlow
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::PerformLastStandFlow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "PerformLastStandFlow");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.PlayFreezeFrameInternal
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class USF_BlueprintLatentAction*        LatentAction                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// float                                   TimeDilation                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   GameDuration                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::PlayFreezeFrameInternal(class USF_BlueprintLatentAction* LatentAction, float TimeDilation, float GameDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "PlayFreezeFrameInternal");

	Params::AC_jRPG_BattleManager_C_PlayFreezeFrameInternal Parms{};

	Parms.LatentAction = LatentAction;
	Parms.TimeDilation = TimeDilation;
	Parms.GameDuration = GameDuration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.PrepareForBackupTeam
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FName>*                    BackupTeam                                             (Parm, OutParm)
// TArray<TSoftClassPtr<class UClass>>*    ClassesToLoad                                          (Parm, OutParm)

void UAC_jRPG_BattleManager_C::PrepareForBackupTeam(TArray<class FName>* BackupTeam, TArray<TSoftClassPtr<class UClass>>* ClassesToLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "PrepareForBackupTeam");

	Params::AC_jRPG_BattleManager_C_PrepareForBackupTeam Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (BackupTeam != nullptr)
		*BackupTeam = std::move(Parms.BackupTeam);

	if (ClassesToLoad != nullptr)
		*ClassesToLoad = std::move(Parms.ClassesToLoad);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ProcessAdditionalTurnEndEvent
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::ProcessAdditionalTurnEndEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ProcessAdditionalTurnEndEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ProcessLastStandEvents
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class USF_BlueprintLatentAction*        LatentAction                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::ProcessLastStandEvents(class USF_BlueprintLatentAction* LatentAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ProcessLastStandEvents");

	Params::AC_jRPG_BattleManager_C_ProcessLastStandEvents Parms{};

	Parms.LatentAction = LatentAction;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ProcessNextCharacterBattleStartEvent
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::ProcessNextCharacterBattleStartEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ProcessNextCharacterBattleStartEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ProcessNextCharacterTurnEnd
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::ProcessNextCharacterTurnEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ProcessNextCharacterTurnEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ProcessNextFeedback
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::ProcessNextFeedback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ProcessNextFeedback");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ProcessNextPendingResurrect
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class USF_BlueprintLatentAction*        LatentAction                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::ProcessNextPendingResurrect(class USF_BlueprintLatentAction* LatentAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ProcessNextPendingResurrect");

	Params::AC_jRPG_BattleManager_C_ProcessNextPendingResurrect Parms{};

	Parms.LatentAction = LatentAction;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ProcessNextTurnStartListener
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::ProcessNextTurnStartListener()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ProcessNextTurnStartListener");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ProcessVictoryEndFlow
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::ProcessVictoryEndFlow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ProcessVictoryEndFlow");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.QueueForcedNextCharacter
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class UAC_jRPG_CharacterBattleStats_C*&CharacterStats                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, InstancedReference, ReferenceParm, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::QueueForcedNextCharacter(const class UAC_jRPG_CharacterBattleStats_C*& CharacterStats)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "QueueForcedNextCharacter");

	Params::AC_jRPG_BattleManager_C_QueueForcedNextCharacter Parms{};

	Parms.CharacterStats = CharacterStats;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ReceiveBattleExperience
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   InputPin                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::ReceiveBattleExperience(int32 InputPin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ReceiveBattleExperience");

	Params::AC_jRPG_BattleManager_C_ReceiveBattleExperience Parms{};

	Parms.InputPin = InputPin;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ReceiveBattleRewards
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_BattleRewards&                BattleRewards                                          (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::ReceiveBattleRewards(struct FS_BattleRewards& BattleRewards)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ReceiveBattleRewards");

	Params::AC_jRPG_BattleManager_C_ReceiveBattleRewards Parms{};

	Parms.BattleRewards = std::move(BattleRewards);

	UObject::ProcessEvent(Func, &Parms);

	BattleRewards = std::move(Parms.BattleRewards);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ReceiveBeginPlay
// (Event, Public, BlueprintEvent)

void UAC_jRPG_BattleManager_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ReceiveTick");

	Params::AC_jRPG_BattleManager_C_ReceiveTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.RegisterBattleListener
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TScriptInterface<class IBPI_BattleListener_C>&NewListener                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::RegisterBattleListener(const TScriptInterface<class IBPI_BattleListener_C>& NewListener)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "RegisterBattleListener");

	Params::AC_jRPG_BattleManager_C_RegisterBattleListener Parms{};

	Parms.NewListener = NewListener;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.RegisterPendingResurrect
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class UAC_jRPG_CharacterBattleStats_C*&CharacterStats                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, InstancedReference, ReferenceParm, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::RegisterPendingResurrect(const class UAC_jRPG_CharacterBattleStats_C*& CharacterStats)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "RegisterPendingResurrect");

	Params::AC_jRPG_BattleManager_C_RegisterPendingResurrect Parms{};

	Parms.CharacterStats = CharacterStats;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ReintegrateCharacterToBattle
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid&                           KickedCharacterHandle                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_jRPG_Character_Battle_Base_C**RespawnedCharacter                                     (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::ReintegrateCharacterToBattle(struct FGuid& KickedCharacterHandle, class ABP_jRPG_Character_Battle_Base_C** RespawnedCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ReintegrateCharacterToBattle");

	Params::AC_jRPG_BattleManager_C_ReintegrateCharacterToBattle Parms{};

	Parms.KickedCharacterHandle = std::move(KickedCharacterHandle);

	UObject::ProcessEvent(Func, &Parms);

	KickedCharacterHandle = std::move(Parms.KickedCharacterHandle);

	if (RespawnedCharacter != nullptr)
		*RespawnedCharacter = Parms.RespawnedCharacter;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.RemoveBattleScreenHUD
// (Private, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::RemoveBattleScreenHUD()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "RemoveBattleScreenHUD");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.RemoveGlobalDodgeWindowModifier
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FSF_ModifierStackEntryHandle&    OutModifierHandle                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UAC_jRPG_BattleManager_C::RemoveGlobalDodgeWindowModifier(struct FSF_ModifierStackEntryHandle& OutModifierHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "RemoveGlobalDodgeWindowModifier");

	Params::AC_jRPG_BattleManager_C_RemoveGlobalDodgeWindowModifier Parms{};

	Parms.OutModifierHandle = std::move(OutModifierHandle);

	UObject::ProcessEvent(Func, &Parms);

	OutModifierHandle = std::move(Parms.OutModifierHandle);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.RemoveGlobalParryWindowModifier
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FSF_ModifierStackEntryHandle&    OutModifierHandle                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UAC_jRPG_BattleManager_C::RemoveGlobalParryWindowModifier(struct FSF_ModifierStackEntryHandle& OutModifierHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "RemoveGlobalParryWindowModifier");

	Params::AC_jRPG_BattleManager_C_RemoveGlobalParryWindowModifier Parms{};

	Parms.OutModifierHandle = std::move(OutModifierHandle);

	UObject::ProcessEvent(Func, &Parms);

	OutModifierHandle = std::move(Parms.OutModifierHandle);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.RemoveInvalidKickedCharacterStateHandles
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FGuid>&                   KickedCharacterHandles                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UAC_jRPG_BattleManager_C::RemoveInvalidKickedCharacterStateHandles(TArray<struct FGuid>& KickedCharacterHandles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "RemoveInvalidKickedCharacterStateHandles");

	Params::AC_jRPG_BattleManager_C_RemoveInvalidKickedCharacterStateHandles Parms{};

	Parms.KickedCharacterHandles = std::move(KickedCharacterHandles);

	UObject::ProcessEvent(Func, &Parms);

	KickedCharacterHandles = std::move(Parms.KickedCharacterHandles);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.RequestActionExecution
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class ABP_jRPG_Character_Battle_Base_C*>&TargetedCharacters                                     (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UAC_jRPG_BattleManager_C::RequestActionExecution(TArray<class ABP_jRPG_Character_Battle_Base_C*>& TargetedCharacters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "RequestActionExecution");

	Params::AC_jRPG_BattleManager_C_RequestActionExecution Parms{};

	Parms.TargetedCharacters = std::move(TargetedCharacters);

	UObject::ProcessEvent(Func, &Parms);

	TargetedCharacters = std::move(Parms.TargetedCharacters);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ResetBattle
// (Private, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::ResetBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ResetBattle");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ResetGlobalTimeDilationForBattle
// (Private, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::ResetGlobalTimeDilationForBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ResetGlobalTimeDilationForBattle");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ResetInterceptions
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class USF_BlueprintLatentAction*        LatentAction                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::ResetInterceptions(class USF_BlueprintLatentAction* LatentAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ResetInterceptions");

	Params::AC_jRPG_BattleManager_C_ResetInterceptions Parms{};

	Parms.LatentAction = LatentAction;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ResumeAudioFromBattle
// (Private, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::ResumeAudioFromBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ResumeAudioFromBattle");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ResumeBattle
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::ResumeBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ResumeBattle");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ResumeBattleNew
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::ResumeBattleNew()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ResumeBattleNew");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.RollBattleRewards
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_BattleRewards*                BattleRewards                                          (Parm, OutParm, ContainsInstancedReference, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::RollBattleRewards(struct FS_BattleRewards* BattleRewards)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "RollBattleRewards");

	Params::AC_jRPG_BattleManager_C_RollBattleRewards Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (BattleRewards != nullptr)
		*BattleRewards = std::move(Parms.BattleRewards);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.Sandfall_AddAP
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// int32                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::Sandfall_AddAP(const class FString& Character, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "Sandfall_AddAP");

	Params::AC_jRPG_BattleManager_C_Sandfall_AddAP Parms{};

	Parms.Character = std::move(Character);
	Parms.Amount = Amount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.Sandfall_ApplyBuffToAllEnemies
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    BuffBPClass                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::Sandfall_ApplyBuffToAllEnemies(const class FString& BuffBPClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "Sandfall_ApplyBuffToAllEnemies");

	Params::AC_jRPG_BattleManager_C_Sandfall_ApplyBuffToAllEnemies Parms{};

	Parms.BuffBPClass = std::move(BuffBPClass);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.Sandfall_ApplyBuffToAlly
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    AllyName                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// const class FString&                    BuffBPClass                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::Sandfall_ApplyBuffToAlly(const class FString& AllyName, const class FString& BuffBPClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "Sandfall_ApplyBuffToAlly");

	Params::AC_jRPG_BattleManager_C_Sandfall_ApplyBuffToAlly Parms{};

	Parms.AllyName = std::move(AllyName);
	Parms.BuffBPClass = std::move(BuffBPClass);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.Sandfall_ApplyShieldToEnemies
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   ShieldAmount                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::Sandfall_ApplyShieldToEnemies(int32 ShieldAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "Sandfall_ApplyShieldToEnemies");

	Params::AC_jRPG_BattleManager_C_Sandfall_ApplyShieldToEnemies Parms{};

	Parms.ShieldAmount = ShieldAmount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.Sandfall_ChangePerfection
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    CharacterId                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// int32                                   PerfectionChange                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::Sandfall_ChangePerfection(const class FString& CharacterId, int32 PerfectionChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "Sandfall_ChangePerfection");

	Params::AC_jRPG_BattleManager_C_Sandfall_ChangePerfection Parms{};

	Parms.CharacterId = std::move(CharacterId);
	Parms.PerfectionChange = PerfectionChange;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.Sandfall_DamageCharacter 
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    CharacterName                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::Sandfall_DamageCharacter_(const class FString& CharacterName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "Sandfall_DamageCharacter ");

	Params::AC_jRPG_BattleManager_C_Sandfall_DamageCharacter_ Parms{};

	Parms.CharacterName = std::move(CharacterName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.Sandfall_DamageEnemies
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Damages                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::Sandfall_DamageEnemies(double Damages)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "Sandfall_DamageEnemies");

	Params::AC_jRPG_BattleManager_C_Sandfall_DamageEnemies Parms{};

	Parms.Damages = Damages;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.Sandfall_HeroesIgnoreDamage
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Ignore                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::Sandfall_HeroesIgnoreDamage(bool Ignore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "Sandfall_HeroesIgnoreDamage");

	Params::AC_jRPG_BattleManager_C_Sandfall_HeroesIgnoreDamage Parms{};

	Parms.Ignore = Ignore;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.Sandfall_KillAllEnemies
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::Sandfall_KillAllEnemies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "Sandfall_KillAllEnemies");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.Sandfall_KillAllies
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::Sandfall_KillAllies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "Sandfall_KillAllies");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.Sandfall_KillCharacter
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    CharacterName                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::Sandfall_KillCharacter(const class FString& CharacterName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "Sandfall_KillCharacter");

	Params::AC_jRPG_BattleManager_C_Sandfall_KillCharacter Parms{};

	Parms.CharacterName = std::move(CharacterName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.Sandfall_KillCharacterByObject
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAC_jRPG_CharacterBattleStats_C*  Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UAC_jRPG_CharacterBattleStats_C*  Source                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::Sandfall_KillCharacterByObject(class UAC_jRPG_CharacterBattleStats_C* Target, class UAC_jRPG_CharacterBattleStats_C* Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "Sandfall_KillCharacterByObject");

	Params::AC_jRPG_BattleManager_C_Sandfall_KillCharacterByObject Parms{};

	Parms.Target = Target;
	Parms.Source = Source;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.Sandfall_KillEnemy
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::Sandfall_KillEnemy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "Sandfall_KillEnemy");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.Sandfall_ReproBurnDeath
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::Sandfall_ReproBurnDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "Sandfall_ReproBurnDeath");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.Sandfall_SetAllAlliesAP
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::Sandfall_SetAllAlliesAP(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "Sandfall_SetAllAlliesAP");

	Params::AC_jRPG_BattleManager_C_Sandfall_SetAllAlliesAP Parms{};

	Parms.Amount = Amount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.Sandfall_SetAllAlliesHP
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   HP                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::Sandfall_SetAllAlliesHP(int32 HP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "Sandfall_SetAllAlliesHP");

	Params::AC_jRPG_BattleManager_C_Sandfall_SetAllAlliesHP Parms{};

	Parms.HP = HP;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.Sandfall_SetAllEnemiesHP
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   NewHPValue                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::Sandfall_SetAllEnemiesHP(int32 NewHPValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "Sandfall_SetAllEnemiesHP");

	Params::AC_jRPG_BattleManager_C_Sandfall_SetAllEnemiesHP Parms{};

	Parms.NewHPValue = NewHPValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.Sandfall_TestInterception
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::Sandfall_TestInterception()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "Sandfall_TestInterception");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.SelectAction
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_jRPG_ActionType                       ActionType                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::SelectAction(E_jRPG_ActionType ActionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "SelectAction");

	Params::AC_jRPG_BattleManager_C_SelectAction Parms{};

	Parms.ActionType = ActionType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.SelectSecondaryAction
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             SelectedSecondaryAction_0                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::SelectSecondaryAction(class FName SelectedSecondaryAction_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "SelectSecondaryAction");

	Params::AC_jRPG_BattleManager_C_SelectSecondaryAction Parms{};

	Parms.SelectedSecondaryAction_0 = SelectedSecondaryAction_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.SetBattleInputEnabled
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enabled                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::SetBattleInputEnabled(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "SetBattleInputEnabled");

	Params::AC_jRPG_BattleManager_C_SetBattleInputEnabled Parms{};

	Parms.Enabled = Enabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.SetBattleMapInternal
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_BattleMap_C*                  BattleMapActor                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::SetBattleMapInternal(class ABP_BattleMap_C* BattleMapActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "SetBattleMapInternal");

	Params::AC_jRPG_BattleManager_C_SetBattleMapInternal Parms{};

	Parms.BattleMapActor = BattleMapActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.SetCurrentCharacter
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_jRPG_Character_Battle_Base_C* CurrentCharacter_0                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::SetCurrentCharacter(class ABP_jRPG_Character_Battle_Base_C* CurrentCharacter_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "SetCurrentCharacter");

	Params::AC_jRPG_BattleManager_C_SetCurrentCharacter Parms{};

	Parms.CurrentCharacter_0 = CurrentCharacter_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.SetDebugFlowState
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    StateName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::SetDebugFlowState(const class FString& StateName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "SetDebugFlowState");

	Params::AC_jRPG_BattleManager_C_SetDebugFlowState Parms{};

	Parms.StateName = std::move(StateName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.SetDefenseState
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    WantedDefense_0                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::SetDefenseState(bool WantedDefense_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "SetDefenseState");

	Params::AC_jRPG_BattleManager_C_SetDefenseState Parms{};

	Parms.WantedDefense_0 = WantedDefense_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.SetInputMappingContextEnabled
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bIsEnabled                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const class UInputMappingContext*       MappingContext                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::SetInputMappingContextEnabled(bool bIsEnabled, const class UInputMappingContext* MappingContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "SetInputMappingContextEnabled");

	Params::AC_jRPG_BattleManager_C_SetInputMappingContextEnabled Parms{};

	Parms.bIsEnabled = bIsEnabled;
	Parms.MappingContext = MappingContext;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.SetIsSkipImpossible
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsSkipImpossible                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::SetIsSkipImpossible(bool IsSkipImpossible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "SetIsSkipImpossible");

	Params::AC_jRPG_BattleManager_C_SetIsSkipImpossible Parms{};

	Parms.IsSkipImpossible = IsSkipImpossible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.SetLastFatalDamageReceivedReason
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EDamageReason                           LastDamageReceivedReason                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::SetLastFatalDamageReceivedReason(EDamageReason LastDamageReceivedReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "SetLastFatalDamageReceivedReason");

	Params::AC_jRPG_BattleManager_C_SetLastFatalDamageReceivedReason Parms{};

	Parms.LastDamageReceivedReason = LastDamageReceivedReason;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.SetupBattleMap
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::SetupBattleMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "SetupBattleMap");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ShouldQueueRevive
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UAC_jRPG_BattleManager_C::ShouldQueueRevive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ShouldQueueRevive");

	Params::AC_jRPG_BattleManager_C_ShouldQueueRevive Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ShouldUpdateCharacterDataWithFinalBattleState
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UAC_jRPG_BattleManager_C::ShouldUpdateCharacterDataWithFinalBattleState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ShouldUpdateCharacterDataWithFinalBattleState");

	Params::AC_jRPG_BattleManager_C_ShouldUpdateCharacterDataWithFinalBattleState Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ShowBattleMenuTooltip
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FText&                      TooltipName                                            (BlueprintVisible, BlueprintReadOnly, Parm)
// const class FText&                      TooltipDesc                                            (BlueprintVisible, BlueprintReadOnly, Parm)

void UAC_jRPG_BattleManager_C::ShowBattleMenuTooltip(const class FText& TooltipName, const class FText& TooltipDesc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ShowBattleMenuTooltip");

	Params::AC_jRPG_BattleManager_C_ShowBattleMenuTooltip Parms{};

	Parms.TooltipName = std::move(TooltipName);
	Parms.TooltipDesc = std::move(TooltipDesc);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ShowBattleTooltip
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FText&                      ToolTipText                                            (BlueprintVisible, BlueprintReadOnly, Parm)
// bool                                    AutoFadeout                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::ShowBattleTooltip(const class FText& ToolTipText, bool AutoFadeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ShowBattleTooltip");

	Params::AC_jRPG_BattleManager_C_ShowBattleTooltip Parms{};

	Parms.ToolTipText = std::move(ToolTipText);
	Parms.AutoFadeout = AutoFadeout;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ShowReserveTeamGameOver
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::ShowReserveTeamGameOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ShowReserveTeamGameOver");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ShowSkillTooltip
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FText&                      TooltipName                                            (BlueprintVisible, BlueprintReadOnly, Parm)
// const class FText&                      TooltipDesc                                            (BlueprintVisible, BlueprintReadOnly, Parm)

void UAC_jRPG_BattleManager_C::ShowSkillTooltip(const class FText& TooltipName, const class FText& TooltipDesc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ShowSkillTooltip");

	Params::AC_jRPG_BattleManager_C_ShowSkillTooltip Parms{};

	Parms.TooltipName = std::move(TooltipName);
	Parms.TooltipDesc = std::move(TooltipDesc);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.Spawn Player Character
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_CharacterData_C*              CharacterData                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   BattleSpotIndex                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_jRPG_FormationType                    FormationType                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_jRPG_Character_Battle_Base_C**SpawnedCharacter                                       (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::Spawn_Player_Character(class UBP_CharacterData_C* CharacterData, int32 BattleSpotIndex, E_jRPG_FormationType FormationType, class ABP_jRPG_Character_Battle_Base_C** SpawnedCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "Spawn Player Character");

	Params::AC_jRPG_BattleManager_C_Spawn_Player_Character Parms{};

	Parms.CharacterData = CharacterData;
	Parms.BattleSpotIndex = BattleSpotIndex;
	Parms.FormationType = FormationType;

	UObject::ProcessEvent(Func, &Parms);

	if (SpawnedCharacter != nullptr)
		*SpawnedCharacter = Parms.SpawnedCharacter;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.SpawnAllCharacters
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::SpawnAllCharacters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "SpawnAllCharacters");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.SpawnBackupTeam
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::SpawnBackupTeam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "SpawnBackupTeam");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.SpawnBattleSequence
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ULevelSequence*                   LevelSequence                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class ABP_jRPG_Character_Battle_Base_C* SourceCharacter                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// TArray<class ABP_jRPG_Character_Battle_Base_C*>&TargetCharacters                                       (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    SnapOnTarget                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    UseTargetAsOrigin                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    UseTargetOrientation                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    LookAtTarget                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    LookAtAttacker                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    DisableSequenceSnapping                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_EpicBattleSequenceActor_C**   EpicSequence                                           (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FTransform*                      AttackerFirstPosition                                  (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::SpawnBattleSequence(class ULevelSequence* LevelSequence, class ABP_jRPG_Character_Battle_Base_C* SourceCharacter, TArray<class ABP_jRPG_Character_Battle_Base_C*>& TargetCharacters, bool SnapOnTarget, bool UseTargetAsOrigin, bool UseTargetOrientation, bool LookAtTarget, bool LookAtAttacker, bool DisableSequenceSnapping, class ABP_EpicBattleSequenceActor_C** EpicSequence, struct FTransform* AttackerFirstPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "SpawnBattleSequence");

	Params::AC_jRPG_BattleManager_C_SpawnBattleSequence Parms{};

	Parms.LevelSequence = LevelSequence;
	Parms.SourceCharacter = SourceCharacter;
	Parms.TargetCharacters = std::move(TargetCharacters);
	Parms.SnapOnTarget = SnapOnTarget;
	Parms.UseTargetAsOrigin = UseTargetAsOrigin;
	Parms.UseTargetOrientation = UseTargetOrientation;
	Parms.LookAtTarget = LookAtTarget;
	Parms.LookAtAttacker = LookAtAttacker;
	Parms.DisableSequenceSnapping = DisableSequenceSnapping;

	UObject::ProcessEvent(Func, &Parms);

	TargetCharacters = std::move(Parms.TargetCharacters);

	if (EpicSequence != nullptr)
		*EpicSequence = Parms.EpicSequence;

	if (AttackerFirstPosition != nullptr)
		*AttackerFirstPosition = std::move(Parms.AttackerFirstPosition);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.SpawnCharacterFromStoredState
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FFBattleCharacterStoredState&StoredState                                            (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// class ABP_jRPG_Character_Battle_Base_C**SpawnedCharacter                                       (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::SpawnCharacterFromStoredState(const struct FFBattleCharacterStoredState& StoredState, class ABP_jRPG_Character_Battle_Base_C** SpawnedCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "SpawnCharacterFromStoredState");

	Params::AC_jRPG_BattleManager_C_SpawnCharacterFromStoredState Parms{};

	Parms.StoredState = std::move(StoredState);

	UObject::ProcessEvent(Func, &Parms);

	if (SpawnedCharacter != nullptr)
		*SpawnedCharacter = Parms.SpawnedCharacter;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.SpawnEnemies
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::SpawnEnemies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "SpawnEnemies");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.SpawnEnemyOnSpot
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   BattleSpotIndex                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             CharacterHardcodedName                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NotifyBattleStart                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_jRPG_Character_Battle_Base_C**SpawnedEnemy                                           (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         EnemySpawnedLocation                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::SpawnEnemyOnSpot(int32 BattleSpotIndex, class FName CharacterHardcodedName, bool NotifyBattleStart, class ABP_jRPG_Character_Battle_Base_C** SpawnedEnemy, struct FVector* EnemySpawnedLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "SpawnEnemyOnSpot");

	Params::AC_jRPG_BattleManager_C_SpawnEnemyOnSpot Parms{};

	Parms.BattleSpotIndex = BattleSpotIndex;
	Parms.CharacterHardcodedName = CharacterHardcodedName;
	Parms.NotifyBattleStart = NotifyBattleStart;

	UObject::ProcessEvent(Func, &Parms);

	if (SpawnedEnemy != nullptr)
		*SpawnedEnemy = Parms.SpawnedEnemy;

	if (EnemySpawnedLocation != nullptr)
		*EnemySpawnedLocation = std::move(Parms.EnemySpawnedLocation);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.SpawnExtraPlayerCharacter
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_CharacterData_C*              CharacterData                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::SpawnExtraPlayerCharacter(class UBP_CharacterData_C* CharacterData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "SpawnExtraPlayerCharacter");

	Params::AC_jRPG_BattleManager_C_SpawnExtraPlayerCharacter Parms{};

	Parms.CharacterData = CharacterData;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.SpawnOnlyRequestedTeam
// (Public, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::SpawnOnlyRequestedTeam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "SpawnOnlyRequestedTeam");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.SpawnPlayerCharactersFromParty
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::SpawnPlayerCharactersFromParty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "SpawnPlayerCharactersFromParty");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.SpawnPuppetCharacter
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UClass*                           CharacterBPClass                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UAC_jRPG_CharacterBattleStats_C*  PuppetedBy                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// double                                  Scale                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_jRPG_Character_Battle_Base_C* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash)

class ABP_jRPG_Character_Battle_Base_C* UAC_jRPG_BattleManager_C::SpawnPuppetCharacter(class UClass* CharacterBPClass, class UAC_jRPG_CharacterBattleStats_C* PuppetedBy, double Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "SpawnPuppetCharacter");

	Params::AC_jRPG_BattleManager_C_SpawnPuppetCharacter Parms{};

	Parms.CharacterBPClass = CharacterBPClass;
	Parms.PuppetedBy = PuppetedBy;
	Parms.Scale = Scale;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.StartAudioForBattle
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class USF_BlueprintLatentAction*        LatentAction                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::StartAudioForBattle(class USF_BlueprintLatentAction* LatentAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "StartAudioForBattle");

	Params::AC_jRPG_BattleManager_C_StartAudioForBattle Parms{};

	Parms.LatentAction = LatentAction;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.StartBattle
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// E_jRPG_EngageTypes                      EngageType                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::StartBattle(E_jRPG_EngageTypes EngageType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "StartBattle");

	Params::AC_jRPG_BattleManager_C_StartBattle Parms{};

	Parms.EngageType = EngageType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.StartBattleEndFlow
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// EBattleEndResult                        BattleEndResult                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::StartBattleEndFlow(EBattleEndResult BattleEndResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "StartBattleEndFlow");

	Params::AC_jRPG_BattleManager_C_StartBattleEndFlow Parms{};

	Parms.BattleEndResult = BattleEndResult;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.StartBattleNEW
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FFBattleStartParams&       BattleStartParams                                      (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::StartBattleNEW(const struct FFBattleStartParams& BattleStartParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "StartBattleNEW");

	Params::AC_jRPG_BattleManager_C_StartBattleNEW Parms{};

	Parms.BattleStartParams = std::move(BattleStartParams);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.StartBattleTransition
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class USF_BlueprintLatentAction*        TransitionIntroLatentAction                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::StartBattleTransition(class USF_BlueprintLatentAction* TransitionIntroLatentAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "StartBattleTransition");

	Params::AC_jRPG_BattleManager_C_StartBattleTransition Parms{};

	Parms.TransitionIntroLatentAction = TransitionIntroLatentAction;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.StartCharacterTurn
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_jRPG_Character_Battle_Base_C* Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::StartCharacterTurn(class ABP_jRPG_Character_Battle_Base_C* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "StartCharacterTurn");

	Params::AC_jRPG_BattleManager_C_StartCharacterTurn Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.StartCharacterTurn_Phase2
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::StartCharacterTurn_Phase2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "StartCharacterTurn_Phase2");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.StartCounterAttackInternal
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_jRPG_Character_Battle_Base_C* Source                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class ABP_jRPG_Character_Battle_Base_C* Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::StartCounterAttackInternal(class ABP_jRPG_Character_Battle_Base_C* Source, class ABP_jRPG_Character_Battle_Base_C* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "StartCounterAttackInternal");

	Params::AC_jRPG_BattleManager_C_StartCounterAttackInternal Parms{};

	Parms.Source = Source;
	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.StartFreeAimFromUI
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::StartFreeAimFromUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "StartFreeAimFromUI");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.StartFreezeFrame
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_FreezeFrame                           FreezeFrameType                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class USF_BlueprintLatentAction**       LatentAction                                           (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::StartFreezeFrame(E_FreezeFrame FreezeFrameType, class USF_BlueprintLatentAction** LatentAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "StartFreezeFrame");

	Params::AC_jRPG_BattleManager_C_StartFreezeFrame Parms{};

	Parms.FreezeFrameType = FreezeFrameType;

	UObject::ProcessEvent(Func, &Parms);

	if (LatentAction != nullptr)
		*LatentAction = Parms.LatentAction;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.StartPlayerTurnChoice
// (Public, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::StartPlayerTurnChoice()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "StartPlayerTurnChoice");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.StartPreloadingBattleDependencies
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::StartPreloadingBattleDependencies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "StartPreloadingBattleDependencies");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.StopBattleSystems
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::StopBattleSystems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "StopBattleSystems");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.SwitchCamera
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             PathID                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    RandomStartDistance                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Loop                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    UpdatePathLocation                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::SwitchCamera(class FName PathID, bool RandomStartDistance, bool Loop, bool UpdatePathLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "SwitchCamera");

	Params::AC_jRPG_BattleManager_C_SwitchCamera Parms{};

	Parms.PathID = PathID;
	Parms.RandomStartDistance = RandomStartDistance;
	Parms.Loop = Loop;
	Parms.UpdatePathLocation = UpdatePathLocation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.TODO_STARTBATTLE
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::TODO_STARTBATTLE()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "TODO_STARTBATTLE");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.TriggerBattleStartEvents
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class USF_BlueprintLatentAction*        LatentAction                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::TriggerBattleStartEvents(class USF_BlueprintLatentAction* LatentAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "TriggerBattleStartEvents");

	Params::AC_jRPG_BattleManager_C_TriggerBattleStartEvents Parms{};

	Parms.LatentAction = LatentAction;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.TriggerBattleStartEventsForCharacters
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class ABP_jRPG_Character_Battle_Base_C*>&CharactersToProcess                                    (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class USF_BlueprintLatentAction*        LatentAction                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::TriggerBattleStartEventsForCharacters(TArray<class ABP_jRPG_Character_Battle_Base_C*>& CharactersToProcess, class USF_BlueprintLatentAction* LatentAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "TriggerBattleStartEventsForCharacters");

	Params::AC_jRPG_BattleManager_C_TriggerBattleStartEventsForCharacters Parms{};

	Parms.CharactersToProcess = std::move(CharactersToProcess);
	Parms.LatentAction = LatentAction;

	UObject::ProcessEvent(Func, &Parms);

	CharactersToProcess = std::move(Parms.CharactersToProcess);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.TriggerBattleStartEventsInstant
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::TriggerBattleStartEventsInstant()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "TriggerBattleStartEventsInstant");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.TriggerSkill
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class ABP_jRPG_Character_Battle_Base_C*>&TargetedCharacters                                     (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class UAC_jRPG_CharacterBattleStats_C*  Source                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UClass*                           SkillClass                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::TriggerSkill(TArray<class ABP_jRPG_Character_Battle_Base_C*>& TargetedCharacters, class UAC_jRPG_CharacterBattleStats_C* Source, class UClass* SkillClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "TriggerSkill");

	Params::AC_jRPG_BattleManager_C_TriggerSkill Parms{};

	Parms.TargetedCharacters = std::move(TargetedCharacters);
	Parms.Source = Source;
	Parms.SkillClass = SkillClass;

	UObject::ProcessEvent(Func, &Parms);

	TargetedCharacters = std::move(Parms.TargetedCharacters);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.TriggerSkillCounter
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAC_jRPG_CharacterBattleStats_C*  TargetCharacterStats                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UAC_jRPG_CharacterBattleStats_C*  CounteringCharacterStats                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UClass*                           Skill                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::TriggerSkillCounter(class UAC_jRPG_CharacterBattleStats_C* TargetCharacterStats, class UAC_jRPG_CharacterBattleStats_C* CounteringCharacterStats, class UClass* Skill)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "TriggerSkillCounter");

	Params::AC_jRPG_BattleManager_C_TriggerSkillCounter Parms{};

	Parms.TargetCharacterStats = TargetCharacterStats;
	Parms.CounteringCharacterStats = CounteringCharacterStats;
	Parms.Skill = Skill;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.TryCounterAttack
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_BattleFeedbackState_C*        ParryState                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::TryCounterAttack(class UBP_BattleFeedbackState_C* ParryState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "TryCounterAttack");

	Params::AC_jRPG_BattleManager_C_TryCounterAttack Parms{};

	Parms.ParryState = ParryState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.TryForceUnregisterPendingResurrect
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class UAC_jRPG_CharacterBattleStats_C*&CharStats                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, InstancedReference, ReferenceParm, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::TryForceUnregisterPendingResurrect(const class UAC_jRPG_CharacterBattleStats_C*& CharStats)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "TryForceUnregisterPendingResurrect");

	Params::AC_jRPG_BattleManager_C_TryForceUnregisterPendingResurrect Parms{};

	Parms.CharStats = CharStats;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.TryGetInterceptingCharacter
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAC_jRPG_CharacterBattleStats_C*  TargetedCharacterStats                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UAC_jRPG_CharacterBattleStats_C*  AttackerCharacterStats                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UAC_jRPG_CharacterBattleStats_C** CharacterStats                                         (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::TryGetInterceptingCharacter(class UAC_jRPG_CharacterBattleStats_C* TargetedCharacterStats, class UAC_jRPG_CharacterBattleStats_C* AttackerCharacterStats, class UAC_jRPG_CharacterBattleStats_C** CharacterStats)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "TryGetInterceptingCharacter");

	Params::AC_jRPG_BattleManager_C_TryGetInterceptingCharacter Parms{};

	Parms.TargetedCharacterStats = TargetedCharacterStats;
	Parms.AttackerCharacterStats = AttackerCharacterStats;

	UObject::ProcessEvent(Func, &Parms);

	if (CharacterStats != nullptr)
		*CharacterStats = Parms.CharacterStats;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.TryGetTargetedAllies
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   Valid                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class ABP_jRPG_Character_Battle_Base_C*>*TargetedHeroes                                         (Parm, OutParm)

void UAC_jRPG_BattleManager_C::TryGetTargetedAllies(bool* Valid, TArray<class ABP_jRPG_Character_Battle_Base_C*>* TargetedHeroes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "TryGetTargetedAllies");

	Params::AC_jRPG_BattleManager_C_TryGetTargetedAllies Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Valid != nullptr)
		*Valid = Parms.Valid;

	if (TargetedHeroes != nullptr)
		*TargetedHeroes = std::move(Parms.TargetedHeroes);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.TryGradientCounterAttack
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_BattleFeedbackState_C*        ParryState                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::TryGradientCounterAttack(class UBP_BattleFeedbackState_C* ParryState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "TryGradientCounterAttack");

	Params::AC_jRPG_BattleManager_C_TryGradientCounterAttack Parms{};

	Parms.ParryState = ParryState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.TryLastStand
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_jRPG_Character_Battle_Base_C* CharacterBattle                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// EDamageReason                           DeathReason                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   HasLastStand                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::TryLastStand(class ABP_jRPG_Character_Battle_Base_C* CharacterBattle, EDamageReason DeathReason, bool* HasLastStand)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "TryLastStand");

	Params::AC_jRPG_BattleManager_C_TryLastStand Parms{};

	Parms.CharacterBattle = CharacterBattle;
	Parms.DeathReason = DeathReason;

	UObject::ProcessEvent(Func, &Parms);

	if (HasLastStand != nullptr)
		*HasLastStand = Parms.HasLastStand;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.TryProcessPendingBattleEnd
// (Public, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::TryProcessPendingBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "TryProcessPendingBattleEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.TryRemoveQueuedForcedNextCharacter
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class UAC_jRPG_CharacterBattleStats_C*&CharacterStats                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, InstancedReference, ReferenceParm, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::TryRemoveQueuedForcedNextCharacter(const class UAC_jRPG_CharacterBattleStats_C*& CharacterStats)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "TryRemoveQueuedForcedNextCharacter");

	Params::AC_jRPG_BattleManager_C_TryRemoveQueuedForcedNextCharacter Parms{};

	Parms.CharacterStats = CharacterStats;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.TryResumeBattle
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::TryResumeBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "TryResumeBattle");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.TryStealConsumableFromPlayer
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAC_jRPG_CharacterBattleStats_C*  Thief                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// const struct FDataTableRowHandle&       ConsumableDataRow                                      (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// int32                                   Quantity                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  RemovedQuantity                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::TryStealConsumableFromPlayer(class UAC_jRPG_CharacterBattleStats_C* Thief, const struct FDataTableRowHandle& ConsumableDataRow, int32 Quantity, int32* RemovedQuantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "TryStealConsumableFromPlayer");

	Params::AC_jRPG_BattleManager_C_TryStealConsumableFromPlayer Parms{};

	Parms.Thief = Thief;
	Parms.ConsumableDataRow = std::move(ConsumableDataRow);
	Parms.Quantity = Quantity;

	UObject::ProcessEvent(Func, &Parms);

	if (RemovedQuantity != nullptr)
		*RemovedQuantity = Parms.RemovedQuantity;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.UnlockNoDamageBossAchievement
// (Public, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::UnlockNoDamageBossAchievement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "UnlockNoDamageBossAchievement");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.UnregisterBattleListener
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TScriptInterface<class IBPI_BattleListener_C>&Item                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::UnregisterBattleListener(const TScriptInterface<class IBPI_BattleListener_C>& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "UnregisterBattleListener");

	Params::AC_jRPG_BattleManager_C_UnregisterBattleListener Parms{};

	Parms.Item = Item;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.UnspawnEnemies
// (Private, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::UnspawnEnemies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "UnspawnEnemies");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.UnspawnPlayerCharacters
// (Private, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::UnspawnPlayerCharacters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "UnspawnPlayerCharacters");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.UpdateBattleEndVictoryScreen
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UAC_jRPG_CharacterBattleStats_C*>&CharacterBattleStats                                   (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// struct FS_BattleRewards&                BattleRewards                                          (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::UpdateBattleEndVictoryScreen(TArray<class UAC_jRPG_CharacterBattleStats_C*>& CharacterBattleStats, struct FS_BattleRewards& BattleRewards)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "UpdateBattleEndVictoryScreen");

	Params::AC_jRPG_BattleManager_C_UpdateBattleEndVictoryScreen Parms{};

	Parms.CharacterBattleStats = std::move(CharacterBattleStats);
	Parms.BattleRewards = std::move(BattleRewards);

	UObject::ProcessEvent(Func, &Parms);

	CharacterBattleStats = std::move(Parms.CharacterBattleStats);
	BattleRewards = std::move(Parms.BattleRewards);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.UpdateBattleTurns
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::UpdateBattleTurns()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "UpdateBattleTurns");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.UpdateCharacterDataWithBattleFinalState
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::UpdateCharacterDataWithBattleFinalState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "UpdateCharacterDataWithBattleFinalState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.UpdateCharacterNextTurns
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::UpdateCharacterNextTurns()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "UpdateCharacterNextTurns");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.UpdateDefend
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FText&                      DebugReason                                            (BlueprintVisible, BlueprintReadOnly, Parm)

void UAC_jRPG_BattleManager_C::UpdateDefend(const class FText& DebugReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "UpdateDefend");

	Params::AC_jRPG_BattleManager_C_UpdateDefend Parms{};

	Parms.DebugReason = std::move(DebugReason);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.UpdateDefenseControls
// (BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::UpdateDefenseControls()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "UpdateDefenseControls");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.UpdateDummyMiddleCharacterLocation
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::UpdateDummyMiddleCharacterLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "UpdateDummyMiddleCharacterLocation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.UpdateFreeAimHover
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::UpdateFreeAimHover()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "UpdateFreeAimHover");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.UpdateMouseTargeting
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::UpdateMouseTargeting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "UpdateMouseTargeting");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.UpdateTargetingArrowsState
// (Private, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_BattleManager_C::UpdateTargetingArrowsState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "UpdateTargetingArrowsState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.Was Battle No Damage
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UAC_jRPG_BattleManager_C::Was_Battle_No_Damage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "Was Battle No Damage");

	Params::AC_jRPG_BattleManager_C_Was_Battle_No_Damage Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.CheckIfAlreadyLootedItem
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// TArray<struct FS_jRPG_Item_DynamicData>&LootedItems                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// class FName                             ItemHardcodedName                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   AlreadyLooted_                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  SlotIndex                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::CheckIfAlreadyLootedItem(TArray<struct FS_jRPG_Item_DynamicData>& LootedItems, class FName ItemHardcodedName, bool* AlreadyLooted_, int32* SlotIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "CheckIfAlreadyLootedItem");

	Params::AC_jRPG_BattleManager_C_CheckIfAlreadyLootedItem Parms{};

	Parms.LootedItems = std::move(LootedItems);
	Parms.ItemHardcodedName = ItemHardcodedName;

	UObject::ProcessEvent(Func, &Parms);

	LootedItems = std::move(Parms.LootedItems);

	if (AlreadyLooted_ != nullptr)
		*AlreadyLooted_ = Parms.AlreadyLooted_;

	if (SlotIndex != nullptr)
		*SlotIndex = Parms.SlotIndex;
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.ConcatActors
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// TArray<class AActor*>&                  Actors                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FText*                            Result                                                 (Parm, OutParm)

void UAC_jRPG_BattleManager_C::ConcatActors(TArray<class AActor*>& Actors, class FText* Result) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "ConcatActors");

	Params::AC_jRPG_BattleManager_C_ConcatActors Parms{};

	Parms.Actors = std::move(Actors);

	UObject::ProcessEvent(Func, &Parms);

	Actors = std::move(Parms.Actors);

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function AC_jRPG_BattleManager.AC_jRPG_BattleManager_C.GetQTEManager
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UBP_QTEManager_C**                QTEManager                                             (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_BattleManager_C::GetQTEManager(class UBP_QTEManager_C** QTEManager) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_BattleManager_C", "GetQTEManager");

	Params::AC_jRPG_BattleManager_C_GetQTEManager Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (QTEManager != nullptr)
		*QTEManager = Parms.QTEManager;
}

}

