#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: AC_jRPG_InventoryManager

#include "Basic.hpp"

#include "AC_jRPG_InventoryManager_classes.hpp"
#include "AC_jRPG_InventoryManager_parameters.hpp"


namespace SDK
{

// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.AddItemInstanceToInventory
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_ItemInstance_Base_C*          ItemInstance                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FS_LootContext&            LootContext                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::AddItemInstanceToInventory(class UBP_ItemInstance_Base_C* ItemInstance, int32 Amount, const struct FS_LootContext& LootContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "AddItemInstanceToInventory");

	Params::AC_jRPG_InventoryManager_C_AddItemInstanceToInventory Parms{};

	Parms.ItemInstance = ItemInstance;
	Parms.Amount = Amount;
	Parms.LootContext = std::move(LootContext);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.AddItemToInventory
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ItemHardcodedName                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FS_LootContext&            LootContext                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UBP_GeneratedItemInfo_Base_C**    GeneratedItem                                          (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::AddItemToInventory(class FName ItemHardcodedName, int32 Amount, const struct FS_LootContext& LootContext, class UBP_GeneratedItemInfo_Base_C** GeneratedItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "AddItemToInventory");

	Params::AC_jRPG_InventoryManager_C_AddItemToInventory Parms{};

	Parms.ItemHardcodedName = ItemHardcodedName;
	Parms.Amount = Amount;
	Parms.LootContext = std::move(LootContext);

	UObject::ProcessEvent(Func, &Parms);

	if (GeneratedItem != nullptr)
		*GeneratedItem = Parms.GeneratedItem;
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.AddMissingItemsFromCharacterSave
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FS_jRPG_CharacterSaveState&CharacterSaveState                                     (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::AddMissingItemsFromCharacterSave(const struct FS_jRPG_CharacterSaveState& CharacterSaveState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "AddMissingItemsFromCharacterSave");

	Params::AC_jRPG_InventoryManager_C_AddMissingItemsFromCharacterSave Parms{};

	Parms.CharacterSaveState = std::move(CharacterSaveState);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.BuyItem
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ItemHardcodedName                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::BuyItem(class FName ItemHardcodedName, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "BuyItem");

	Params::AC_jRPG_InventoryManager_C_BuyItem Parms{};

	Parms.ItemHardcodedName = ItemHardcodedName;

	UObject::ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.CalculateStatsComparisonOnEquip
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ItemHardcodedName                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::CalculateStatsComparisonOnEquip(class FName ItemHardcodedName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "CalculateStatsComparisonOnEquip");

	Params::AC_jRPG_InventoryManager_C_CalculateStatsComparisonOnEquip Parms{};

	Parms.ItemHardcodedName = ItemHardcodedName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.CanAffordItemCosts
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<struct FS_ItemQuantity>&         RequiredItem                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UAC_jRPG_InventoryManager_C::CanAffordItemCosts(TArray<struct FS_ItemQuantity>& RequiredItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "CanAffordItemCosts");

	Params::AC_jRPG_InventoryManager_C_CanAffordItemCosts Parms{};

	Parms.RequiredItem = std::move(RequiredItem);

	UObject::ProcessEvent(Func, &Parms);

	RequiredItem = std::move(Parms.RequiredItem);

	return Parms.ReturnValue;
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.CanAutoEquipConsumableShard
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UAC_jRPG_InventoryManager_C::CanAutoEquipConsumableShard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "CanAutoEquipConsumableShard");

	Params::AC_jRPG_InventoryManager_C_CanAutoEquipConsumableShard Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.CheckAmountOfItemInInventory
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             ItemHardcodedName                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  TotalAmountInInventory                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::CheckAmountOfItemInInventory(class FName ItemHardcodedName, int32* TotalAmountInInventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "CheckAmountOfItemInInventory");

	Params::AC_jRPG_InventoryManager_C_CheckAmountOfItemInInventory Parms{};

	Parms.ItemHardcodedName = ItemHardcodedName;

	UObject::ProcessEvent(Func, &Parms);

	if (TotalAmountInInventory != nullptr)
		*TotalAmountInInventory = Parms.TotalAmountInInventory;
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.CheckAmountOfItemTypeInInventory
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_jRPG_ItemType                         ItemType                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_jRPG_ItemSubtype                      ItemSubtype                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  TotalAmountInInventory                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::CheckAmountOfItemTypeInInventory(E_jRPG_ItemType ItemType, E_jRPG_ItemSubtype ItemSubtype, int32* TotalAmountInInventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "CheckAmountOfItemTypeInInventory");

	Params::AC_jRPG_InventoryManager_C_CheckAmountOfItemTypeInInventory Parms{};

	Parms.ItemType = ItemType;
	Parms.ItemSubtype = ItemSubtype;

	UObject::ProcessEvent(Func, &Parms);

	if (TotalAmountInInventory != nullptr)
		*TotalAmountInInventory = Parms.TotalAmountInInventory;
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.CheckIfCanUnequipItemToInventory
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             ItemHardcodedName                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::CheckIfCanUnequipItemToInventory(class FName ItemHardcodedName, bool* Success_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "CheckIfCanUnequipItemToInventory");

	Params::AC_jRPG_InventoryManager_C_CheckIfCanUnequipItemToInventory Parms{};

	Parms.ItemHardcodedName = ItemHardcodedName;

	UObject::ProcessEvent(Func, &Parms);

	if (Success_ != nullptr)
		*Success_ = Parms.Success_;
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.CheckIfItemCanBeBought
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ItemId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   CanBeBought                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::CheckIfItemCanBeBought(class FName ItemId, bool* CanBeBought)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "CheckIfItemCanBeBought");

	Params::AC_jRPG_InventoryManager_C_CheckIfItemCanBeBought Parms{};

	Parms.ItemId = ItemId;

	UObject::ProcessEvent(Func, &Parms);

	if (CanBeBought != nullptr)
		*CanBeBought = Parms.CanBeBought;
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.CheckIfThereIsAmountOfItemInInventory
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ItemHardcodedName                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::CheckIfThereIsAmountOfItemInInventory(class FName ItemHardcodedName, int32 Amount, bool* Success_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "CheckIfThereIsAmountOfItemInInventory");

	Params::AC_jRPG_InventoryManager_C_CheckIfThereIsAmountOfItemInInventory Parms{};

	Parms.ItemHardcodedName = ItemHardcodedName;
	Parms.Amount = Amount;

	UObject::ProcessEvent(Func, &Parms);

	if (Success_ != nullptr)
		*Success_ = Parms.Success_;
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.CheckIfThereIsFreeSlotInInventory
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   Success_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::CheckIfThereIsFreeSlotInInventory(bool* Success_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "CheckIfThereIsFreeSlotInInventory");

	Params::AC_jRPG_InventoryManager_C_CheckIfThereIsFreeSlotInInventory Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Success_ != nullptr)
		*Success_ = Parms.Success_;
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.CheckIfThereIsItemInInventory
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ItemHardcodedName                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsItemFullyStacked_                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  ItemIndex                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::CheckIfThereIsItemInInventory(class FName ItemHardcodedName, bool* Success_, bool* IsItemFullyStacked_, int32* ItemIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "CheckIfThereIsItemInInventory");

	Params::AC_jRPG_InventoryManager_C_CheckIfThereIsItemInInventory Parms{};

	Parms.ItemHardcodedName = ItemHardcodedName;

	UObject::ProcessEvent(Func, &Parms);

	if (Success_ != nullptr)
		*Success_ = Parms.Success_;

	if (IsItemFullyStacked_ != nullptr)
		*IsItemFullyStacked_ = Parms.IsItemFullyStacked_;

	if (ItemIndex != nullptr)
		*ItemIndex = Parms.ItemIndex;
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.CheckIfThereIsNotFullyStackedItemInInventory
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ItemHardcodedName                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  ItemIndex                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::CheckIfThereIsNotFullyStackedItemInInventory(class FName ItemHardcodedName, bool* Success_, int32* ItemIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "CheckIfThereIsNotFullyStackedItemInInventory");

	Params::AC_jRPG_InventoryManager_C_CheckIfThereIsNotFullyStackedItemInInventory Parms{};

	Parms.ItemHardcodedName = ItemHardcodedName;

	UObject::ProcessEvent(Func, &Parms);

	if (Success_ != nullptr)
		*Success_ = Parms.Success_;

	if (ItemIndex != nullptr)
		*ItemIndex = Parms.ItemIndex;
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.CreateReferenceToInventoryWindow
// (Public, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_InventoryManager_C::CreateReferenceToInventoryWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "CreateReferenceToInventoryWindow");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.CreateReferenceToVendorWindow
// (Public, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_InventoryManager_C::CreateReferenceToVendorWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "CreateReferenceToVendorWindow");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.DEBUG_ShowDebugText
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_InventoryManager_C::DEBUG_ShowDebugText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "DEBUG_ShowDebugText");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.EquipItem
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ItemHardcodedName                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             CharacterName                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::EquipItem(class FName ItemHardcodedName, class FName CharacterName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "EquipItem");

	Params::AC_jRPG_InventoryManager_C_EquipItem Parms{};

	Parms.ItemHardcodedName = ItemHardcodedName;
	Parms.CharacterName = CharacterName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.EquipItem_DEPRECATED
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ItemHardcodedName                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::EquipItem_DEPRECATED(class FName ItemHardcodedName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "EquipItem_DEPRECATED");

	Params::AC_jRPG_InventoryManager_C_EquipItem_DEPRECATED Parms{};

	Parms.ItemHardcodedName = ItemHardcodedName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.ExecuteUbergraph_AC_jRPG_InventoryManager
// (Final, UbergraphFunction)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::ExecuteUbergraph_AC_jRPG_InventoryManager(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "ExecuteUbergraph_AC_jRPG_InventoryManager");

	Params::AC_jRPG_InventoryManager_C_ExecuteUbergraph_AC_jRPG_InventoryManager Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.FindItemCountFromInventory
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ItemHardcodedName                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  Quantity                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::FindItemCountFromInventory(class FName ItemHardcodedName, int32* Quantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "FindItemCountFromInventory");

	Params::AC_jRPG_InventoryManager_C_FindItemCountFromInventory Parms{};

	Parms.ItemHardcodedName = ItemHardcodedName;

	UObject::ProcessEvent(Func, &Parms);

	if (Quantity != nullptr)
		*Quantity = Parms.Quantity;
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.FindItemDynamicFromInventory
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ItemHardcodedName                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FS_jRPG_Item_DynamicData*        ItemStruct                                             (Parm, OutParm, ContainsInstancedReference, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::FindItemDynamicFromInventory(class FName ItemHardcodedName, bool* Found, struct FS_jRPG_Item_DynamicData* ItemStruct)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "FindItemDynamicFromInventory");

	Params::AC_jRPG_InventoryManager_C_FindItemDynamicFromInventory Parms{};

	Parms.ItemHardcodedName = ItemHardcodedName;

	UObject::ProcessEvent(Func, &Parms);

	if (Found != nullptr)
		*Found = Parms.Found;

	if (ItemStruct != nullptr)
		*ItemStruct = std::move(Parms.ItemStruct);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.GetAllEquipableItems
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_jRPG_ItemType                         ItemType                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const TSet<E_jRPG_ItemSubtype>&         AvailableSubtypes                                      (BlueprintVisible, BlueprintReadOnly, Parm)
// TArray<struct FS_jRPG_Item_DynamicData>*EquipableItems                                         (Parm, OutParm, ContainsInstancedReference)

void UAC_jRPG_InventoryManager_C::GetAllEquipableItems(E_jRPG_ItemType ItemType, const TSet<E_jRPG_ItemSubtype>& AvailableSubtypes, TArray<struct FS_jRPG_Item_DynamicData>* EquipableItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "GetAllEquipableItems");

	Params::AC_jRPG_InventoryManager_C_GetAllEquipableItems Parms{};

	Parms.ItemType = ItemType;
	Parms.AvailableSubtypes = std::move(AvailableSubtypes);

	UObject::ProcessEvent(Func, &Parms);

	if (EquipableItems != nullptr)
		*EquipableItems = std::move(Parms.EquipableItems);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.GetCharactersForWeapon
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FS_jRPG_Item_StaticData&   ItemStatic                                             (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)
// TArray<class UBP_CharacterData_C*>      ReturnValue                                            (Parm, OutParm, ReturnParm)

TArray<class UBP_CharacterData_C*> UAC_jRPG_InventoryManager_C::GetCharactersForWeapon(const struct FS_jRPG_Item_StaticData& ItemStatic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "GetCharactersForWeapon");

	Params::AC_jRPG_InventoryManager_C_GetCharactersForWeapon Parms{};

	Parms.ItemStatic = std::move(ItemStatic);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.GetCharactersWithItemEquipped
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ItemId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FFCharacterAssignedEquipment>*AssignedEquipment                                      (Parm, OutParm)

void UAC_jRPG_InventoryManager_C::GetCharactersWithItemEquipped(class FName ItemId, TArray<struct FFCharacterAssignedEquipment>* AssignedEquipment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "GetCharactersWithItemEquipped");

	Params::AC_jRPG_InventoryManager_C_GetCharactersWithItemEquipped Parms{};

	Parms.ItemId = ItemId;

	UObject::ProcessEvent(Func, &Parms);

	if (AssignedEquipment != nullptr)
		*AssignedEquipment = std::move(Parms.AssignedEquipment);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.GetConsumables
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FS_jRPG_Item_DynamicData>*FilteredArray                                          (Parm, OutParm, ContainsInstancedReference)

void UAC_jRPG_InventoryManager_C::GetConsumables(TArray<struct FS_jRPG_Item_DynamicData>* FilteredArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "GetConsumables");

	Params::AC_jRPG_InventoryManager_C_GetConsumables Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (FilteredArray != nullptr)
		*FilteredArray = std::move(Parms.FilteredArray);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.GetConsumablesShards
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FS_jRPG_Item_DynamicData>*FilteredArray                                          (Parm, OutParm, ContainsInstancedReference)

void UAC_jRPG_InventoryManager_C::GetConsumablesShards(TArray<struct FS_jRPG_Item_DynamicData>* FilteredArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "GetConsumablesShards");

	Params::AC_jRPG_InventoryManager_C_GetConsumablesShards Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (FilteredArray != nullptr)
		*FilteredArray = std::move(Parms.FilteredArray);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.GetItemDefinitionFromID
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ItemId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FS_jRPG_Item_StaticData          ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, HasGetValueTypeHash)

struct FS_jRPG_Item_StaticData UAC_jRPG_InventoryManager_C::GetItemDefinitionFromID(class FName ItemId, bool* Found)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "GetItemDefinitionFromID");

	Params::AC_jRPG_InventoryManager_C_GetItemDefinitionFromID Parms{};

	Parms.ItemId = ItemId;

	UObject::ProcessEvent(Func, &Parms);

	if (Found != nullptr)
		*Found = Parms.Found;

	return Parms.ReturnValue;
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.GetItemDynamicFromInventory
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             ItemHardcodedName                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FS_jRPG_Item_DynamicData*        ItemStruct                                             (Parm, OutParm, ContainsInstancedReference, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::GetItemDynamicFromInventory(class FName ItemHardcodedName, struct FS_jRPG_Item_DynamicData* ItemStruct)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "GetItemDynamicFromInventory");

	Params::AC_jRPG_InventoryManager_C_GetItemDynamicFromInventory Parms{};

	Parms.ItemHardcodedName = ItemHardcodedName;

	UObject::ProcessEvent(Func, &Parms);

	if (ItemStruct != nullptr)
		*ItemStruct = std::move(Parms.ItemStruct);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.GetItemStackMaxCount
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FS_jRPG_Item_StaticData&   ItemStaticData                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

int32 UAC_jRPG_InventoryManager_C::GetItemStackMaxCount(const struct FS_jRPG_Item_StaticData& ItemStaticData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "GetItemStackMaxCount");

	Params::AC_jRPG_InventoryManager_C_GetItemStackMaxCount Parms{};

	Parms.ItemStaticData = std::move(ItemStaticData);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.GetItemStructFromInventory
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             ItemHardcodedName                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FS_jRPG_Item_StaticData*         ItemStruct                                             (Parm, OutParm, ContainsInstancedReference, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::GetItemStructFromInventory(class FName ItemHardcodedName, struct FS_jRPG_Item_StaticData* ItemStruct)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "GetItemStructFromInventory");

	Params::AC_jRPG_InventoryManager_C_GetItemStructFromInventory Parms{};

	Parms.ItemHardcodedName = ItemHardcodedName;

	UObject::ProcessEvent(Func, &Parms);

	if (ItemStruct != nullptr)
		*ItemStruct = std::move(Parms.ItemStruct);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.GetItemTypeMetadata
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_jRPG_ItemType                         ItemType                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FS_InventoryItemTypeMetadata*    ItemTypeMetadata                                       (Parm, OutParm, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::GetItemTypeMetadata(E_jRPG_ItemType ItemType, bool* Found, struct FS_InventoryItemTypeMetadata* ItemTypeMetadata)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "GetItemTypeMetadata");

	Params::AC_jRPG_InventoryManager_C_GetItemTypeMetadata Parms{};

	Parms.ItemType = ItemType;

	UObject::ProcessEvent(Func, &Parms);

	if (Found != nullptr)
		*Found = Parms.Found;

	if (ItemTypeMetadata != nullptr)
		*ItemTypeMetadata = std::move(Parms.ItemTypeMetadata);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.GetNotificationPoolTagFromItemType
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_jRPG_ItemType                         Index_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash)

struct FGameplayTag UAC_jRPG_InventoryManager_C::GetNotificationPoolTagFromItemType(E_jRPG_ItemType Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "GetNotificationPoolTagFromItemType");

	Params::AC_jRPG_InventoryManager_C_GetNotificationPoolTagFromItemType Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.GetOwnedItemsByType
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_jRPG_ItemType                         ItemType                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_jRPG_ItemSubtype                      ItemSubtype                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IncludeHidden                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FS_jRPG_Item_DynamicData>*FilteredArray                                          (Parm, OutParm, ContainsInstancedReference)

void UAC_jRPG_InventoryManager_C::GetOwnedItemsByType(E_jRPG_ItemType ItemType, E_jRPG_ItemSubtype ItemSubtype, bool IncludeHidden, TArray<struct FS_jRPG_Item_DynamicData>* FilteredArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "GetOwnedItemsByType");

	Params::AC_jRPG_InventoryManager_C_GetOwnedItemsByType Parms{};

	Parms.ItemType = ItemType;
	Parms.ItemSubtype = ItemSubtype;
	Parms.IncludeHidden = IncludeHidden;

	UObject::ProcessEvent(Func, &Parms);

	if (FilteredArray != nullptr)
		*FilteredArray = std::move(Parms.FilteredArray);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.GetPartyHealConsumable
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName*                            Row_Name                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::GetPartyHealConsumable(class FName* Row_Name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "GetPartyHealConsumable");

	Params::AC_jRPG_InventoryManager_C_GetPartyHealConsumable Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Row_Name != nullptr)
		*Row_Name = Parms.Row_Name;
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.GetPartyHealShard
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName*                            Row_Name                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::GetPartyHealShard(class FName* Row_Name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "GetPartyHealShard");

	Params::AC_jRPG_InventoryManager_C_GetPartyHealShard Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Row_Name != nullptr)
		*Row_Name = Parms.Row_Name;
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.GetProperEquipmentChangeSlot
// (Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   SlotIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::GetProperEquipmentChangeSlot(int32 SlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "GetProperEquipmentChangeSlot");

	Params::AC_jRPG_InventoryManager_C_GetProperEquipmentChangeSlot Parms{};

	Parms.SlotIndex = SlotIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.GetProperInventorySlotWidget
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   ItemIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::GetProperInventorySlotWidget(int32 ItemIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "GetProperInventorySlotWidget");

	Params::AC_jRPG_InventoryManager_C_GetProperInventorySlotWidget Parms{};

	Parms.ItemIndex = ItemIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.GetProperUseItemOnCharacterSlotWidget
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   SlotIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::GetProperUseItemOnCharacterSlotWidget(int32 SlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "GetProperUseItemOnCharacterSlotWidget");

	Params::AC_jRPG_InventoryManager_C_GetProperUseItemOnCharacterSlotWidget Parms{};

	Parms.SlotIndex = SlotIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.GetProperVendorSlot
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Index_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::GetProperVendorSlot(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "GetProperVendorSlot");

	Params::AC_jRPG_InventoryManager_C_GetProperVendorSlot Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.GetStacksLeftForItem
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ItemId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   HasExistingStack                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  ItemIndex                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  StackLeft                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  StackCount                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::GetStacksLeftForItem(class FName ItemId, bool* HasExistingStack, int32* ItemIndex, int32* StackLeft, int32* StackCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "GetStacksLeftForItem");

	Params::AC_jRPG_InventoryManager_C_GetStacksLeftForItem Parms{};

	Parms.ItemId = ItemId;

	UObject::ProcessEvent(Func, &Parms);

	if (HasExistingStack != nullptr)
		*HasExistingStack = Parms.HasExistingStack;

	if (ItemIndex != nullptr)
		*ItemIndex = Parms.ItemIndex;

	if (StackLeft != nullptr)
		*StackLeft = Parms.StackLeft;

	if (StackCount != nullptr)
		*StackCount = Parms.StackCount;
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.GetWeaponsForCharacter
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_CharacterData_C*              CharacterData                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// TArray<struct FS_jRPG_Item_DynamicData>*WeaponsDynamicData                                     (Parm, OutParm, ContainsInstancedReference)

void UAC_jRPG_InventoryManager_C::GetWeaponsForCharacter(class UBP_CharacterData_C* CharacterData, TArray<struct FS_jRPG_Item_DynamicData>* WeaponsDynamicData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "GetWeaponsForCharacter");

	Params::AC_jRPG_InventoryManager_C_GetWeaponsForCharacter Parms{};

	Parms.CharacterData = CharacterData;

	UObject::ProcessEvent(Func, &Parms);

	if (WeaponsDynamicData != nullptr)
		*WeaponsDynamicData = std::move(Parms.WeaponsDynamicData);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.IsThereNotifiedCustomizationForCharacter
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_CharacterData_C*              CharacterData                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsNotified                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::IsThereNotifiedCustomizationForCharacter(class UBP_CharacterData_C* CharacterData, bool* IsNotified)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "IsThereNotifiedCustomizationForCharacter");

	Params::AC_jRPG_InventoryManager_C_IsThereNotifiedCustomizationForCharacter Parms{};

	Parms.CharacterData = CharacterData;

	UObject::ProcessEvent(Func, &Parms);

	if (IsNotified != nullptr)
		*IsNotified = Parms.IsNotified;
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.IsThereNotifiedWeaponForCharacter
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_CharacterData_C*              CharacterData                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsNotified                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::IsThereNotifiedWeaponForCharacter(class UBP_CharacterData_C* CharacterData, bool* IsNotified)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "IsThereNotifiedWeaponForCharacter");

	Params::AC_jRPG_InventoryManager_C_IsThereNotifiedWeaponForCharacter Parms{};

	Parms.CharacterData = CharacterData;

	UObject::ProcessEvent(Func, &Parms);

	if (IsNotified != nullptr)
		*IsNotified = Parms.IsNotified;
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.MarkItemAsRead
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FS_jRPG_Item_StaticData&   ItemData                                               (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)
// class UUserWidget*                      Mark_Caller                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::MarkItemAsRead(const struct FS_jRPG_Item_StaticData& ItemData, class UUserWidget* Mark_Caller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "MarkItemAsRead");

	Params::AC_jRPG_InventoryManager_C_MarkItemAsRead Parms{};

	Parms.ItemData = std::move(ItemData);
	Parms.Mark_Caller = Mark_Caller;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.NotifyItem
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FS_jRPG_Item_StaticData&   ItemData                                               (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::NotifyItem(const struct FS_jRPG_Item_StaticData& ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "NotifyItem");

	Params::AC_jRPG_InventoryManager_C_NotifyItem Parms{};

	Parms.ItemData = std::move(ItemData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.OnInitializeComponent
// (Event, Public, BlueprintEvent)

void UAC_jRPG_InventoryManager_C::OnInitializeComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "OnInitializeComponent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.OnItemRemovedFromInventory
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_jRPG_Item_StaticData&         ItemStaticData                                         (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash)
// int32                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::OnItemRemovedFromInventory(struct FS_jRPG_Item_StaticData& ItemStaticData, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "OnItemRemovedFromInventory");

	Params::AC_jRPG_InventoryManager_C_OnItemRemovedFromInventory Parms{};

	Parms.ItemStaticData = std::move(ItemStaticData);
	Parms.Amount = Amount;

	UObject::ProcessEvent(Func, &Parms);

	ItemStaticData = std::move(Parms.ItemStaticData);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.OnVendorItemSold
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             VendorID                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             ItemId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Quantity                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::OnVendorItemSold(class FName VendorID, class FName ItemId, int32 Quantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "OnVendorItemSold");

	Params::AC_jRPG_InventoryManager_C_OnVendorItemSold Parms{};

	Parms.VendorID = VendorID;
	Parms.ItemId = ItemId;
	Parms.Quantity = Quantity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.ReceiveGold
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   GoldAmount                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const class FString&                    Reason                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::ReceiveGold(int32 GoldAmount, const class FString& Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "ReceiveGold");

	Params::AC_jRPG_InventoryManager_C_ReceiveGold Parms{};

	Parms.GoldAmount = GoldAmount;
	Parms.Reason = std::move(Reason);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "ReceiveTick");

	Params::AC_jRPG_InventoryManager_C_ReceiveTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.RefillConsumables
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_InventoryManager_C::RefillConsumables()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "RefillConsumables");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.RefreshAllInventorySlots
// (Public, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_InventoryManager_C::RefreshAllInventorySlots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "RefreshAllInventorySlots");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.RefreshGoldAmount
// (Public, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_InventoryManager_C::RefreshGoldAmount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "RefreshGoldAmount");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.RefreshInventorySlot
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   SlotIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::RefreshInventorySlot(int32 SlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "RefreshInventorySlot");

	Params::AC_jRPG_InventoryManager_C_RefreshInventorySlot Parms{};

	Parms.SlotIndex = SlotIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.RefreshInventorySlotAfterDiscarding
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   SlotIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::RefreshInventorySlotAfterDiscarding(int32 SlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "RefreshInventorySlotAfterDiscarding");

	Params::AC_jRPG_InventoryManager_C_RefreshInventorySlotAfterDiscarding Parms{};

	Parms.SlotIndex = SlotIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.RefreshItemDetails
// (Public, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_InventoryManager_C::RefreshItemDetails()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "RefreshItemDetails");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.RefreshUseItemOnCharacterSlots
// (Private, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_InventoryManager_C::RefreshUseItemOnCharacterSlots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "RefreshUseItemOnCharacterSlots");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.RefreshVendorItemDetails
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ShowItemFromInventory                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::RefreshVendorItemDetails(bool ShowItemFromInventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "RefreshVendorItemDetails");

	Params::AC_jRPG_InventoryManager_C_RefreshVendorItemDetails Parms{};

	Parms.ShowItemFromInventory = ShowItemFromInventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.ReleaseInventorySlot
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   InventorySlot                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::ReleaseInventorySlot(int32 InventorySlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "ReleaseInventorySlot");

	Params::AC_jRPG_InventoryManager_C_ReleaseInventorySlot Parms{};

	Parms.InventorySlot = InventorySlot;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.RemoveAllItemsOfType
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_jRPG_ItemType                         ItemType                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::RemoveAllItemsOfType(E_jRPG_ItemType ItemType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "RemoveAllItemsOfType");

	Params::AC_jRPG_InventoryManager_C_RemoveAllItemsOfType Parms{};

	Parms.ItemType = ItemType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.RemoveItemFromInventory
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ItemHardcodedName                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    KeepEmptyStack                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::RemoveItemFromInventory(class FName ItemHardcodedName, int32 Amount, bool KeepEmptyStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "RemoveItemFromInventory");

	Params::AC_jRPG_InventoryManager_C_RemoveItemFromInventory Parms{};

	Parms.ItemHardcodedName = ItemHardcodedName;
	Parms.Amount = Amount;
	Parms.KeepEmptyStack = KeepEmptyStack;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.ResetInventory
// (Public, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_InventoryManager_C::ResetInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "ResetInventory");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.ResetInventoryForNewGamePlus
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_InventoryManager_C::ResetInventoryForNewGamePlus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "ResetInventoryForNewGamePlus");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.SelectItemToUse
// (Public, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_InventoryManager_C::SelectItemToUse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "SelectItemToUse");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.SetShouldDispatchModifications
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ShouldDispatch                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::SetShouldDispatchModifications(bool ShouldDispatch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "SetShouldDispatchModifications");

	Params::AC_jRPG_InventoryManager_C_SetShouldDispatchModifications Parms{};

	Parms.ShouldDispatch = ShouldDispatch;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.ShouldItemBeNotified
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FS_jRPG_Item_StaticData&   ItemData                                               (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)
// bool*                                   IsNotified                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::ShouldItemBeNotified(const struct FS_jRPG_Item_StaticData& ItemData, bool* IsNotified)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "ShouldItemBeNotified");

	Params::AC_jRPG_InventoryManager_C_ShouldItemBeNotified Parms{};

	Parms.ItemData = std::move(ItemData);

	UObject::ProcessEvent(Func, &Parms);

	if (IsNotified != nullptr)
		*IsNotified = Parms.IsNotified;
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.ShouldRefillConsumableShard
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const class FName&                      ItemToFind                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UAC_jRPG_InventoryManager_C::ShouldRefillConsumableShard(const class FName& ItemToFind)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "ShouldRefillConsumableShard");

	Params::AC_jRPG_InventoryManager_C_ShouldRefillConsumableShard Parms{};

	Parms.ItemToFind = ItemToFind;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.ShowAllEquipableItems
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_jRPG_ItemType                         ItemType                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::ShowAllEquipableItems(E_jRPG_ItemType ItemType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "ShowAllEquipableItems");

	Params::AC_jRPG_InventoryManager_C_ShowAllEquipableItems Parms{};

	Parms.ItemType = ItemType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.ShowDiscardWindow
// (Public, BlueprintCallable, BlueprintEvent)

void UAC_jRPG_InventoryManager_C::ShowDiscardWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "ShowDiscardWindow");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.ShowItemsToBuy
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   SlotToFocus                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::ShowItemsToBuy(int32 SlotToFocus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "ShowItemsToBuy");

	Params::AC_jRPG_InventoryManager_C_ShowItemsToBuy Parms{};

	Parms.SlotToFocus = SlotToFocus;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.ShowItemsToSell
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   SlotToFocus                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::ShowItemsToSell(int32 SlotToFocus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "ShowItemsToSell");

	Params::AC_jRPG_InventoryManager_C_ShowItemsToSell Parms{};

	Parms.SlotToFocus = SlotToFocus;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.ShowLootNotificationInDialogue
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_GeneratedItemInfo_Base_C*     GeneratedItemInfo                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const struct FS_jRPG_Item_StaticData&   ItemData                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::ShowLootNotificationInDialogue(class UBP_GeneratedItemInfo_Base_C* GeneratedItemInfo, const struct FS_jRPG_Item_StaticData& ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "ShowLootNotificationInDialogue");

	Params::AC_jRPG_InventoryManager_C_ShowLootNotificationInDialogue Parms{};

	Parms.GeneratedItemInfo = GeneratedItemInfo;
	Parms.ItemData = std::move(ItemData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.TrySpendGold
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   GoldAmount                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const class FString&                    Reason                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::TrySpendGold(int32 GoldAmount, const class FString& Reason, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "TrySpendGold");

	Params::AC_jRPG_InventoryManager_C_TrySpendGold Parms{};

	Parms.GoldAmount = GoldAmount;
	Parms.Reason = std::move(Reason);

	UObject::ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.UnequipItem
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_jRPG_ItemType                         ItemType                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::UnequipItem(E_jRPG_ItemType ItemType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "UnequipItem");

	Params::AC_jRPG_InventoryManager_C_UnequipItem Parms{};

	Parms.ItemType = ItemType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C.UseItemOnCharacter
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ItemToUse_0                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             CharacterHardcodedName                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAC_jRPG_InventoryManager_C::UseItemOnCharacter(class FName ItemToUse_0, class FName CharacterHardcodedName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AC_jRPG_InventoryManager_C", "UseItemOnCharacter");

	Params::AC_jRPG_InventoryManager_C_UseItemOnCharacter Parms{};

	Parms.ItemToUse_0 = ItemToUse_0;
	Parms.CharacterHardcodedName = CharacterHardcodedName;

	UObject::ProcessEvent(Func, &Parms);
}

}

