#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_BattleDamages

#include "Basic.hpp"

#include "FDamageModifier_structs.hpp"
#include "EAttackType_structs.hpp"
#include "EElementalAffinity_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "EDamageValueState_structs.hpp"
#include "EDamageReason_structs.hpp"
#include "EMissReason_structs.hpp"
#include "ECharacterTeamSelector_structs.hpp"
#include "SandFall_classes.hpp"
#include "E_jRPG_StatType_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass BP_BattleDamages.BP_BattleDamages_C
// 0x00A8 (0x0388 - 0x02E0)
class UBP_BattleDamages_C final : public USF_ExtendedUserWidget
{
public:
	double                                        CurrentInputDamages_Base;                          // 0x02E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsFinalDamageInitialized;                          // 0x02E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2E9[0x7];                                      // 0x02E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAC_jRPG_CharacterBattleStats_C*        SourceCharacter;                                   // 0x02F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	class UAC_jRPG_CharacterBattleStats_C*        TargetCharacter;                                   // 0x02F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          logEnabled;                                        // 0x0300(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IgnoreTargetDefense;                               // 0x0301(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EAttackType                                   InputAttackElement;                                // 0x0302(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	EAttackType                                   FinalAttackElement;                                // 0x0303(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsCriticalHit;                                     // 0x0304(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EDamageReason                                 DamageReason;                                      // 0x0305(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	uint8                                         Pad_306[0x2];                                      // 0x0306(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DamageWorldLocation;                               // 0x0308(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        DamageBaseBeforeTargetHPClamp;                     // 0x0320(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EElementalAffinity                            BaseTypeAffinity;                                  // 0x0328(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_329[0x7];                                      // 0x0329(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWBP_Debug_BattleDamageDetails_C*       DEBUG_LogWidget;                                   // 0x0330(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	double                                        InputDamageMultiplier;                             // 0x0338(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	double                                        CriticalRoll;                                      // 0x0340(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<struct FFDamageModifier>               ActiveModifiers;                                   // 0x0348(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	EDamageValueState                             ValueState_AttackElement;                          // 0x0358(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EDamageValueState                             ValueState_CriticalHitRoll;                        // 0x0359(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          FinalLock;                                         // 0x035A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsAbsorbedByShield;                                // 0x035B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_35C[0x4];                                      // 0x035C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        ExtraCriticalHitChance;                            // 0x0360(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        ExtraCriticalHitDamageMultiplier;                  // 0x0368(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        BreakBarDamageMultiplier;                          // 0x0370(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UBP_BattleDamageBuilder_C*              SourceDamageBuilder;                               // 0x0378(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	EMissReason                                   MissReason;                                        // 0x0380(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

public:
	void AddAttackPowerModifier(const struct FFDamageModifier& Modifier);
	void AddBreakBarDamageMultiplier(double Multiplier, const class FString& Reason);
	void AddCriticalHitExtraChance(double Chance__0_0_1_0, const class FString& DebugReason);
	void AddDamageModifier(const struct FFDamageModifier& Modifier);
	void AddModifierInternal(const struct FFDamageModifier& Modifier);
	void ApplyActiveModifiers();
	void ApplyAffinitiesModifiers();
	void ApplyClamp();
	void ApplyCommonDamageMultipliers();
	void ApplyCriticalHitModifiers(bool* IsCriticalHit_0);
	void ApplyDeathtouch();
	void ApplyDebugOverrides();
	void ApplyDefense();
	void ApplyStraightDamages(double StraightDamage);
	void ApplyTargetClampAndRounding();
	double CalculateDefense(double AttackPower, double Defense);
	void Cancel(EMissReason MissReason_0, const class FString& DebugReason);
	void CheckEditableValue_Modify(EDamageValueState Selection, const class FString& ValueName, const class FString& ChangeReason, bool* Allowed);
	void CheckEditableValue_GetFinalValue(EDamageValueState Selection, bool* Allowed);
	void CheckValidReason(const class FText& Reason, const class FString& Context);
	void ComputeDamageModifiers(TArray<struct FFDamageModifier>& Modifiers, double InputBase, double* base, TArray<class FText>* DamageLogs);
	void Finish();
	void GetAffinityType(EElementalAffinity* BaseTypeAffinity_0);
	double GetBreakBarDamageMultiplier();
	void GetCriticalRollToBeat(double* Value);
	void GetFeedbackReason(bool* HasFeedback, class FText* FeedbackReasonText, struct FLinearColor* FeedbackReasonColor);
	void GetFinalBaseElement(EAttackType* AttackElement);
	int64 GetFinalBreakBarDamageAmount();
	class USoundBase* GetHitSoundOverride();
	bool GetIgnoreMarkedRemoval();
	void GetInputBaseElement(EAttackType* InputAttackType);
	double GetInputDamageMultiplier();
	void GetIsCriticalHit(bool* IsCritical);
	void GetIsResistant(bool* IsResistant);
	void GetIsWeakness(bool* IsWeakness);
	EMissReason GetMissReason();
	void GetTargetCharacter(class UAC_jRPG_CharacterBattleStats_C** NewParam);
	void Init();
	void InitAffinities();
	void InitFinalDamages();
	bool IsDeathtouch();
	void LoadFromBuilder(class UBP_BattleDamageBuilder_C* Builder);
	void LogModifier(const class FText& Text);
	void ModifyBaseDamageElement(EAttackType NewAttackType, const class FText& Reason);
	void ModifyFloatRef(double& TargetVariable, double NewValue, const class FString& VarName, const class FText& Reason);
	void NotifyListeners();
	void OverrideWithEffectiveDamage(double FinalDamage);
	void PrintMessage(const class FText& Message);
	void ProcessBaseElement();
	void RollCriticalHit(bool* IsCriticalHit_0);
	void Set_Ignore_Target_Defense(bool Ignore);
	void SetAbsorbedByShield();
	void SetAffinities(EElementalAffinity BaseTypeAffinity_0);
	void SetIgnoreMarkedRemoval();
	void SetIgnoreShields();
	void SetIsCriticalHit(bool IsCritical, const class FString& DebugReason);
	void SetMissReason(EMissReason MissReason_0);
	void TryAddLog(const class FText& Reason, double PreviousValue, double NewValue, const TArray<class FText>& TargetArray);
	bool TryRollEnemyDodgeFromStats();

	void GetDamageSourceObject(TScriptInterface<class IIBattleDamageSource_C>* SourceObject) const;
	void GetFinalDamages(double* FinalDamages) const;
	void GetFinalDamages_Base(double* FinalDamages) const;
	void GetIgnoreTargetDefense(bool* IgnoreTargetDefense_0) const;
	void GetInputDamages(double* RawDamages) const;
	void GetInputDamages_Base(double* RawDamages) const;
	void GetSourceCharacter(class UAC_jRPG_CharacterBattleStats_C** SourceCharacter_0) const;
	void PrintError(const class FText& Message) const;

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BP_BattleDamages_C">();
	}
	static class UBP_BattleDamages_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBP_BattleDamages_C>();
	}
};
static_assert(alignof(UBP_BattleDamages_C) == 0x000008, "Wrong alignment on UBP_BattleDamages_C");
static_assert(sizeof(UBP_BattleDamages_C) == 0x000388, "Wrong size on UBP_BattleDamages_C");
static_assert(offsetof(UBP_BattleDamages_C, CurrentInputDamages_Base) == 0x0002E0, "Member 'UBP_BattleDamages_C::CurrentInputDamages_Base' has a wrong offset!");
static_assert(offsetof(UBP_BattleDamages_C, IsFinalDamageInitialized) == 0x0002E8, "Member 'UBP_BattleDamages_C::IsFinalDamageInitialized' has a wrong offset!");
static_assert(offsetof(UBP_BattleDamages_C, SourceCharacter) == 0x0002F0, "Member 'UBP_BattleDamages_C::SourceCharacter' has a wrong offset!");
static_assert(offsetof(UBP_BattleDamages_C, TargetCharacter) == 0x0002F8, "Member 'UBP_BattleDamages_C::TargetCharacter' has a wrong offset!");
static_assert(offsetof(UBP_BattleDamages_C, logEnabled) == 0x000300, "Member 'UBP_BattleDamages_C::logEnabled' has a wrong offset!");
static_assert(offsetof(UBP_BattleDamages_C, IgnoreTargetDefense) == 0x000301, "Member 'UBP_BattleDamages_C::IgnoreTargetDefense' has a wrong offset!");
static_assert(offsetof(UBP_BattleDamages_C, InputAttackElement) == 0x000302, "Member 'UBP_BattleDamages_C::InputAttackElement' has a wrong offset!");
static_assert(offsetof(UBP_BattleDamages_C, FinalAttackElement) == 0x000303, "Member 'UBP_BattleDamages_C::FinalAttackElement' has a wrong offset!");
static_assert(offsetof(UBP_BattleDamages_C, IsCriticalHit) == 0x000304, "Member 'UBP_BattleDamages_C::IsCriticalHit' has a wrong offset!");
static_assert(offsetof(UBP_BattleDamages_C, DamageReason) == 0x000305, "Member 'UBP_BattleDamages_C::DamageReason' has a wrong offset!");
static_assert(offsetof(UBP_BattleDamages_C, DamageWorldLocation) == 0x000308, "Member 'UBP_BattleDamages_C::DamageWorldLocation' has a wrong offset!");
static_assert(offsetof(UBP_BattleDamages_C, DamageBaseBeforeTargetHPClamp) == 0x000320, "Member 'UBP_BattleDamages_C::DamageBaseBeforeTargetHPClamp' has a wrong offset!");
static_assert(offsetof(UBP_BattleDamages_C, BaseTypeAffinity) == 0x000328, "Member 'UBP_BattleDamages_C::BaseTypeAffinity' has a wrong offset!");
static_assert(offsetof(UBP_BattleDamages_C, DEBUG_LogWidget) == 0x000330, "Member 'UBP_BattleDamages_C::DEBUG_LogWidget' has a wrong offset!");
static_assert(offsetof(UBP_BattleDamages_C, InputDamageMultiplier) == 0x000338, "Member 'UBP_BattleDamages_C::InputDamageMultiplier' has a wrong offset!");
static_assert(offsetof(UBP_BattleDamages_C, CriticalRoll) == 0x000340, "Member 'UBP_BattleDamages_C::CriticalRoll' has a wrong offset!");
static_assert(offsetof(UBP_BattleDamages_C, ActiveModifiers) == 0x000348, "Member 'UBP_BattleDamages_C::ActiveModifiers' has a wrong offset!");
static_assert(offsetof(UBP_BattleDamages_C, ValueState_AttackElement) == 0x000358, "Member 'UBP_BattleDamages_C::ValueState_AttackElement' has a wrong offset!");
static_assert(offsetof(UBP_BattleDamages_C, ValueState_CriticalHitRoll) == 0x000359, "Member 'UBP_BattleDamages_C::ValueState_CriticalHitRoll' has a wrong offset!");
static_assert(offsetof(UBP_BattleDamages_C, FinalLock) == 0x00035A, "Member 'UBP_BattleDamages_C::FinalLock' has a wrong offset!");
static_assert(offsetof(UBP_BattleDamages_C, IsAbsorbedByShield) == 0x00035B, "Member 'UBP_BattleDamages_C::IsAbsorbedByShield' has a wrong offset!");
static_assert(offsetof(UBP_BattleDamages_C, ExtraCriticalHitChance) == 0x000360, "Member 'UBP_BattleDamages_C::ExtraCriticalHitChance' has a wrong offset!");
static_assert(offsetof(UBP_BattleDamages_C, ExtraCriticalHitDamageMultiplier) == 0x000368, "Member 'UBP_BattleDamages_C::ExtraCriticalHitDamageMultiplier' has a wrong offset!");
static_assert(offsetof(UBP_BattleDamages_C, BreakBarDamageMultiplier) == 0x000370, "Member 'UBP_BattleDamages_C::BreakBarDamageMultiplier' has a wrong offset!");
static_assert(offsetof(UBP_BattleDamages_C, SourceDamageBuilder) == 0x000378, "Member 'UBP_BattleDamages_C::SourceDamageBuilder' has a wrong offset!");
static_assert(offsetof(UBP_BattleDamages_C, MissReason) == 0x000380, "Member 'UBP_BattleDamages_C::MissReason' has a wrong offset!");

}

