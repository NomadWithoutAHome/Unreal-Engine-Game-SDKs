#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: AC_jRPG_InventoryManager

#include "Basic.hpp"

#include "E_jRPG_ItemSubtype_structs.hpp"
#include "SandFall_classes.hpp"
#include "Engine_structs.hpp"
#include "S_LootContext_structs.hpp"
#include "E_jRPG_ItemType_structs.hpp"
#include "E_CustomizationItemType_structs.hpp"
#include "E_jRPG_StatType_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass AC_jRPG_InventoryManager.AC_jRPG_InventoryManager_C
// 0x0068 (0x0108 - 0x00A0)
class UAC_jRPG_InventoryManager_C final : public UExtendedActorComponent
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x00A0(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	int32                                         InventorySlotsAmount;                              // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          MultipleStacksAllowed_;                            // 0x00AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SelectedItemSlot;                                  // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBP_jRPG_GI_Custom_C*                   GameInstanceReference;                             // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	class FName                                   ItemToUse;                                         // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TMulticastInlineDelegate<void()>              OnAnyItemAdded;                                    // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	TMulticastInlineDelegate<void()>              OnAnyItemRemoved;                                  // 0x00D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	TMulticastInlineDelegate<void(class UBP_GeneratedItemInfo_Base_C* GeneratedItemInfo, const struct FS_LootContext& LootContext)> OnItemAdded; // 0x00E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          ItemInstances;                                     // 0x00F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          ShouldDispatchModifications;                       // 0x00F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_FA[0x6];                                       // 0x00FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             InventoryItemTypeMetadataTable;                    // 0x0100(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)

public:
	void AddItemInstanceToInventory(class UBP_ItemInstance_Base_C* ItemInstance, int32 Amount, const struct FS_LootContext& LootContext);
	void AddItemToInventory(class FName ItemHardcodedName, int32 Amount, const struct FS_LootContext& LootContext, class UBP_GeneratedItemInfo_Base_C** GeneratedItem);
	void AddMissingItemsFromCharacterSave(const struct FS_jRPG_CharacterSaveState& CharacterSaveState);
	void BuyItem(class FName ItemHardcodedName, bool* Success);
	void CalculateStatsComparisonOnEquip(class FName ItemHardcodedName);
	bool CanAffordItemCosts(TArray<struct FS_ItemQuantity>& RequiredItem);
	bool CanAutoEquipConsumableShard();
	void CheckAmountOfItemInInventory(class FName ItemHardcodedName, int32* TotalAmountInInventory);
	void CheckAmountOfItemTypeInInventory(E_jRPG_ItemType ItemType, E_jRPG_ItemSubtype ItemSubtype, int32* TotalAmountInInventory);
	void CheckIfCanUnequipItemToInventory(class FName ItemHardcodedName, bool* Success_);
	void CheckIfItemCanBeBought(class FName ItemId, bool* CanBeBought);
	void CheckIfThereIsAmountOfItemInInventory(class FName ItemHardcodedName, int32 Amount, bool* Success_);
	void CheckIfThereIsFreeSlotInInventory(bool* Success_);
	void CheckIfThereIsItemInInventory(class FName ItemHardcodedName, bool* Success_, bool* IsItemFullyStacked_, int32* ItemIndex);
	void CheckIfThereIsNotFullyStackedItemInInventory(class FName ItemHardcodedName, bool* Success_, int32* ItemIndex);
	void CreateReferenceToInventoryWindow();
	void CreateReferenceToVendorWindow();
	void DEBUG_ShowDebugText();
	void EquipItem(class FName ItemHardcodedName, class FName CharacterName);
	void EquipItem_DEPRECATED(class FName ItemHardcodedName);
	void ExecuteUbergraph_AC_jRPG_InventoryManager(int32 EntryPoint);
	void FindItemCountFromInventory(class FName ItemHardcodedName, int32* Quantity);
	void FindItemDynamicFromInventory(class FName ItemHardcodedName, bool* Found, struct FS_jRPG_Item_DynamicData* ItemStruct);
	void GetAllEquipableItems(E_jRPG_ItemType ItemType, const TSet<E_jRPG_ItemSubtype>& AvailableSubtypes, TArray<struct FS_jRPG_Item_DynamicData>* EquipableItems);
	TArray<class UBP_CharacterData_C*> GetCharactersForWeapon(const struct FS_jRPG_Item_StaticData& ItemStatic);
	void GetCharactersWithItemEquipped(class FName ItemId, TArray<struct FFCharacterAssignedEquipment>* AssignedEquipment);
	void GetConsumables(TArray<struct FS_jRPG_Item_DynamicData>* FilteredArray);
	void GetConsumablesShards(TArray<struct FS_jRPG_Item_DynamicData>* FilteredArray);
	struct FS_jRPG_Item_StaticData GetItemDefinitionFromID(class FName ItemId, bool* Found);
	void GetItemDynamicFromInventory(class FName ItemHardcodedName, struct FS_jRPG_Item_DynamicData* ItemStruct);
	int32 GetItemStackMaxCount(const struct FS_jRPG_Item_StaticData& ItemStaticData);
	void GetItemStructFromInventory(class FName ItemHardcodedName, struct FS_jRPG_Item_StaticData* ItemStruct);
	void GetItemTypeMetadata(E_jRPG_ItemType ItemType, bool* Found, struct FS_InventoryItemTypeMetadata* ItemTypeMetadata);
	struct FGameplayTag GetNotificationPoolTagFromItemType(E_jRPG_ItemType Index_0);
	void GetOwnedItemsByType(E_jRPG_ItemType ItemType, E_jRPG_ItemSubtype ItemSubtype, bool IncludeHidden, TArray<struct FS_jRPG_Item_DynamicData>* FilteredArray);
	void GetPartyHealConsumable(class FName* Row_Name);
	void GetPartyHealShard(class FName* Row_Name);
	void GetProperEquipmentChangeSlot(int32 SlotIndex);
	void GetProperInventorySlotWidget(int32 ItemIndex);
	void GetProperUseItemOnCharacterSlotWidget(int32 SlotIndex);
	void GetProperVendorSlot(int32 Index_0);
	void GetStacksLeftForItem(class FName ItemId, bool* HasExistingStack, int32* ItemIndex, int32* StackLeft, int32* StackCount);
	void GetWeaponsForCharacter(class UBP_CharacterData_C* CharacterData, TArray<struct FS_jRPG_Item_DynamicData>* WeaponsDynamicData);
	void IsThereNotifiedCustomizationForCharacter(class UBP_CharacterData_C* CharacterData, bool* IsNotified);
	void IsThereNotifiedWeaponForCharacter(class UBP_CharacterData_C* CharacterData, bool* IsNotified);
	void MarkItemAsRead(const struct FS_jRPG_Item_StaticData& ItemData, class UUserWidget* Mark_Caller);
	void NotifyItem(const struct FS_jRPG_Item_StaticData& ItemData);
	void OnInitializeComponent();
	void OnItemRemovedFromInventory(struct FS_jRPG_Item_StaticData& ItemStaticData, int32 Amount);
	void OnVendorItemSold(class FName VendorID, class FName ItemId, int32 Quantity);
	void ReceiveGold(int32 GoldAmount, const class FString& Reason);
	void ReceiveTick(float DeltaSeconds);
	void RefillConsumables();
	void RefreshAllInventorySlots();
	void RefreshGoldAmount();
	void RefreshInventorySlot(int32 SlotIndex);
	void RefreshInventorySlotAfterDiscarding(int32 SlotIndex);
	void RefreshItemDetails();
	void RefreshUseItemOnCharacterSlots();
	void RefreshVendorItemDetails(bool ShowItemFromInventory);
	void ReleaseInventorySlot(int32 InventorySlot);
	void RemoveAllItemsOfType(E_jRPG_ItemType ItemType);
	void RemoveItemFromInventory(class FName ItemHardcodedName, int32 Amount, bool KeepEmptyStack);
	void ResetInventory();
	void ResetInventoryForNewGamePlus();
	void SelectItemToUse();
	void SetShouldDispatchModifications(bool ShouldDispatch);
	void ShouldItemBeNotified(const struct FS_jRPG_Item_StaticData& ItemData, bool* IsNotified);
	bool ShouldRefillConsumableShard(const class FName& ItemToFind);
	void ShowAllEquipableItems(E_jRPG_ItemType ItemType);
	void ShowDiscardWindow();
	void ShowItemsToBuy(int32 SlotToFocus);
	void ShowItemsToSell(int32 SlotToFocus);
	void ShowLootNotificationInDialogue(class UBP_GeneratedItemInfo_Base_C* GeneratedItemInfo, const struct FS_jRPG_Item_StaticData& ItemData);
	void TrySpendGold(int32 GoldAmount, const class FString& Reason, bool* Success);
	void UnequipItem(E_jRPG_ItemType ItemType);
	void UseItemOnCharacter(class FName ItemToUse_0, class FName CharacterHardcodedName);

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"AC_jRPG_InventoryManager_C">();
	}
	static class UAC_jRPG_InventoryManager_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAC_jRPG_InventoryManager_C>();
	}
};
static_assert(alignof(UAC_jRPG_InventoryManager_C) == 0x000008, "Wrong alignment on UAC_jRPG_InventoryManager_C");
static_assert(sizeof(UAC_jRPG_InventoryManager_C) == 0x000108, "Wrong size on UAC_jRPG_InventoryManager_C");
static_assert(offsetof(UAC_jRPG_InventoryManager_C, UberGraphFrame) == 0x0000A0, "Member 'UAC_jRPG_InventoryManager_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_InventoryManager_C, InventorySlotsAmount) == 0x0000A8, "Member 'UAC_jRPG_InventoryManager_C::InventorySlotsAmount' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_InventoryManager_C, MultipleStacksAllowed_) == 0x0000AC, "Member 'UAC_jRPG_InventoryManager_C::MultipleStacksAllowed_' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_InventoryManager_C, SelectedItemSlot) == 0x0000B0, "Member 'UAC_jRPG_InventoryManager_C::SelectedItemSlot' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_InventoryManager_C, GameInstanceReference) == 0x0000B8, "Member 'UAC_jRPG_InventoryManager_C::GameInstanceReference' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_InventoryManager_C, ItemToUse) == 0x0000C0, "Member 'UAC_jRPG_InventoryManager_C::ItemToUse' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_InventoryManager_C, OnAnyItemAdded) == 0x0000C8, "Member 'UAC_jRPG_InventoryManager_C::OnAnyItemAdded' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_InventoryManager_C, OnAnyItemRemoved) == 0x0000D8, "Member 'UAC_jRPG_InventoryManager_C::OnAnyItemRemoved' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_InventoryManager_C, OnItemAdded) == 0x0000E8, "Member 'UAC_jRPG_InventoryManager_C::OnItemAdded' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_InventoryManager_C, ItemInstances) == 0x0000F8, "Member 'UAC_jRPG_InventoryManager_C::ItemInstances' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_InventoryManager_C, ShouldDispatchModifications) == 0x0000F9, "Member 'UAC_jRPG_InventoryManager_C::ShouldDispatchModifications' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_InventoryManager_C, InventoryItemTypeMetadataTable) == 0x000100, "Member 'UAC_jRPG_InventoryManager_C::InventoryItemTypeMetadataTable' has a wrong offset!");

}

