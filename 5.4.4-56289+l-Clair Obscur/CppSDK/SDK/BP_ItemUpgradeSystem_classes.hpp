#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_ItemUpgradeSystem

#include "Basic.hpp"

#include "S_WeaponInstanceData_structs.hpp"
#include "SandFall_classes.hpp"
#include "EWeaponQuality_structs.hpp"
#include "Engine_structs.hpp"
#include "S_ItemQuantityList_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass BP_ItemUpgradeSystem.BP_ItemUpgradeSystem_C
// 0x02B8 (0x02E0 - 0x0028)
class UBP_ItemUpgradeSystem_C final : public UExtendedObject
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x0028(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	TMulticastInlineDelegate<void(const struct FS_WeaponInstanceData& ReplacedWeaponInstance)> OnWeaponReplaced; // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	TArray<struct FS_WeaponInstanceData>          OwnedWeaponInstances;                              // 0x0040(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, Deprecated)
	TMulticastInlineDelegate<void()>              OnWeaponModified;                                  // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	TMap<EWeaponQuality, struct FS_ItemQuantityList> UpgradeCostTable;                               // 0x0060(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance)
	TMap<class FName, class FName>                ConsumableShardUpgradeTable;                       // 0x00B0(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, Deprecated)
	TMap<class FName, class UBP_DataAsset_Item_Shard_C*> ShardDataCache;                             // 0x0100(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	TMap<class FName, class FName>                UpgradeItemToShard;                                // 0x0150(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	TMap<class FName, int32>                      UpgradeLevelsByShard;                              // 0x01A0(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	TMap<class FName, class FName>                ConsumableItemToShard;                             // 0x01F0(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	TMap<class FName, class UBP_ItemInstance_Base_C*> ItemInstances;                                 // 0x0240(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	TMap<int32, struct FS_ItemQuantityList>       UpgradeCostTable_V2;                               // 0x0290(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance)

public:
	void AddWeaponToInventory(const struct FS_WeaponInstanceHandle& WeaponInstanceHandle, int32* PreviousLevel);
	void ComputeWeaponInstanceData(const struct FS_WeaponInstanceHandle& WeaponHandle, struct FS_WeaponInstanceData* WeaponInstanceData);
	void ComputeWeaponUnlockedPassivesFromID(class FName WeaponID, TArray<class FName>* ActivePassiveEffectIDs);
	void CreateInventorySaveState(TArray<struct FS_WeaponInstanceHandle>* WeaponHandles);
	void CreateItemInstanceInternal(const struct FS_jRPG_Item_StaticData& ItemStaticData, int32 Quantity, class UBP_ItemInstance_Base_C** ItemInstance);
	void CreateItemInstanceTransient(const struct FS_jRPG_Item_StaticData& ItemStaticData, int32 Quantity, class UBP_ItemInstance_Base_C** ItemInstance);
	void ExecuteUbergraph_BP_ItemUpgradeSystem(int32 EntryPoint);
	void FindItemInstanceByID(class FName ItemDefinitionID, class UBP_ItemInstance_Base_C** ItemInstance);
	void FindWeaponInstanceByWeaponID(class FName WeaponDefinitionID, bool* Found, int32* WeaponIndex, struct FS_WeaponInstanceData* WeaponInstanceData);
	TArray<class UBP_ItemInstance_Base_C*> GetAllItemInstances();
	class UClass* GetItemInstanceClassFromData(const struct FS_jRPG_Item_StaticData& ItemStaticData);
	void GetItemInstanceUpgradeCost(class UBP_ItemInstance_Gear_C* GearItemInstance, TArray<struct FS_ItemQuantity>* ItemQuantities);
	void GetItemUpgradeCost(class FName WeaponDefinitionID, TArray<struct FS_ItemQuantity>* ItemQuantities);
	void GetOrCreateItemInstance(const struct FS_jRPG_Item_StaticData& ItemStaticData, int32 Quantity, class UBP_ItemInstance_Base_C** ItemInstance);
	void GetShardForConsumable(const class FName& ConsumableID, class FName* ShardID);
	void GetShardItemUpgradeItemRow(class UBP_DataAsset_Item_Shard_C* ShardItem, struct FDataTableRowHandle* UpgradeItemRow);
	struct FDataTableRowHandle GetUpgradedConsumableItemFromShard(class FName ShardStaticDataID);
	void GetUpgradeResourceList(TArray<struct FDataTableRowHandle>* UpgradeResourcesList);
	void GetWeaponQualityForUpgradeLevel(int32 UpgradeLevel, EWeaponQuality* Quality);
	void GetWeaponQualityLevel(class FName WeaponDefinitionID, EWeaponQuality* Quality);
	void Initialize();
	bool IsItemConsumableUpgrade(class FName ItemId);
	void IsShardUpgradable(class FName ShardName, bool* IsShardUpgradable_0);
	void LoadInventoryState(TArray<struct FS_WeaponInstanceHandle>& WeaponHandles);
	void LoadShardDefinition(const struct FS_jRPG_Item_StaticData& ShardItemDefinition);
	void OnItemAddedToInventory(const struct FS_jRPG_Item_StaticData& ItemStaticData, int32 Quantity, const struct FS_LootContext& LootContext, class UBP_GeneratedItemInfo_Base_C** GeneratedItemInfo);
	void OnItemRemovedFromInventory(const struct FS_jRPG_Item_StaticData& ItemStaticData, int32 Amount, int32* RemainingQuantity);
	void ResetState();
	void Sandfall_Debug_SetGearLevel(class FName WeaponID, int32 NewLevel);
	void Sandfall_Debug_UpgradeWeapon(class FName WeaponID);
	void UpdateWeaponInstance(const struct FS_WeaponInstanceData& WeaponInstanceData);
	void UpgradeShardToNextLevel(class FName ShardName, bool* bIsUpgradeSuccessful);
	void UpgradeWeaponFromHandle(const struct FS_WeaponInstanceHandle& WeaponHandle, struct FS_WeaponInstanceData* UpgradedWeaponData);
	void UpgradeWeaponFromInstance(class UBP_ItemInstance_Gear_C* ItemInstance, const class FString& DebugReason);

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BP_ItemUpgradeSystem_C">();
	}
	static class UBP_ItemUpgradeSystem_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBP_ItemUpgradeSystem_C>();
	}
};
static_assert(alignof(UBP_ItemUpgradeSystem_C) == 0x000008, "Wrong alignment on UBP_ItemUpgradeSystem_C");
static_assert(sizeof(UBP_ItemUpgradeSystem_C) == 0x0002E0, "Wrong size on UBP_ItemUpgradeSystem_C");
static_assert(offsetof(UBP_ItemUpgradeSystem_C, UberGraphFrame) == 0x000028, "Member 'UBP_ItemUpgradeSystem_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(UBP_ItemUpgradeSystem_C, OnWeaponReplaced) == 0x000030, "Member 'UBP_ItemUpgradeSystem_C::OnWeaponReplaced' has a wrong offset!");
static_assert(offsetof(UBP_ItemUpgradeSystem_C, OwnedWeaponInstances) == 0x000040, "Member 'UBP_ItemUpgradeSystem_C::OwnedWeaponInstances' has a wrong offset!");
static_assert(offsetof(UBP_ItemUpgradeSystem_C, OnWeaponModified) == 0x000050, "Member 'UBP_ItemUpgradeSystem_C::OnWeaponModified' has a wrong offset!");
static_assert(offsetof(UBP_ItemUpgradeSystem_C, UpgradeCostTable) == 0x000060, "Member 'UBP_ItemUpgradeSystem_C::UpgradeCostTable' has a wrong offset!");
static_assert(offsetof(UBP_ItemUpgradeSystem_C, ConsumableShardUpgradeTable) == 0x0000B0, "Member 'UBP_ItemUpgradeSystem_C::ConsumableShardUpgradeTable' has a wrong offset!");
static_assert(offsetof(UBP_ItemUpgradeSystem_C, ShardDataCache) == 0x000100, "Member 'UBP_ItemUpgradeSystem_C::ShardDataCache' has a wrong offset!");
static_assert(offsetof(UBP_ItemUpgradeSystem_C, UpgradeItemToShard) == 0x000150, "Member 'UBP_ItemUpgradeSystem_C::UpgradeItemToShard' has a wrong offset!");
static_assert(offsetof(UBP_ItemUpgradeSystem_C, UpgradeLevelsByShard) == 0x0001A0, "Member 'UBP_ItemUpgradeSystem_C::UpgradeLevelsByShard' has a wrong offset!");
static_assert(offsetof(UBP_ItemUpgradeSystem_C, ConsumableItemToShard) == 0x0001F0, "Member 'UBP_ItemUpgradeSystem_C::ConsumableItemToShard' has a wrong offset!");
static_assert(offsetof(UBP_ItemUpgradeSystem_C, ItemInstances) == 0x000240, "Member 'UBP_ItemUpgradeSystem_C::ItemInstances' has a wrong offset!");
static_assert(offsetof(UBP_ItemUpgradeSystem_C, UpgradeCostTable_V2) == 0x000290, "Member 'UBP_ItemUpgradeSystem_C::UpgradeCostTable_V2' has a wrong offset!");

}

