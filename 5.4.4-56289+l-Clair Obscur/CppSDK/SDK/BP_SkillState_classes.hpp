#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_SkillState

#include "Basic.hpp"

#include "EAttackType_structs.hpp"
#include "SandFall_structs.hpp"
#include "SandFall_classes.hpp"


namespace SDK
{

// BlueprintGeneratedClass BP_SkillState.BP_SkillState_C
// 0x0098 (0x00C0 - 0x0028)
class UBP_SkillState_C final : public UExtendedObject
{
public:
	class UAC_jRPG_CharacterBattleStats_C*        CharacterStats;                                    // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          IsOvercharged;                                     // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBP_DataAsset_Skill_C*                  SkillDefinition;                                   // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	TMulticastInlineDelegate<void(bool NewOvercharge)> OnOverchargeStateChanged;                     // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	TMap<class UBP_SkillDataComponent_Base_C*, class UBP_SkillDataComponentScript_C*> SkillComponentScripts; // 0x0050(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	EAttackType                                   ElementalType;                                     // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABP_Battle_SkillScript_C*               SkillScriptInstance;                               // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	struct FSF_ModifierStackWrapper               SkillCostModifierStack;                            // 0x00B0(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, ContainsInstancedReference)
	bool                                          IsOverchargeFeedbackForced;                        // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

public:
	void AddSkillCostModifier(int32 DeltaCost, struct FSF_ModifierStackEntryHandle& OutModifierHandle, const class FString& DebugName);
	void FindComponentScriptsByClass(class UClass* ScriptClass, TArray<class UBP_SkillDataComponentScript_C*>* Array);
	void GetScriptForComponent(const class UBP_SkillDataComponent_Base_C*& SkillComponent, class UBP_SkillDataComponentScript_C** SkillComponentScript);
	int32 GetSkillCost();
	void GetSkillCostModifier(class UModifierStack_Float** Stack);
	EAttackType GetSkillRuntimeElement();
	void Initialize();
	void InitializeSkillScriptActor();
	void IsSkillOvercharged(bool* IsOvercharged_0);
	void RemoveSkillCostModifier(struct FSF_ModifierStackEntryHandle& ModifierHandle);
	void SetOvercharge(bool IsOvercharged_0, bool ForcedOverchargeFeedback);
	bool ShouldShowAsOvercharged();
	void UpdateSkillState();

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BP_SkillState_C">();
	}
	static class UBP_SkillState_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBP_SkillState_C>();
	}
};
static_assert(alignof(UBP_SkillState_C) == 0x000008, "Wrong alignment on UBP_SkillState_C");
static_assert(sizeof(UBP_SkillState_C) == 0x0000C0, "Wrong size on UBP_SkillState_C");
static_assert(offsetof(UBP_SkillState_C, CharacterStats) == 0x000028, "Member 'UBP_SkillState_C::CharacterStats' has a wrong offset!");
static_assert(offsetof(UBP_SkillState_C, IsOvercharged) == 0x000030, "Member 'UBP_SkillState_C::IsOvercharged' has a wrong offset!");
static_assert(offsetof(UBP_SkillState_C, SkillDefinition) == 0x000038, "Member 'UBP_SkillState_C::SkillDefinition' has a wrong offset!");
static_assert(offsetof(UBP_SkillState_C, OnOverchargeStateChanged) == 0x000040, "Member 'UBP_SkillState_C::OnOverchargeStateChanged' has a wrong offset!");
static_assert(offsetof(UBP_SkillState_C, SkillComponentScripts) == 0x000050, "Member 'UBP_SkillState_C::SkillComponentScripts' has a wrong offset!");
static_assert(offsetof(UBP_SkillState_C, ElementalType) == 0x0000A0, "Member 'UBP_SkillState_C::ElementalType' has a wrong offset!");
static_assert(offsetof(UBP_SkillState_C, SkillScriptInstance) == 0x0000A8, "Member 'UBP_SkillState_C::SkillScriptInstance' has a wrong offset!");
static_assert(offsetof(UBP_SkillState_C, SkillCostModifierStack) == 0x0000B0, "Member 'UBP_SkillState_C::SkillCostModifierStack' has a wrong offset!");
static_assert(offsetof(UBP_SkillState_C, IsOverchargeFeedbackForced) == 0x0000B8, "Member 'UBP_SkillState_C::IsOverchargeFeedbackForced' has a wrong offset!");

}

