#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: LGUI

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK
{

// Enum LGUI.ELGUIPointerInputType
// NumValues: 0x0003
enum class ELGUIPointerInputType : uint8
{
	Pointer                                  = 0,
	Navigation                               = 1,
	ELGUIPointerInputType_MAX                = 2,
};

// Enum LGUI.ELayoutElementType
// NumValues: 0x0005
enum class ELayoutElementType : uint8
{
	AutoSize                                 = 0,
	IgnoreLayout                             = 1,
	ConstantSize                             = 2,
	RatioSize                                = 3,
	ELayoutElementType_MAX                   = 4,
};

// Enum LGUI.ELayoutElementSizeType
// NumValues: 0x0003
enum class ELayoutElementSizeType : uint8
{
	Horizontal                               = 0,
	Vertical                                 = 1,
	ELayoutElementSizeType_MAX               = 2,
};

// Enum LGUI.ELGUIEventFireType
// NumValues: 0x0004
enum class ELGUIEventFireType : uint8
{
	TargetActorAndAllItsComponents           = 0,
	OnlyTargetComponent                      = 1,
	OnlyTargetActor                          = 2,
	ELGUIEventFireType_MAX                   = 3,
};

// Enum LGUI.EPointerEventType
// NumValues: 0x000E
enum class EPointerEventType : uint8
{
	Click                                    = 0,
	Enter                                    = 1,
	Exit                                     = 2,
	Down                                     = 3,
	Up                                       = 4,
	BeginDrag                                = 5,
	Drag                                     = 6,
	EndDrag                                  = 7,
	Scroll                                   = 8,
	DragDrop                                 = 11,
	Select                                   = 12,
	Deselect                                 = 13,
	Navigate                                 = 14,
	EPointerEventType_MAX                    = 15,
};

// Enum LGUI.EMouseButtonType
// NumValues: 0x000C
enum class EMouseButtonType : uint8
{
	Left                                     = 0,
	Middle                                   = 1,
	Right                                    = 2,
	UserDefined1                             = 3,
	UserDefined2                             = 4,
	UserDefined3                             = 5,
	UserDefined4                             = 6,
	UserDefined5                             = 7,
	UserDefined6                             = 8,
	UserDefined7                             = 9,
	UserDefined8                             = 10,
	EMouseButtonType_MAX                     = 11,
};

// Enum LGUI.ELGUIRenderMode
// NumValues: 0x0006
enum class ELGUIRenderMode : uint8
{
	ScreenSpaceOverlay                       = 0,
	WorldSpace                               = 1,
	WorldSpace_LGUI                          = 3,
	RenderTarget                             = 2,
	None                                     = 255,
	ELGUIRenderMode_MAX                      = 256,
};

// Enum LGUI.ELGUICanvasRenderTargetSizeMode
// NumValues: 0x0004
enum class ELGUICanvasRenderTargetSizeMode : uint8
{
	None                                     = 0,
	CanvasFitToRenderTarget                  = 1,
	RenderTargetFitToCanvas                  = 2,
	ELGUICanvasRenderTargetSizeMode_MAX      = 3,
};

// Enum LGUI.ELGUICanvasRenderTargetUpdateMode
// NumValues: 0x0004
enum class ELGUICanvasRenderTargetUpdateMode : uint8
{
	Automatic                                = 0,
	Always                                   = 1,
	WhenRequest                              = 2,
	ELGUICanvasRenderTargetUpdateMode_MAX    = 3,
};

// Enum LGUI.ELGUICanvasClipType
// NumValues: 0x0005
enum class ELGUICanvasClipType : uint8
{
	None                                     = 0,
	Rect                                     = 1,
	Texture                                  = 2,
	Custom                                   = 3,
	ELGUICanvasClipType_MAX                  = 4,
};

// Enum LGUI.ELGUICanvasAdditionalChannelType
// NumValues: 0x0006
enum class ELGUICanvasAdditionalChannelType : uint8
{
	Normal                                   = 0,
	Tangent                                  = 1,
	UV1                                      = 2,
	UV2                                      = 3,
	UV3                                      = 4,
	ELGUICanvasAdditionalChannelType_MAX     = 5,
};

// Enum LGUI.ELGUICanvasOverrideParameters
// NumValues: 0x0008
enum class ELGUICanvasOverrideParameters : uint8
{
	DefaltMaterials                          = 0,
	PixelPerfect                             = 1,
	DynamicPixelsPerUnit                     = 2,
	ClipType                                 = 3,
	AdditionalShaderChannels                 = 4,
	BlendDepth                               = 5,
	DepthFade                                = 6,
	ELGUICanvasOverrideParameters_MAX        = 7,
};

// Enum LGUI.ELGUICanvasCustomClip_RoundedRect_UnitMode
// NumValues: 0x0003
enum class ELGUICanvasCustomClip_RoundedRect_UnitMode : uint8
{
	Value                                    = 0,
	Percentage                               = 1,
	ELGUICanvasCustomClip_RoundedRect_MAX    = 2,
};

// Enum LGUI.ELGUICanvasScaleMode
// NumValues: 0x0004
enum class ELGUICanvasScaleMode : uint8
{
	ConstantPixelSize                        = 0,
	ScaleWithScreenSize                      = 1,
	Custom                                   = 2,
	ELGUICanvasScaleMode_MAX                 = 3,
};

// Enum LGUI.ELGUICanvasScreenMatchMode
// NumValues: 0x0004
enum class ELGUICanvasScreenMatchMode : uint8
{
	MatchWidthOrHeight                       = 0,
	Expand                                   = 1,
	Shrink                                   = 2,
	ELGUICanvasScreenMatchMode_MAX           = 3,
};

// Enum LGUI.ELGUIEventDelegateParameterType
// NumValues: 0x001C
enum class ELGUIEventDelegateParameterType : uint8
{
	None                                     = 0,
	Empty                                    = 1,
	Bool                                     = 2,
	Float                                    = 3,
	Double                                   = 4,
	Int8                                     = 5,
	UInt8                                    = 6,
	Int16                                    = 7,
	UInt16                                   = 8,
	Int32                                    = 9,
	UInt32                                   = 10,
	Int64                                    = 11,
	UInt64                                   = 12,
	Vector2                                  = 13,
	Vector3                                  = 14,
	Vector4                                  = 15,
	Color                                    = 16,
	LinearColor                              = 17,
	Quaternion                               = 18,
	String                                   = 19,
	Object                                   = 20,
	Actor                                    = 21,
	PointerEvent                             = 22,
	Class                                    = 23,
	Rotator                                  = 24,
	Name                                     = 25,
	Text                                     = 26,
	ELGUIEventDelegateParameterType_MAX      = 27,
};

// Enum LGUI.ELGUIDynamicFontDataType
// NumValues: 0x0003
enum class ELGUIDynamicFontDataType : uint8
{
	CustomFontFile                           = 0,
	UnrealFont                               = 1,
	ELGUIDynamicFontDataType_MAX             = 2,
};

// Enum LGUI.ELGUIDynamicFontLineHeightType
// NumValues: 0x0003
enum class ELGUIDynamicFontLineHeightType : uint8
{
	FromFontFace                             = 0,
	FontSizeAsLineHeight                     = 1,
	ELGUIDynamicFontLineHeightType_MAX       = 2,
};

// Enum LGUI.ELGUINavigationDirection
// NumValues: 0x0008
enum class ELGUINavigationDirection : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	Up                                       = 3,
	Down                                     = 4,
	Next                                     = 5,
	Prev                                     = 6,
	ELGUINavigationDirection_MAX             = 7,
};

// Enum LGUI.ELGUIRenderTargetGeometryMode
// NumValues: 0x0004
enum class ELGUIRenderTargetGeometryMode : uint8
{
	Plane                                    = 0,
	Cylinder                                 = 1,
	StaticMesh                               = 100,
	ELGUIRenderTargetGeometryMode_MAX        = 101,
};

// Enum LGUI.ELGUIRichTextCustomStyleData_SizeType
// NumValues: 0x0004
enum class ELGUIRichTextCustomStyleData_SizeType : uint8
{
	KeepOrigin                               = 0,
	SizeValue                                = 1,
	SizeValueAsAdditional                    = 2,
	ELGUIRichTextCustomStyleData_MAX         = 3,
};

// Enum LGUI.ELGUIRichTextCustomStyleData_ColorType
// NumValues: 0x0004
enum class ELGUIRichTextCustomStyleData_ColorType : uint8
{
	KeepOrigin                               = 0,
	Replace                                  = 1,
	Multiply                                 = 2,
	ELGUIRichTextCustomStyleData_MAX         = 3,
};

// Enum LGUI.ELGUIRichTextCustomStyleData_SupOrSubType
// NumValues: 0x0005
enum class ELGUIRichTextCustomStyleData_SupOrSubType : uint8
{
	KeepOrigin                               = 0,
	None                                     = 1,
	Superscript                              = 2,
	Subscript                                = 3,
	ELGUIRichTextCustomStyleData_MAX         = 4,
};

// Enum LGUI.ELGUIAtlasTextureSizeType
// NumValues: 0x0007
enum class ELGUIAtlasTextureSizeType : uint8
{
	SIZE_256x256                             = 0,
	SIZE_512x512                             = 1,
	SIZE_1024x1024                           = 2,
	SIZE_2048x2048                           = 3,
	SIZE_4096x4096                           = 4,
	SIZE_8192x8192                           = 5,
	SIZE_MAX_0                               = 6,
};

// Enum LGUI.ELGUIRendererAntiAliasingMethod
// NumValues: 0x0003
enum class ELGUIRendererAntiAliasingMethod : uint8
{
	None                                     = 0,
	MSAA                                     = 3,
	ELGUIRendererAntiAliasingMethod_MAX      = 4,
};

// Enum LGUI.ELGUIRendererMSAASampleCount
// NumValues: 0x0006
enum class ELGUIRendererMSAASampleCount : uint8
{
	Hidden                                   = 0,
	One                                      = 1,
	Two                                      = 2,
	Four                                     = 4,
	Eight                                    = 8,
	ELGUIRendererMSAASampleCount_MAX         = 9,
};

// Enum LGUI.EUITextParagraphHorizontalAlign
// NumValues: 0x0004
enum class EUITextParagraphHorizontalAlign : uint8
{
	Left                                     = 0,
	Center                                   = 1,
	Right                                    = 2,
	EUITextParagraphHorizontalAlign_MAX      = 3,
};

// Enum LGUI.EUITextParagraphVerticalAlign
// NumValues: 0x0004
enum class EUITextParagraphVerticalAlign : uint8
{
	Top                                      = 0,
	Middle                                   = 1,
	Bottom                                   = 2,
	EUITextParagraphVerticalAlign_MAX        = 3,
};

// Enum LGUI.EUITextFontStyle
// NumValues: 0x0005
enum class EUITextFontStyle : uint8
{
	None                                     = 0,
	Bold                                     = 1,
	Italic                                   = 2,
	BoldAndItalic                            = 3,
	EUITextFontStyle_MAX                     = 4,
};

// Enum LGUI.EUITextOverflowType
// NumValues: 0x0005
enum class EUITextOverflowType : uint8
{
	HorizontalOverflow                       = 0,
	VerticalOverflow                         = 1,
	HorizontalAndVerticalOverflow            = 3,
	ClampContent                             = 2,
	EUITextOverflowType_MAX                  = 4,
};

// Enum LGUI.EUIText_RichTextTagFilterFlags
// NumValues: 0x000B
enum class EUIText_RichTextTagFilterFlags : uint8
{
	Bold                                     = 0,
	Italic                                   = 1,
	Underline                                = 2,
	Strikethrough                            = 3,
	Size                                     = 4,
	Color                                    = 5,
	Superscript                              = 6,
	Subscript                                = 7,
	CustomTag                                = 8,
	Image                                    = 9,
	EUIText_MAX                              = 10,
};

// Enum LGUI.ELGUIInteractionTarget
// NumValues: 0x0004
enum class ELGUIInteractionTarget : uint8
{
	UI                                       = 0,
	World                                    = 1,
	UIAndWorld                               = 2,
	ELGUIInteractionTarget_MAX               = 3,
};

// Enum LGUI.ELGUISceneComponentDirection
// NumValues: 0x0007
enum class ELGUISceneComponentDirection : uint8
{
	PositiveX                                = 0,
	NagtiveX                                 = 1,
	PositiveY                                = 2,
	NagtiveY                                 = 3,
	PositiveZ                                = 4,
	NagtiveZ                                 = 5,
	ELGUISceneComponentDirection_MAX         = 6,
};

// Enum LGUI.EUI2DLineRenderer_EndType
// NumValues: 0x0004
enum class EUI2DLineRenderer_EndType : uint8
{
	None                                     = 0,
	Cap                                      = 1,
	ConnectStartAndEnd                       = 2,
	EUI2DLineRenderer_MAX                    = 3,
};

// Enum LGUI.EUIRenderableType
// NumValues: 0x0005
enum class EUIRenderableType : uint8
{
	None                                     = 0,
	UIBatchMeshRenderable                    = 1,
	UIPostProcessRenderable                  = 2,
	UIDirectMeshRenderable                   = 3,
	EUIRenderableType_MAX                    = 4,
};

// Enum LGUI.EUIRenderableRaycastType
// NumValues: 0x0005
enum class EUIRenderableRaycastType : uint8
{
	Rect                                     = 0,
	Mesh                                     = 1,
	VisiblePixel                             = 3,
	Custom                                   = 2,
	EUIRenderableRaycastType_MAX             = 4,
};

// Enum LGUI.EUIDropdownVerticalPosition
// NumValues: 0x0005
enum class EUIDropdownVerticalPosition : uint8
{
	Bottom                                   = 0,
	Middle                                   = 1,
	Top                                      = 2,
	Automatic                                = 3,
	EUIDropdownVerticalPosition_MAX          = 4,
};

// Enum LGUI.EUIDropdownHorizontalPosition
// NumValues: 0x0005
enum class EUIDropdownHorizontalPosition : uint8
{
	Left                                     = 0,
	Center                                   = 1,
	Right                                    = 2,
	Automatic                                = 3,
	EUIDropdownHorizontalPosition_MAX        = 4,
};

// Enum LGUI.EUIEffectGradientColorDirection
// NumValues: 0x0006
enum class EUIEffectGradientColorDirection : uint8
{
	BottomToTop                              = 0,
	TopToBottom                              = 1,
	LeftToRight                              = 2,
	RightToLeft                              = 3,
	FourCornor                               = 4,
	EUIEffectGradientColorDirection_MAX      = 5,
};

// Enum LGUI.EUIFlexibleGridLayoutCellSizeType
// NumValues: 0x0003
enum class EUIFlexibleGridLayoutCellSizeType : uint8
{
	Constant                                 = 0,
	Ratio                                    = 1,
	EUIFlexibleGridLayoutCellSizeType_MAX    = 2,
};

// Enum LGUI.ELGUIGeometryModifierHelper_UITextModifyPositionType
// NumValues: 0x0003
enum class ELGUIGeometryModifierHelper_UITextModifyPositionType : uint8
{
	Relative                                 = 0,
	Absolute                                 = 1,
	ELGUIGeometryModifierHelper_MAX          = 2,
};

// Enum LGUI.ELGUILayoutAlignmentType
// NumValues: 0x000A
enum class ELGUILayoutAlignmentType : uint8
{
	UpperLeft                                = 0,
	UpperCenter                              = 1,
	UpperRight                               = 2,
	MiddleLeft                               = 3,
	MiddleCenter                             = 4,
	MiddleRight                              = 5,
	LowerLeft                                = 6,
	LowerCenter                              = 7,
	LowerRight                               = 8,
	ELGUILayoutAlignmentType_MAX             = 9,
};

// Enum LGUI.EUILayoutElement_ConstantSizeType
// NumValues: 0x0003
enum class EUILayoutElement_ConstantSizeType : uint8
{
	UseUIItemSize                            = 0,
	UseCustomSize                            = 1,
	EUILayoutElement_MAX                     = 2,
};

// Enum LGUI.EUILayoutAnimationType
// NumValues: 0x0004
enum class EUILayoutAnimationType : uint8
{
	Immediately                              = 0,
	EaseAnimation                            = 1,
	Custom                                   = 2,
	EUILayoutAnimationType_MAX               = 3,
};

// Enum LGUI.EUIPanelLayout_FlexibleGridSizeRule
// NumValues: 0x0003
enum class EUIPanelLayout_FlexibleGridSizeRule : uint8
{
	Constant                                 = 0,
	Ratio                                    = 1,
	EUIPanelLayout_MAX                       = 2,
};

// Enum LGUI.UIPolygonUVType
// NumValues: 0x0004
enum class EUIPolygonUVType : uint8
{
	SpriteRect                               = 0,
	HeightCenter                             = 1,
	StretchSpriteHeight                      = 2,
	UIPolygonUVType_MAX                      = 3,
};

// Enum LGUI.EUIPostProcessMaskTextureType
// NumValues: 0x0003
enum class EUIPostProcessMaskTextureType : uint8
{
	Simple                                   = 0,
	Sliced                                   = 1,
	EUIPostProcessMaskTextureType_MAX        = 2,
};

// Enum LGUI.EUIProceduralRectTextureScaleMode
// NumValues: 0x0004
enum class EUIProceduralRectTextureScaleMode : uint8
{
	Stretch                                  = 0,
	Fit                                      = 1,
	Envelop                                  = 2,
	EUIProceduralRectTextureScaleMode_MAX    = 3,
};

// Enum LGUI.EUIProceduralRectUnitMode
// NumValues: 0x0003
enum class EUIProceduralRectUnitMode : uint8
{
	Value                                    = 0,
	Percentage                               = 1,
	EUIProceduralRectUnitMode_MAX            = 2,
};

// Enum LGUI.EUIProceduralBodyTextureMode
// NumValues: 0x0003
enum class EUIProceduralBodyTextureMode : uint8
{
	Texture                                  = 0,
	Sprite                                   = 1,
	EUIProceduralBodyTextureMode_MAX         = 2,
};

// Enum LGUI.EUIRecyclableScrollViewCellTemplateType
// NumValues: 0x0003
enum class EUIRecyclableScrollViewCellTemplateType : uint8
{
	Actor                                    = 0,
	Prefab                                   = 1,
	EUIRecyclableScrollViewCellTemplateType_MAX = 2,
};

// Enum LGUI.UIScrollbarDirectionType
// NumValues: 0x0005
enum class EUIScrollbarDirectionType : uint8
{
	LeftToRight                              = 0,
	RightToLeft                              = 1,
	BottomToTop                              = 2,
	TopToBottom                              = 3,
	UIScrollbarDirectionType_MAX             = 4,
};

// Enum LGUI.EScrollViewScrollbarVisibility
// NumValues: 0x0004
enum class EScrollViewScrollbarVisibility : uint8
{
	Permanent                                = 0,
	AutoHide                                 = 1,
	AutoHideAndExpandViewport                = 2,
	EScrollViewScrollbarVisibility_MAX       = 3,
};

// Enum LGUI.UISelectableTransitionType
// NumValues: 0x0005
enum class EUISelectableTransitionType : uint8
{
	None                                     = 0,
	ColorTint                                = 1,
	SpriteSwap                               = 2,
	TransitionComponent                      = 3,
	UISelectableTransitionType_MAX           = 4,
};

// Enum LGUI.EUISelectableSelectionState
// NumValues: 0x0005
enum class EUISelectableSelectionState : uint8
{
	Normal                                   = 0,
	Highlighted                              = 1,
	Pressed                                  = 2,
	Disabled                                 = 3,
	EUISelectableSelectionState_MAX          = 4,
};

// Enum LGUI.EUISelectableNavigationMode
// NumValues: 0x0004
enum class EUISelectableNavigationMode : uint8
{
	None                                     = 0,
	Auto                                     = 1,
	Explicit                                 = 2,
	EUISelectableNavigationMode_MAX          = 3,
};

// Enum LGUI.EUISizeControlByAspectRatioMode
// NumValues: 0x0006
enum class EUISizeControlByAspectRatioMode : uint8
{
	None                                     = 0,
	WidthControlHeight                       = 1,
	HeightControlWidth                       = 2,
	FitInParent                              = 3,
	EnvelopeParent                           = 4,
	EUISizeControlByAspectRatioMode_MAX      = 5,
};

// Enum LGUI.UISliderDirectionType
// NumValues: 0x0005
enum class EUISliderDirectionType : uint8
{
	LeftToRight                              = 0,
	RightToLeft                              = 1,
	BottomToTop                              = 2,
	TopToBottom                              = 3,
	UISliderDirectionType_MAX                = 4,
};

// Enum LGUI.EUISpriteType
// NumValues: 0x0006
enum class EUISpriteType : uint8
{
	Normal                                   = 0,
	Sliced                                   = 1,
	SlicedFrame                              = 2,
	Tiled                                    = 3,
	Filled                                   = 4,
	EUISpriteType_MAX                        = 5,
};

// Enum LGUI.EUISpriteFillMethod
// NumValues: 0x0006
enum class EUISpriteFillMethod : uint8
{
	Horizontal                               = 0,
	Vertical                                 = 1,
	Radial90                                 = 2,
	Radial180                                = 3,
	Radial360                                = 4,
	EUISpriteFillMethod_MAX                  = 5,
};

// Enum LGUI.EUISpriteFillOriginType_Radial90
// NumValues: 0x0005
enum class EUISpriteFillOriginType_Radial90 : uint8
{
	BottomLeft                               = 0,
	TopLeft                                  = 1,
	TopRight                                 = 2,
	BottomRight                              = 3,
	EUISpriteFillOriginType_MAX              = 4,
};

// Enum LGUI.EUISpriteFillOriginType_Radial180
// NumValues: 0x0005
enum class EUISpriteFillOriginType_Radial180 : uint8
{
	Bottom                                   = 0,
	Left                                     = 1,
	Top                                      = 2,
	Right                                    = 3,
	EUISpriteFillOriginType_MAX              = 4,
};

// Enum LGUI.EUISpriteFillOriginType_Radial360
// NumValues: 0x0005
enum class EUISpriteFillOriginType_Radial360 : uint8
{
	Bottom                                   = 0,
	Right                                    = 1,
	Top                                      = 2,
	Left                                     = 3,
	EUISpriteFillOriginType_MAX              = 4,
};

// Enum LGUI.UIStaticMeshVertexColorType
// NumValues: 0x0004
enum class EUIStaticMeshVertexColorType : uint8
{
	MultiplyWithUIColor                      = 0,
	ReplaceByUIColor                         = 1,
	NotAffectByUIColor                       = 2,
	UIStaticMeshVertexColorType_MAX          = 3,
};

// Enum LGUI.ELGUITextInputType
// NumValues: 0x0009
enum class ELGUITextInputType : uint8
{
	Standard                                 = 0,
	IntegerNumber                            = 1,
	DecimalNumber                            = 2,
	Alphanumeric                             = 5,
	EmailAddress                             = 6,
	Password                                 = 3,
	CustomFunction                           = 4,
	Custom                                   = 7,
	ELGUITextInputType_MAX                   = 8,
};

// Enum LGUI.ELGUITextInputDisplayType
// NumValues: 0x0003
enum class ELGUITextInputDisplayType : uint8
{
	Standard                                 = 0,
	Password                                 = 1,
	ELGUITextInputDisplayType_MAX            = 2,
};

// Enum LGUI.ELGUITextInputOverflowType
// NumValues: 0x0003
enum class ELGUITextInputOverflowType : uint8
{
	ClampContent                             = 0,
	OverflowToMax                            = 1,
	ELGUITextInputOverflowType_MAX           = 2,
};

// Enum LGUI.EUITextureType
// NumValues: 0x0006
enum class EUITextureType : uint8
{
	Normal                                   = 0,
	Sliced                                   = 1,
	SlicedFrame                              = 2,
	Tiled                                    = 3,
	Filled                                   = 4,
	EUITextureType_MAX                       = 5,
};

// Enum LGUI.EUITextureUVRectControlMode
// NumValues: 0x0004
enum class EUITextureUVRectControlMode : uint8
{
	None                                     = 0,
	KeepAspectRatio_FitIn                    = 1,
	KeepAspectRatio_Envelope                 = 2,
	EUITextureUVRectControlMode_MAX          = 3,
};

// Enum LGUI.UIToggleTransitionType
// NumValues: 0x0005
enum class EUIToggleTransitionType : uint8
{
	None                                     = 0,
	Fade                                     = 1,
	ColorTint                                = 2,
	TransitionComponent                      = 3,
	UIToggleTransitionType_MAX               = 4,
};

// ScriptStruct LGUI.LGUICanLayoutControlAnchor
// 0x0006 (0x0006 - 0x0000)
struct FLGUICanLayoutControlAnchor final
{
public:
	bool                                          bCanControlHorizontalAnchor;                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanControlVerticalAnchor;                         // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanControlHorizontalAnchoredPosition;             // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanControlVerticalAnchoredPosition;               // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanControlHorizontalSizeDelta;                    // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanControlVerticalSizeDelta;                      // 0x0005(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLGUICanLayoutControlAnchor) == 0x000001, "Wrong alignment on FLGUICanLayoutControlAnchor");
static_assert(sizeof(FLGUICanLayoutControlAnchor) == 0x000006, "Wrong size on FLGUICanLayoutControlAnchor");
static_assert(offsetof(FLGUICanLayoutControlAnchor, bCanControlHorizontalAnchor) == 0x000000, "Member 'FLGUICanLayoutControlAnchor::bCanControlHorizontalAnchor' has a wrong offset!");
static_assert(offsetof(FLGUICanLayoutControlAnchor, bCanControlVerticalAnchor) == 0x000001, "Member 'FLGUICanLayoutControlAnchor::bCanControlVerticalAnchor' has a wrong offset!");
static_assert(offsetof(FLGUICanLayoutControlAnchor, bCanControlHorizontalAnchoredPosition) == 0x000002, "Member 'FLGUICanLayoutControlAnchor::bCanControlHorizontalAnchoredPosition' has a wrong offset!");
static_assert(offsetof(FLGUICanLayoutControlAnchor, bCanControlVerticalAnchoredPosition) == 0x000003, "Member 'FLGUICanLayoutControlAnchor::bCanControlVerticalAnchoredPosition' has a wrong offset!");
static_assert(offsetof(FLGUICanLayoutControlAnchor, bCanControlHorizontalSizeDelta) == 0x000004, "Member 'FLGUICanLayoutControlAnchor::bCanControlHorizontalSizeDelta' has a wrong offset!");
static_assert(offsetof(FLGUICanLayoutControlAnchor, bCanControlVerticalSizeDelta) == 0x000005, "Member 'FLGUICanLayoutControlAnchor::bCanControlVerticalSizeDelta' has a wrong offset!");

// ScriptStruct LGUI.LGUIDuplicateDataContainer
// 0x0490 (0x0490 - 0x0000)
struct alignas(0x10) FLGUIDuplicateDataContainer final
{
public:
	uint8                                         Pad_0[0x490];                                      // 0x0000(0x0490)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIDuplicateDataContainer) == 0x000010, "Wrong alignment on FLGUIDuplicateDataContainer");
static_assert(sizeof(FLGUIDuplicateDataContainer) == 0x000490, "Wrong size on FLGUIDuplicateDataContainer");

// ScriptStruct LGUI.LGUIMaterialArrayContainer
// 0x0010 (0x0010 - 0x0000)
struct FLGUIMaterialArrayContainer final
{
public:
	TArray<class UMaterialInstanceDynamic*>       MaterialList;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLGUIMaterialArrayContainer) == 0x000008, "Wrong alignment on FLGUIMaterialArrayContainer");
static_assert(sizeof(FLGUIMaterialArrayContainer) == 0x000010, "Wrong size on FLGUIMaterialArrayContainer");
static_assert(offsetof(FLGUIMaterialArrayContainer, MaterialList) == 0x000000, "Member 'FLGUIMaterialArrayContainer::MaterialList' has a wrong offset!");

// ScriptStruct LGUI.LGUIComponentReference
// 0x0020 (0x0020 - 0x0000)
struct FLGUIComponentReference final
{
public:
	class AActor*                                 HelperActor;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UActorComponent>            HelperClass;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   HelperComponentName;                               // 0x0010(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UActorComponent*                        TargetComp;                                        // 0x0018(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FLGUIComponentReference) == 0x000008, "Wrong alignment on FLGUIComponentReference");
static_assert(sizeof(FLGUIComponentReference) == 0x000020, "Wrong size on FLGUIComponentReference");
static_assert(offsetof(FLGUIComponentReference, HelperActor) == 0x000000, "Member 'FLGUIComponentReference::HelperActor' has a wrong offset!");
static_assert(offsetof(FLGUIComponentReference, HelperClass) == 0x000008, "Member 'FLGUIComponentReference::HelperClass' has a wrong offset!");
static_assert(offsetof(FLGUIComponentReference, HelperComponentName) == 0x000010, "Member 'FLGUIComponentReference::HelperComponentName' has a wrong offset!");
static_assert(offsetof(FLGUIComponentReference, TargetComp) == 0x000018, "Member 'FLGUIComponentReference::TargetComp' has a wrong offset!");

// ScriptStruct LGUI.LGUIDelegateHandleWrapper
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FLGUIDelegateHandleWrapper final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIDelegateHandleWrapper) == 0x000008, "Wrong alignment on FLGUIDelegateHandleWrapper");
static_assert(sizeof(FLGUIDelegateHandleWrapper) == 0x000008, "Wrong size on FLGUIDelegateHandleWrapper");

// ScriptStruct LGUI.LGUIDynamicSpriteAtlasData
// 0x0070 (0x0070 - 0x0000)
struct FLGUIDynamicSpriteAtlasData final
{
public:
	class UTexture2D*                             atlasTexture;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x30];                                       // 0x0008(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULGUISpriteData*>                spriteDataArray;                                   // 0x0038(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class UObject>>         renderSpriteArray;                                 // 0x0048(0x0010)(Edit, ZeroConstructor, Transient, EditConst, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x18];                                      // 0x0058(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIDynamicSpriteAtlasData) == 0x000008, "Wrong alignment on FLGUIDynamicSpriteAtlasData");
static_assert(sizeof(FLGUIDynamicSpriteAtlasData) == 0x000070, "Wrong size on FLGUIDynamicSpriteAtlasData");
static_assert(offsetof(FLGUIDynamicSpriteAtlasData, atlasTexture) == 0x000000, "Member 'FLGUIDynamicSpriteAtlasData::atlasTexture' has a wrong offset!");
static_assert(offsetof(FLGUIDynamicSpriteAtlasData, spriteDataArray) == 0x000038, "Member 'FLGUIDynamicSpriteAtlasData::spriteDataArray' has a wrong offset!");
static_assert(offsetof(FLGUIDynamicSpriteAtlasData, renderSpriteArray) == 0x000048, "Member 'FLGUIDynamicSpriteAtlasData::renderSpriteArray' has a wrong offset!");

// ScriptStruct LGUI.LGUIEventDelegateData
// 0x0058 (0x0058 - 0x0000)
struct FLGUIEventDelegateData final
{
public:
	class AActor*                                 HelperActor;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UObject>                    HelperClass;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   HelperComponentName;                               // 0x0010(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UObject*                                TargetObject;                                      // 0x0018(0x0008)(Edit, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   FunctionName;                                      // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELGUIEventDelegateParameterType               ParamType;                                         // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 ParamBuffer;                                       // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class UObject*                                ReferenceObject;                                   // 0x0040(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          UseNativeParameter;                                // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFunction*                              CacheFunction;                                     // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLGUIEventDelegateData) == 0x000008, "Wrong alignment on FLGUIEventDelegateData");
static_assert(sizeof(FLGUIEventDelegateData) == 0x000058, "Wrong size on FLGUIEventDelegateData");
static_assert(offsetof(FLGUIEventDelegateData, HelperActor) == 0x000000, "Member 'FLGUIEventDelegateData::HelperActor' has a wrong offset!");
static_assert(offsetof(FLGUIEventDelegateData, HelperClass) == 0x000008, "Member 'FLGUIEventDelegateData::HelperClass' has a wrong offset!");
static_assert(offsetof(FLGUIEventDelegateData, HelperComponentName) == 0x000010, "Member 'FLGUIEventDelegateData::HelperComponentName' has a wrong offset!");
static_assert(offsetof(FLGUIEventDelegateData, TargetObject) == 0x000018, "Member 'FLGUIEventDelegateData::TargetObject' has a wrong offset!");
static_assert(offsetof(FLGUIEventDelegateData, FunctionName) == 0x000020, "Member 'FLGUIEventDelegateData::FunctionName' has a wrong offset!");
static_assert(offsetof(FLGUIEventDelegateData, ParamType) == 0x000028, "Member 'FLGUIEventDelegateData::ParamType' has a wrong offset!");
static_assert(offsetof(FLGUIEventDelegateData, ParamBuffer) == 0x000030, "Member 'FLGUIEventDelegateData::ParamBuffer' has a wrong offset!");
static_assert(offsetof(FLGUIEventDelegateData, ReferenceObject) == 0x000040, "Member 'FLGUIEventDelegateData::ReferenceObject' has a wrong offset!");
static_assert(offsetof(FLGUIEventDelegateData, UseNativeParameter) == 0x000048, "Member 'FLGUIEventDelegateData::UseNativeParameter' has a wrong offset!");
static_assert(offsetof(FLGUIEventDelegateData, CacheFunction) == 0x000050, "Member 'FLGUIEventDelegateData::CacheFunction' has a wrong offset!");

// ScriptStruct LGUI.LGUIEventDelegate
// 0x0018 (0x0018 - 0x0000)
struct FLGUIEventDelegate
{
public:
	TArray<struct FLGUIEventDelegateData>         eventList;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	ELGUIEventDelegateParameterType               supportParameterType;                              // 0x0010(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIEventDelegate) == 0x000008, "Wrong alignment on FLGUIEventDelegate");
static_assert(sizeof(FLGUIEventDelegate) == 0x000018, "Wrong size on FLGUIEventDelegate");
static_assert(offsetof(FLGUIEventDelegate, eventList) == 0x000000, "Member 'FLGUIEventDelegate::eventList' has a wrong offset!");
static_assert(offsetof(FLGUIEventDelegate, supportParameterType) == 0x000010, "Member 'FLGUIEventDelegate::supportParameterType' has a wrong offset!");

// ScriptStruct LGUI.LGUIEventDelegate_Empty
// 0x0018 (0x0030 - 0x0018)
struct FLGUIEventDelegate_Empty final : public FLGUIEventDelegate
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIEventDelegate_Empty) == 0x000008, "Wrong alignment on FLGUIEventDelegate_Empty");
static_assert(sizeof(FLGUIEventDelegate_Empty) == 0x000030, "Wrong size on FLGUIEventDelegate_Empty");

// ScriptStruct LGUI.LGUIEventDelegate_Bool
// 0x0018 (0x0030 - 0x0018)
struct FLGUIEventDelegate_Bool final : public FLGUIEventDelegate
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIEventDelegate_Bool) == 0x000008, "Wrong alignment on FLGUIEventDelegate_Bool");
static_assert(sizeof(FLGUIEventDelegate_Bool) == 0x000030, "Wrong size on FLGUIEventDelegate_Bool");

// ScriptStruct LGUI.LGUIEventDelegate_Float
// 0x0018 (0x0030 - 0x0018)
struct FLGUIEventDelegate_Float final : public FLGUIEventDelegate
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIEventDelegate_Float) == 0x000008, "Wrong alignment on FLGUIEventDelegate_Float");
static_assert(sizeof(FLGUIEventDelegate_Float) == 0x000030, "Wrong size on FLGUIEventDelegate_Float");

// ScriptStruct LGUI.LGUIEventDelegate_Double
// 0x0018 (0x0030 - 0x0018)
struct FLGUIEventDelegate_Double final : public FLGUIEventDelegate
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIEventDelegate_Double) == 0x000008, "Wrong alignment on FLGUIEventDelegate_Double");
static_assert(sizeof(FLGUIEventDelegate_Double) == 0x000030, "Wrong size on FLGUIEventDelegate_Double");

// ScriptStruct LGUI.LGUIEventDelegate_Int8
// 0x0018 (0x0030 - 0x0018)
struct FLGUIEventDelegate_Int8 final : public FLGUIEventDelegate
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIEventDelegate_Int8) == 0x000008, "Wrong alignment on FLGUIEventDelegate_Int8");
static_assert(sizeof(FLGUIEventDelegate_Int8) == 0x000030, "Wrong size on FLGUIEventDelegate_Int8");

// ScriptStruct LGUI.LGUIEventDelegate_UInt8
// 0x0018 (0x0030 - 0x0018)
struct FLGUIEventDelegate_UInt8 final : public FLGUIEventDelegate
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIEventDelegate_UInt8) == 0x000008, "Wrong alignment on FLGUIEventDelegate_UInt8");
static_assert(sizeof(FLGUIEventDelegate_UInt8) == 0x000030, "Wrong size on FLGUIEventDelegate_UInt8");

// ScriptStruct LGUI.LGUIEventDelegate_Int16
// 0x0018 (0x0030 - 0x0018)
struct FLGUIEventDelegate_Int16 final : public FLGUIEventDelegate
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIEventDelegate_Int16) == 0x000008, "Wrong alignment on FLGUIEventDelegate_Int16");
static_assert(sizeof(FLGUIEventDelegate_Int16) == 0x000030, "Wrong size on FLGUIEventDelegate_Int16");

// ScriptStruct LGUI.LGUIEventDelegate_UInt16
// 0x0018 (0x0030 - 0x0018)
struct FLGUIEventDelegate_UInt16 final : public FLGUIEventDelegate
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIEventDelegate_UInt16) == 0x000008, "Wrong alignment on FLGUIEventDelegate_UInt16");
static_assert(sizeof(FLGUIEventDelegate_UInt16) == 0x000030, "Wrong size on FLGUIEventDelegate_UInt16");

// ScriptStruct LGUI.LGUIEventDelegate_Int32
// 0x0018 (0x0030 - 0x0018)
struct FLGUIEventDelegate_Int32 final : public FLGUIEventDelegate
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIEventDelegate_Int32) == 0x000008, "Wrong alignment on FLGUIEventDelegate_Int32");
static_assert(sizeof(FLGUIEventDelegate_Int32) == 0x000030, "Wrong size on FLGUIEventDelegate_Int32");

// ScriptStruct LGUI.LGUIEventDelegate_UInt32
// 0x0018 (0x0030 - 0x0018)
struct FLGUIEventDelegate_UInt32 final : public FLGUIEventDelegate
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIEventDelegate_UInt32) == 0x000008, "Wrong alignment on FLGUIEventDelegate_UInt32");
static_assert(sizeof(FLGUIEventDelegate_UInt32) == 0x000030, "Wrong size on FLGUIEventDelegate_UInt32");

// ScriptStruct LGUI.LGUIEventDelegate_Int64
// 0x0018 (0x0030 - 0x0018)
struct FLGUIEventDelegate_Int64 final : public FLGUIEventDelegate
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIEventDelegate_Int64) == 0x000008, "Wrong alignment on FLGUIEventDelegate_Int64");
static_assert(sizeof(FLGUIEventDelegate_Int64) == 0x000030, "Wrong size on FLGUIEventDelegate_Int64");

// ScriptStruct LGUI.LGUIEventDelegate_UInt64
// 0x0018 (0x0030 - 0x0018)
struct FLGUIEventDelegate_UInt64 final : public FLGUIEventDelegate
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIEventDelegate_UInt64) == 0x000008, "Wrong alignment on FLGUIEventDelegate_UInt64");
static_assert(sizeof(FLGUIEventDelegate_UInt64) == 0x000030, "Wrong size on FLGUIEventDelegate_UInt64");

// ScriptStruct LGUI.LGUIEventDelegate_Vector2
// 0x0018 (0x0030 - 0x0018)
struct FLGUIEventDelegate_Vector2 final : public FLGUIEventDelegate
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIEventDelegate_Vector2) == 0x000008, "Wrong alignment on FLGUIEventDelegate_Vector2");
static_assert(sizeof(FLGUIEventDelegate_Vector2) == 0x000030, "Wrong size on FLGUIEventDelegate_Vector2");

// ScriptStruct LGUI.LGUIEventDelegate_Vector3
// 0x0018 (0x0030 - 0x0018)
struct FLGUIEventDelegate_Vector3 final : public FLGUIEventDelegate
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIEventDelegate_Vector3) == 0x000008, "Wrong alignment on FLGUIEventDelegate_Vector3");
static_assert(sizeof(FLGUIEventDelegate_Vector3) == 0x000030, "Wrong size on FLGUIEventDelegate_Vector3");

// ScriptStruct LGUI.LGUIEventDelegate_Vector4
// 0x0018 (0x0030 - 0x0018)
struct FLGUIEventDelegate_Vector4 final : public FLGUIEventDelegate
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIEventDelegate_Vector4) == 0x000008, "Wrong alignment on FLGUIEventDelegate_Vector4");
static_assert(sizeof(FLGUIEventDelegate_Vector4) == 0x000030, "Wrong size on FLGUIEventDelegate_Vector4");

// ScriptStruct LGUI.LGUIEventDelegate_Color
// 0x0018 (0x0030 - 0x0018)
struct FLGUIEventDelegate_Color final : public FLGUIEventDelegate
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIEventDelegate_Color) == 0x000008, "Wrong alignment on FLGUIEventDelegate_Color");
static_assert(sizeof(FLGUIEventDelegate_Color) == 0x000030, "Wrong size on FLGUIEventDelegate_Color");

// ScriptStruct LGUI.LGUIEventDelegate_LinearColor
// 0x0018 (0x0030 - 0x0018)
struct FLGUIEventDelegate_LinearColor final : public FLGUIEventDelegate
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIEventDelegate_LinearColor) == 0x000008, "Wrong alignment on FLGUIEventDelegate_LinearColor");
static_assert(sizeof(FLGUIEventDelegate_LinearColor) == 0x000030, "Wrong size on FLGUIEventDelegate_LinearColor");

// ScriptStruct LGUI.LGUIEventDelegate_Quaternion
// 0x0018 (0x0030 - 0x0018)
struct FLGUIEventDelegate_Quaternion final : public FLGUIEventDelegate
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIEventDelegate_Quaternion) == 0x000008, "Wrong alignment on FLGUIEventDelegate_Quaternion");
static_assert(sizeof(FLGUIEventDelegate_Quaternion) == 0x000030, "Wrong size on FLGUIEventDelegate_Quaternion");

// ScriptStruct LGUI.LGUIEventDelegate_String
// 0x0018 (0x0030 - 0x0018)
struct FLGUIEventDelegate_String final : public FLGUIEventDelegate
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIEventDelegate_String) == 0x000008, "Wrong alignment on FLGUIEventDelegate_String");
static_assert(sizeof(FLGUIEventDelegate_String) == 0x000030, "Wrong size on FLGUIEventDelegate_String");

// ScriptStruct LGUI.LGUIEventDelegate_Object
// 0x0018 (0x0030 - 0x0018)
struct FLGUIEventDelegate_Object final : public FLGUIEventDelegate
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIEventDelegate_Object) == 0x000008, "Wrong alignment on FLGUIEventDelegate_Object");
static_assert(sizeof(FLGUIEventDelegate_Object) == 0x000030, "Wrong size on FLGUIEventDelegate_Object");

// ScriptStruct LGUI.LGUIEventDelegate_Actor
// 0x0018 (0x0030 - 0x0018)
struct FLGUIEventDelegate_Actor final : public FLGUIEventDelegate
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIEventDelegate_Actor) == 0x000008, "Wrong alignment on FLGUIEventDelegate_Actor");
static_assert(sizeof(FLGUIEventDelegate_Actor) == 0x000030, "Wrong size on FLGUIEventDelegate_Actor");

// ScriptStruct LGUI.LGUIEventDelegate_PointerEvent
// 0x0018 (0x0030 - 0x0018)
struct FLGUIEventDelegate_PointerEvent final : public FLGUIEventDelegate
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIEventDelegate_PointerEvent) == 0x000008, "Wrong alignment on FLGUIEventDelegate_PointerEvent");
static_assert(sizeof(FLGUIEventDelegate_PointerEvent) == 0x000030, "Wrong size on FLGUIEventDelegate_PointerEvent");

// ScriptStruct LGUI.LGUIEventDelegate_Class
// 0x0018 (0x0030 - 0x0018)
struct FLGUIEventDelegate_Class final : public FLGUIEventDelegate
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIEventDelegate_Class) == 0x000008, "Wrong alignment on FLGUIEventDelegate_Class");
static_assert(sizeof(FLGUIEventDelegate_Class) == 0x000030, "Wrong size on FLGUIEventDelegate_Class");

// ScriptStruct LGUI.LGUIEventDelegate_Rotator
// 0x0018 (0x0030 - 0x0018)
struct FLGUIEventDelegate_Rotator final : public FLGUIEventDelegate
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIEventDelegate_Rotator) == 0x000008, "Wrong alignment on FLGUIEventDelegate_Rotator");
static_assert(sizeof(FLGUIEventDelegate_Rotator) == 0x000030, "Wrong size on FLGUIEventDelegate_Rotator");

// ScriptStruct LGUI.LGUIEventDelegate_Text
// 0x0018 (0x0030 - 0x0018)
struct FLGUIEventDelegate_Text final : public FLGUIEventDelegate
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIEventDelegate_Text) == 0x000008, "Wrong alignment on FLGUIEventDelegate_Text");
static_assert(sizeof(FLGUIEventDelegate_Text) == 0x000030, "Wrong size on FLGUIEventDelegate_Text");

// ScriptStruct LGUI.LGUIEventDelegate_Name
// 0x0018 (0x0030 - 0x0018)
struct FLGUIEventDelegate_Name final : public FLGUIEventDelegate
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIEventDelegate_Name) == 0x000008, "Wrong alignment on FLGUIEventDelegate_Name");
static_assert(sizeof(FLGUIEventDelegate_Name) == 0x000030, "Wrong size on FLGUIEventDelegate_Name");

// ScriptStruct LGUI.LGUICharData
// 0x001C (0x001C - 0x0000)
struct FLGUICharData final
{
public:
	uint16                                        Width;                                             // 0x0000(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        Height;                                            // 0x0002(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         xoffset;                                           // 0x0004(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         yoffset;                                           // 0x0006(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         xadvance;                                          // 0x0008(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         uv0X;                                              // 0x000C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         uv0Y;                                              // 0x0010(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         uv3X;                                              // 0x0014(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         uv3Y;                                              // 0x0018(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLGUICharData) == 0x000004, "Wrong alignment on FLGUICharData");
static_assert(sizeof(FLGUICharData) == 0x00001C, "Wrong size on FLGUICharData");
static_assert(offsetof(FLGUICharData, Width) == 0x000000, "Member 'FLGUICharData::Width' has a wrong offset!");
static_assert(offsetof(FLGUICharData, Height) == 0x000002, "Member 'FLGUICharData::Height' has a wrong offset!");
static_assert(offsetof(FLGUICharData, xoffset) == 0x000004, "Member 'FLGUICharData::xoffset' has a wrong offset!");
static_assert(offsetof(FLGUICharData, yoffset) == 0x000006, "Member 'FLGUICharData::yoffset' has a wrong offset!");
static_assert(offsetof(FLGUICharData, xadvance) == 0x000008, "Member 'FLGUICharData::xadvance' has a wrong offset!");
static_assert(offsetof(FLGUICharData, uv0X) == 0x00000C, "Member 'FLGUICharData::uv0X' has a wrong offset!");
static_assert(offsetof(FLGUICharData, uv0Y) == 0x000010, "Member 'FLGUICharData::uv0Y' has a wrong offset!");
static_assert(offsetof(FLGUICharData, uv3X) == 0x000014, "Member 'FLGUICharData::uv3X' has a wrong offset!");
static_assert(offsetof(FLGUICharData, uv3Y) == 0x000018, "Member 'FLGUICharData::uv3Y' has a wrong offset!");

// ScriptStruct LGUI.LGUIPrefabOverrideParameterData
// 0x0018 (0x0018 - 0x0000)
struct FLGUIPrefabOverrideParameterData final
{
public:
	TWeakObjectPtr<class UObject>                 Object;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           MemberPropertyNames;                               // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLGUIPrefabOverrideParameterData) == 0x000008, "Wrong alignment on FLGUIPrefabOverrideParameterData");
static_assert(sizeof(FLGUIPrefabOverrideParameterData) == 0x000018, "Wrong size on FLGUIPrefabOverrideParameterData");
static_assert(offsetof(FLGUIPrefabOverrideParameterData, Object) == 0x000000, "Member 'FLGUIPrefabOverrideParameterData::Object' has a wrong offset!");
static_assert(offsetof(FLGUIPrefabOverrideParameterData, MemberPropertyNames) == 0x000008, "Member 'FLGUIPrefabOverrideParameterData::MemberPropertyNames' has a wrong offset!");

// ScriptStruct LGUI.LGUISubPrefabObjectUniqueId
// 0x0020 (0x0020 - 0x0000)
struct FLGUISubPrefabObjectUniqueId final
{
public:
	struct FGuid                                  RootActorGuidInParentPrefab;                       // 0x0000(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ObjectGuidInOrignPrefab;                           // 0x0010(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLGUISubPrefabObjectUniqueId) == 0x000004, "Wrong alignment on FLGUISubPrefabObjectUniqueId");
static_assert(sizeof(FLGUISubPrefabObjectUniqueId) == 0x000020, "Wrong size on FLGUISubPrefabObjectUniqueId");
static_assert(offsetof(FLGUISubPrefabObjectUniqueId, RootActorGuidInParentPrefab) == 0x000000, "Member 'FLGUISubPrefabObjectUniqueId::RootActorGuidInParentPrefab' has a wrong offset!");
static_assert(offsetof(FLGUISubPrefabObjectUniqueId, ObjectGuidInOrignPrefab) == 0x000010, "Member 'FLGUISubPrefabObjectUniqueId::ObjectGuidInOrignPrefab' has a wrong offset!");

// ScriptStruct LGUI.LGUISubPrefabData
// 0x0108 (0x0108 - 0x0000)
struct FLGUISubPrefabData final
{
public:
	class ULGUIPrefab*                            PrefabAsset;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLGUIPrefabOverrideParameterData> ObjectOverrideParameterArray;                    // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TMap<struct FGuid, struct FGuid>              MapObjectGuidFromParentPrefabToSubPrefab;          // 0x0018(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<struct FLGUISubPrefabObjectUniqueId, struct FGuid> MapObjectIdToNewlyCreatedId;             // 0x0068(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TMap<struct FGuid, class UObject*>            MapGuidToObject;                                   // 0x00B8(0x0050)(Edit, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLGUISubPrefabData) == 0x000008, "Wrong alignment on FLGUISubPrefabData");
static_assert(sizeof(FLGUISubPrefabData) == 0x000108, "Wrong size on FLGUISubPrefabData");
static_assert(offsetof(FLGUISubPrefabData, PrefabAsset) == 0x000000, "Member 'FLGUISubPrefabData::PrefabAsset' has a wrong offset!");
static_assert(offsetof(FLGUISubPrefabData, ObjectOverrideParameterArray) == 0x000008, "Member 'FLGUISubPrefabData::ObjectOverrideParameterArray' has a wrong offset!");
static_assert(offsetof(FLGUISubPrefabData, MapObjectGuidFromParentPrefabToSubPrefab) == 0x000018, "Member 'FLGUISubPrefabData::MapObjectGuidFromParentPrefabToSubPrefab' has a wrong offset!");
static_assert(offsetof(FLGUISubPrefabData, MapObjectIdToNewlyCreatedId) == 0x000068, "Member 'FLGUISubPrefabData::MapObjectIdToNewlyCreatedId' has a wrong offset!");
static_assert(offsetof(FLGUISubPrefabData, MapGuidToObject) == 0x0000B8, "Member 'FLGUISubPrefabData::MapGuidToObject' has a wrong offset!");

// ScriptStruct LGUI.LGUIPrefabDataForPrefabEditor
// 0x00A8 (0x00A8 - 0x0000)
struct FLGUIPrefabDataForPrefabEditor final
{
public:
	struct FVector                                ViewLocation;                                      // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ViewRotation;                                      // 0x0018(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ViewOrbitLocation;                                 // 0x0030(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              CanvasSize;                                        // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedCanvas;                                       // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CanvasRenderMode;                                  // 0x0051(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewModeIndex                                ViewMode;                                          // 0x0052(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_53[0x5];                                       // 0x0053(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FGuid>                            UnexpendActorSet;                                  // 0x0058(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FLGUIPrefabDataForPrefabEditor) == 0x000008, "Wrong alignment on FLGUIPrefabDataForPrefabEditor");
static_assert(sizeof(FLGUIPrefabDataForPrefabEditor) == 0x0000A8, "Wrong size on FLGUIPrefabDataForPrefabEditor");
static_assert(offsetof(FLGUIPrefabDataForPrefabEditor, ViewLocation) == 0x000000, "Member 'FLGUIPrefabDataForPrefabEditor::ViewLocation' has a wrong offset!");
static_assert(offsetof(FLGUIPrefabDataForPrefabEditor, ViewRotation) == 0x000018, "Member 'FLGUIPrefabDataForPrefabEditor::ViewRotation' has a wrong offset!");
static_assert(offsetof(FLGUIPrefabDataForPrefabEditor, ViewOrbitLocation) == 0x000030, "Member 'FLGUIPrefabDataForPrefabEditor::ViewOrbitLocation' has a wrong offset!");
static_assert(offsetof(FLGUIPrefabDataForPrefabEditor, CanvasSize) == 0x000048, "Member 'FLGUIPrefabDataForPrefabEditor::CanvasSize' has a wrong offset!");
static_assert(offsetof(FLGUIPrefabDataForPrefabEditor, bNeedCanvas) == 0x000050, "Member 'FLGUIPrefabDataForPrefabEditor::bNeedCanvas' has a wrong offset!");
static_assert(offsetof(FLGUIPrefabDataForPrefabEditor, CanvasRenderMode) == 0x000051, "Member 'FLGUIPrefabDataForPrefabEditor::CanvasRenderMode' has a wrong offset!");
static_assert(offsetof(FLGUIPrefabDataForPrefabEditor, ViewMode) == 0x000052, "Member 'FLGUIPrefabDataForPrefabEditor::ViewMode' has a wrong offset!");
static_assert(offsetof(FLGUIPrefabDataForPrefabEditor, UnexpendActorSet) == 0x000058, "Member 'FLGUIPrefabDataForPrefabEditor::UnexpendActorSet' has a wrong offset!");

// ScriptStruct LGUI.LGUIPrefabSequenceObjectReference
// 0x0020 (0x0020 - 0x0000)
struct FLGUIPrefabSequenceObjectReference final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 HelperActor;                                       // 0x0008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UObject>                    HelperClass;                                       // 0x0010(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   HelperComponentName;                               // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLGUIPrefabSequenceObjectReference) == 0x000008, "Wrong alignment on FLGUIPrefabSequenceObjectReference");
static_assert(sizeof(FLGUIPrefabSequenceObjectReference) == 0x000020, "Wrong size on FLGUIPrefabSequenceObjectReference");
static_assert(offsetof(FLGUIPrefabSequenceObjectReference, Object) == 0x000000, "Member 'FLGUIPrefabSequenceObjectReference::Object' has a wrong offset!");
static_assert(offsetof(FLGUIPrefabSequenceObjectReference, HelperActor) == 0x000008, "Member 'FLGUIPrefabSequenceObjectReference::HelperActor' has a wrong offset!");
static_assert(offsetof(FLGUIPrefabSequenceObjectReference, HelperClass) == 0x000010, "Member 'FLGUIPrefabSequenceObjectReference::HelperClass' has a wrong offset!");
static_assert(offsetof(FLGUIPrefabSequenceObjectReference, HelperComponentName) == 0x000018, "Member 'FLGUIPrefabSequenceObjectReference::HelperComponentName' has a wrong offset!");

// ScriptStruct LGUI.LGUIPrefabSequenceObjectReferences
// 0x0010 (0x0010 - 0x0000)
struct FLGUIPrefabSequenceObjectReferences final
{
public:
	TArray<struct FLGUIPrefabSequenceObjectReference> Array;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLGUIPrefabSequenceObjectReferences) == 0x000008, "Wrong alignment on FLGUIPrefabSequenceObjectReferences");
static_assert(sizeof(FLGUIPrefabSequenceObjectReferences) == 0x000010, "Wrong size on FLGUIPrefabSequenceObjectReferences");
static_assert(offsetof(FLGUIPrefabSequenceObjectReferences, Array) == 0x000000, "Member 'FLGUIPrefabSequenceObjectReferences::Array' has a wrong offset!");

// ScriptStruct LGUI.LGUIPrefabSequenceObjectReferenceMap
// 0x0020 (0x0020 - 0x0000)
struct FLGUIPrefabSequenceObjectReferenceMap final
{
public:
	TArray<struct FGuid>                          BindingIds;                                        // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FLGUIPrefabSequenceObjectReferences> References;                                   // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLGUIPrefabSequenceObjectReferenceMap) == 0x000008, "Wrong alignment on FLGUIPrefabSequenceObjectReferenceMap");
static_assert(sizeof(FLGUIPrefabSequenceObjectReferenceMap) == 0x000020, "Wrong size on FLGUIPrefabSequenceObjectReferenceMap");
static_assert(offsetof(FLGUIPrefabSequenceObjectReferenceMap, BindingIds) == 0x000000, "Member 'FLGUIPrefabSequenceObjectReferenceMap::BindingIds' has a wrong offset!");
static_assert(offsetof(FLGUIPrefabSequenceObjectReferenceMap, References) == 0x000010, "Member 'FLGUIPrefabSequenceObjectReferenceMap::References' has a wrong offset!");

// ScriptStruct LGUI.LGUIRichTextCustomStyleItemData
// 0x0018 (0x0018 - 0x0000)
struct FLGUIRichTextCustomStyleItemData final
{
public:
	bool                                          Bold;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Italic;                                            // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          underline;                                         // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          strikethrough;                                     // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELGUIRichTextCustomStyleData_SizeType         SizeType;                                          // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Size;                                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELGUIRichTextCustomStyleData_ColorType        colorType;                                         // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 Color;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELGUIRichTextCustomStyleData_SupOrSubType     supOrSub;                                          // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIRichTextCustomStyleItemData) == 0x000004, "Wrong alignment on FLGUIRichTextCustomStyleItemData");
static_assert(sizeof(FLGUIRichTextCustomStyleItemData) == 0x000018, "Wrong size on FLGUIRichTextCustomStyleItemData");
static_assert(offsetof(FLGUIRichTextCustomStyleItemData, Bold) == 0x000000, "Member 'FLGUIRichTextCustomStyleItemData::Bold' has a wrong offset!");
static_assert(offsetof(FLGUIRichTextCustomStyleItemData, Italic) == 0x000001, "Member 'FLGUIRichTextCustomStyleItemData::Italic' has a wrong offset!");
static_assert(offsetof(FLGUIRichTextCustomStyleItemData, underline) == 0x000002, "Member 'FLGUIRichTextCustomStyleItemData::underline' has a wrong offset!");
static_assert(offsetof(FLGUIRichTextCustomStyleItemData, strikethrough) == 0x000003, "Member 'FLGUIRichTextCustomStyleItemData::strikethrough' has a wrong offset!");
static_assert(offsetof(FLGUIRichTextCustomStyleItemData, SizeType) == 0x000004, "Member 'FLGUIRichTextCustomStyleItemData::SizeType' has a wrong offset!");
static_assert(offsetof(FLGUIRichTextCustomStyleItemData, Size) == 0x000008, "Member 'FLGUIRichTextCustomStyleItemData::Size' has a wrong offset!");
static_assert(offsetof(FLGUIRichTextCustomStyleItemData, colorType) == 0x00000C, "Member 'FLGUIRichTextCustomStyleItemData::colorType' has a wrong offset!");
static_assert(offsetof(FLGUIRichTextCustomStyleItemData, Color) == 0x000010, "Member 'FLGUIRichTextCustomStyleItemData::Color' has a wrong offset!");
static_assert(offsetof(FLGUIRichTextCustomStyleItemData, supOrSub) == 0x000014, "Member 'FLGUIRichTextCustomStyleItemData::supOrSub' has a wrong offset!");

// ScriptStruct LGUI.LGUIRichTextImageItemData
// 0x0018 (0x0018 - 0x0000)
struct FLGUIRichTextImageItemData final
{
public:
	TArray<class ULGUISpriteData_BaseObject*>     Frames;                                            // 0x0000(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         overrideAnimationFps;                              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGUIRichTextImageItemData) == 0x000008, "Wrong alignment on FLGUIRichTextImageItemData");
static_assert(sizeof(FLGUIRichTextImageItemData) == 0x000018, "Wrong size on FLGUIRichTextImageItemData");
static_assert(offsetof(FLGUIRichTextImageItemData, Frames) == 0x000000, "Member 'FLGUIRichTextImageItemData::Frames' has a wrong offset!");
static_assert(offsetof(FLGUIRichTextImageItemData, overrideAnimationFps) == 0x000010, "Member 'FLGUIRichTextImageItemData::overrideAnimationFps' has a wrong offset!");

// ScriptStruct LGUI.LGUIAtlasSettings
// 0x0008 (0x0008 - 0x0000)
struct FLGUIAtlasSettings final
{
public:
	ELGUIAtlasTextureSizeType                     atlasTextureInitialSize;                           // 0x0000(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          atlasTextureUseSRGB;                               // 0x0001(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextureFilter                                atlasTextureFilter;                                // 0x0002(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         spaceBetweenSprites;                               // 0x0004(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLGUIAtlasSettings) == 0x000004, "Wrong alignment on FLGUIAtlasSettings");
static_assert(sizeof(FLGUIAtlasSettings) == 0x000008, "Wrong size on FLGUIAtlasSettings");
static_assert(offsetof(FLGUIAtlasSettings, atlasTextureInitialSize) == 0x000000, "Member 'FLGUIAtlasSettings::atlasTextureInitialSize' has a wrong offset!");
static_assert(offsetof(FLGUIAtlasSettings, atlasTextureUseSRGB) == 0x000001, "Member 'FLGUIAtlasSettings::atlasTextureUseSRGB' has a wrong offset!");
static_assert(offsetof(FLGUIAtlasSettings, atlasTextureFilter) == 0x000002, "Member 'FLGUIAtlasSettings::atlasTextureFilter' has a wrong offset!");
static_assert(offsetof(FLGUIAtlasSettings, spaceBetweenSprites) == 0x000004, "Member 'FLGUIAtlasSettings::spaceBetweenSprites' has a wrong offset!");

// ScriptStruct LGUI.LGUISpriteInfo
// 0x0034 (0x0034 - 0x0000)
struct FLGUISpriteInfo final
{
public:
	uint16                                        Width;                                             // 0x0000(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        Height;                                            // 0x0002(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        borderLeft;                                        // 0x0004(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        borderRight;                                       // 0x0006(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        borderTop;                                         // 0x0008(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        borderBottom;                                      // 0x000A(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         paddingLeft;                                       // 0x000C(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         paddingRight;                                      // 0x000E(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         paddingTop;                                        // 0x0010(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         paddingBottom;                                     // 0x0012(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         uv0X;                                              // 0x0014(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         uv0Y;                                              // 0x0018(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         uv3X;                                              // 0x001C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         uv3Y;                                              // 0x0020(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         buv0X;                                             // 0x0024(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         buv0Y;                                             // 0x0028(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         buv3X;                                             // 0x002C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         buv3Y;                                             // 0x0030(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLGUISpriteInfo) == 0x000004, "Wrong alignment on FLGUISpriteInfo");
static_assert(sizeof(FLGUISpriteInfo) == 0x000034, "Wrong size on FLGUISpriteInfo");
static_assert(offsetof(FLGUISpriteInfo, Width) == 0x000000, "Member 'FLGUISpriteInfo::Width' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, Height) == 0x000002, "Member 'FLGUISpriteInfo::Height' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, borderLeft) == 0x000004, "Member 'FLGUISpriteInfo::borderLeft' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, borderRight) == 0x000006, "Member 'FLGUISpriteInfo::borderRight' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, borderTop) == 0x000008, "Member 'FLGUISpriteInfo::borderTop' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, borderBottom) == 0x00000A, "Member 'FLGUISpriteInfo::borderBottom' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, paddingLeft) == 0x00000C, "Member 'FLGUISpriteInfo::paddingLeft' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, paddingRight) == 0x00000E, "Member 'FLGUISpriteInfo::paddingRight' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, paddingTop) == 0x000010, "Member 'FLGUISpriteInfo::paddingTop' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, paddingBottom) == 0x000012, "Member 'FLGUISpriteInfo::paddingBottom' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, uv0X) == 0x000014, "Member 'FLGUISpriteInfo::uv0X' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, uv0Y) == 0x000018, "Member 'FLGUISpriteInfo::uv0Y' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, uv3X) == 0x00001C, "Member 'FLGUISpriteInfo::uv3X' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, uv3Y) == 0x000020, "Member 'FLGUISpriteInfo::uv3Y' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, buv0X) == 0x000024, "Member 'FLGUISpriteInfo::buv0X' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, buv0Y) == 0x000028, "Member 'FLGUISpriteInfo::buv0Y' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, buv3X) == 0x00002C, "Member 'FLGUISpriteInfo::buv3X' has a wrong offset!");
static_assert(offsetof(FLGUISpriteInfo, buv3Y) == 0x000030, "Member 'FLGUISpriteInfo::buv3Y' has a wrong offset!");

// ScriptStruct LGUI.UITextCharProperty
// 0x0014 (0x0014 - 0x0000)
struct FUITextCharProperty final
{
public:
	int32                                         CharIndex;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartVertIndex;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VertCount;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartTriangleIndex;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IndicesCount;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUITextCharProperty) == 0x000004, "Wrong alignment on FUITextCharProperty");
static_assert(sizeof(FUITextCharProperty) == 0x000014, "Wrong size on FUITextCharProperty");
static_assert(offsetof(FUITextCharProperty, CharIndex) == 0x000000, "Member 'FUITextCharProperty::CharIndex' has a wrong offset!");
static_assert(offsetof(FUITextCharProperty, StartVertIndex) == 0x000004, "Member 'FUITextCharProperty::StartVertIndex' has a wrong offset!");
static_assert(offsetof(FUITextCharProperty, VertCount) == 0x000008, "Member 'FUITextCharProperty::VertCount' has a wrong offset!");
static_assert(offsetof(FUITextCharProperty, StartTriangleIndex) == 0x00000C, "Member 'FUITextCharProperty::StartTriangleIndex' has a wrong offset!");
static_assert(offsetof(FUITextCharProperty, IndicesCount) == 0x000010, "Member 'FUITextCharProperty::IndicesCount' has a wrong offset!");

// ScriptStruct LGUI.UIText_RichTextCustomTag
// 0x0010 (0x0010 - 0x0000)
struct FUIText_RichTextCustomTag final
{
public:
	class FName                                   TagName;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharIndexStart;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharIndexEnd;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIText_RichTextCustomTag) == 0x000004, "Wrong alignment on FUIText_RichTextCustomTag");
static_assert(sizeof(FUIText_RichTextCustomTag) == 0x000010, "Wrong size on FUIText_RichTextCustomTag");
static_assert(offsetof(FUIText_RichTextCustomTag, TagName) == 0x000000, "Member 'FUIText_RichTextCustomTag::TagName' has a wrong offset!");
static_assert(offsetof(FUIText_RichTextCustomTag, CharIndexStart) == 0x000008, "Member 'FUIText_RichTextCustomTag::CharIndexStart' has a wrong offset!");
static_assert(offsetof(FUIText_RichTextCustomTag, CharIndexEnd) == 0x00000C, "Member 'FUIText_RichTextCustomTag::CharIndexEnd' has a wrong offset!");

// ScriptStruct LGUI.UIText_RichTextImageTag
// 0x0020 (0x0020 - 0x0000)
struct FUIText_RichTextImageTag final
{
public:
	class FName                                   TagName;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              position;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Size;                                              // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 TintColor;                                         // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIText_RichTextImageTag) == 0x000008, "Wrong alignment on FUIText_RichTextImageTag");
static_assert(sizeof(FUIText_RichTextImageTag) == 0x000020, "Wrong size on FUIText_RichTextImageTag");
static_assert(offsetof(FUIText_RichTextImageTag, TagName) == 0x000000, "Member 'FUIText_RichTextImageTag::TagName' has a wrong offset!");
static_assert(offsetof(FUIText_RichTextImageTag, position) == 0x000008, "Member 'FUIText_RichTextImageTag::position' has a wrong offset!");
static_assert(offsetof(FUIText_RichTextImageTag, Size) == 0x000018, "Member 'FUIText_RichTextImageTag::Size' has a wrong offset!");
static_assert(offsetof(FUIText_RichTextImageTag, TintColor) == 0x00001C, "Member 'FUIText_RichTextImageTag::TintColor' has a wrong offset!");

// ScriptStruct LGUI.UIAnchorData
// 0x0050 (0x0050 - 0x0000)
struct FUIAnchorData final
{
public:
	struct FVector2D                              Pivot;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AnchorMin;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AnchorMax;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AnchoredPosition;                                  // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SizeDelta;                                         // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIAnchorData) == 0x000008, "Wrong alignment on FUIAnchorData");
static_assert(sizeof(FUIAnchorData) == 0x000050, "Wrong size on FUIAnchorData");
static_assert(offsetof(FUIAnchorData, Pivot) == 0x000000, "Member 'FUIAnchorData::Pivot' has a wrong offset!");
static_assert(offsetof(FUIAnchorData, AnchorMin) == 0x000010, "Member 'FUIAnchorData::AnchorMin' has a wrong offset!");
static_assert(offsetof(FUIAnchorData, AnchorMax) == 0x000020, "Member 'FUIAnchorData::AnchorMax' has a wrong offset!");
static_assert(offsetof(FUIAnchorData, AnchoredPosition) == 0x000030, "Member 'FUIAnchorData::AnchoredPosition' has a wrong offset!");
static_assert(offsetof(FUIAnchorData, SizeDelta) == 0x000040, "Member 'FUIAnchorData::SizeDelta' has a wrong offset!");

// ScriptStruct LGUI.LGUIGeometryVertex
// 0x0090 (0x0090 - 0x0000)
struct FLGUIGeometryVertex final
{
public:
	struct FVector                                position;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              UV0;                                               // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              UV1;                                               // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              UV2;                                               // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              UV3;                                               // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x0060(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Tangent;                                           // 0x0078(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLGUIGeometryVertex) == 0x000008, "Wrong alignment on FLGUIGeometryVertex");
static_assert(sizeof(FLGUIGeometryVertex) == 0x000090, "Wrong size on FLGUIGeometryVertex");
static_assert(offsetof(FLGUIGeometryVertex, position) == 0x000000, "Member 'FLGUIGeometryVertex::position' has a wrong offset!");
static_assert(offsetof(FLGUIGeometryVertex, Color) == 0x000018, "Member 'FLGUIGeometryVertex::Color' has a wrong offset!");
static_assert(offsetof(FLGUIGeometryVertex, UV0) == 0x000020, "Member 'FLGUIGeometryVertex::UV0' has a wrong offset!");
static_assert(offsetof(FLGUIGeometryVertex, UV1) == 0x000030, "Member 'FLGUIGeometryVertex::UV1' has a wrong offset!");
static_assert(offsetof(FLGUIGeometryVertex, UV2) == 0x000040, "Member 'FLGUIGeometryVertex::UV2' has a wrong offset!");
static_assert(offsetof(FLGUIGeometryVertex, UV3) == 0x000050, "Member 'FLGUIGeometryVertex::UV3' has a wrong offset!");
static_assert(offsetof(FLGUIGeometryVertex, Normal) == 0x000060, "Member 'FLGUIGeometryVertex::Normal' has a wrong offset!");
static_assert(offsetof(FLGUIGeometryVertex, Tangent) == 0x000078, "Member 'FLGUIGeometryVertex::Tangent' has a wrong offset!");

// ScriptStruct LGUI.UIDropdownOptionData
// 0x0018 (0x0018 - 0x0000)
struct FUIDropdownOptionData final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class ULGUISpriteData_BaseObject*             Sprite;                                            // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIDropdownOptionData) == 0x000008, "Wrong alignment on FUIDropdownOptionData");
static_assert(sizeof(FUIDropdownOptionData) == 0x000018, "Wrong size on FUIDropdownOptionData");
static_assert(offsetof(FUIDropdownOptionData, Text) == 0x000000, "Member 'FUIDropdownOptionData::Text' has a wrong offset!");
static_assert(offsetof(FUIDropdownOptionData, Sprite) == 0x000010, "Member 'FUIDropdownOptionData::Sprite' has a wrong offset!");

// ScriptStruct LGUI.UIFlexibleGridLayoutCellData
// 0x0008 (0x0008 - 0x0000)
struct FUIFlexibleGridLayoutCellData final
{
public:
	float                                         Size;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUIFlexibleGridLayoutCellSizeType             SizeType;                                          // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIFlexibleGridLayoutCellData) == 0x000004, "Wrong alignment on FUIFlexibleGridLayoutCellData");
static_assert(sizeof(FUIFlexibleGridLayoutCellData) == 0x000008, "Wrong size on FUIFlexibleGridLayoutCellData");
static_assert(offsetof(FUIFlexibleGridLayoutCellData, Size) == 0x000000, "Member 'FUIFlexibleGridLayoutCellData::Size' has a wrong offset!");
static_assert(offsetof(FUIFlexibleGridLayoutCellData, SizeType) == 0x000004, "Member 'FUIFlexibleGridLayoutCellData::SizeType' has a wrong offset!");

// ScriptStruct LGUI.UIPanelLayout_FlexibleGridSize
// 0x0008 (0x0008 - 0x0000)
struct FUIPanelLayout_FlexibleGridSize final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUIPanelLayout_FlexibleGridSizeRule           SizeType;                                          // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIPanelLayout_FlexibleGridSize) == 0x000004, "Wrong alignment on FUIPanelLayout_FlexibleGridSize");
static_assert(sizeof(FUIPanelLayout_FlexibleGridSize) == 0x000008, "Wrong size on FUIPanelLayout_FlexibleGridSize");
static_assert(offsetof(FUIPanelLayout_FlexibleGridSize, Value) == 0x000000, "Member 'FUIPanelLayout_FlexibleGridSize::Value' has a wrong offset!");
static_assert(offsetof(FUIPanelLayout_FlexibleGridSize, SizeType) == 0x000004, "Member 'FUIPanelLayout_FlexibleGridSize::SizeType' has a wrong offset!");

// ScriptStruct LGUI.UIRecyclableScrollViewCellContainer
// 0x0010 (0x0010 - 0x0000)
struct FUIRecyclableScrollViewCellContainer final
{
public:
	class UActorComponent*                        CellComponent;                                     // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUIItem*                                UIItem;                                            // 0x0008(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIRecyclableScrollViewCellContainer) == 0x000008, "Wrong alignment on FUIRecyclableScrollViewCellContainer");
static_assert(sizeof(FUIRecyclableScrollViewCellContainer) == 0x000010, "Wrong size on FUIRecyclableScrollViewCellContainer");
static_assert(offsetof(FUIRecyclableScrollViewCellContainer, CellComponent) == 0x000000, "Member 'FUIRecyclableScrollViewCellContainer::CellComponent' has a wrong offset!");
static_assert(offsetof(FUIRecyclableScrollViewCellContainer, UIItem) == 0x000008, "Member 'FUIRecyclableScrollViewCellContainer::UIItem' has a wrong offset!");

// ScriptStruct LGUI.LGUIStaticMeshVertex
// 0x0090 (0x0090 - 0x0000)
struct FLGUIStaticMeshVertex final
{
public:
	struct FVector                                position;                                          // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TangentX;                                          // 0x0018(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TangentZ;                                          // 0x0030(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              UV0;                                               // 0x0050(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              UV1;                                               // 0x0060(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              UV2;                                               // 0x0070(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              UV3;                                               // 0x0080(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLGUIStaticMeshVertex) == 0x000008, "Wrong alignment on FLGUIStaticMeshVertex");
static_assert(sizeof(FLGUIStaticMeshVertex) == 0x000090, "Wrong size on FLGUIStaticMeshVertex");
static_assert(offsetof(FLGUIStaticMeshVertex, position) == 0x000000, "Member 'FLGUIStaticMeshVertex::position' has a wrong offset!");
static_assert(offsetof(FLGUIStaticMeshVertex, TangentX) == 0x000018, "Member 'FLGUIStaticMeshVertex::TangentX' has a wrong offset!");
static_assert(offsetof(FLGUIStaticMeshVertex, TangentZ) == 0x000030, "Member 'FLGUIStaticMeshVertex::TangentZ' has a wrong offset!");
static_assert(offsetof(FLGUIStaticMeshVertex, Color) == 0x000048, "Member 'FLGUIStaticMeshVertex::Color' has a wrong offset!");
static_assert(offsetof(FLGUIStaticMeshVertex, UV0) == 0x000050, "Member 'FLGUIStaticMeshVertex::UV0' has a wrong offset!");
static_assert(offsetof(FLGUIStaticMeshVertex, UV1) == 0x000060, "Member 'FLGUIStaticMeshVertex::UV1' has a wrong offset!");
static_assert(offsetof(FLGUIStaticMeshVertex, UV2) == 0x000070, "Member 'FLGUIStaticMeshVertex::UV2' has a wrong offset!");
static_assert(offsetof(FLGUIStaticMeshVertex, UV3) == 0x000080, "Member 'FLGUIStaticMeshVertex::UV3' has a wrong offset!");

}

