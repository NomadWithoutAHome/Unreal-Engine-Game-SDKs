#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SandFall

#include "Basic.hpp"

#include "SandFall_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "NavigationSystem_classes.hpp"
#include "CommonUI_classes.hpp"
#include "SlateCore_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "DeveloperSettings_classes.hpp"
#include "UMG_classes.hpp"
#include "CommonInput_structs.hpp"
#include "StateTreeModule_structs.hpp"
#include "StateTreeModule_classes.hpp"


namespace SDK
{

// Class SandFall.AsyncActionHandlePlatformsSaveData
// 0x0020 (0x0050 - 0x0030)
class UAsyncActionHandlePlatformsSaveData final : public UBlueprintAsyncActionBase
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bSuccess)> OnCompleted;                                       // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	static class UAsyncActionHandlePlatformsSaveData* AsyncSaveLatestGameSaveLoaded(class UObject* WorldContextObject, const class FString& SaveName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncActionHandlePlatformsSaveData">();
	}
	static class UAsyncActionHandlePlatformsSaveData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncActionHandlePlatformsSaveData>();
	}
};
static_assert(alignof(UAsyncActionHandlePlatformsSaveData) == 0x000008, "Wrong alignment on UAsyncActionHandlePlatformsSaveData");
static_assert(sizeof(UAsyncActionHandlePlatformsSaveData) == 0x000050, "Wrong size on UAsyncActionHandlePlatformsSaveData");
static_assert(offsetof(UAsyncActionHandlePlatformsSaveData, OnCompleted) == 0x000040, "Member 'UAsyncActionHandlePlatformsSaveData::OnCompleted' has a wrong offset!");

// Class SandFall.CameraModifier_CameraShake_BP
// 0x0020 (0x00D0 - 0x00B0)
class UCameraModifier_CameraShake_BP final : public UCameraModifier_CameraShake
{
public:
	class UCameraModifier_Meta*                   Modifier;                                          // 0x00B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopModifierAfterShake;                            // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShakeDuration;                                     // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShakeBase>           ShakeAtStart;                                      // 0x00C0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlueprintAddedToCamera(class APlayerCameraManager* Camera);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraModifier_CameraShake_BP">();
	}
	static class UCameraModifier_CameraShake_BP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraModifier_CameraShake_BP>();
	}
};
static_assert(alignof(UCameraModifier_CameraShake_BP) == 0x000008, "Wrong alignment on UCameraModifier_CameraShake_BP");
static_assert(sizeof(UCameraModifier_CameraShake_BP) == 0x0000D0, "Wrong size on UCameraModifier_CameraShake_BP");
static_assert(offsetof(UCameraModifier_CameraShake_BP, Modifier) == 0x0000B0, "Member 'UCameraModifier_CameraShake_BP::Modifier' has a wrong offset!");
static_assert(offsetof(UCameraModifier_CameraShake_BP, StopModifierAfterShake) == 0x0000B8, "Member 'UCameraModifier_CameraShake_BP::StopModifierAfterShake' has a wrong offset!");
static_assert(offsetof(UCameraModifier_CameraShake_BP, ShakeDuration) == 0x0000BC, "Member 'UCameraModifier_CameraShake_BP::ShakeDuration' has a wrong offset!");
static_assert(offsetof(UCameraModifier_CameraShake_BP, ShakeAtStart) == 0x0000C0, "Member 'UCameraModifier_CameraShake_BP::ShakeAtStart' has a wrong offset!");

// Class SandFall.CameraModifier_Meta
// 0x0008 (0x0030 - 0x0028)
class UCameraModifier_Meta : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void GetCameraMetaModifier(const struct FCameraModifier_MetaWrapper& _wrapper, class UCameraModifier_Meta** OutMetaModifier);

	void SetTargetCameraModifier(class UCameraModifier* _cameraModifier);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraModifier_Meta">();
	}
	static class UCameraModifier_Meta* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraModifier_Meta>();
	}
};
static_assert(alignof(UCameraModifier_Meta) == 0x000008, "Wrong alignment on UCameraModifier_Meta");
static_assert(sizeof(UCameraModifier_Meta) == 0x000030, "Wrong size on UCameraModifier_Meta");

// Class SandFall.CameraModifier_Meta_Expiration
// 0x0010 (0x0040 - 0x0030)
class UCameraModifier_Meta_Expiration final : public UCameraModifier_Meta
{
public:
	float                                         m_expirationDuration;                              // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0xC];                                       // 0x0034(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraModifier_Meta_Expiration">();
	}
	static class UCameraModifier_Meta_Expiration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraModifier_Meta_Expiration>();
	}
};
static_assert(alignof(UCameraModifier_Meta_Expiration) == 0x000008, "Wrong alignment on UCameraModifier_Meta_Expiration");
static_assert(sizeof(UCameraModifier_Meta_Expiration) == 0x000040, "Wrong size on UCameraModifier_Meta_Expiration");
static_assert(offsetof(UCameraModifier_Meta_Expiration, m_expirationDuration) == 0x000030, "Member 'UCameraModifier_Meta_Expiration::m_expirationDuration' has a wrong offset!");

// Class SandFall.CameraModifier_RotationLimiter
// 0x0018 (0x0060 - 0x0048)
class UCameraModifier_RotationLimiter : public UCameraModifier
{
public:
	float                                         PitchMin;                                          // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMax;                                          // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawMin;                                            // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YaxMax;                                            // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollMin;                                           // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollMax;                                           // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraModifier_RotationLimiter">();
	}
	static class UCameraModifier_RotationLimiter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraModifier_RotationLimiter>();
	}
};
static_assert(alignof(UCameraModifier_RotationLimiter) == 0x000008, "Wrong alignment on UCameraModifier_RotationLimiter");
static_assert(sizeof(UCameraModifier_RotationLimiter) == 0x000060, "Wrong size on UCameraModifier_RotationLimiter");
static_assert(offsetof(UCameraModifier_RotationLimiter, PitchMin) == 0x000048, "Member 'UCameraModifier_RotationLimiter::PitchMin' has a wrong offset!");
static_assert(offsetof(UCameraModifier_RotationLimiter, PitchMax) == 0x00004C, "Member 'UCameraModifier_RotationLimiter::PitchMax' has a wrong offset!");
static_assert(offsetof(UCameraModifier_RotationLimiter, YawMin) == 0x000050, "Member 'UCameraModifier_RotationLimiter::YawMin' has a wrong offset!");
static_assert(offsetof(UCameraModifier_RotationLimiter, YaxMax) == 0x000054, "Member 'UCameraModifier_RotationLimiter::YaxMax' has a wrong offset!");
static_assert(offsetof(UCameraModifier_RotationLimiter, RollMin) == 0x000058, "Member 'UCameraModifier_RotationLimiter::RollMin' has a wrong offset!");
static_assert(offsetof(UCameraModifier_RotationLimiter, RollMax) == 0x00005C, "Member 'UCameraModifier_RotationLimiter::RollMax' has a wrong offset!");

// Class SandFall.CharacterSkinAssignPolicy
// 0x00A0 (0x00C8 - 0x0028)
class UCharacterSkinAssignPolicy : public UObject
{
public:
	TMulticastInlineDelegate<void(class AActor* NewBodySkinObject)> OnBodySkinAssigned;              // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* NewFaceSkinObject)> OnFaceSkinAssigned;              // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* NewBodySkinObject, class AActor* NewFaceSkinObject)> OnSkinAssignCompleted; // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x70];                                      // 0x0058(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AssignBodyAndFaceSkin(class AActor* Owner, const class FName& CharacterName, const TSubclassOf<class AActor>& BodySkinClass, const TSubclassOf<class AActor>& FaceSkinClass);
	void AssignBodyAndFaceSkinAsync(class AActor* Owner, const class FName& CharacterName, const TSoftClassPtr<class UClass>& BodySkinClass, const TSoftClassPtr<class UClass>& FaceSkinClass);
	void AssignBodySkin(class AActor* Owner, const class FName& CharacterName, const TSubclassOf<class AActor>& BodySkinClass);
	void AssignBodySkinAsync(class AActor* Owner, const class FName& CharacterName, const TSoftClassPtr<class UClass>& BodySkinClass);
	void AssignFaceSkin(class AActor* Owner, const class FName& CharacterName, const TSubclassOf<class AActor>& FaceSkinClass);
	void AssignFaceSkinAsync(class AActor* Owner, const class FName& CharacterName, const TSoftClassPtr<class UClass>& FaceSkinClass);
	void InitSkinAssignPolicy();
	void OnSkinAssignPolicyDestroyed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterSkinAssignPolicy">();
	}
	static class UCharacterSkinAssignPolicy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterSkinAssignPolicy>();
	}
};
static_assert(alignof(UCharacterSkinAssignPolicy) == 0x000008, "Wrong alignment on UCharacterSkinAssignPolicy");
static_assert(sizeof(UCharacterSkinAssignPolicy) == 0x0000C8, "Wrong size on UCharacterSkinAssignPolicy");
static_assert(offsetof(UCharacterSkinAssignPolicy, OnBodySkinAssigned) == 0x000028, "Member 'UCharacterSkinAssignPolicy::OnBodySkinAssigned' has a wrong offset!");
static_assert(offsetof(UCharacterSkinAssignPolicy, OnFaceSkinAssigned) == 0x000038, "Member 'UCharacterSkinAssignPolicy::OnFaceSkinAssigned' has a wrong offset!");
static_assert(offsetof(UCharacterSkinAssignPolicy, OnSkinAssignCompleted) == 0x000048, "Member 'UCharacterSkinAssignPolicy::OnSkinAssignCompleted' has a wrong offset!");

// Class SandFall.ConsoleUtils
// 0x0000 (0x0028 - 0x0028)
class UConsoleUtils final : public UBlueprintFunctionLibrary
{
public:
	static bool GetBoolCVar(class FName Name_0);
	static float GetFloatCVar(class FName Name_0);
	static int32 GetIntCVar(class FName Name_0);
	static class FString GetStringCVar(class FName Name_0);
	static bool IsCVarRegistered(class FName Name_0);
	static void SetBoolCVar(class FName Name_0, bool Value);
	static void SetFloatCVar(class FName Name_0, float Value);
	static void SetIntCVar(class FName Name_0, int32 Value);
	static void SetStringCVar(class FName Name_0, const class FString& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsoleUtils">();
	}
	static class UConsoleUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsoleUtils>();
	}
};
static_assert(alignof(UConsoleUtils) == 0x000008, "Wrong alignment on UConsoleUtils");
static_assert(sizeof(UConsoleUtils) == 0x000028, "Wrong size on UConsoleUtils");

// Class SandFall.CSAP_AssetAssign
// 0x0010 (0x00D8 - 0x00C8)
class UCSAP_AssetAssign final : public UCharacterSkinAssignPolicy
{
public:
	TSubclassOf<class AActor>                     m_ActiveBodySkinClass;                             // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     m_ActiveFaceSkinClass;                             // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSAP_AssetAssign">();
	}
	static class UCSAP_AssetAssign* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSAP_AssetAssign>();
	}
};
static_assert(alignof(UCSAP_AssetAssign) == 0x000008, "Wrong alignment on UCSAP_AssetAssign");
static_assert(sizeof(UCSAP_AssetAssign) == 0x0000D8, "Wrong size on UCSAP_AssetAssign");
static_assert(offsetof(UCSAP_AssetAssign, m_ActiveBodySkinClass) == 0x0000C8, "Member 'UCSAP_AssetAssign::m_ActiveBodySkinClass' has a wrong offset!");
static_assert(offsetof(UCSAP_AssetAssign, m_ActiveFaceSkinClass) == 0x0000D0, "Member 'UCSAP_AssetAssign::m_ActiveFaceSkinClass' has a wrong offset!");

// Class SandFall.CSAP_SwapAssign
// 0x0128 (0x01F0 - 0x00C8)
class UCSAP_SwapAssign final : public UCharacterSkinAssignPolicy
{
public:
	int32                                         CachePoolSize;                                     // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     m_ActiveBodySkinClass;                             // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     m_ActiveFaceSkinClass;                             // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0xB0];                                      // 0x00E0(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USceneComponent*>                m_MainBodyChildrenComponents;                      // 0x0190(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class USceneComponent*, bool>            m_MainBodyChildrenComponentVisibility;             // 0x01A0(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnSettingsChanged(const class UConfigurableGameUserSettings* UserGameConfig);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSAP_SwapAssign">();
	}
	static class UCSAP_SwapAssign* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSAP_SwapAssign>();
	}
};
static_assert(alignof(UCSAP_SwapAssign) == 0x000008, "Wrong alignment on UCSAP_SwapAssign");
static_assert(sizeof(UCSAP_SwapAssign) == 0x0001F0, "Wrong size on UCSAP_SwapAssign");
static_assert(offsetof(UCSAP_SwapAssign, CachePoolSize) == 0x0000C8, "Member 'UCSAP_SwapAssign::CachePoolSize' has a wrong offset!");
static_assert(offsetof(UCSAP_SwapAssign, m_ActiveBodySkinClass) == 0x0000D0, "Member 'UCSAP_SwapAssign::m_ActiveBodySkinClass' has a wrong offset!");
static_assert(offsetof(UCSAP_SwapAssign, m_ActiveFaceSkinClass) == 0x0000D8, "Member 'UCSAP_SwapAssign::m_ActiveFaceSkinClass' has a wrong offset!");
static_assert(offsetof(UCSAP_SwapAssign, m_MainBodyChildrenComponents) == 0x000190, "Member 'UCSAP_SwapAssign::m_MainBodyChildrenComponents' has a wrong offset!");
static_assert(offsetof(UCSAP_SwapAssign, m_MainBodyChildrenComponentVisibility) == 0x0001A0, "Member 'UCSAP_SwapAssign::m_MainBodyChildrenComponentVisibility' has a wrong offset!");

// Class SandFall.CurveBlendingProfile
// 0x0050 (0x0080 - 0x0030)
class UCurveBlendingProfile final : public UPrimaryDataAsset
{
public:
	TMap<class FName, float>                      Profiles;                                          // 0x0030(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurveBlendingProfile">();
	}
	static class UCurveBlendingProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurveBlendingProfile>();
	}
};
static_assert(alignof(UCurveBlendingProfile) == 0x000008, "Wrong alignment on UCurveBlendingProfile");
static_assert(sizeof(UCurveBlendingProfile) == 0x000080, "Wrong size on UCurveBlendingProfile");
static_assert(offsetof(UCurveBlendingProfile, Profiles) == 0x000030, "Member 'UCurveBlendingProfile::Profiles' has a wrong offset!");

// Class SandFall.CurveModifyIntensityProfile
// 0x0050 (0x0080 - 0x0030)
class UCurveModifyIntensityProfile final : public UPrimaryDataAsset
{
public:
	TMap<class FName, struct FCurveIntensityData> Profiles;                                          // 0x0030(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurveModifyIntensityProfile">();
	}
	static class UCurveModifyIntensityProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurveModifyIntensityProfile>();
	}
};
static_assert(alignof(UCurveModifyIntensityProfile) == 0x000008, "Wrong alignment on UCurveModifyIntensityProfile");
static_assert(sizeof(UCurveModifyIntensityProfile) == 0x000080, "Wrong size on UCurveModifyIntensityProfile");
static_assert(offsetof(UCurveModifyIntensityProfile, Profiles) == 0x000030, "Member 'UCurveModifyIntensityProfile::Profiles' has a wrong offset!");

// Class SandFall.CVarChangeListener
// 0x0058 (0x0080 - 0x0028)
class UCVarChangeListener final : public UObject
{
public:
	uint8                                         Pad_28[0x58];                                      // 0x0028(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CVarChangeListener">();
	}
	static class UCVarChangeListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCVarChangeListener>();
	}
};
static_assert(alignof(UCVarChangeListener) == 0x000008, "Wrong alignment on UCVarChangeListener");
static_assert(sizeof(UCVarChangeListener) == 0x000080, "Wrong size on UCVarChangeListener");

// Class SandFall.CVarChangeListenerManager
// 0x0050 (0x0078 - 0x0028)
class UCVarChangeListenerManager final : public UObject
{
public:
	TMap<class FName, class UCVarChangeListener*> Listeners;                                         // 0x0028(0x0050)(NativeAccessSpecifierPrivate)

public:
	static void AddBoolCVarCallbackStatic(class FName Name_0, TDelegate<void(bool NewValue)> ChangedCallback, bool CallbackImmediately);
	static void AddFloatCVarCallbackStatic(class FName Name_0, TDelegate<void(float NewValue)> ChangedCallback, bool CallbackImmediately);
	static void AddIntCVarCallbackStatic(class FName Name_0, TDelegate<void(int32 NewValue)> ChangedCallback, bool CallbackImmediately);
	static void AddStringCVarCallbackStatic(class FName Name_0, TDelegate<void(const class FString& NewValue)> ChangedCallback, bool CallbackImmediately);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CVarChangeListenerManager">();
	}
	static class UCVarChangeListenerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCVarChangeListenerManager>();
	}
};
static_assert(alignof(UCVarChangeListenerManager) == 0x000008, "Wrong alignment on UCVarChangeListenerManager");
static_assert(sizeof(UCVarChangeListenerManager) == 0x000078, "Wrong size on UCVarChangeListenerManager");
static_assert(offsetof(UCVarChangeListenerManager, Listeners) == 0x000028, "Member 'UCVarChangeListenerManager::Listeners' has a wrong offset!");

// Class SandFall.EpicCamerasFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UEpicCamerasFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void FindAllBattleKeyframesInSequence(class ULevelSequence* _sequence, const struct FMovieSceneObjectBindingID& _actorBindingID, TArray<float>* _skillEffectWithQTETimes, TArray<float>* _skillEffectNoQTETimes, TArray<float>* _explicitComboPromptTimes, TArray<float>* _comboSectionStartTimes, float* _lastComboSectionEnd, TArray<float>* _comboFailSectionStartTimes, TArray<float>* _comboFailSectionEndTimes, TArray<float>* _snapToTargetTimes, TArray<float>* _snapToSourceTimes);
	static void FindAllBattleKeyframesInSequenceAsList(class ULevelSequence* _sequence, const struct FMovieSceneObjectBindingID& _actorBindingID, TArray<struct FBattleSequenceKeyframe>* _keyframes, int32 _trackIndex);
	static void FindAllBattleKeyframesInSequenceAsListFromTrackName(class ULevelSequence* _sequence, const struct FMovieSceneObjectBindingID& _actorBindingID, TArray<struct FBattleSequenceKeyframe>* _keyframes, const class FName _trackName);
	static void FindAllBattleKeyframesInSequenceAsMap(class ULevelSequence* _sequence, const struct FMovieSceneObjectBindingID& _actorBindingID, TMap<float, EBattleSequenceKeyframeType>* _keyframes, int32 _trackIndex);
	static void FindBattleCameraKeyframesInSequenceAsMap(class ULevelSequence* _sequence, const struct FMovieSceneObjectBindingID& _actorBindingID, TMap<float, EBattleSequenceCameraType>* _keyframes, int32 _trackIndex);
	static void FindBattleCameraKeyframesInSequenceAsMapFromTrackName(class ULevelSequence* _sequence, const struct FMovieSceneObjectBindingID& _actorBindingID, TMap<float, EBattleSequenceCameraType>* _keyframes, const class FName _trackName);
	static void FindBattleKeyframesInSequence(EBattleSequenceKeyframeType _keyframeType, class ULevelSequence* _sequence, const struct FMovieSceneObjectBindingID& _actorBindingID, TArray<float>* _times);
	static void FindQTEKeyframes(class ULevelSequence* _sequence, const struct FMovieSceneObjectBindingID& _actorBindingID, TArray<float>* ImpactTimes);
	static float GetCinematicTimeDilation(class UObject* _WorldContextObject);
	static struct FTransform GetInitialActorPositionInSequence(class ULevelSequence* _sequence, const struct FMovieSceneObjectBindingID& _bindingID);
	static void GetLinearTimeMapFromSequence(class ULevelSequence* _sequence, TMap<int32, float>* _linearTimeMap);
	static float GetRealTimeDilation(class UObject* _WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicCamerasFunctionLibrary">();
	}
	static class UEpicCamerasFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicCamerasFunctionLibrary>();
	}
};
static_assert(alignof(UEpicCamerasFunctionLibrary) == 0x000008, "Wrong alignment on UEpicCamerasFunctionLibrary");
static_assert(sizeof(UEpicCamerasFunctionLibrary) == 0x000028, "Wrong size on UEpicCamerasFunctionLibrary");

// Class SandFall.SF_GameConfigurationSettings
// 0x0298 (0x02D0 - 0x0038)
class USF_GameConfigurationSettings final : public UDeveloperSettings
{
public:
	TSoftObjectPtr<class UPrimaryDataAsset>       ProjectConfiguration;                              // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DefaultLoadingScreenWidget;                        // 0x0060(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DefaultSubtitlesWidget;                            // 0x0088(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SubtitleMinDisplayTime;                            // 0x00B0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USF_DialogueSubtitleSpeakersData> SubtitleSpeakerData;                      // 0x00B8(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<EDialogueTextSceneType>                  ForcedSubtitleDisplayScene;                        // 0x00E0(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSF_SettingsData                       DefaultSettingsValue;                              // 0x0130(0x0054)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_184[0x4];                                      // 0x0184(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FConsoleVariablesOverrideProfile       CvarOverrideDuringLevelLoading;                    // 0x0188(0x0140)(Edit, Config, NativeAccessSpecifierPublic)
	float                                         SizeAudioStreamingCacheTrimRequest;                // 0x02C8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SF_GameConfigurationSettings">();
	}
	static class USF_GameConfigurationSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USF_GameConfigurationSettings>();
	}
};
static_assert(alignof(USF_GameConfigurationSettings) == 0x000008, "Wrong alignment on USF_GameConfigurationSettings");
static_assert(sizeof(USF_GameConfigurationSettings) == 0x0002D0, "Wrong size on USF_GameConfigurationSettings");
static_assert(offsetof(USF_GameConfigurationSettings, ProjectConfiguration) == 0x000038, "Member 'USF_GameConfigurationSettings::ProjectConfiguration' has a wrong offset!");
static_assert(offsetof(USF_GameConfigurationSettings, DefaultLoadingScreenWidget) == 0x000060, "Member 'USF_GameConfigurationSettings::DefaultLoadingScreenWidget' has a wrong offset!");
static_assert(offsetof(USF_GameConfigurationSettings, DefaultSubtitlesWidget) == 0x000088, "Member 'USF_GameConfigurationSettings::DefaultSubtitlesWidget' has a wrong offset!");
static_assert(offsetof(USF_GameConfigurationSettings, SubtitleMinDisplayTime) == 0x0000B0, "Member 'USF_GameConfigurationSettings::SubtitleMinDisplayTime' has a wrong offset!");
static_assert(offsetof(USF_GameConfigurationSettings, SubtitleSpeakerData) == 0x0000B8, "Member 'USF_GameConfigurationSettings::SubtitleSpeakerData' has a wrong offset!");
static_assert(offsetof(USF_GameConfigurationSettings, ForcedSubtitleDisplayScene) == 0x0000E0, "Member 'USF_GameConfigurationSettings::ForcedSubtitleDisplayScene' has a wrong offset!");
static_assert(offsetof(USF_GameConfigurationSettings, DefaultSettingsValue) == 0x000130, "Member 'USF_GameConfigurationSettings::DefaultSettingsValue' has a wrong offset!");
static_assert(offsetof(USF_GameConfigurationSettings, CvarOverrideDuringLevelLoading) == 0x000188, "Member 'USF_GameConfigurationSettings::CvarOverrideDuringLevelLoading' has a wrong offset!");
static_assert(offsetof(USF_GameConfigurationSettings, SizeAudioStreamingCacheTrimRequest) == 0x0002C8, "Member 'USF_GameConfigurationSettings::SizeAudioStreamingCacheTrimRequest' has a wrong offset!");

// Class SandFall.VariableWatcher_bool
// 0x0018 (0x0040 - 0x0028)
class UVariableWatcher_bool final : public UObject
{
public:
	TMulticastInlineDelegate<void(bool NewValue)> OnValueChangedEvent;                               // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          Value;                                             // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetValue();
	void SetValue(bool _newValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VariableWatcher_bool">();
	}
	static class UVariableWatcher_bool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVariableWatcher_bool>();
	}
};
static_assert(alignof(UVariableWatcher_bool) == 0x000008, "Wrong alignment on UVariableWatcher_bool");
static_assert(sizeof(UVariableWatcher_bool) == 0x000040, "Wrong size on UVariableWatcher_bool");
static_assert(offsetof(UVariableWatcher_bool, OnValueChangedEvent) == 0x000028, "Member 'UVariableWatcher_bool::OnValueChangedEvent' has a wrong offset!");
static_assert(offsetof(UVariableWatcher_bool, Value) == 0x000038, "Member 'UVariableWatcher_bool::Value' has a wrong offset!");

// Class SandFall.GlobalPostProcessActor
// 0x0000 (0x0290 - 0x0290)
class AGlobalPostProcessActor : public AActor
{
public:
	void UpdatePostProcessSaturation(float RGBMultiplier, float LuminanceMultiplier);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlobalPostProcessActor">();
	}
	static class AGlobalPostProcessActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGlobalPostProcessActor>();
	}
};
static_assert(alignof(AGlobalPostProcessActor) == 0x000008, "Wrong alignment on AGlobalPostProcessActor");
static_assert(sizeof(AGlobalPostProcessActor) == 0x000290, "Wrong size on AGlobalPostProcessActor");

// Class SandFall.MyInterface
// 0x0000 (0x0000 - 0x0000)
class IMyInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MyInterface">();
	}
	static class IMyInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMyInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IMyInterface) == 0x000001, "Wrong alignment on IMyInterface");
static_assert(sizeof(IMyInterface) == 0x000001, "Wrong size on IMyInterface");

// Class SandFall.MyObject
// 0x0000 (0x0028 - 0x0028)
class UMyObject final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MyObject">();
	}
	static class UMyObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMyObject>();
	}
};
static_assert(alignof(UMyObject) == 0x000008, "Wrong alignment on UMyObject");
static_assert(sizeof(UMyObject) == 0x000028, "Wrong size on UMyObject");

// Class SandFall.PlatformsSaveData
// 0x0068 (0x0090 - 0x0028)
class UPlatformsSaveData final : public USaveGame
{
public:
	TMap<class FName, float>                      FailedAchievementsMap;                             // 0x0028(0x0050)(NativeAccessSpecifierPrivate)
	class FString                                 LatestSaveGameLoaded;                              // 0x0078(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformsSaveData">();
	}
	static class UPlatformsSaveData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformsSaveData>();
	}
};
static_assert(alignof(UPlatformsSaveData) == 0x000008, "Wrong alignment on UPlatformsSaveData");
static_assert(sizeof(UPlatformsSaveData) == 0x000090, "Wrong size on UPlatformsSaveData");
static_assert(offsetof(UPlatformsSaveData, FailedAchievementsMap) == 0x000028, "Member 'UPlatformsSaveData::FailedAchievementsMap' has a wrong offset!");
static_assert(offsetof(UPlatformsSaveData, LatestSaveGameLoaded) == 0x000078, "Member 'UPlatformsSaveData::LatestSaveGameLoaded' has a wrong offset!");

// Class SandFall.PlatformsSubsystem
// 0x0110 (0x0140 - 0x0030)
class UPlatformsSubsystem final : public UGameInstanceSubsystem
{
public:
	TMulticastInlineDelegate<void()>              OnControllerConfirmed;                             // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bIsConnected)> OnControllerConnectionChanged;                 // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bShouldPause)> OnPlatformPauseEvent;                          // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLoggedInUserEvent;                               // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x90];                                      // 0x0070(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TDelegate<void()>>                     GameStartedFromActivtyDelegatesContainer;          // 0x0100(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x30];                                     // 0x0110(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AttemptToLoginTheUser();
	void BindToGameStartedFromActivity(TDelegate<void()> Delegate);
	void ClearAllBindedEventToGameStartedFromActivity();
	bool ClearAllCloudSaves();
	TMap<class FName, float> GetAchievementsFromCurrentWriteRequest();
	const class FString GetCurrentUserNickname();
	class FString GetLatestGameSaveLoaded();
	bool IsGameStartedFromActivity();
	void LoadAndTriggerFailedAchievments();
	void OnExternalUIChange(bool Value);
	void OnUserIsLoggedIn(bool bIsUserLoggedIn);
	void OnUserIsSelected(bool bIsSellectedUserLoggedIn);
	void QueryAchievements();
	void QueryEntitlements();
	void RegisterLatestGameSaveLoaded(const class FString& SaveName);
	bool ResetAllAchievements();
	void ResetAllActivities();
	void SetActivityStatus(const class FString& ActivityID, EActivityStatus AcitivityStatus);
	void SetPS5ControllerLightColor(const struct FColor& Color, bool Enable);
	void SetRichPresence(const class FString& InRichPresenceStatus);
	void TriggerAchievement(TDelegate<void(const struct FAchievementsMap& AchievementsMap, const bool bSuccess)> TriggeredDelegate, const class FName& ID);
	void TriggerMultipleAchievements(TDelegate<void(const struct FAchievementsMap& AchievementsMap, const bool bSuccess)> TriggeredDelegate, const TMap<class FName, float>& AchievementsMap);

	class FString ComputeSaveNameWithPath(const class FString& SaveName) const;
	class FString GetCurrentUserID() const;
	struct FGameplayTag GetStoreNameAsTag() const;
	bool HasAllEntitlements(const TArray<class FName>& Entitlements) const;
	bool HasAnyEntitlement(const TArray<class FName>& Entitlements) const;
	bool IsChunkInstalled(int32 ChunkId) const;
	bool IsUserLoggedIn() const;
	bool IsUsingCloudSave() const;
	bool IsUsingSteam() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformsSubsystem">();
	}
	static class UPlatformsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformsSubsystem>();
	}
};
static_assert(alignof(UPlatformsSubsystem) == 0x000008, "Wrong alignment on UPlatformsSubsystem");
static_assert(sizeof(UPlatformsSubsystem) == 0x000140, "Wrong size on UPlatformsSubsystem");
static_assert(offsetof(UPlatformsSubsystem, OnControllerConfirmed) == 0x000030, "Member 'UPlatformsSubsystem::OnControllerConfirmed' has a wrong offset!");
static_assert(offsetof(UPlatformsSubsystem, OnControllerConnectionChanged) == 0x000040, "Member 'UPlatformsSubsystem::OnControllerConnectionChanged' has a wrong offset!");
static_assert(offsetof(UPlatformsSubsystem, OnPlatformPauseEvent) == 0x000050, "Member 'UPlatformsSubsystem::OnPlatformPauseEvent' has a wrong offset!");
static_assert(offsetof(UPlatformsSubsystem, OnLoggedInUserEvent) == 0x000060, "Member 'UPlatformsSubsystem::OnLoggedInUserEvent' has a wrong offset!");
static_assert(offsetof(UPlatformsSubsystem, GameStartedFromActivtyDelegatesContainer) == 0x000100, "Member 'UPlatformsSubsystem::GameStartedFromActivtyDelegatesContainer' has a wrong offset!");

// Class SandFall.ReloadConfigActor
// 0x0008 (0x0298 - 0x0290)
class AReloadConfigActor final : public AActor
{
public:
	bool                                          ReloadConfig;                                      // 0x0290(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReloadConfigActor">();
	}
	static class AReloadConfigActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReloadConfigActor>();
	}
};
static_assert(alignof(AReloadConfigActor) == 0x000008, "Wrong alignment on AReloadConfigActor");
static_assert(sizeof(AReloadConfigActor) == 0x000298, "Wrong size on AReloadConfigActor");
static_assert(offsetof(AReloadConfigActor, ReloadConfig) == 0x000290, "Member 'AReloadConfigActor::ReloadConfig' has a wrong offset!");

// Class SandFall.SF_ActivityWrapper
// 0x0068 (0x0098 - 0x0030)
class USF_ActivityWrapper final : public UPrimaryDataAsset
{
public:
	class FString                                 ActivityID;                                        // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MappedToQuestID;                                   // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FString, struct FActivityTask>     ActivityTasks;                                     // 0x0048(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	class FString GetActivityID();
	TArray<class FString> GetAllTasks();
	class FString GetSubTaskID(class FName TaskName);
	bool IsMappedToActivity(class FName QuestID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SF_ActivityWrapper">();
	}
	static class USF_ActivityWrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<USF_ActivityWrapper>();
	}
};
static_assert(alignof(USF_ActivityWrapper) == 0x000008, "Wrong alignment on USF_ActivityWrapper");
static_assert(sizeof(USF_ActivityWrapper) == 0x000098, "Wrong size on USF_ActivityWrapper");
static_assert(offsetof(USF_ActivityWrapper, ActivityID) == 0x000030, "Member 'USF_ActivityWrapper::ActivityID' has a wrong offset!");
static_assert(offsetof(USF_ActivityWrapper, MappedToQuestID) == 0x000040, "Member 'USF_ActivityWrapper::MappedToQuestID' has a wrong offset!");
static_assert(offsetof(USF_ActivityWrapper, ActivityTasks) == 0x000048, "Member 'USF_ActivityWrapper::ActivityTasks' has a wrong offset!");

// Class SandFall.ActorComoponentHelpers
// 0x0000 (0x0028 - 0x0028)
class UActorComoponentHelpers final : public UBlueprintFunctionLibrary
{
public:
	static bool ChangeOwner(class UActorComponent* Component, class AActor* NewOwner);
	static void DestroyComponentExternally(class UActorComponent* ComponentToDestroy);
	static bool HasComponentBegunPlay(class UActorComponent* Component);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorComoponentHelpers">();
	}
	static class UActorComoponentHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorComoponentHelpers>();
	}
};
static_assert(alignof(UActorComoponentHelpers) == 0x000008, "Wrong alignment on UActorComoponentHelpers");
static_assert(sizeof(UActorComoponentHelpers) == 0x000028, "Wrong size on UActorComoponentHelpers");

// Class SandFall.ActorSpawnWatcherInterface
// 0x0000 (0x0000 - 0x0000)
class IActorSpawnWatcherInterface final
{
public:
	bool OnInstigatedActorSpawned(class AActor* SpawnedActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorSpawnWatcherInterface">();
	}
	static class IActorSpawnWatcherInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IActorSpawnWatcherInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IActorSpawnWatcherInterface) == 0x000001, "Wrong alignment on IActorSpawnWatcherInterface");
static_assert(sizeof(IActorSpawnWatcherInterface) == 0x000001, "Wrong size on IActorSpawnWatcherInterface");

// Class SandFall.SF_ActorWatcherSubSystem
// 0x0008 (0x0038 - 0x0030)
class USF_ActorWatcherSubSystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SF_ActorWatcherSubSystem">();
	}
	static class USF_ActorWatcherSubSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USF_ActorWatcherSubSystem>();
	}
};
static_assert(alignof(USF_ActorWatcherSubSystem) == 0x000008, "Wrong alignment on USF_ActorWatcherSubSystem");
static_assert(sizeof(USF_ActorWatcherSubSystem) == 0x000038, "Wrong size on USF_ActorWatcherSubSystem");

// Class SandFall.AIHelpers
// 0x0000 (0x0028 - 0x0028)
class UAIHelpers final : public UBlueprintFunctionLibrary
{
public:
	static void PauseLogic(class UBrainComponent* BrainComponent, const class FString& DebugReason);
	static void ResumeLogic(class UBrainComponent* BrainComponent, const class FString& Reason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIHelpers">();
	}
	static class UAIHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIHelpers>();
	}
};
static_assert(alignof(UAIHelpers) == 0x000008, "Wrong alignment on UAIHelpers");
static_assert(sizeof(UAIHelpers) == 0x000028, "Wrong size on UAIHelpers");

// Class SandFall.SF_AnimationBlueprintHelpers
// 0x0000 (0x0028 - 0x0028)
class USF_AnimationBlueprintHelpers final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class UAnimMontage*> GetAllActiveMontages(class UAnimInstance* AnimInstance);
	static void GetAnimDataModelBoneTrackData(const TScriptInterface<class IAnimationDataModel> DataModel, const class FName TrackName, TArray<struct FVector>* PositionKeys, TArray<struct FQuat>* RotationKeys, TArray<struct FVector>* ScalingKeys);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SF_AnimationBlueprintHelpers">();
	}
	static class USF_AnimationBlueprintHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<USF_AnimationBlueprintHelpers>();
	}
};
static_assert(alignof(USF_AnimationBlueprintHelpers) == 0x000008, "Wrong alignment on USF_AnimationBlueprintHelpers");
static_assert(sizeof(USF_AnimationBlueprintHelpers) == 0x000028, "Wrong size on USF_AnimationBlueprintHelpers");

// Class SandFall.SF_AsyncActionDeleteSaveGame
// 0x0028 (0x0058 - 0x0030)
class USF_AsyncActionDeleteSaveGame final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(bool bSuccess)> Completed;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USF_AsyncActionDeleteSaveGame* AsyncDeleteGameFromSlot(class UObject* WorldContextObject, const class FString& SlotName, const int32 UserIndex);
	static class USF_AsyncActionDeleteSaveGame* AsyncDeleteGamesFromSlot(class UObject* WorldContextObject, const TArray<class FString>& SlotNames, const int32 UserIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SF_AsyncActionDeleteSaveGame">();
	}
	static class USF_AsyncActionDeleteSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<USF_AsyncActionDeleteSaveGame>();
	}
};
static_assert(alignof(USF_AsyncActionDeleteSaveGame) == 0x000008, "Wrong alignment on USF_AsyncActionDeleteSaveGame");
static_assert(sizeof(USF_AsyncActionDeleteSaveGame) == 0x000058, "Wrong size on USF_AsyncActionDeleteSaveGame");
static_assert(offsetof(USF_AsyncActionDeleteSaveGame, Completed) == 0x000030, "Member 'USF_AsyncActionDeleteSaveGame::Completed' has a wrong offset!");

// Class SandFall.BakedActors
// 0x0010 (0x02A0 - 0x0290)
class ABakedActors final : public AActor
{
public:
	TArray<TSoftObjectPtr<class AActor>>          BakedActors;                                       // 0x0290(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	bool BakeActors();
	TSubclassOf<class AActor> GetActorClassToSpawn();
	class FString GetBakedActorsFolderName();
	const TArray<struct FTransform> GetBakedActorTransforms();
	void TryDestroyAllBakedActors();

	bool HasAnyBakedActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BakedActors">();
	}
	static class ABakedActors* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABakedActors>();
	}
};
static_assert(alignof(ABakedActors) == 0x000008, "Wrong alignment on ABakedActors");
static_assert(sizeof(ABakedActors) == 0x0002A0, "Wrong size on ABakedActors");
static_assert(offsetof(ABakedActors, BakedActors) == 0x000290, "Member 'ABakedActors::BakedActors' has a wrong offset!");

// Class SandFall.SandfallBlueprintHelpers
// 0x0000 (0x0028 - 0x0028)
class USandfallBlueprintHelpers final : public UBlueprintFunctionLibrary
{
public:
	static void Array_Remap(const TArray<int32>& TargetArray, const TMap<int32, int32>& RemapTable, TArray<int32>* ResultArray);
	static void Assert(const bool _check, const class FText& _message, const bool _breakpoint);
	static void AssertMessage(const class FString& _message, const bool _breakpoint);
	static class AActor* BeginDeferredActorSpawnFromClass(const class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, const struct FTransform& SpawnTransform, ESpawnActorCollisionHandlingMethod CollisionHandlingOverride, class AActor* Owner, ESpawnActorScaleMethod TransformScaleMethod);
	static void BlockTillLevelStreamingCompleted(class UObject* WorldContextObject);
	static void CallFunctionByName(class UObject* _object, const class FString& _functionName, bool* _IsFailed);
	static void CancelLatentActions(class UObject* WorldContextObject, class UObject* Object);
	static bool CheckEntitlement(class UWorld* _worldContext);
	static int32 CompareStrings(const class FString& A, const class FString& B);
	static void ConvertSoftRefToWorldSoftRef(const TSoftObjectPtr<class UObject>& _InObject, TSoftObjectPtr<class UWorld>* _OutWorldSoftRef);
	static void CopyAllProperties(class UObject* FromObject, class UObject* ToObject, bool bIncludeComponents);
	static class UObject* DebugConstructFromClass(class UClass* _class, class UObject* _owner);
	static void DebugCppBreakpoint();
	static class UClass* DebugFindClassByName(const class FString& _className);
	static void DebugMe(class UObject* _objectToDebug);
	static void DrawDebugCircleArc(const class UObject* WorldContextObject, const struct FVector& Center, float Radius, const struct FVector& Direction, float AngleWidth, int32 Segments, const struct FLinearColor& Color, float Lifetime, float Thickness);
	static bool Editor_FileDelete(const class FString& Filename);
	static bool Editor_FileLoadString(const class FString& Filename, class FString* Content);
	static bool Editor_FileLoadStringReal(const class FString& Filename, class FString* Content);
	static bool Editor_FileSaveString(const class FString& Content, const class FString& Filename);
	static bool Editor_GetShaderCompilationState(int32* jobCount, int32* workerCount);
	static bool Editor_GetStatValue(const class FName _StatGroup, const class FName _StatName, bool _isMemory, class FString* _OutValue);
	static bool Editor_MoveScreenshots(const class FString& _sourceFile, const class FString& _destination);
	static void Editor_PushJSONToMongoDB(const class FString& Json);
	static void Editor_TakeScreenshot(const class FString& _filename, bool _showUI);
	static void EditorAlert(const class FText& _text);
	static bool EqualsObjects(const class UObject* A, const class UObject* B);
	static class FString EscapeJson(const class FString& Input);
	static void ExecuteDelegate(TDelegate<void()> Delegate);
	static class AActor* FinishSpawningActor(class AActor* Actor, const struct FTransform& SpawnTransform, ESpawnActorScaleMethod TransformScaleMethod);
	static void FlushInputs(class APlayerController* PlayerController);
	static class FString Format(const class FString& InPattern, const TArray<struct FFormatArgumentData>& InArgs);
	static class FString FormatDateTime(const struct FDateTime& DateTime);
	static class FString FormatDateTimeWithPattern(const struct FDateTime& DateTime, const class FString& FormatString);
	static class FString FormatTimespan(const struct FTimespan& Timespan);
	static class FString FormatTimespanWithPattern(const struct FTimespan& Timespan, const class FString& FormatString);
	static void GetAllComponentsByClass(class UWorld* World, TSubclassOf<class UActorComponent> Class_0, TArray<class UActorComponent*>* Components);
	static void GetAllLightComponents(class UWorld* World, TArray<class ULightComponent*>* LightComponents);
	static void GetBuildInfo(class UObject* WorldContextObject, class FString* Changelist, class FString* CurrentPersistentLevel);
	static void GetCameraCutTrackSettings(const class UMovieSceneCameraCutTrack* CameraCutTrack, bool* SectionFound, bool* CanBlend, bool* HasEasing, bool* IsPreviousCameraLocked);
	static class UObject* GetClassDefaultObject(class UClass* Object);
	static class UActorComponent* GetComponentFromReference(const struct FComponentReference& ComponentReference, class AActor* OwningActor);
	static void GetDataTableRowFromName(class UDataTable* Table, class FName RowName, struct FTableRowBase* OutRow);
	static class FString GetDebugInfo();
	static struct FTransform GetEditorViewportTransform();
	static float GetLastRenderTimeOnScreen(const class UPrimitiveComponent* Primitive);
	static float GetMaxDistanceAttenuation(class USoundBase* Sound);
	static struct FGameplayTag GetPlatformNameAsTag();
	static TArray<class FName> GetSamplingRegionNames(class USkeletalMesh* SkeletalMeshAsset);
	static TArray<class FString> GetStackTrace();
	static class FString GetUpscalerInfo();
	static void GetVendorBuildInfo(class UObject* WorldContextObject, class FString* OwnerInfo, class FString* BuildInfo);
	static bool HasActorBegunPlay(const class AActor* Actor);
	static bool IsActorSpatiallyLoaded(const class AActor* Actor);
	static bool isCollisionProfileValid(class FName ProfileName);
	static bool IsCurrentConsoleTypeLockheart();
	static bool IsEventDispatcherConnected(class UObject* Object, class FName EventDispatcherName);
	static bool IsInPlayMode();
	static bool IsInSimulateMode();
	static bool IsPackagedBuild();
	static bool IsPawnInputEnabled(const class APawn* _actor);
	static bool IsRunningAutomationTest();
	static bool IsRunningOnSteamDeck();
	static class UOutputDeviceWrapper* MakeLogOutputCapture();
	static void Map_Remap(const TMap<int32, int32>& TargetMap, const TMap<int32, int32>& RemapTable, TMap<int32, int32>* ResultMap);
	static void Map_ToString(const TMap<int32, int32>& TargetMap, TArray<class FString>* OutStringList);
	static void MemTraceUserMark(const class FString& userMark);
	static struct FTransform OffsetTransform(const struct FTransform& StartTransform, float ForwardOffset, float UpOffset);
	static void OverrideBoolCVar(const class FName _name, bool _value);
	static TArray<class FString> ParseIntoArrayLines(const class FString& In, bool CullEmpty);
	static void PrintStringInLog(const class UObject* WorldContextObject, const class FString& InString);
	static void Refresh3DEditorViewport();
	static void RegisterBoolCVar(const class FName _name, bool _defaultValue, const class FText& _description);
	static void RegisterInputAction(class UObject* WorldContextObject, class FName InputAction, TDelegate<void()> OnPressed);
	static void RegisterIntegerCVar(const class FName _name, const int32 _defaultValue, const class FText& _description);
	static void RegisterStringCVar(const class FName _name, const class FString& _defaultValue, const class FText& _description);
	static void ReloadActor(class AActor* Actor);
	static bool RemoveMaterialInstanceParameterOverride(class UMaterialInstanceConstant* _MaterialInstance, const class FName& _ParameterName);
	static bool RemoveMaterialInstanceStaticSwitchOverride(class UMaterialInstanceConstant* _MaterialInstance, const class FName& _ParameterName);
	static void RequestToTrimAudioStreamingCache();
	static void ResetAllProperties(class UObject* Object, bool bIncludeComponents);
	static void ResetMaterialInstanceTextureStreamingData(class UMaterialInstanceConstant* _MaterialInstance);
	static void SetActorIsEditorOnly(class AActor* Actor, bool bIsEditorOnly);
	static void SetActorIsSpatiallyLoaded(class AActor* Actor, bool bIsSpatiallyLoaded);
	static void SetComponentIsEditorOnly(class UActorComponent* ActorComponent, bool bIsEditorOnly);
	static void SetTimeDilationEnabledForSequencePlayer(const class UMovieSceneSequencePlayer* SequencePlayer, bool Enabled);
	static struct FTimerHandle SetTimerDelegate(TDelegate<void()> Delegate, float Time, bool bLooping, float InitialStartDelay, float InitialStartDelayVariance);
	static void StartMemTrace(const class FString& ip, int32 Port);
	static void StopMemTrace();
	static void TestMemTrace(const class FString& ip, int32 Port);
	static void TriggerMouseLMBDown(const struct FVector2D& CursorPosition);
	static void TriggerMouseLMBUp(const struct FVector2D& CursorPosition);
	static class UClass* TryGetBlueprintClass(class UObject* Object);
	static void UpdateFloatingObjectsTransform(const class UObject* WorldContextObject, const TArray<class USceneComponent*>& Objects, const TArray<struct FVector>& SpeedVectors, const TArray<struct FVector>& RandomLocations, const TArray<double>& RotatorSpeeds, const TArray<double>& MovingDistances, const TArray<int32>& MultiplierRemapArray);
	static void UpdateWPRuntimeHashSetRuntimeStreamingDataLoadingRange(const class UObject* WorldContextObject, class FName RuntimeStreamingDataName, int32 NewLoadingRange);
	static void WaitForLatentAction(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class USF_BlueprintLatentAction* LatentBlueprintAction);
	static void WaitTillLevelStreamingCompleted(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const TArray<class UWorldPartitionStreamingSourceComponent*>& SourceComponents, bool AddPlayerControllerSource);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SandfallBlueprintHelpers">();
	}
	static class USandfallBlueprintHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<USandfallBlueprintHelpers>();
	}
};
static_assert(alignof(USandfallBlueprintHelpers) == 0x000008, "Wrong alignment on USandfallBlueprintHelpers");
static_assert(sizeof(USandfallBlueprintHelpers) == 0x000028, "Wrong size on USandfallBlueprintHelpers");

// Class SandFall.LZAsyncAction_RequestHttpMessage
// 0x0020 (0x0050 - 0x0030)
class ULZAsyncAction_RequestHttpMessage final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(const class FString& _content, bool bSuccess)> Completed;          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ULZAsyncAction_RequestHttpMessage* AsyncRequestHTTP(class UObject* WorldContextObject, const class FString& URL);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LZAsyncAction_RequestHttpMessage">();
	}
	static class ULZAsyncAction_RequestHttpMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULZAsyncAction_RequestHttpMessage>();
	}
};
static_assert(alignof(ULZAsyncAction_RequestHttpMessage) == 0x000008, "Wrong alignment on ULZAsyncAction_RequestHttpMessage");
static_assert(sizeof(ULZAsyncAction_RequestHttpMessage) == 0x000050, "Wrong size on ULZAsyncAction_RequestHttpMessage");
static_assert(offsetof(ULZAsyncAction_RequestHttpMessage, Completed) == 0x000030, "Member 'ULZAsyncAction_RequestHttpMessage::Completed' has a wrong offset!");

// Class SandFall.OutputDeviceWrapper
// 0x0050 (0x0078 - 0x0028)
class UOutputDeviceWrapper final : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString Flush();
	void Unregister();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutputDeviceWrapper">();
	}
	static class UOutputDeviceWrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOutputDeviceWrapper>();
	}
};
static_assert(alignof(UOutputDeviceWrapper) == 0x000008, "Wrong alignment on UOutputDeviceWrapper");
static_assert(sizeof(UOutputDeviceWrapper) == 0x000078, "Wrong size on UOutputDeviceWrapper");

// Class SandFall.SF_ReferenceCounterWrapper
// 0x0020 (0x0048 - 0x0028)
class USF_ReferenceCounterWrapper final : public UObject
{
public:
	struct FSF_ReferenceCounter                   ReferenceCounter;                                  // 0x0028(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SF_ReferenceCounterWrapper">();
	}
	static class USF_ReferenceCounterWrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<USF_ReferenceCounterWrapper>();
	}
};
static_assert(alignof(USF_ReferenceCounterWrapper) == 0x000008, "Wrong alignment on USF_ReferenceCounterWrapper");
static_assert(sizeof(USF_ReferenceCounterWrapper) == 0x000048, "Wrong size on USF_ReferenceCounterWrapper");
static_assert(offsetof(USF_ReferenceCounterWrapper, ReferenceCounter) == 0x000028, "Member 'USF_ReferenceCounterWrapper::ReferenceCounter' has a wrong offset!");

// Class SandFall.ExtendedObject
// 0x0000 (0x0028 - 0x0028)
class UExtendedObject : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExtendedObject">();
	}
	static class UExtendedObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExtendedObject>();
	}
};
static_assert(alignof(UExtendedObject) == 0x000008, "Wrong alignment on UExtendedObject");
static_assert(sizeof(UExtendedObject) == 0x000028, "Wrong size on UExtendedObject");

// Class SandFall.SF_BlueprintLatentAction
// 0x0020 (0x0048 - 0x0028)
class USF_BlueprintLatentAction : public UExtendedObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFinished();
	void StartOperation();
	void UpdateOperation();

	bool IsFinished() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SF_BlueprintLatentAction">();
	}
	static class USF_BlueprintLatentAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USF_BlueprintLatentAction>();
	}
};
static_assert(alignof(USF_BlueprintLatentAction) == 0x000008, "Wrong alignment on USF_BlueprintLatentAction");
static_assert(sizeof(USF_BlueprintLatentAction) == 0x000048, "Wrong size on USF_BlueprintLatentAction");

// Class SandFall.SF_BlueprintAsyncAction
// 0x0020 (0x0050 - 0x0030)
class USF_BlueprintAsyncAction final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              OnFinished;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USF_BlueprintAsyncAction* StartWaitAsyncAction(class UObject* WorldContextObject, const class FString& DebugReason, class USF_BlueprintLatentAction** NewLatentAction);
	static class USF_BlueprintAsyncAction* WaitAsyncAction(class USF_BlueprintLatentAction* LatentAction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SF_BlueprintAsyncAction">();
	}
	static class USF_BlueprintAsyncAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USF_BlueprintAsyncAction>();
	}
};
static_assert(alignof(USF_BlueprintAsyncAction) == 0x000008, "Wrong alignment on USF_BlueprintAsyncAction");
static_assert(sizeof(USF_BlueprintAsyncAction) == 0x000050, "Wrong size on USF_BlueprintAsyncAction");
static_assert(offsetof(USF_BlueprintAsyncAction, OnFinished) == 0x000030, "Member 'USF_BlueprintAsyncAction::OnFinished' has a wrong offset!");

// Class SandFall.GameplayEventMatchingRuleNode
// 0x0090 (0x00B8 - 0x0028)
class UGameplayEventMatchingRuleNode final : public UObject
{
public:
	struct FGameplayEventMatchingRule             MatchingRule;                                      // 0x0028(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FAudioEvent                            AudioEvent;                                        // 0x0088(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayEventCooldown                 CooldownOverride;                                  // 0x00A0(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class UGameplayEventMatchingRuleNode*> SubRules;                                          // 0x00A8(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayEventMatchingRuleNode">();
	}
	static class UGameplayEventMatchingRuleNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayEventMatchingRuleNode>();
	}
};
static_assert(alignof(UGameplayEventMatchingRuleNode) == 0x000008, "Wrong alignment on UGameplayEventMatchingRuleNode");
static_assert(sizeof(UGameplayEventMatchingRuleNode) == 0x0000B8, "Wrong size on UGameplayEventMatchingRuleNode");
static_assert(offsetof(UGameplayEventMatchingRuleNode, MatchingRule) == 0x000028, "Member 'UGameplayEventMatchingRuleNode::MatchingRule' has a wrong offset!");
static_assert(offsetof(UGameplayEventMatchingRuleNode, AudioEvent) == 0x000088, "Member 'UGameplayEventMatchingRuleNode::AudioEvent' has a wrong offset!");
static_assert(offsetof(UGameplayEventMatchingRuleNode, CooldownOverride) == 0x0000A0, "Member 'UGameplayEventMatchingRuleNode::CooldownOverride' has a wrong offset!");
static_assert(offsetof(UGameplayEventMatchingRuleNode, SubRules) == 0x0000A8, "Member 'UGameplayEventMatchingRuleNode::SubRules' has a wrong offset!");

// Class SandFall.SF_RunHardwareBenchmark
// 0x0038 (0x0068 - 0x0030)
class USF_RunHardwareBenchmark final : public UBlueprintAsyncActionBase
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnBenchmarkRunCompleted;                           // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USF_RunHardwareBenchmark* RunHardwareBenchmarkWithNoAlteration(class UObject* WorldContextObject, int32 WorkScale, float CPUMultiplier, float GPUMultiplier);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SF_RunHardwareBenchmark">();
	}
	static class USF_RunHardwareBenchmark* GetDefaultObj()
	{
		return GetDefaultObjImpl<USF_RunHardwareBenchmark>();
	}
};
static_assert(alignof(USF_RunHardwareBenchmark) == 0x000008, "Wrong alignment on USF_RunHardwareBenchmark");
static_assert(sizeof(USF_RunHardwareBenchmark) == 0x000068, "Wrong size on USF_RunHardwareBenchmark");
static_assert(offsetof(USF_RunHardwareBenchmark, OnBenchmarkRunCompleted) == 0x000058, "Member 'USF_RunHardwareBenchmark::OnBenchmarkRunCompleted' has a wrong offset!");

// Class SandFall.GameplayEventMatchingRuleInstance
// 0x0018 (0x0040 - 0x0028)
class UGameplayEventMatchingRuleInstance final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayEventMatchingRuleInstance">();
	}
	static class UGameplayEventMatchingRuleInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayEventMatchingRuleInstance>();
	}
};
static_assert(alignof(UGameplayEventMatchingRuleInstance) == 0x000008, "Wrong alignment on UGameplayEventMatchingRuleInstance");
static_assert(sizeof(UGameplayEventMatchingRuleInstance) == 0x000040, "Wrong size on UGameplayEventMatchingRuleInstance");

// Class SandFall.GameplayEventCooldownRule
// 0x0000 (0x0028 - 0x0028)
class UGameplayEventCooldownRule final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayEventCooldownRule">();
	}
	static class UGameplayEventCooldownRule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayEventCooldownRule>();
	}
};
static_assert(alignof(UGameplayEventCooldownRule) == 0x000008, "Wrong alignment on UGameplayEventCooldownRule");
static_assert(sizeof(UGameplayEventCooldownRule) == 0x000028, "Wrong size on UGameplayEventCooldownRule");

// Class SandFall.SF_QuestSettings
// 0x0020 (0x0048 - 0x0028)
class USF_QuestSettings final : public UObject
{
public:
	struct FSoftObjectPath                        QuestDataTable;                                    // 0x0028(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SF_QuestSettings">();
	}
	static class USF_QuestSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USF_QuestSettings>();
	}
};
static_assert(alignof(USF_QuestSettings) == 0x000008, "Wrong alignment on USF_QuestSettings");
static_assert(sizeof(USF_QuestSettings) == 0x000048, "Wrong size on USF_QuestSettings");
static_assert(offsetof(USF_QuestSettings, QuestDataTable) == 0x000028, "Member 'USF_QuestSettings::QuestDataTable' has a wrong offset!");

// Class SandFall.GameplayEventCooldownSystem
// 0x0020 (0x0048 - 0x0028)
class UGameplayEventCooldownSystem final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayEventCooldownSystem">();
	}
	static class UGameplayEventCooldownSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayEventCooldownSystem>();
	}
};
static_assert(alignof(UGameplayEventCooldownSystem) == 0x000008, "Wrong alignment on UGameplayEventCooldownSystem");
static_assert(sizeof(UGameplayEventCooldownSystem) == 0x000048, "Wrong size on UGameplayEventCooldownSystem");

// Class SandFall.CharacterSpringArmComponent
// 0x0010 (0x0340 - 0x0330)
class UCharacterSpringArmComponent final : public USpringArmComponent
{
public:
	bool                                          bIgnoreX;                                          // 0x0330(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreY;                                          // 0x0331(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreZ;                                          // 0x0332(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_333[0xD];                                      // 0x0333(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterSpringArmComponent">();
	}
	static class UCharacterSpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterSpringArmComponent>();
	}
};
static_assert(alignof(UCharacterSpringArmComponent) == 0x000010, "Wrong alignment on UCharacterSpringArmComponent");
static_assert(sizeof(UCharacterSpringArmComponent) == 0x000340, "Wrong size on UCharacterSpringArmComponent");
static_assert(offsetof(UCharacterSpringArmComponent, bIgnoreX) == 0x000330, "Member 'UCharacterSpringArmComponent::bIgnoreX' has a wrong offset!");
static_assert(offsetof(UCharacterSpringArmComponent, bIgnoreY) == 0x000331, "Member 'UCharacterSpringArmComponent::bIgnoreY' has a wrong offset!");
static_assert(offsetof(UCharacterSpringArmComponent, bIgnoreZ) == 0x000332, "Member 'UCharacterSpringArmComponent::bIgnoreZ' has a wrong offset!");

// Class SandFall.ConditionChecker
// 0x0028 (0x0050 - 0x0028)
class UConditionChecker : public UExtendedObject
{
public:
	TSoftObjectPtr<class UObject>                 WorldContextObject;                                // 0x0028(0x0028)(BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool Check(class UObject* WorldContext);
	bool CheckInternal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConditionChecker">();
	}
	static class UConditionChecker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConditionChecker>();
	}
};
static_assert(alignof(UConditionChecker) == 0x000008, "Wrong alignment on UConditionChecker");
static_assert(sizeof(UConditionChecker) == 0x000050, "Wrong size on UConditionChecker");
static_assert(offsetof(UConditionChecker, WorldContextObject) == 0x000028, "Member 'UConditionChecker::WorldContextObject' has a wrong offset!");

// Class SandFall.ConditionCheckerDataAsset
// 0x0008 (0x0038 - 0x0030)
class UConditionCheckerDataAsset : public UPrimaryDataAsset
{
public:
	struct FConditionChecker_Wrapper              ConditionCheckerWrapper;                           // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConditionCheckerDataAsset">();
	}
	static class UConditionCheckerDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConditionCheckerDataAsset>();
	}
};
static_assert(alignof(UConditionCheckerDataAsset) == 0x000008, "Wrong alignment on UConditionCheckerDataAsset");
static_assert(sizeof(UConditionCheckerDataAsset) == 0x000038, "Wrong size on UConditionCheckerDataAsset");
static_assert(offsetof(UConditionCheckerDataAsset, ConditionCheckerWrapper) == 0x000030, "Member 'UConditionCheckerDataAsset::ConditionCheckerWrapper' has a wrong offset!");

// Class SandFall.ConfigurableGameUserSettings
// 0x0168 (0x02B0 - 0x0148)
class UConfigurableGameUserSettings final : public UGameUserSettings
{
public:
	struct FSF_SettingsData                       SettingsData;                                      // 0x0148(0x0054)(Config, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C[0x54];                                     // 0x019C(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class UConfigurableGameUserSettings* UserConfig)> OnSettingsApplied; // 0x01F0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(const class UConfigurableGameUserSettings* UserConfig)> OnGraphicSettingsApplied; // 0x0200(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnMonitorChanged;                                  // 0x0210(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_220[0x20];                                     // 0x0220(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CurrentSelectedMonitorIDName;                      // 0x0240(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_250[0x10];                                     // 0x0250(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CurrentSelectedUpscaler;                           // 0x0260(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_270[0x10];                                     // 0x0270(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentSelectedUpscalerQualityMode;                // 0x0280(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UserConfigHardwareProfile;                         // 0x0288(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_298[0x18];                                     // 0x0298(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool GetAvailableMonitorDisplayName(TArray<class FText>* MonitorsName);

	bool CheckForFirstLaunchBenchmark();
	TMap<int32, class FText> GetAvailableQualityModeFromCurrentSelectedUpscaler();
	TArray<class FText> GetAvailableUpscaler();
	float GetFloatConsoleVariable(const class FString& CVarName);
	void GetSelectedUpscalerInfo(bool* ShouldLockScreenPercentage, int32* DefaultSelectedQualityMode);
	void GetSelectedUpscalerQualityModeScreenPercentage(float* ScreenPercentage);
	void GetSelectedUpscalerShouldLockScreenPercentage(bool* ShouldLockScreenPercentage);
	bool GetSupportedResolutionForCurrentMonitor(TArray<struct FIntPoint>* Resolutions);
	void RemoveGameplayFrameRateLimit();
	void RequestGameplayFrameRateLimit(float InLimit);
	void ResetCategoryToCurrentSettings(ESF_SettingsCategory Category);
	void SetApplicationScale(float Value);
	void SetAudioGameCulture(const class FString& Culture);
	void SetAutomaticBattleQTE(bool Value);
	void SetBrightnessValue(float Value);
	void SetCameraPitchInputMultiplier(float Value);
	void SetCameraYawInputMultiplier(float Value);
	void SetCategoryToDefaults(ESF_SettingsCategory Category);
	void SetColorVisionDeficiency(EColorVisionDeficiency Value);
	void SetColorVisionDeficiencyCorrectionSeverity(float Value);
	void SetConsoleGraphicPreset(int32 Value);
	void SetContrastValue(float Value);
	void SetEnableCameraMovement(bool Value);
	void SetEnableCameraShakes(bool Value);
	void SetEnableChromaticAberration(bool Value);
	void SetEnableControllerForceFeedback(bool Value);
	void SetEnableCustomizationDuringCinematics(bool Value);
	void SetEnableFilmGrain(bool Value);
	void SetEnableHoldInputToAim(bool Value);
	void SetEnableHoldInputToSprint(bool Value);
	void SetEnableMotionBlur(bool Value);
	void SetEnablePersistentCenterDot(bool Value);
	void SetEnableSubtitles(bool Value);
	void SetEnableSubtitlesSpeakerDisplay(bool Value);
	void SetEnableSubtitlesSpeakerPersonalColor(bool Value);
	void SetEnableTutorials(bool Value);
	void SetEnableVignette(bool Value);
	void SetFloatConsoleVariable(const class FString& CVarName, float Value);
	void SetGameCulture(const class FString& Culture);
	void SetGammaValue(float Value);
	void SetIntConsoleVariable(const class FString& CVarName, int32 Value);
	void SetInvertCameraPitch(bool Value);
	void SetInvertCameraYaw(bool Value);
	void SetMasterVolume(float Value);
	void SetMusicVolume(float Value);
	void SetSelectedDisplayMonitor(int32 Value);
	void SetSpecialEffectsVolume(float Value);
	void SetSubtitlesSize(int32 Value);
	void SetUpscalerQualityModeUsedValue(int32 Value);
	void SetUpscalerUsedValue(int32 Value);
	void SetUserInterfaceVolume(float Value);
	void SetVoiceVolume(float Value);

	float GetApplicationScale() const;
	class FString GetAudioGameCulture() const;
	float GetBrightnessValue() const;
	float GetCameraPitchInputMultiplier() const;
	float GetCameraYawInputMultiplier() const;
	EColorVisionDeficiency GetColorVisionDeficiency() const;
	float GetColorVisionDeficiencyCorrectionSeverity() const;
	int32 GetConsoleGraphicPreset() const;
	float GetContrastValue() const;
	bool GetEnableAutomaticBattleQTE() const;
	bool GetEnableCameraMovement() const;
	bool GetEnableCameraShakes() const;
	bool GetEnableChromaticAberration() const;
	bool GetEnableControllerForceFeedback() const;
	bool GetEnableCustomizationDuringCinematics() const;
	bool GetEnableFilmGrain() const;
	bool GetEnableHoldInputToAim() const;
	bool GetEnableHoldInputToSprint() const;
	bool GetEnableMotionBlur() const;
	bool GetEnablePersistentCenterDot() const;
	bool GetEnableSubtitles() const;
	bool GetEnableSubtitlesSpeakerDisplay() const;
	bool GetEnableSubtitlesSpeakerPersonalColor() const;
	bool GetEnableTutorials() const;
	bool GetEnableVignette() const;
	class FString GetGameCulture() const;
	float GetGammaValue() const;
	bool GetInvertCameraPitch() const;
	bool GetInvertCameraYaw() const;
	float GetLastCPUHardwareBenchmarkResult() const;
	float GetLastGPUHardwareBenchmarkResult() const;
	float GetMasterVolume() const;
	float GetMusicVolume() const;
	int32 GetSelectedDisplayMonitor() const;
	float GetSpecialEffectsVolume() const;
	int32 GetSubtitlesSize() const;
	int32 GetUpscalerQualityModeUsedValue() const;
	int32 GetUpscalerUsedValue() const;
	float GetUserInterfaceVolume() const;
	float GetVoiceVolume() const;
	bool IsPendingScalabilityChangesAtSameQuality() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConfigurableGameUserSettings">();
	}
	static class UConfigurableGameUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfigurableGameUserSettings>();
	}
};
static_assert(alignof(UConfigurableGameUserSettings) == 0x000008, "Wrong alignment on UConfigurableGameUserSettings");
static_assert(sizeof(UConfigurableGameUserSettings) == 0x0002B0, "Wrong size on UConfigurableGameUserSettings");
static_assert(offsetof(UConfigurableGameUserSettings, SettingsData) == 0x000148, "Member 'UConfigurableGameUserSettings::SettingsData' has a wrong offset!");
static_assert(offsetof(UConfigurableGameUserSettings, OnSettingsApplied) == 0x0001F0, "Member 'UConfigurableGameUserSettings::OnSettingsApplied' has a wrong offset!");
static_assert(offsetof(UConfigurableGameUserSettings, OnGraphicSettingsApplied) == 0x000200, "Member 'UConfigurableGameUserSettings::OnGraphicSettingsApplied' has a wrong offset!");
static_assert(offsetof(UConfigurableGameUserSettings, OnMonitorChanged) == 0x000210, "Member 'UConfigurableGameUserSettings::OnMonitorChanged' has a wrong offset!");
static_assert(offsetof(UConfigurableGameUserSettings, CurrentSelectedMonitorIDName) == 0x000240, "Member 'UConfigurableGameUserSettings::CurrentSelectedMonitorIDName' has a wrong offset!");
static_assert(offsetof(UConfigurableGameUserSettings, CurrentSelectedUpscaler) == 0x000260, "Member 'UConfigurableGameUserSettings::CurrentSelectedUpscaler' has a wrong offset!");
static_assert(offsetof(UConfigurableGameUserSettings, CurrentSelectedUpscalerQualityMode) == 0x000280, "Member 'UConfigurableGameUserSettings::CurrentSelectedUpscalerQualityMode' has a wrong offset!");
static_assert(offsetof(UConfigurableGameUserSettings, UserConfigHardwareProfile) == 0x000288, "Member 'UConfigurableGameUserSettings::UserConfigHardwareProfile' has a wrong offset!");

// Class SandFall.CustomDebugCameraController
// 0x0060 (0x0A48 - 0x09E8)
class ACustomDebugCameraController : public ADebugCameraController
{
public:
	uint8                                         Pad_9E8[0x60];                                     // 0x09E8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomDebugCameraController">();
	}
	static class ACustomDebugCameraController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomDebugCameraController>();
	}
};
static_assert(alignof(ACustomDebugCameraController) == 0x000008, "Wrong alignment on ACustomDebugCameraController");
static_assert(sizeof(ACustomDebugCameraController) == 0x000A48, "Wrong size on ACustomDebugCameraController");

// Class SandFall.CustomGameViewportClient
// 0x0000 (0x03F0 - 0x03F0)
class UCustomGameViewportClient final : public UCommonGameViewportClient
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomGameViewportClient">();
	}
	static class UCustomGameViewportClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomGameViewportClient>();
	}
};
static_assert(alignof(UCustomGameViewportClient) == 0x000008, "Wrong alignment on UCustomGameViewportClient");
static_assert(sizeof(UCustomGameViewportClient) == 0x0003F0, "Wrong size on UCustomGameViewportClient");

// Class SandFall.CustomizationHelpers
// 0x0000 (0x0028 - 0x0028)
class UCustomizationHelpers final : public UBlueprintFunctionLibrary
{
public:
	static class USkeletalMeshComponent* GetCharacterBody(class AActor* Character);
	static class USkeletalMeshComponent* GetCharacterFace(class AActor* Character);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationHelpers">();
	}
	static class UCustomizationHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationHelpers>();
	}
};
static_assert(alignof(UCustomizationHelpers) == 0x000008, "Wrong alignment on UCustomizationHelpers");
static_assert(sizeof(UCustomizationHelpers) == 0x000028, "Wrong size on UCustomizationHelpers");

// Class SandFall.CustomNavModifierComponent
// 0x0020 (0x0110 - 0x00F0)
class UCustomNavModifierComponent final : public UNavRelevantComponent
{
public:
	TSubclassOf<class UNavArea>                   AreaClass;                                         // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ComponentsToInclude;                               // 0x00F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ComponentTagToIgnore;                              // 0x00FC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0xC];                                      // 0x0104(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateNavigationSystem();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomNavModifierComponent">();
	}
	static class UCustomNavModifierComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomNavModifierComponent>();
	}
};
static_assert(alignof(UCustomNavModifierComponent) == 0x000008, "Wrong alignment on UCustomNavModifierComponent");
static_assert(sizeof(UCustomNavModifierComponent) == 0x000110, "Wrong size on UCustomNavModifierComponent");
static_assert(offsetof(UCustomNavModifierComponent, AreaClass) == 0x0000F0, "Member 'UCustomNavModifierComponent::AreaClass' has a wrong offset!");
static_assert(offsetof(UCustomNavModifierComponent, ComponentsToInclude) == 0x0000F8, "Member 'UCustomNavModifierComponent::ComponentsToInclude' has a wrong offset!");
static_assert(offsetof(UCustomNavModifierComponent, ComponentTagToIgnore) == 0x0000FC, "Member 'UCustomNavModifierComponent::ComponentTagToIgnore' has a wrong offset!");

// Class SandFall.DataLayerEditorHelpers
// 0x0000 (0x0028 - 0x0028)
class UDataLayerEditorHelpers final : public UBlueprintFunctionLibrary
{
public:
	static void SetDataLayersVisibility(const TArray<class UDataLayerInstance*>& DataLayers, const bool bIsVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataLayerEditorHelpers">();
	}
	static class UDataLayerEditorHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataLayerEditorHelpers>();
	}
};
static_assert(alignof(UDataLayerEditorHelpers) == 0x000008, "Wrong alignment on UDataLayerEditorHelpers");
static_assert(sizeof(UDataLayerEditorHelpers) == 0x000028, "Wrong size on UDataLayerEditorHelpers");

// Class SandFall.SF_DataTableGettersSettings
// 0x0010 (0x0038 - 0x0028)
class USF_DataTableGettersSettings final : public UObject
{
public:
	TArray<struct FSoftObjectPath>                DataTables;                                        // 0x0028(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SF_DataTableGettersSettings">();
	}
	static class USF_DataTableGettersSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USF_DataTableGettersSettings>();
	}
};
static_assert(alignof(USF_DataTableGettersSettings) == 0x000008, "Wrong alignment on USF_DataTableGettersSettings");
static_assert(sizeof(USF_DataTableGettersSettings) == 0x000038, "Wrong size on USF_DataTableGettersSettings");
static_assert(offsetof(USF_DataTableGettersSettings, DataTables) == 0x000028, "Member 'USF_DataTableGettersSettings::DataTables' has a wrong offset!");

// Class SandFall.DialogueBlueprintHelpers
// 0x0000 (0x0028 - 0x0028)
class UDialogueBlueprintHelpers final : public UBlueprintFunctionLibrary
{
public:
	static void DevelopmentTextToSpeech(const class FString& Text, class USF_BlueprintLatentAction* LatentAction);
	static struct FDialogueContext GetDialogueWaveFirstContext(const class UDialogueWave* _dialogueWave);
	static class USoundWave* GetFirstSoundFromDialogueWave(class UDialogueWave* DialogueWave);
	static class UTextToSpeechEngineSubsystem* GetTextToSpeechEngineSubsystem();
	static void PlaySandfallDialogue2D(const class UObject* WorldContextObject, class UDialogueWave* Dialogue, float VolumeMultiplier, float PitchMultiplier, float StartTime);
	static void PlaySandfallDialogueAtLocation(const class UObject* WorldContextObject, class UDialogueWave* Dialogue, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings);
	static class UAudioComponent* SpawnSandfallDialogue2D(const class UObject* WorldContextObject, class UDialogueWave* Dialogue, float VolumeMultiplier, float PitchMultiplier, float StartTime, bool bAutoDestroy);
	static class UAudioComponent* SpawnSandfallDialogueAtLocation(const class UObject* WorldContextObject, class UDialogueWave* Dialogue, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, bool bAutoDestroy);
	static class UAudioComponent* SpawnSandfallDialogueAttached(class UDialogueWave* Dialogue, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, bool bAutoDestroy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogueBlueprintHelpers">();
	}
	static class UDialogueBlueprintHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogueBlueprintHelpers>();
	}
};
static_assert(alignof(UDialogueBlueprintHelpers) == 0x000008, "Wrong alignment on UDialogueBlueprintHelpers");
static_assert(sizeof(UDialogueBlueprintHelpers) == 0x000028, "Wrong size on UDialogueBlueprintHelpers");

// Class SandFall.SF_DialogueSubtitleSpeakersData
// 0x0060 (0x0090 - 0x0030)
class USF_DialogueSubtitleSpeakersData final : public UPrimaryDataAsset
{
public:
	class UDataTable*                             SubSpeakerData;                                    // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStringTable*                           ST_CharaNames;                                     // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FString, struct FSpeakerProfile>   SpeakerProfiles;                                   // 0x0040(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SF_DialogueSubtitleSpeakersData">();
	}
	static class USF_DialogueSubtitleSpeakersData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USF_DialogueSubtitleSpeakersData>();
	}
};
static_assert(alignof(USF_DialogueSubtitleSpeakersData) == 0x000008, "Wrong alignment on USF_DialogueSubtitleSpeakersData");
static_assert(sizeof(USF_DialogueSubtitleSpeakersData) == 0x000090, "Wrong size on USF_DialogueSubtitleSpeakersData");
static_assert(offsetof(USF_DialogueSubtitleSpeakersData, SubSpeakerData) == 0x000030, "Member 'USF_DialogueSubtitleSpeakersData::SubSpeakerData' has a wrong offset!");
static_assert(offsetof(USF_DialogueSubtitleSpeakersData, ST_CharaNames) == 0x000038, "Member 'USF_DialogueSubtitleSpeakersData::ST_CharaNames' has a wrong offset!");
static_assert(offsetof(USF_DialogueSubtitleSpeakersData, SpeakerProfiles) == 0x000040, "Member 'USF_DialogueSubtitleSpeakersData::SpeakerProfiles' has a wrong offset!");

// Class SandFall.DynamicNavModifierComponent
// 0x0008 (0x00F8 - 0x00F0)
class UDynamicNavModifierComponent final : public UNavRelevantComponent
{
public:
	TSubclassOf<class UNavArea>                   AreaClass;                                         // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicNavModifierComponent">();
	}
	static class UDynamicNavModifierComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicNavModifierComponent>();
	}
};
static_assert(alignof(UDynamicNavModifierComponent) == 0x000008, "Wrong alignment on UDynamicNavModifierComponent");
static_assert(sizeof(UDynamicNavModifierComponent) == 0x0000F8, "Wrong size on UDynamicNavModifierComponent");
static_assert(offsetof(UDynamicNavModifierComponent, AreaClass) == 0x0000F0, "Member 'UDynamicNavModifierComponent::AreaClass' has a wrong offset!");

// Class SandFall.SF_EditorDebugDrawSource
// 0x0000 (0x0000 - 0x0000)
class ISF_EditorDebugDrawSource final
{
public:
	bool Editor_DrawDebugShapes() const;
	bool Editor_GetDebugShapes(TArray<struct FEditorDebugShape_Arrow>& Arrows, TArray<struct FEditorDebugShape_Arrow>& Lines) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SF_EditorDebugDrawSource">();
	}
	static class ISF_EditorDebugDrawSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISF_EditorDebugDrawSource>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISF_EditorDebugDrawSource) == 0x000001, "Wrong alignment on ISF_EditorDebugDrawSource");
static_assert(sizeof(ISF_EditorDebugDrawSource) == 0x000001, "Wrong size on ISF_EditorDebugDrawSource");

// Class SandFall.SF_EditorDebugViewer
// 0x0008 (0x0298 - 0x0290)
class ASF_EditorDebugViewer final : public AActor
{
public:
	bool                                          IsEnabled;                                         // 0x0290(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SF_EditorDebugViewer">();
	}
	static class ASF_EditorDebugViewer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASF_EditorDebugViewer>();
	}
};
static_assert(alignof(ASF_EditorDebugViewer) == 0x000008, "Wrong alignment on ASF_EditorDebugViewer");
static_assert(sizeof(ASF_EditorDebugViewer) == 0x000298, "Wrong size on ASF_EditorDebugViewer");
static_assert(offsetof(ASF_EditorDebugViewer, IsEnabled) == 0x000290, "Member 'ASF_EditorDebugViewer::IsEnabled' has a wrong offset!");

// Class SandFall.EditorCheckableForErrors
// 0x0000 (0x0000 - 0x0000)
class IEditorCheckableForErrors final
{
public:
	bool CheckForErrors(TArray<class FText>& ErrorMessages);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditorCheckableForErrors">();
	}
	static class IEditorCheckableForErrors* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEditorCheckableForErrors>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IEditorCheckableForErrors) == 0x000001, "Wrong alignment on IEditorCheckableForErrors");
static_assert(sizeof(IEditorCheckableForErrors) == 0x000001, "Wrong size on IEditorCheckableForErrors");

// Class SandFall.EnemyCharacterMovementComponent
// 0x0000 (0x0F80 - 0x0F80)
class UEnemyCharacterMovementComponent final : public UCharacterMovementComponent
{
public:
	class FName                                   EncounterCapsuleComponentTag;                      // 0x0F78(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyCharacterMovementComponent">();
	}
	static class UEnemyCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyCharacterMovementComponent>();
	}
};
static_assert(alignof(UEnemyCharacterMovementComponent) == 0x000010, "Wrong alignment on UEnemyCharacterMovementComponent");
static_assert(sizeof(UEnemyCharacterMovementComponent) == 0x000F80, "Wrong size on UEnemyCharacterMovementComponent");
static_assert(offsetof(UEnemyCharacterMovementComponent, EncounterCapsuleComponentTag) == 0x000F78, "Member 'UEnemyCharacterMovementComponent::EncounterCapsuleComponentTag' has a wrong offset!");

// Class SandFall.ExtendedGameInstance
// 0x0000 (0x01C0 - 0x01C0)
class UExtendedGameInstance : public UGameInstance
{
public:
	void ReceivePostInitSubsystemCollection();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExtendedGameInstance">();
	}
	static class UExtendedGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExtendedGameInstance>();
	}
};
static_assert(alignof(UExtendedGameInstance) == 0x000008, "Wrong alignment on UExtendedGameInstance");
static_assert(sizeof(UExtendedGameInstance) == 0x0001C0, "Wrong size on UExtendedGameInstance");

// Class SandFall.ExtendedPlayerCameraManager
// 0x0000 (0x24C0 - 0x24C0)
class AExtendedPlayerCameraManager : public APlayerCameraManager
{
public:
	bool ShouldPlayCameraShake() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExtendedPlayerCameraManager">();
	}
	static class AExtendedPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AExtendedPlayerCameraManager>();
	}
};
static_assert(alignof(AExtendedPlayerCameraManager) == 0x000010, "Wrong alignment on AExtendedPlayerCameraManager");
static_assert(sizeof(AExtendedPlayerCameraManager) == 0x0024C0, "Wrong size on AExtendedPlayerCameraManager");

// Class SandFall.GameActionInstance
// 0x0018 (0x0040 - 0x0028)
class UGameActionInstance : public UExtendedObject
{
public:
	class UGameAction*                            GameAction;                                        // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UGameActionInstance* GameActionInstance)> OnGameActionExecutionFinishedDelegate; // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	void ExecuteGameAction(const class APlayerController* Controller);

	class FString GetDebugString() const;
	bool ShouldBlockAutoSaveDuringExecution() const;
	bool ShouldTriggerAutoSaveAfterExecution() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameActionInstance">();
	}
	static class UGameActionInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameActionInstance>();
	}
};
static_assert(alignof(UGameActionInstance) == 0x000008, "Wrong alignment on UGameActionInstance");
static_assert(sizeof(UGameActionInstance) == 0x000040, "Wrong size on UGameActionInstance");
static_assert(offsetof(UGameActionInstance, GameAction) == 0x000028, "Member 'UGameActionInstance::GameAction' has a wrong offset!");
static_assert(offsetof(UGameActionInstance, OnGameActionExecutionFinishedDelegate) == 0x000030, "Member 'UGameActionInstance::OnGameActionExecutionFinishedDelegate' has a wrong offset!");

// Class SandFall.GameAction
// 0x0000 (0x0030 - 0x0030)
class UGameAction : public UPrimaryDataAsset
{
public:
	TSubclassOf<class UGameActionInstance> GetInstanceClass();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameAction">();
	}
	static class UGameAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameAction>();
	}
};
static_assert(alignof(UGameAction) == 0x000008, "Wrong alignment on UGameAction");
static_assert(sizeof(UGameAction) == 0x000030, "Wrong size on UGameAction");

// Class SandFall.SkillState
// 0x0000 (0x0028 - 0x0028)
class USkillState final : public UExtendedObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillState">();
	}
	static class USkillState* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillState>();
	}
};
static_assert(alignof(USkillState) == 0x000008, "Wrong alignment on USkillState");
static_assert(sizeof(USkillState) == 0x000028, "Wrong size on USkillState");

// Class SandFall.SkillDataComponent
// 0x0000 (0x0028 - 0x0028)
class USkillDataComponent : public UExtendedObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillDataComponent">();
	}
	static class USkillDataComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillDataComponent>();
	}
};
static_assert(alignof(USkillDataComponent) == 0x000008, "Wrong alignment on USkillDataComponent");
static_assert(sizeof(USkillDataComponent) == 0x000028, "Wrong size on USkillDataComponent");

// Class SandFall.SkillDataAsset
// 0x0030 (0x0060 - 0x0030)
class USkillDataAsset : public UPrimaryDataAsset
{
public:
	struct FGameplayTagContainer                  SkillTags;                                         // 0x0030(0x0020)(Edit, NativeAccessSpecifierPublic)
	TArray<class USkillDataComponent*>            SkillComponentList;                                // 0x0050(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	bool HasSkillTag(const struct FGameplayTag& Tag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillDataAsset">();
	}
	static class USkillDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillDataAsset>();
	}
};
static_assert(alignof(USkillDataAsset) == 0x000008, "Wrong alignment on USkillDataAsset");
static_assert(sizeof(USkillDataAsset) == 0x000060, "Wrong size on USkillDataAsset");
static_assert(offsetof(USkillDataAsset, SkillTags) == 0x000030, "Member 'USkillDataAsset::SkillTags' has a wrong offset!");
static_assert(offsetof(USkillDataAsset, SkillComponentList) == 0x000050, "Member 'USkillDataAsset::SkillComponentList' has a wrong offset!");

// Class SandFall.GameplayDebuggerCategory_SandfallGameplay_BlueprintHelper
// 0x0000 (0x0028 - 0x0028)
class UGameplayDebuggerCategory_SandfallGameplay_BlueprintHelper final : public UBlueprintFunctionLibrary
{
public:
	static void AddGameplayFrameMessage(const class FText& _content);
	static bool IsGameplayDebugCategoryEnabled();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayDebuggerCategory_SandfallGameplay_BlueprintHelper">();
	}
	static class UGameplayDebuggerCategory_SandfallGameplay_BlueprintHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayDebuggerCategory_SandfallGameplay_BlueprintHelper>();
	}
};
static_assert(alignof(UGameplayDebuggerCategory_SandfallGameplay_BlueprintHelper) == 0x000008, "Wrong alignment on UGameplayDebuggerCategory_SandfallGameplay_BlueprintHelper");
static_assert(sizeof(UGameplayDebuggerCategory_SandfallGameplay_BlueprintHelper) == 0x000028, "Wrong size on UGameplayDebuggerCategory_SandfallGameplay_BlueprintHelper");

// Class SandFall.GameplayTagHelpers
// 0x0000 (0x0028 - 0x0028)
class UGameplayTagHelpers final : public UBlueprintFunctionLibrary
{
public:
	static struct FGameplayTag GetGameplayTagFromName(class FName TagName);
	static struct FGameplayTag GetGameplayTagFromString(const class FString& TagName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTagHelpers">();
	}
	static class UGameplayTagHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTagHelpers>();
	}
};
static_assert(alignof(UGameplayTagHelpers) == 0x000008, "Wrong alignment on UGameplayTagHelpers");
static_assert(sizeof(UGameplayTagHelpers) == 0x000028, "Wrong size on UGameplayTagHelpers");

// Class SandFall.SF_GeneratedInvisibleWallBase
// 0x0000 (0x0290 - 0x0290)
class ASF_GeneratedInvisibleWallBase : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SF_GeneratedInvisibleWallBase">();
	}
	static class ASF_GeneratedInvisibleWallBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASF_GeneratedInvisibleWallBase>();
	}
};
static_assert(alignof(ASF_GeneratedInvisibleWallBase) == 0x000008, "Wrong alignment on ASF_GeneratedInvisibleWallBase");
static_assert(sizeof(ASF_GeneratedInvisibleWallBase) == 0x000290, "Wrong size on ASF_GeneratedInvisibleWallBase");

// Class SandFall.SF_GeneratedInvisibleWallBoxComponent
// 0x0008 (0x0298 - 0x0290)
class ASF_GeneratedInvisibleWallBoxComponent final : public ASF_GeneratedInvisibleWallBase
{
public:
	class UBoxComponent*                          BoxCollisionComponent;                             // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SF_GeneratedInvisibleWallBoxComponent">();
	}
	static class ASF_GeneratedInvisibleWallBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASF_GeneratedInvisibleWallBoxComponent>();
	}
};
static_assert(alignof(ASF_GeneratedInvisibleWallBoxComponent) == 0x000008, "Wrong alignment on ASF_GeneratedInvisibleWallBoxComponent");
static_assert(sizeof(ASF_GeneratedInvisibleWallBoxComponent) == 0x000298, "Wrong size on ASF_GeneratedInvisibleWallBoxComponent");
static_assert(offsetof(ASF_GeneratedInvisibleWallBoxComponent, BoxCollisionComponent) == 0x000290, "Member 'ASF_GeneratedInvisibleWallBoxComponent::BoxCollisionComponent' has a wrong offset!");

// Class SandFall.SF_GeneratedInvisibleWallStaticMesh
// 0x0008 (0x0298 - 0x0290)
class ASF_GeneratedInvisibleWallStaticMesh : public ASF_GeneratedInvisibleWallBase
{
public:
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SF_GeneratedInvisibleWallStaticMesh">();
	}
	static class ASF_GeneratedInvisibleWallStaticMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASF_GeneratedInvisibleWallStaticMesh>();
	}
};
static_assert(alignof(ASF_GeneratedInvisibleWallStaticMesh) == 0x000008, "Wrong alignment on ASF_GeneratedInvisibleWallStaticMesh");
static_assert(sizeof(ASF_GeneratedInvisibleWallStaticMesh) == 0x000298, "Wrong size on ASF_GeneratedInvisibleWallStaticMesh");
static_assert(offsetof(ASF_GeneratedInvisibleWallStaticMesh, MeshComponent) == 0x000290, "Member 'ASF_GeneratedInvisibleWallStaticMesh::MeshComponent' has a wrong offset!");

// Class SandFall.GeometryCollectionBlueprintHelpers
// 0x0000 (0x0028 - 0x0028)
class UGeometryCollectionBlueprintHelpers final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class UMaterialInterface*> GetGeometryCollectionMaterials(class UGeometryCollection* GeometryCollection);
	static void RecreatePhysicsState(class UActorComponent* Component);
	static void SetCollisionResponseToChannel(class UGeometryCollectionComponent* GeometryCollectionComponent, ECollisionChannel Channel, ECollisionResponse NewResponse);
	static class UGeometryCollectionComponent* SpawnGeometryCollectionComponentWithRestCollection(class AActor* OwnerActor, class UGeometryCollection* InRestCollection, const struct FTransform& InTransform);
	static void SpawnGeometryCollectionWithRestCollection(const class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, class UGeometryCollection* InRestCollection, const struct FTransform& InTransform);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryCollectionBlueprintHelpers">();
	}
	static class UGeometryCollectionBlueprintHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryCollectionBlueprintHelpers>();
	}
};
static_assert(alignof(UGeometryCollectionBlueprintHelpers) == 0x000008, "Wrong alignment on UGeometryCollectionBlueprintHelpers");
static_assert(sizeof(UGeometryCollectionBlueprintHelpers) == 0x000028, "Wrong size on UGeometryCollectionBlueprintHelpers");

// Class SandFall.SF_GraphicBlueprintHelpers
// 0x0000 (0x0028 - 0x0028)
class USF_GraphicBlueprintHelpers final : public UBlueprintFunctionLibrary
{
public:
	static void BringToFrontWindow(bool bForced);
	static void UpdateSplineFloatingObject(class UObject* WorldContextObject, const TArray<class UInstancedStaticMeshComponent*>& ISMs, const TArray<struct FSplineFloatingInstancesData>& SplineInstanceData, const TMap<class UInstancedStaticMeshComponent*, float>& MovingDistance, const TMap<class UInstancedStaticMeshComponent*, float>& RotatorSpeed, float DeltaSeconds, int32 InstanceCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SF_GraphicBlueprintHelpers">();
	}
	static class USF_GraphicBlueprintHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<USF_GraphicBlueprintHelpers>();
	}
};
static_assert(alignof(USF_GraphicBlueprintHelpers) == 0x000008, "Wrong alignment on USF_GraphicBlueprintHelpers");
static_assert(sizeof(USF_GraphicBlueprintHelpers) == 0x000028, "Wrong size on USF_GraphicBlueprintHelpers");

// Class SandFall.RichTextBlockCustomWidget
// 0x0360 (0x0640 - 0x02E0)
class URichTextBlockCustomWidget : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x360];                                    // 0x02E0(0x0360)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyUpdateNeeded();
	void SetContentText(const class FText& ContentText);
	void SetIDString(const class FString& IDString);
	void SetParentStyle(const struct FTextBlockStyle& Style);

	class FText GetContentText() const;
	class FString GetIDString() const;
	const struct FTextBlockStyle GetParentStyle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichTextBlockCustomWidget">();
	}
	static class URichTextBlockCustomWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URichTextBlockCustomWidget>();
	}
};
static_assert(alignof(URichTextBlockCustomWidget) == 0x000008, "Wrong alignment on URichTextBlockCustomWidget");
static_assert(sizeof(URichTextBlockCustomWidget) == 0x000640, "Wrong size on URichTextBlockCustomWidget");

// Class SandFall.InputActionBindingWidget
// 0x0000 (0x0640 - 0x0640)
class UInputActionBindingWidget : public URichTextBlockCustomWidget
{
public:
	void SetupInputBindingParametersFromExternal(const class FName& InLegacyActionName, const struct FDataTableRowHandle& InCommonUIAction, class UInputAction* InEnhancedInputAction, class UInputMappingContext* InIMC);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputActionBindingWidget">();
	}
	static class UInputActionBindingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputActionBindingWidget>();
	}
};
static_assert(alignof(UInputActionBindingWidget) == 0x000008, "Wrong alignment on UInputActionBindingWidget");
static_assert(sizeof(UInputActionBindingWidget) == 0x000640, "Wrong size on UInputActionBindingWidget");

// Class SandFall.InputBlueprintHelpers
// 0x0000 (0x0028 - 0x0028)
class UInputBlueprintHelpers final : public UBlueprintFunctionLibrary
{
public:
	static struct FSlateBrush FindInputBrushFromCommonUIDataTable(class UObject* WorldContextObject, class UDataTable* CommonInputActionDataTable, class FName InputRowName);
	static struct FSlateBrush FindInputBrushFromEnhancedInputAction(class UObject* WorldContextObject, const class UInputAction* EnhancedInputAction);
	static struct FSlateBrush FindInputBrushFromEnhancedInputActionByInputType(class UObject* WorldContextObject, ECommonInputType InputType, const class UInputAction* EnhancedInputAction, const class UInputMappingContext* InputMappingContext);
	static struct FSlateBrush FindInputBrushFromInputAction(class UObject* WorldContextObject, class FName InputActionName);
	static struct FSlateBrush FindInputBrushFromKey(class UObject* WorldContextObject, ECommonInputType InputType, const struct FKey& Key);
	static struct FKey GetFirstKeyForEnhancedInputActionByInputType(class UObject* WorldContextObject, ECommonInputType InputType, const class UInputAction* EnhancedInputAction, const class UInputMappingContext* InputMappingContext);
	static struct FKey GetKeyForCommonAction(const class UCommonInputSubsystem* CommonInputSubsystem, const struct FDataTableRowHandle& InputAction);
	static bool IsInGamepadOrKeyboardNavigationMode(class UObject* WorldContextObject);
	static void SetIgnoreNavigationKeysInAnalogCursor(class UObject* WorldContextObject, bool bInIgnoreNavigationKeys);
	static TArray<struct FKey> TryFindKeysForEnhancedInputAction(class UObject* WorldContextObject, const class UInputAction* EnhancedInputAction);
	static TArray<struct FKey> TryFindKeysForEnhancedInputActionName(class UObject* WorldContextObject, const class FName& EnhancedInputActionName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputBlueprintHelpers">();
	}
	static class UInputBlueprintHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputBlueprintHelpers>();
	}
};
static_assert(alignof(UInputBlueprintHelpers) == 0x000008, "Wrong alignment on UInputBlueprintHelpers");
static_assert(sizeof(UInputBlueprintHelpers) == 0x000028, "Wrong size on UInputBlueprintHelpers");

// Class SandFall.SF_InvisibleWall
// 0x0078 (0x0308 - 0x0290)
class ASF_InvisibleWall final : public AActor
{
public:
	bool                                          bMustBeIgnoredInCommandlet;                        // 0x0290(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_291[0x3];                                      // 0x0291(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentWallVersion;                                // 0x0294(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldAffectNavigation;                           // 0x0298(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClosedLoop;                                       // 0x0299(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRemoveNavigationMeshInClosedLoop;                 // 0x029A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasWarnMissingBakedData;                          // 0x029B(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 BakedInvisibleWall;                                // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class ASF_GeneratedInvisibleWallBase>> GeneratedInvisibleWalls;            // 0x02A8(0x0010)(Edit, ZeroConstructor, EditConst, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UPrimitiveComponent*>            WallCollection;                                    // 0x02B8(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UPrimitiveComponent*>            WallDynamicCollection;                             // 0x02C8(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UPrimitiveComponent*>            CornerCollection;                                  // 0x02D8(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UPrimitiveComponent*>            CornerDynamicCollection;                           // 0x02E8(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSubclassOf<class ASF_GeneratedInvisibleWallBase> WallPrefab;                                    // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ASF_GeneratedInvisibleWallBase> CornerPrefab;                                  // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	TArray<class ASF_GeneratedInvisibleWallBase*> GetGeneratedInvisibleWalls();
	bool HasBakedData();
	bool IsBakeVersionOutDated();
	bool TryBakeInvisibleWall(bool ForceBake);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SF_InvisibleWall">();
	}
	static class ASF_InvisibleWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASF_InvisibleWall>();
	}
};
static_assert(alignof(ASF_InvisibleWall) == 0x000008, "Wrong alignment on ASF_InvisibleWall");
static_assert(sizeof(ASF_InvisibleWall) == 0x000308, "Wrong size on ASF_InvisibleWall");
static_assert(offsetof(ASF_InvisibleWall, bMustBeIgnoredInCommandlet) == 0x000290, "Member 'ASF_InvisibleWall::bMustBeIgnoredInCommandlet' has a wrong offset!");
static_assert(offsetof(ASF_InvisibleWall, CurrentWallVersion) == 0x000294, "Member 'ASF_InvisibleWall::CurrentWallVersion' has a wrong offset!");
static_assert(offsetof(ASF_InvisibleWall, bShouldAffectNavigation) == 0x000298, "Member 'ASF_InvisibleWall::bShouldAffectNavigation' has a wrong offset!");
static_assert(offsetof(ASF_InvisibleWall, bClosedLoop) == 0x000299, "Member 'ASF_InvisibleWall::bClosedLoop' has a wrong offset!");
static_assert(offsetof(ASF_InvisibleWall, bRemoveNavigationMeshInClosedLoop) == 0x00029A, "Member 'ASF_InvisibleWall::bRemoveNavigationMeshInClosedLoop' has a wrong offset!");
static_assert(offsetof(ASF_InvisibleWall, bHasWarnMissingBakedData) == 0x00029B, "Member 'ASF_InvisibleWall::bHasWarnMissingBakedData' has a wrong offset!");
static_assert(offsetof(ASF_InvisibleWall, BakedInvisibleWall) == 0x0002A0, "Member 'ASF_InvisibleWall::BakedInvisibleWall' has a wrong offset!");
static_assert(offsetof(ASF_InvisibleWall, GeneratedInvisibleWalls) == 0x0002A8, "Member 'ASF_InvisibleWall::GeneratedInvisibleWalls' has a wrong offset!");
static_assert(offsetof(ASF_InvisibleWall, WallCollection) == 0x0002B8, "Member 'ASF_InvisibleWall::WallCollection' has a wrong offset!");
static_assert(offsetof(ASF_InvisibleWall, WallDynamicCollection) == 0x0002C8, "Member 'ASF_InvisibleWall::WallDynamicCollection' has a wrong offset!");
static_assert(offsetof(ASF_InvisibleWall, CornerCollection) == 0x0002D8, "Member 'ASF_InvisibleWall::CornerCollection' has a wrong offset!");
static_assert(offsetof(ASF_InvisibleWall, CornerDynamicCollection) == 0x0002E8, "Member 'ASF_InvisibleWall::CornerDynamicCollection' has a wrong offset!");
static_assert(offsetof(ASF_InvisibleWall, WallPrefab) == 0x0002F8, "Member 'ASF_InvisibleWall::WallPrefab' has a wrong offset!");
static_assert(offsetof(ASF_InvisibleWall, CornerPrefab) == 0x000300, "Member 'ASF_InvisibleWall::CornerPrefab' has a wrong offset!");

// Class SandFall.LightingScenarioHelpers
// 0x0000 (0x0028 - 0x0028)
class ULightingScenarioHelpers final : public UBlueprintFunctionLibrary
{
public:
	static void BlendDirectionalLightComponent(class UDirectionalLightComponent* Source, class UDirectionalLightComponent* Destination, class UDirectionalLightComponent* Target, float Multiplier);
	static void BlendExponentialHeightFogComponent(class UExponentialHeightFogComponent* Source, class UExponentialHeightFogComponent* Destination, class UExponentialHeightFogComponent* Target, float Multiplier);
	static void BlendLightComponent(class ULightComponent* Source, class ULightComponent* Destination, class ULightComponent* Target, float Multiplier);
	static void BlendLightComponentBase(class ULightComponentBase* Source, class ULightComponentBase* Destination, class ULightComponentBase* Target, float Multiplier);
	static void BlendSkyAtmosphereComponent(class USkyAtmosphereComponent* Source, class USkyAtmosphereComponent* Destination, class USkyAtmosphereComponent* Target, float Multiplier);
	static void BlendSkyLightComponent(class USkyLightComponent* Source, class USkyLightComponent* Destination, class USkyLightComponent* Target, float Multiplier);
	static struct FColor Lerp_FColor(const struct FColor& A, const struct FColor& B, float T);
	static struct FExponentialHeightFogData Lerp_FExponentialHeightFogData(const struct FExponentialHeightFogData& A, const struct FExponentialHeightFogData& B, float T);
	static void MarkWholeRenderStateDirty(class UActorComponent* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightingScenarioHelpers">();
	}
	static class ULightingScenarioHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightingScenarioHelpers>();
	}
};
static_assert(alignof(ULightingScenarioHelpers) == 0x000008, "Wrong alignment on ULightingScenarioHelpers");
static_assert(sizeof(ULightingScenarioHelpers) == 0x000028, "Wrong size on ULightingScenarioHelpers");

// Class SandFall.SF_LoadingScreenGISubsystem
// 0x0348 (0x0378 - 0x0030)
class USF_LoadingScreenGISubsystem final : public UGameInstanceSubsystem
{
public:
	class USF_LoadingScreenWidget*                CurrentWidgetBuffer;                               // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x68];                                      // 0x0038(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class USF_BlueprintLatentAction*              LatentActionOnLevelLoadingObj;                     // 0x00A0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x2D0];                                     // 0x00A8(0x02D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsLoadingScreenSubSystemActive();
	void OnLoadingScreenFinished();
	void OpenLevelBySoftPtrWithLoadingScreen(const class UObject* WorldContextObject, const TSoftObjectPtr<class UWorld> Level, const struct FLatentActionInfo& LatentInfo, bool bAbsolute, const class FString& Options, TSubclassOf<class USF_LoadingScreenWidget> LoadingScreenOverride);
	void OpenLevelWithLoadingScreen(const class UObject* WorldContextObject, class FName LevelName, const struct FLatentActionInfo& LatentInfo, bool bAbsolute, const class FString& Options, TSubclassOf<class USF_LoadingScreenWidget> LoadingScreenOverride);
	void OverrideNextLoadingScreenData(const struct FLoadingScreenData& dataOverride);
	void StopPostLoadingScreenTransition();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SF_LoadingScreenGISubsystem">();
	}
	static class USF_LoadingScreenGISubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USF_LoadingScreenGISubsystem>();
	}
};
static_assert(alignof(USF_LoadingScreenGISubsystem) == 0x000008, "Wrong alignment on USF_LoadingScreenGISubsystem");
static_assert(sizeof(USF_LoadingScreenGISubsystem) == 0x000378, "Wrong size on USF_LoadingScreenGISubsystem");
static_assert(offsetof(USF_LoadingScreenGISubsystem, CurrentWidgetBuffer) == 0x000030, "Member 'USF_LoadingScreenGISubsystem::CurrentWidgetBuffer' has a wrong offset!");
static_assert(offsetof(USF_LoadingScreenGISubsystem, LatentActionOnLevelLoadingObj) == 0x0000A0, "Member 'USF_LoadingScreenGISubsystem::LatentActionOnLevelLoadingObj' has a wrong offset!");

// Class SandFall.SF_LoadingScreenWidget
// 0x0020 (0x0300 - 0x02E0)
class USF_LoadingScreenWidget final : public UUserWidget
{
public:
	struct FLoadingScreenData                     LSData;                                            // 0x02E0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void StartLoadingScreen(class FName LevelLoaded);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SF_LoadingScreenWidget">();
	}
	static class USF_LoadingScreenWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USF_LoadingScreenWidget>();
	}
};
static_assert(alignof(USF_LoadingScreenWidget) == 0x000008, "Wrong alignment on USF_LoadingScreenWidget");
static_assert(sizeof(USF_LoadingScreenWidget) == 0x000300, "Wrong size on USF_LoadingScreenWidget");
static_assert(offsetof(USF_LoadingScreenWidget, LSData) == 0x0002E0, "Member 'USF_LoadingScreenWidget::LSData' has a wrong offset!");

// Class SandFall.SF_LocalizationGISubsystem
// 0x0010 (0x0040 - 0x0030)
class USF_LocalizationGISubsystem final : public UGameInstanceSubsystem
{
public:
	TMulticastInlineDelegate<void()>              OnCultureChangedBPCallback;                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	bool ChangeAssetGroupCultureSettings(class FName AssetGroup, const class FString& Culture_IETF_Tag);
	bool ChangeAssetGroupCultureSettingsByIndex(class FName AssetGroup, int32 CultureIndex);
	bool ChangeGameCultureSettings(const class FString& Culture_IETF_Tag);
	bool ChangeGameCultureSettingsByIndex(int32 CultureIndex);
	int32 Get_IETF_TagIndex(const class FString& IETF_Tag);
	struct FAssetGroupCultureData GetAssetGroupCultureData(class FName AssetGroup, bool GetDisplayNameInCurrentLanguage);
	struct FProjectCultureData GetGameCultureData(bool GetDisplayNameInCurrentLanguage);

	class FName GetAudioAssetGroupName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SF_LocalizationGISubsystem">();
	}
	static class USF_LocalizationGISubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USF_LocalizationGISubsystem>();
	}
};
static_assert(alignof(USF_LocalizationGISubsystem) == 0x000008, "Wrong alignment on USF_LocalizationGISubsystem");
static_assert(sizeof(USF_LocalizationGISubsystem) == 0x000040, "Wrong size on USF_LocalizationGISubsystem");
static_assert(offsetof(USF_LocalizationGISubsystem, OnCultureChangedBPCallback) == 0x000030, "Member 'USF_LocalizationGISubsystem::OnCultureChangedBPCallback' has a wrong offset!");

// Class SandFall.SF_LocalizationSettings
// 0x0010 (0x0048 - 0x0038)
class USF_LocalizationSettings final : public UDeveloperSettings
{
public:
	TArray<struct FAssetGroupSubLocaleWrapper>    AssetsGroupsCultureWrapper;                        // 0x0038(0x0010)(Edit, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SF_LocalizationSettings">();
	}
	static class USF_LocalizationSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USF_LocalizationSettings>();
	}
};
static_assert(alignof(USF_LocalizationSettings) == 0x000008, "Wrong alignment on USF_LocalizationSettings");
static_assert(sizeof(USF_LocalizationSettings) == 0x000048, "Wrong size on USF_LocalizationSettings");
static_assert(offsetof(USF_LocalizationSettings, AssetsGroupsCultureWrapper) == 0x000038, "Member 'USF_LocalizationSettings::AssetsGroupsCultureWrapper' has a wrong offset!");

// Class SandFall.MathHelpers
// 0x0000 (0x0028 - 0x0028)
class UMathHelpers final : public UBlueprintFunctionLibrary
{
public:
	static float GetBlendAlpha(EViewTargetBlendFunction BlendFunction, float BlendExp, float Time);
	static double LimitMax_Double();
	static int32 LimitMax_Integer();
	static int64 LimitMax_Integer64();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MathHelpers">();
	}
	static class UMathHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMathHelpers>();
	}
};
static_assert(alignof(UMathHelpers) == 0x000008, "Wrong alignment on UMathHelpers");
static_assert(sizeof(UMathHelpers) == 0x000028, "Wrong size on UMathHelpers");

// Class SandFall.ModifierStack_Float
// 0x0088 (0x00B0 - 0x0028)
class UModifierStack_Float final : public UObject
{
public:
	struct FGuid                                  StackGuid;                                         // 0x0028(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModifierStackingType                         StackingType;                                      // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DebugStackName;                                    // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGuid, float>                     Values;                                            // 0x0050(0x0050)(NativeAccessSpecifierPublic)
	bool                                          AutoUpdateOnEdit;                                  // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentValue;                                      // 0x00A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddModifier(float NewValue, struct FSF_ModifierStackEntryHandle& OutModifierHandle, const class FString& DebugModifierName);
	bool RemoveModifier(struct FSF_ModifierStackEntryHandle& ModifierHandle);
	void UpdateStackValue();

	float GetCurrentValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModifierStack_Float">();
	}
	static class UModifierStack_Float* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModifierStack_Float>();
	}
};
static_assert(alignof(UModifierStack_Float) == 0x000008, "Wrong alignment on UModifierStack_Float");
static_assert(sizeof(UModifierStack_Float) == 0x0000B0, "Wrong size on UModifierStack_Float");
static_assert(offsetof(UModifierStack_Float, StackGuid) == 0x000028, "Member 'UModifierStack_Float::StackGuid' has a wrong offset!");
static_assert(offsetof(UModifierStack_Float, StackingType) == 0x000038, "Member 'UModifierStack_Float::StackingType' has a wrong offset!");
static_assert(offsetof(UModifierStack_Float, DebugStackName) == 0x000040, "Member 'UModifierStack_Float::DebugStackName' has a wrong offset!");
static_assert(offsetof(UModifierStack_Float, Values) == 0x000050, "Member 'UModifierStack_Float::Values' has a wrong offset!");
static_assert(offsetof(UModifierStack_Float, AutoUpdateOnEdit) == 0x0000A0, "Member 'UModifierStack_Float::AutoUpdateOnEdit' has a wrong offset!");
static_assert(offsetof(UModifierStack_Float, CurrentValue) == 0x0000A4, "Member 'UModifierStack_Float::CurrentValue' has a wrong offset!");

// Class SandFall.NamedID
// 0x0018 (0x0040 - 0x0028)
class UNamedID final : public UObject
{
public:
	struct FGuid                                  Guid;                                              // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name_0;                                            // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NamedID">();
	}
	static class UNamedID* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNamedID>();
	}
};
static_assert(alignof(UNamedID) == 0x000008, "Wrong alignment on UNamedID");
static_assert(sizeof(UNamedID) == 0x000040, "Wrong size on UNamedID");
static_assert(offsetof(UNamedID, Guid) == 0x000028, "Member 'UNamedID::Guid' has a wrong offset!");
static_assert(offsetof(UNamedID, Name_0) == 0x000038, "Member 'UNamedID::Name_0' has a wrong offset!");

// Class SandFall.NamedIDHelpers
// 0x0000 (0x0028 - 0x0028)
class UNamedIDHelpers final : public UBlueprintFunctionLibrary
{
public:
	static struct FTopLevelAssetPath GetNamedIDClassPathName();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NamedIDHelpers">();
	}
	static class UNamedIDHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNamedIDHelpers>();
	}
};
static_assert(alignof(UNamedIDHelpers) == 0x000008, "Wrong alignment on UNamedIDHelpers");
static_assert(sizeof(UNamedIDHelpers) == 0x000028, "Wrong size on UNamedIDHelpers");

// Class SandFall.NavigationHelpers
// 0x0000 (0x0028 - 0x0028)
class UNavigationHelpers final : public UBlueprintFunctionLibrary
{
public:
	static bool CanEverAffectNavigation(class UActorComponent* ActorComponent);
	static class ANavigationData* GetNavDataForAgentName(class UObject* WorldContextObject, class FName AgentName);
	static bool IsNavigationRelevant(class UActorComponent* ActorComponent);
	static void SetCanEverAffectNavigation(class UActorComponent* ActorComponent, bool bRelevant);
	static void SetFillCollisionUnderneathForNavmesh(class UPrimitiveComponent* PrimitiveComponent, bool bFillCollisionUnderneathForNavmesh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationHelpers">();
	}
	static class UNavigationHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationHelpers>();
	}
};
static_assert(alignof(UNavigationHelpers) == 0x000008, "Wrong alignment on UNavigationHelpers");
static_assert(sizeof(UNavigationHelpers) == 0x000028, "Wrong size on UNavigationHelpers");

// Class SandFall.ProjectConfiguration
// 0x0008 (0x0038 - 0x0030)
class UProjectConfiguration : public UPrimaryDataAsset
{
public:
	class UDataTable*                             LevelDataTable;                                    // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UDataTable* GetEditorOnlyLevelDataTable();
	class UDataTable* GetLevelDataTable();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectConfiguration">();
	}
	static class UProjectConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectConfiguration>();
	}
};
static_assert(alignof(UProjectConfiguration) == 0x000008, "Wrong alignment on UProjectConfiguration");
static_assert(sizeof(UProjectConfiguration) == 0x000038, "Wrong size on UProjectConfiguration");
static_assert(offsetof(UProjectConfiguration, LevelDataTable) == 0x000030, "Member 'UProjectConfiguration::LevelDataTable' has a wrong offset!");

// Class SandFall.QuestHelpers
// 0x0000 (0x0028 - 0x0028)
class UQuestHelpers final : public UBlueprintFunctionLibrary
{
public:
	static class FName CreateQuestIdentifier(class FName QuestName);
	static struct FQuestObjectiveIdentifier CreateQuestObjectiveIdentifier(class FName QuestName, class FName ObjectiveName);
	static bool Equal_FQuestObjectiveIdentifier(const struct FQuestObjectiveIdentifier& A, const struct FQuestObjectiveIdentifier& B);
	static class UDataTable* GetObjectiveDataTable(class FName QuestName);
	static class UDataTable* GetQuestDataTable();
	static bool IsValid_FQuestObjectiveIdentifier(const struct FQuestObjectiveIdentifier& QuestObjectiveIdentifier);
	static bool NotEqual_FQuestObjectiveIdentifier(const struct FQuestObjectiveIdentifier& A, const struct FQuestObjectiveIdentifier& B);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestHelpers">();
	}
	static class UQuestHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestHelpers>();
	}
};
static_assert(alignof(UQuestHelpers) == 0x000008, "Wrong alignment on UQuestHelpers");
static_assert(sizeof(UQuestHelpers) == 0x000028, "Wrong size on UQuestHelpers");

// Class SandFall.SF_ReadTexturePixelQuery
// 0x0018 (0x0040 - 0x0028)
class USF_ReadTexturePixelQuery final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FeedTexture(TSoftObjectPtr<class UTexture2D> TextureRef);
	int32 GetTextureHeight();
	int32 GetTextureWidth();
	bool HasValidData();
	bool TryReadPixel(int32 PositionX, int32 PositionY, uint8* PixelValue, float* PixelValueNormalized);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SF_ReadTexturePixelQuery">();
	}
	static class USF_ReadTexturePixelQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<USF_ReadTexturePixelQuery>();
	}
};
static_assert(alignof(USF_ReadTexturePixelQuery) == 0x000008, "Wrong alignment on USF_ReadTexturePixelQuery");
static_assert(sizeof(USF_ReadTexturePixelQuery) == 0x000040, "Wrong size on USF_ReadTexturePixelQuery");

// Class SandFall.SF_ReferencerCounterUtils
// 0x0000 (0x0028 - 0x0028)
class USF_ReferencerCounterUtils final : public UBlueprintFunctionLibrary
{
public:
	static bool AddReference(struct FSF_ReferenceCounter& Target, struct FSF_ReferenceCounterHandle& ReferenceHandle, const class FString& DebugName);
	static void BindEventOnChanged(struct FSF_ReferenceCounter& Target, TDelegate<void(bool _isActive)> Event);
	static bool GetReferenceCounterState(const struct FSF_ReferenceCounter& Target);
	static bool IsHandleValid(const struct FSF_ReferenceCounterHandle& ReferenceHandle);
	static class USF_ReferenceCounterWrapper* MakeReferenceCounterWrapper();
	static void RemoveAllReferences(struct FSF_ReferenceCounter& Target);
	static bool RemoveReference(struct FSF_ReferenceCounter& Target, struct FSF_ReferenceCounterHandle& ReferenceHandle);
	static void UnbindEventOnChanged(struct FSF_ReferenceCounter& Target, TDelegate<void(bool _isActive)> Event);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SF_ReferencerCounterUtils">();
	}
	static class USF_ReferencerCounterUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<USF_ReferencerCounterUtils>();
	}
};
static_assert(alignof(USF_ReferencerCounterUtils) == 0x000008, "Wrong alignment on USF_ReferencerCounterUtils");
static_assert(sizeof(USF_ReferencerCounterUtils) == 0x000028, "Wrong size on USF_ReferencerCounterUtils");

// Class SandFall.RichTextBlockCustomWidgetDecorator
// 0x0018 (0x0040 - 0x0028)
class URichTextBlockCustomWidgetDecorator : public URichTextBlockDecorator
{
public:
	TSubclassOf<class URichTextBlockCustomWidget> CustomWidgetClass;                                 // 0x0028(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Keyword;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichTextBlockCustomWidgetDecorator">();
	}
	static class URichTextBlockCustomWidgetDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<URichTextBlockCustomWidgetDecorator>();
	}
};
static_assert(alignof(URichTextBlockCustomWidgetDecorator) == 0x000008, "Wrong alignment on URichTextBlockCustomWidgetDecorator");
static_assert(sizeof(URichTextBlockCustomWidgetDecorator) == 0x000040, "Wrong size on URichTextBlockCustomWidgetDecorator");
static_assert(offsetof(URichTextBlockCustomWidgetDecorator, CustomWidgetClass) == 0x000028, "Member 'URichTextBlockCustomWidgetDecorator::CustomWidgetClass' has a wrong offset!");
static_assert(offsetof(URichTextBlockCustomWidgetDecorator, Keyword) == 0x000030, "Member 'URichTextBlockCustomWidgetDecorator::Keyword' has a wrong offset!");

// Class SandFall.RichTextBlockInputDecorator
// 0x0008 (0x0048 - 0x0040)
class URichTextBlockInputDecorator : public URichTextBlockCustomWidgetDecorator
{
public:
	class UDataTable*                             CommonInputActionDataTable;                        // 0x0040(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichTextBlockInputDecorator">();
	}
	static class URichTextBlockInputDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<URichTextBlockInputDecorator>();
	}
};
static_assert(alignof(URichTextBlockInputDecorator) == 0x000008, "Wrong alignment on URichTextBlockInputDecorator");
static_assert(sizeof(URichTextBlockInputDecorator) == 0x000048, "Wrong size on URichTextBlockInputDecorator");
static_assert(offsetof(URichTextBlockInputDecorator, CommonInputActionDataTable) == 0x000040, "Member 'URichTextBlockInputDecorator::CommonInputActionDataTable' has a wrong offset!");

// Class SandFall.SandfallGameMode
// 0x0000 (0x0328 - 0x0328)
class ASandfallGameMode : public AGameModeBase
{
public:
	void OnPreStartPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SandfallGameMode">();
	}
	static class ASandfallGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASandfallGameMode>();
	}
};
static_assert(alignof(ASandfallGameMode) == 0x000008, "Wrong alignment on ASandfallGameMode");
static_assert(sizeof(ASandfallGameMode) == 0x000328, "Wrong size on ASandfallGameMode");

// Class SandFall.SaveGameHelpers
// 0x0000 (0x0028 - 0x0028)
class USaveGameHelpers final : public UBlueprintFunctionLibrary
{
public:
	static void CopyIdenticalProperties(class UObject* FromObject, class UObject* ToObject);
	static class USaveGame* LoadGameFromPath(const class FString& SaveFilePath);
	static bool SaveGameToPath(class USaveGame* SaveGameObject, const class FString& SaveFilePath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveGameHelpers">();
	}
	static class USaveGameHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveGameHelpers>();
	}
};
static_assert(alignof(USaveGameHelpers) == 0x000008, "Wrong alignment on USaveGameHelpers");
static_assert(sizeof(USaveGameHelpers) == 0x000028, "Wrong size on USaveGameHelpers");

// Class SandFall.SF_ScreenShotRequestAsyncAction
// 0x0040 (0x0070 - 0x0030)
class USF_ScreenShotRequestAsyncAction final : public UBlueprintAsyncActionBase
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnRequestDone;                                     // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0058(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x10];                                      // 0x0060(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USF_ScreenShotRequestAsyncAction* WriteCurrentScreenToRenderTarget(class UObject* WorldContextObject, class UTextureRenderTarget2D* RenderTarget_0, float FallBackTime, bool bShowUI);

	void OnScreenShotDone(int32 Width, int32 Height, const TArray<struct FColor>& Colors);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SF_ScreenShotRequestAsyncAction">();
	}
	static class USF_ScreenShotRequestAsyncAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USF_ScreenShotRequestAsyncAction>();
	}
};
static_assert(alignof(USF_ScreenShotRequestAsyncAction) == 0x000008, "Wrong alignment on USF_ScreenShotRequestAsyncAction");
static_assert(sizeof(USF_ScreenShotRequestAsyncAction) == 0x000070, "Wrong size on USF_ScreenShotRequestAsyncAction");
static_assert(offsetof(USF_ScreenShotRequestAsyncAction, OnRequestDone) == 0x000038, "Member 'USF_ScreenShotRequestAsyncAction::OnRequestDone' has a wrong offset!");
static_assert(offsetof(USF_ScreenShotRequestAsyncAction, RenderTarget) == 0x000058, "Member 'USF_ScreenShotRequestAsyncAction::RenderTarget' has a wrong offset!");

// Class SandFall.SharedGameUserSettings
// 0x00B0 (0x00D8 - 0x0028)
class USharedGameUserSettings final : public USaveGame
{
public:
	struct FSF_SettingsData                       GameSettingsData;                                  // 0x0028(0x0054)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSF_EngineSettingsData                 EngineSettingsData;                                // 0x0080(0x0058)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SharedGameUserSettings">();
	}
	static class USharedGameUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USharedGameUserSettings>();
	}
};
static_assert(alignof(USharedGameUserSettings) == 0x000008, "Wrong alignment on USharedGameUserSettings");
static_assert(sizeof(USharedGameUserSettings) == 0x0000D8, "Wrong size on USharedGameUserSettings");
static_assert(offsetof(USharedGameUserSettings, GameSettingsData) == 0x000028, "Member 'USharedGameUserSettings::GameSettingsData' has a wrong offset!");
static_assert(offsetof(USharedGameUserSettings, EngineSettingsData) == 0x000080, "Member 'USharedGameUserSettings::EngineSettingsData' has a wrong offset!");

// Class SandFall.SmartSpringArmComponent
// 0x0030 (0x0360 - 0x0330)
class USmartSpringArmComponent final : public USpringArmComponent
{
public:
	bool                                          bDoSmartLineTrace;                                 // 0x0330(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_331[0x3];                                      // 0x0331(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SmartProbeSize;                                    // 0x0334(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0338(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UPrimitiveComponent*>            PrimitiveComponentsToIgnore;                       // 0x0348(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmartSpringArmComponent">();
	}
	static class USmartSpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USmartSpringArmComponent>();
	}
};
static_assert(alignof(USmartSpringArmComponent) == 0x000010, "Wrong alignment on USmartSpringArmComponent");
static_assert(sizeof(USmartSpringArmComponent) == 0x000360, "Wrong size on USmartSpringArmComponent");
static_assert(offsetof(USmartSpringArmComponent, bDoSmartLineTrace) == 0x000330, "Member 'USmartSpringArmComponent::bDoSmartLineTrace' has a wrong offset!");
static_assert(offsetof(USmartSpringArmComponent, SmartProbeSize) == 0x000334, "Member 'USmartSpringArmComponent::SmartProbeSize' has a wrong offset!");
static_assert(offsetof(USmartSpringArmComponent, ActorsToIgnore) == 0x000338, "Member 'USmartSpringArmComponent::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(USmartSpringArmComponent, PrimitiveComponentsToIgnore) == 0x000348, "Member 'USmartSpringArmComponent::PrimitiveComponentsToIgnore' has a wrong offset!");

// Class SandFall.SF_StateTreeRunner
// 0x0040 (0x0068 - 0x0028)
class USF_StateTreeRunner final : public UExtendedObject
{
public:
	struct FStateTreeReference                    StateTreeRef;                                      // 0x0028(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FStateTreeInstanceData                 InstanceData;                                      // 0x0050(0x0010)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SendStateTreeEvent(const struct FStateTreeEvent& Event);
	void StartLogic();
	void StopLogic();
	void Tick(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SF_StateTreeRunner">();
	}
	static class USF_StateTreeRunner* GetDefaultObj()
	{
		return GetDefaultObjImpl<USF_StateTreeRunner>();
	}
};
static_assert(alignof(USF_StateTreeRunner) == 0x000008, "Wrong alignment on USF_StateTreeRunner");
static_assert(sizeof(USF_StateTreeRunner) == 0x000068, "Wrong size on USF_StateTreeRunner");
static_assert(offsetof(USF_StateTreeRunner, StateTreeRef) == 0x000028, "Member 'USF_StateTreeRunner::StateTreeRef' has a wrong offset!");
static_assert(offsetof(USF_StateTreeRunner, InstanceData) == 0x000050, "Member 'USF_StateTreeRunner::InstanceData' has a wrong offset!");

// Class SandFall.StateTreeGameInstanceSchema
// 0x0020 (0x0048 - 0x0028)
class UStateTreeGameInstanceSchema final : public UStateTreeSchema
{
public:
	TSubclassOf<class UGameInstance>              ContextGameInstanceClass;                          // 0x0028(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FStateTreeExternalDataDesc             ContextGameInstanceDataDesc;                       // 0x0030(0x0018)(NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateTreeGameInstanceSchema">();
	}
	static class UStateTreeGameInstanceSchema* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateTreeGameInstanceSchema>();
	}
};
static_assert(alignof(UStateTreeGameInstanceSchema) == 0x000008, "Wrong alignment on UStateTreeGameInstanceSchema");
static_assert(sizeof(UStateTreeGameInstanceSchema) == 0x000048, "Wrong size on UStateTreeGameInstanceSchema");
static_assert(offsetof(UStateTreeGameInstanceSchema, ContextGameInstanceClass) == 0x000028, "Member 'UStateTreeGameInstanceSchema::ContextGameInstanceClass' has a wrong offset!");
static_assert(offsetof(UStateTreeGameInstanceSchema, ContextGameInstanceDataDesc) == 0x000030, "Member 'UStateTreeGameInstanceSchema::ContextGameInstanceDataDesc' has a wrong offset!");

// Class SandFall.SF_SubtitlesLineWidget
// 0x0038 (0x0318 - 0x02E0)
class USF_SubtitlesLineWidget : public UUserWidget
{
public:
	class URichTextBlock*                         MainSubtitleText;                                  // 0x02E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SpeakerSubtitleText;                               // 0x02E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 SubtitlesSizeConfig;                               // 0x02F0(0x0010)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bSeparateSpeakerNameWithColon;                     // 0x0300(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_301[0x7];                                      // 0x0301(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   SpeakerFormatWithColon;                            // 0x0308(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SF_SubtitlesLineWidget">();
	}
	static class USF_SubtitlesLineWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USF_SubtitlesLineWidget>();
	}
};
static_assert(alignof(USF_SubtitlesLineWidget) == 0x000008, "Wrong alignment on USF_SubtitlesLineWidget");
static_assert(sizeof(USF_SubtitlesLineWidget) == 0x000318, "Wrong size on USF_SubtitlesLineWidget");
static_assert(offsetof(USF_SubtitlesLineWidget, MainSubtitleText) == 0x0002E0, "Member 'USF_SubtitlesLineWidget::MainSubtitleText' has a wrong offset!");
static_assert(offsetof(USF_SubtitlesLineWidget, SpeakerSubtitleText) == 0x0002E8, "Member 'USF_SubtitlesLineWidget::SpeakerSubtitleText' has a wrong offset!");
static_assert(offsetof(USF_SubtitlesLineWidget, SubtitlesSizeConfig) == 0x0002F0, "Member 'USF_SubtitlesLineWidget::SubtitlesSizeConfig' has a wrong offset!");
static_assert(offsetof(USF_SubtitlesLineWidget, bSeparateSpeakerNameWithColon) == 0x000300, "Member 'USF_SubtitlesLineWidget::bSeparateSpeakerNameWithColon' has a wrong offset!");
static_assert(offsetof(USF_SubtitlesLineWidget, SpeakerFormatWithColon) == 0x000308, "Member 'USF_SubtitlesLineWidget::SpeakerFormatWithColon' has a wrong offset!");

// Class SandFall.SF_SubtitlesWidget
// 0x0098 (0x0378 - 0x02E0)
class USF_SubtitlesWidget : public UUserWidget
{
public:
	TMap<EDialogueTextSceneType, TSubclassOf<class USF_SubtitlesLineWidget>> LinesVisualsAssets;     // 0x02E0(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class FText                                   Colon_ST_Entry;                                    // 0x0330(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            DefaultColorProfile;                               // 0x0340(0x0014)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bOneSubtitleDisplayedAtAllTime;                    // 0x0354(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_355[0xB];                                      // 0x0355(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSubLineProfile>                CurrentShownSubLines;                              // 0x0360(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UVerticalBox*                           SubLinesContainer;                                 // 0x0370(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnSubtitleWidgetCreated_BP(class UVerticalBoxSlot* NewSubWidget);
	void UpdateFromGameUserSettings(const class UConfigurableGameUserSettings* Settings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SF_SubtitlesWidget">();
	}
	static class USF_SubtitlesWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USF_SubtitlesWidget>();
	}
};
static_assert(alignof(USF_SubtitlesWidget) == 0x000008, "Wrong alignment on USF_SubtitlesWidget");
static_assert(sizeof(USF_SubtitlesWidget) == 0x000378, "Wrong size on USF_SubtitlesWidget");
static_assert(offsetof(USF_SubtitlesWidget, LinesVisualsAssets) == 0x0002E0, "Member 'USF_SubtitlesWidget::LinesVisualsAssets' has a wrong offset!");
static_assert(offsetof(USF_SubtitlesWidget, Colon_ST_Entry) == 0x000330, "Member 'USF_SubtitlesWidget::Colon_ST_Entry' has a wrong offset!");
static_assert(offsetof(USF_SubtitlesWidget, DefaultColorProfile) == 0x000340, "Member 'USF_SubtitlesWidget::DefaultColorProfile' has a wrong offset!");
static_assert(offsetof(USF_SubtitlesWidget, bOneSubtitleDisplayedAtAllTime) == 0x000354, "Member 'USF_SubtitlesWidget::bOneSubtitleDisplayedAtAllTime' has a wrong offset!");
static_assert(offsetof(USF_SubtitlesWidget, CurrentShownSubLines) == 0x000360, "Member 'USF_SubtitlesWidget::CurrentShownSubLines' has a wrong offset!");
static_assert(offsetof(USF_SubtitlesWidget, SubLinesContainer) == 0x000370, "Member 'USF_SubtitlesWidget::SubLinesContainer' has a wrong offset!");

// Class SandFall.SF_SubtitlesWorldSubsystem
// 0x0090 (0x00D0 - 0x0040)
class USF_SubtitlesWorldSubsystem final : public UTickableWorldSubsystem
{
public:
	uint8                                         Pad_40[0x80];                                      // 0x0040(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class USF_SubtitlesWidget*                    CurrentSubtitlesWidget;                            // 0x00C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USF_DialogueSubtitleSpeakersData*       SpeakersData;                                      // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ClearSubtitles();
	void DisableForcedSubtitle();
	void EnableForcedSubtitle();
	void UpdateFromGameUserSettings(const class UConfigurableGameUserSettings* Settings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SF_SubtitlesWorldSubsystem">();
	}
	static class USF_SubtitlesWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USF_SubtitlesWorldSubsystem>();
	}
};
static_assert(alignof(USF_SubtitlesWorldSubsystem) == 0x000008, "Wrong alignment on USF_SubtitlesWorldSubsystem");
static_assert(sizeof(USF_SubtitlesWorldSubsystem) == 0x0000D0, "Wrong size on USF_SubtitlesWorldSubsystem");
static_assert(offsetof(USF_SubtitlesWorldSubsystem, CurrentSubtitlesWidget) == 0x0000C0, "Member 'USF_SubtitlesWorldSubsystem::CurrentSubtitlesWidget' has a wrong offset!");
static_assert(offsetof(USF_SubtitlesWorldSubsystem, SpeakersData) == 0x0000C8, "Member 'USF_SubtitlesWorldSubsystem::SpeakersData' has a wrong offset!");

// Class SandFall.CharacterStats
// 0x0020 (0x0048 - 0x0028)
class UCharacterStats final : public UObject
{
public:
	class FName                                   CharacterId;                                       // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FStatsArray>                    Stats;                                             // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         StatSteps;                                         // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetStat(int32 StatId);
	void InitStat();
	void SetStat(int32 StatId, int32 StatValue);
	void TickStats();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterStats">();
	}
	static class UCharacterStats* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterStats>();
	}
};
static_assert(alignof(UCharacterStats) == 0x000008, "Wrong alignment on UCharacterStats");
static_assert(sizeof(UCharacterStats) == 0x000048, "Wrong size on UCharacterStats");
static_assert(offsetof(UCharacterStats, CharacterId) == 0x000028, "Member 'UCharacterStats::CharacterId' has a wrong offset!");
static_assert(offsetof(UCharacterStats, Stats) == 0x000030, "Member 'UCharacterStats::Stats' has a wrong offset!");
static_assert(offsetof(UCharacterStats, StatSteps) == 0x000040, "Member 'UCharacterStats::StatSteps' has a wrong offset!");

// Class SandFall.SandfallCharacterStatsHelpers
// 0x0000 (0x0028 - 0x0028)
class USandfallCharacterStatsHelpers final : public UBlueprintFunctionLibrary
{
public:
	static TMap<int32, int32> GetBaseStatValues();
	static void RegisterStats(class FName CharacterId, TDelegate<void(int32 StatId, int32 StatValue)> StatCallback);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SandfallCharacterStatsHelpers">();
	}
	static class USandfallCharacterStatsHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<USandfallCharacterStatsHelpers>();
	}
};
static_assert(alignof(USandfallCharacterStatsHelpers) == 0x000008, "Wrong alignment on USandfallCharacterStatsHelpers");
static_assert(sizeof(USandfallCharacterStatsHelpers) == 0x000028, "Wrong size on USandfallCharacterStatsHelpers");

// Class SandFall.ExtendedActorComponent
// 0x0000 (0x00A0 - 0x00A0)
class UExtendedActorComponent : public UActorComponent
{
public:
	void OnInitializeComponent();
	void OnPreSave();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExtendedActorComponent">();
	}
	static class UExtendedActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExtendedActorComponent>();
	}
};
static_assert(alignof(UExtendedActorComponent) == 0x000008, "Wrong alignment on UExtendedActorComponent");
static_assert(sizeof(UExtendedActorComponent) == 0x0000A0, "Wrong size on UExtendedActorComponent");

// Class SandFall.UMGBlueprintHelpers
// 0x0000 (0x0028 - 0x0028)
class UUMGBlueprintHelpers final : public UBlueprintFunctionLibrary
{
public:
	static float GetMaxCharacterHeightFromStyle(const struct FTextBlockStyle& Style);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGBlueprintHelpers">();
	}
	static class UUMGBlueprintHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGBlueprintHelpers>();
	}
};
static_assert(alignof(UUMGBlueprintHelpers) == 0x000008, "Wrong alignment on UUMGBlueprintHelpers");
static_assert(sizeof(UUMGBlueprintHelpers) == 0x000028, "Wrong size on UUMGBlueprintHelpers");

// Class SandFall.SF_ExtendedUserWidget
// 0x0000 (0x02E0 - 0x02E0)
class USF_ExtendedUserWidget : public UUserWidget
{
public:
	void OnSynchronizeProperties();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SF_ExtendedUserWidget">();
	}
	static class USF_ExtendedUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USF_ExtendedUserWidget>();
	}
};
static_assert(alignof(USF_ExtendedUserWidget) == 0x000008, "Wrong alignment on USF_ExtendedUserWidget");
static_assert(sizeof(USF_ExtendedUserWidget) == 0x0002E0, "Wrong size on USF_ExtendedUserWidget");

// Class SandFall.SF_WaitForPSOCachingAsyncAction
// 0x0030 (0x0060 - 0x0030)
class USF_WaitForPSOCachingAsyncAction final : public UBlueprintAsyncActionBase
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnCachingDone;                                     // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCachingTakingMoreTime;                           // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USF_WaitForPSOCachingAsyncAction* WaitForPSOCaching(class UObject* WorldContextObject, float MinWaitingTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SF_WaitForPSOCachingAsyncAction">();
	}
	static class USF_WaitForPSOCachingAsyncAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USF_WaitForPSOCachingAsyncAction>();
	}
};
static_assert(alignof(USF_WaitForPSOCachingAsyncAction) == 0x000008, "Wrong alignment on USF_WaitForPSOCachingAsyncAction");
static_assert(sizeof(USF_WaitForPSOCachingAsyncAction) == 0x000060, "Wrong size on USF_WaitForPSOCachingAsyncAction");
static_assert(offsetof(USF_WaitForPSOCachingAsyncAction, OnCachingDone) == 0x000038, "Member 'USF_WaitForPSOCachingAsyncAction::OnCachingDone' has a wrong offset!");
static_assert(offsetof(USF_WaitForPSOCachingAsyncAction, OnCachingTakingMoreTime) == 0x000048, "Member 'USF_WaitForPSOCachingAsyncAction::OnCachingTakingMoreTime' has a wrong offset!");

}

