#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: AC_jRPG_BattleManager

#include "Basic.hpp"

#include "FTeamMotivationData_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "EFreeAimType_structs.hpp"
#include "ECharacterTeamSelector_structs.hpp"
#include "SandFall_structs.hpp"
#include "FBattleStartParams_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "E_jRPG_EngageTypes_structs.hpp"
#include "E_jRPG_ActionType_structs.hpp"
#include "FGlobalFeedback_structs.hpp"
#include "FSoundEvent_structs.hpp"
#include "EBattleEndResult_structs.hpp"
#include "FBattleCharacterStoredState_structs.hpp"
#include "EDamageReason_structs.hpp"
#include "S_BattleRewards_structs.hpp"
#include "E_GameDifficulty_structs.hpp"
#include "S_jRPG_PartySlot_structs.hpp"
#include "E_jRPG_ItemType_structs.hpp"
#include "E_jRPG_FormationType_structs.hpp"
#include "E_FreezeFrame_structs.hpp"
#include "E_jRPG_StatType_structs.hpp"
#include "EBattleTurnState_structs.hpp"
#include "ETeamMotivationLevelType_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass AC_jRPG_BattleManager.AC_jRPG_BattleManager_C
// 0x0950 (0x09F0 - 0x00A0)
class UAC_jRPG_BattleManager_C final : public UActorComponent
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x00A0(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	bool                                          IsBattleInitialized;                               // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          ResumeBattleRequested;                             // 0x00A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ABP_jRPG_Character_Battle_Base_C*       CurrentCharacter;                                  // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	TArray<class ABP_jRPG_Character_Battle_Base_C*> PlayerCharacters;                                // 0x00B8(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance)
	TArray<class ABP_jRPG_Character_Battle_Base_C*> Enemies;                                         // 0x00C8(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance)
	double                                        InitiativeNeededToTakeTurn;                        // 0x00D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UWBP_HUD_GM_EndBattle_Panel_C*          BattleEndScreenReference;                          // 0x00E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	class UBP_jRPG_GI_Custom_C*                   GameInstanceReference;                             // 0x00E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	TArray<class UWBP_jRPG_BattleEndCharacterSlot_C*> BattleEndCharacterSlotsReference;              // 0x00F0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	TMap<int32, class ABP_jRPG_Character_Battle_Base_C*> EnemiesBySpotIndex;                         // 0x0100(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	TArray<class ABP_jRPG_Character_Battle_Base_C*> DeadPlayerCharacters;                            // 0x0150(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance)
	TArray<class ABP_jRPG_Character_Battle_Base_C*> DeadEnemies;                                     // 0x0160(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance)
	E_jRPG_ActionType                             SelectedAction;                                    // 0x0170(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_171[0x3];                                      // 0x0171(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SelectedSecondaryAction;                           // 0x0174(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_17C[0x4];                                      // 0x017C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABP_jRPG_Character_Battle_Base_C*> NextCharacterTurns;                              // 0x0180(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance)
	class FName                                   EncounterName;                                     // 0x0190(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<TScriptInterface<class IBPI_BattleListener_C>> BattleListeners;                           // 0x0198(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	class USoundBase*                             VictorySong;                                       // 0x01A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	double                                        TeamMotivationValue;                               // 0x01B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FFTeamMotivationData                   TeamMotivationData;                                // 0x01B8(0x0014)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1CC[0x4];                                      // 0x01CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  OldControlledPawn;                                 // 0x01D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	bool                                          OnlySpawnHeroesAtNextBattleStart;                  // 0x01D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          OnlySpawnEnemiesAtNextBattleStart;                 // 0x01D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1DA[0x6];                                      // 0x01DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool Victory)>  OnBattleFinished;                                  // 0x01E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          HasSpawnedHeroes;                                  // 0x01F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          HasSpawnedEnemies;                                 // 0x01F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1F2[0x6];                                      // 0x01F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABP_jRPG_Character_Battle_Base_C*> DefendingHeroes;                                 // 0x01F8(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance)
	TArray<class ABP_jRPG_Character_Battle_Base_C*> PreviousDefendingHeroes;                         // 0x0208(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance)
	class UBP_BattleFeedbackState_C*              SuccessfulDodgeFeedback;                           // 0x0218(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	class UBP_BattleFeedbackState_C*              SuccessfulParryFeedback;                           // 0x0220(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	class UBP_BattleFeedbackState_C*              SuccessfulDefendFeedback;                          // 0x0228(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	struct FFGlobalFeedback                       DefendSuccessFeedback;                             // 0x0230(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
	struct FFGlobalFeedback                       DodgeSuccessFeedback;                              // 0x0248(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
	struct FFGlobalFeedback                       ParrySuccessFeedback;                              // 0x0260(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
	int32                                         DEBUG_ComboAutoSuccessCount;                       // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFGlobalFeedback                       SkillComboQTE_SuccessFeedback;                     // 0x0280(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
	struct FFGlobalFeedback                       SkillComboQTE_FailFeedback;                        // 0x0298(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
	bool                                          FEATURE_UseNewBattleUI;                            // 0x02B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          DEBUG_OverlayInfo;                                 // 0x02B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2B2[0x6];                                      // 0x02B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UWBP_HUD_BattleScreen_C*                BattleScreenWidget;                                // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	bool                                          WantedDefense;                                     // 0x02C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          HasActiveCounterAttack;                            // 0x02C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          HasActiveTurnEndEvent;                             // 0x02C2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2C3[0x5];                                      // 0x02C3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class ABP_jRPG_Character_Battle_Base_C*       CurrentHoveredCharacter;                           // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
	bool                                          FEATURE_UseBattleChecks;                           // 0x02D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2D1[0x7];                                      // 0x02D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABP_BattleMap_C*                        BattleMapBP;                                       // 0x02D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	struct FFGlobalFeedback                       APRecoverFeedback;                                 // 0x02E0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
	struct FFGlobalFeedback                       APConsumedFeedback;                                // 0x02F8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
	bool                                          Play_Battle_Camera_Intro_;                         // 0x0310(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CanAddTurnEndEvent;                                // 0x0311(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_312[0x6];                                      // 0x0312(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UBP_DependencyRefCounter_C*             TurnStartNotifyDependencies;                       // 0x0318(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
	int32                                         TurnStartNextPhase;                                // 0x0320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TScriptInterface<class IBPI_BattleListener_C>> TurnStartBattleListenersToProcess;         // 0x0328(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	TMulticastInlineDelegate<void(class ABP_jRPG_Character_Battle_Base_C* Character)> OnTurnStart;   // 0x0338(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	struct FSoundEventDataTableRowHandle          SoundEvent_TargetChange_Enemy;                     // 0x0348(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor)
	struct FSoundEventDataTableRowHandle          SoundEvent_TargetChange_Ally;                      // 0x0358(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor)
	struct FSoundEventDataTableRowHandle          SoundEvent_Skill_TargetEnemy_Start;                // 0x0368(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor)
	struct FSoundEventDataTableRowHandle          SoundEvent_Skill_TargetAlly_Start;                 // 0x0378(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor)
	struct FSoundEventDataTableRowHandle          SoundEvent_Item_TargetAlly_Start;                  // 0x0388(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor)
	struct FSoundEventDataTableRowHandle          SoundEvent_Item_TargetEnemy_Start;                 // 0x0398(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor)
	struct FSoundEventDataTableRowHandle          SoundEvent_TurnStart_Ally;                         // 0x03A8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, Deprecated, NoDestructor)
	struct FSoundEventDataTableRowHandle          SoundEvent_TurnStart_Enemy;                        // 0x03B8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, Deprecated, NoDestructor)
	struct FSoundEventDataTableRowHandle          SoundEvent_BattleStart;                            // 0x03C8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, Deprecated, NoDestructor)
	int32                                         TurnCount;                                         // 0x03D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnBattleReadyToStart;                              // 0x03E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	class ABP_jRPG_Character_Battle_Base_C*       CurrentHoveredCharacterFreeAim;                    // 0x03F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
	struct FVector                                LastMouseHitLocation;                              // 0x03F8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TMulticastInlineDelegate<void()>              OnBattleFlee;                                      // 0x0410(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          BlockAllDefensiveMoves;                            // 0x0420(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          DisableCriticalHit;                                // 0x0421(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_422[0x6];                                      // 0x0422(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UAC_jRPG_CharacterBattleStats_C* CharStats)> OnEnemyKilledEvent; // 0x0428(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	TMulticastInlineDelegate<void(class ABP_jRPG_Character_Battle_Base_C* CharacterResurected)> OnResurected; // 0x0438(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          UseDiegeticQTE;                                    // 0x0448(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_449[0x7];                                      // 0x0449(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ABP_jRPG_Character_Battle_Base_C* Character, class ABP_jRPG_Character_Battle_Base_C* Enemy)> OnParrySuccessful; // 0x0450(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	TMulticastInlineDelegate<void(class ABP_jRPG_Character_Battle_Base_C* Character, class ABP_jRPG_Character_Battle_Base_C* Enemy)> OnDodgeSuccessful; // 0x0460(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	TMulticastInlineDelegate<void(class ABP_jRPG_Character_Battle_Base_C* Character, class ABP_jRPG_Character_Battle_Base_C* Enemy)> OnDefendSuccessful; // 0x0470(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	struct FSoundEventDataTableRowHandle          SoundEvent_DodgeTriggered;                         // 0x0480(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor)
	struct FSoundEventDataTableRowHandle          SoundEvent_ParryTriggered;                         // 0x0490(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor)
	TArray<class UBP_PDT_GameAction_C*>           GameActionsAfterBattle;                            // 0x04A0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	TArray<class ABP_jRPG_Character_Battle_Base_C*> AllPlayerCharactersBySpotIndex;                  // 0x04B0(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance)
	bool                                          CurrentTurn_CanChooseAction;                       // 0x04C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_4C1[0x7];                                      // 0x04C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFBattleStartParams                    CurrentBattleStartParams;                          // 0x04C8(0x0158)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference, HasGetValueTypeHash)
	bool                                          WasLastBattleLost;                                 // 0x0620(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_621[0x7];                                      // 0x0621(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFSoundEvent                           SD_BattleStarts;                                   // 0x0628(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
	struct FFSoundEvent                           SD_FirstStrike;                                    // 0x0630(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
	TArray<class ABP_jRPG_Character_Battle_Base_C*> AllEnemyCharactersBySpotIndex;                   // 0x0638(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance)
	struct FFSoundEvent                           SD_GameOverMusic;                                  // 0x0648(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
	struct FSoundEventDataTableRowHandle          SoundEvent_GradientCounterTriggered;               // 0x0650(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor)
	bool                                          WasCurrentSkillInterrupted;                        // 0x0660(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_661[0x7];                                      // 0x0661(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABP_jRPG_Character_Battle_Base_C*> WaitingForCharactersToDashBack;                  // 0x0668(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance)
	TMap<struct FGuid, struct FFBattleCharacterStoredState> KickedCharacters;                        // 0x0678(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	struct FSF_ReferenceCounter                   BattleEndBlockerRefCount;                          // 0x06C8(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance)
	TMulticastInlineDelegate<void(class ABP_jRPG_Character_Battle_Base_C* Character)> OnCharacterKilled; // 0x06E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	class ABP_jRPG_Character_Battle_Base_C*       DEBUG_RandomHeroAcquireOverride;                   // 0x06F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	class UBP_DependencyRefCounter_C*             BattleStartNotifyDependencies;                     // 0x0700(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	TArray<class ABP_jRPG_Character_Battle_Base_C*> BattleStartEvents_CharactersToProcess;           // 0x0708(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance)
	struct FSF_ReferenceCounterHandle             DataLayerRequestReference;                         // 0x0718(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance)
	class UBP_LastStandSystem_C*                  LastStandSystem;                                   // 0x0738(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	TArray<class UAC_jRPG_CharacterBattleStats_C*> CurrentCharacterStack;                            // 0x0740(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, Deprecated, ContainsInstancedReference)
	class ABP_jRPG_Character_Battle_Base_C*       CurrentTurnCharacter;                              // 0x0750(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	TMap<int32, class FName>                      CurrentBattleEnemies;                              // 0x0758(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          FleeImpossible;                                    // 0x07A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          HasBattleStartedEndFlow;                           // 0x07A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_7AA[0x2];                                      // 0x07AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentBattleEncounterLevel;                       // 0x07AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FS_BattleRewards                       LastReceivedBattleRewards;                         // 0x07B0(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, Deprecated, ContainsInstancedReference, HasGetValueTypeHash)
	class UBP_BattleSummaryStatsManager_C*        BattleSummaryStatsManager;                         // 0x07C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	TArray<class UAC_jRPG_CharacterBattleStats_C*> PendingResurrects;                                // 0x07D0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	bool                                          IsProcessingKilledCharacter;                       // 0x07E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          HasSentReserveTeam;                                // 0x07E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsWaitingForTurnEndBeforeGameOver;                 // 0x07E2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_7E3[0x5];                                      // 0x07E3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UBP_GradientGaugeSystem_C*              GradientGaugeSystem;                               // 0x07E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	TMap<class FName, int32>                      CurrentBattleExtraLoot;                            // 0x07F0(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	class UBP_AudioControlSystem_Battle_C*        BattleAudioControlSystem;                          // 0x0840(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	TMulticastInlineDelegate<void(class UBP_BattleDamages_C* BattleDamage)> OnCharacterReceivedDamage; // 0x0848(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	class UBP_BattleBuffComponent_C*              BattleModifiersBuffComponent;                      // 0x0858(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	TArray<struct FS_jRPG_PartySlot>              BattleParty;                                       // 0x0860(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	class UWBP_jRPG_GameOverScreen_C*             GameOverScreenWidget;                              // 0x0870(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	class UWBP_BattleTransition_C*                BattleTransitionWidget;                            // 0x0878(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	TMulticastInlineDelegate<void()>              OnStartedTargeting;                                // 0x0880(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	class ABP_LGUI_UIContainer_BattleWheelRoot_C* LGUI_Actor_BattleWheels;                           // 0x0890(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	EDamageReason                                 LastFatalDamageReceivedReason;                     // 0x0898(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_899[0x7];                                      // 0x0899(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EDamageReason, struct FDataTableRowHandle> CameraFinisherMap;                               // 0x08A0(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	TMulticastInlineDelegate<void(class UAC_jRPG_CharacterBattleStats_C* StunnedCharacterStat, class UAC_jRPG_CharacterBattleStats_C* SourceCharacterStat)> OnCharacterBreakStunned; // 0x08F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	struct FSF_ModifierStackWrapper               GlobalDodgeWindowModifierStack;                    // 0x0900(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, ContainsInstancedReference)
	struct FSF_ModifierStackWrapper               GlobalParryWindowModifierStack;                    // 0x0908(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, ContainsInstancedReference)
	EBattleEndResult                              BattleEndState;                                    // 0x0910(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          Deactivate_Battle_EndCameraMovement;               // 0x0911(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_912[0x6];                                      // 0x0912(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UAC_jRPG_CharacterBattleStats_C* CharacterStats)> OnEnemySpawned; // 0x0918(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	class ABP_jRPG_Character_Battle_Base_C*       DummyMiddleCharacter;                              // 0x0928(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	TArray<class ABP_jRPG_Character_Battle_Base_C*> AliveCharactersAtTurnStart;                      // 0x0930(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance)
	struct FDataTableRowHandle                    SoundEventSlowMo;                                  // 0x0940(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor)
	TArray<class UAC_jRPG_CharacterBattleStats_C*> CurrentlyCounteringCharacters;                    // 0x0950(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	class ABP_jRPG_Character_Battle_Base_C*       CurrentCounteredCharacter;                         // 0x0960(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	TMulticastInlineDelegate<void(class UBP_BattleHeal_C* HealObject)> OnCharacterHealSuccessful;    // 0x0968(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	TMulticastInlineDelegate<void(class UAC_jRPG_CharacterBattleStats_C* TargetCharacter, int32 NewPoints, int32 PreviousPoints)> OnShieldPointsIncreased; // 0x0978(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	TMulticastInlineDelegate<void(class UBP_BattleEvent_APChange_C* APChange)> OnAPChanged;          // 0x0988(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	E_GameDifficulty                              BattleDifficulty;                                  // 0x0998(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_999[0x7];                                      // 0x0999(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        NewVar;                                            // 0x09A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<class UAC_jRPG_CharacterBattleStats_C*> ForcedNextCharactersQueue;                        // 0x09A8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	class USoundBase*                             LoadedBattleMusic;                                 // 0x09B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	bool                                          DisableReactionBattleLines;                        // 0x09C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bIsSkipImpossible;                                 // 0x09C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_9C2[0x6];                                      // 0x09C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool IsSkipImpossible)> OnSkipImpossibleChanged;                   // 0x09C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	class FString                                 DebugLastFlowState;                                // 0x09D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash)
	bool                                          bIsNarrativeBattle;                                // 0x09E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

public:
	void ActivateCharacterCamera();
	void AdaptSpawnedCharacterLocation(const struct FVector& BaseLocation, const TArray<class AActor*>& ActorsToIgnore, struct FVector* GroundLocation);
	void AddBattleModifierBuff(class UBP_BattleBuffInstance_C* BuffInstance, bool ForcePermanent);
	void AddDefenseSuccessFeedback();
	void AddDodgeSuccessFeedback();
	void AddExtraLootItem(const class FName ItemId, const int32 Quantity, const class FString& Reason);
	void AddGlobalDodgeWindowModifier(float Multiplier, struct FSF_ModifierStackEntryHandle& OutModifierHandle, const class FString& DebugName);
	void AddGlobalParryWindowModifier(float Multiplier, struct FSF_ModifierStackEntryHandle& OutModifierHandle, const class FString& DebugName);
	void AddInitativeToAllCharacters();
	void AddParrySuccessFeedback();
	void AreAllKickedCharacterStateHandleValid(TArray<struct FGuid>& KickedCharacterHandle, bool* Success);
	void BattleStart_ProcessNextCharacter_SkillSetup();
	void BeginAOECounterAttack();
	void CancelFreeAimFromUI();
	void CanCharactersCounterAttackEnemySkill(class ABP_jRPG_Character_Battle_Base_C* EnemyCharacter, TArray<class ABP_jRPG_Character_Battle_Base_C*>& TargetedCharacters, bool* CanCounter);
	void CanFleeCurrentFight(bool* FleeImpossible_0);
	bool CanPlayReactionBattleLines();
	bool CanResumeBattle();
	bool CanSendReserveTeam();
	void ChangeBattleMap(TSoftObjectPtr<class ABP_BattleMap_C> BattleMapActor);
	void ChangeTeamMotivation(double Delta, const class FText& ReasonText);
	void CheckBattleEnd(bool* BattleHasEnded);
	void CheckForGameOver();
	void ClearBattleMap();
	TArray<class UAC_jRPG_CharacterBattleStats_C*> ComputeCharactersForAOECounterAttack();
	void ComputeExtraLootItems();
	void ComputeFreeAim3rdPersonTargetLocation(bool DEBUG_ForShoot, bool* HasHitCharacter, class ABP_jRPG_Character_Battle_Base_C** CharacterBattle, struct FVector* HitLocation, struct FVector* StartLocation);
	void CreateBattleEndVictoryScreen(TArray<class UBP_CharacterData_C*>& AllCharacterData);
	void CreateBattleInterface();
	void DeactivateAllBattleCBM();
	void DEBUG_CVarChange_BattleLine_SkipRoll(bool NewValue);
	bool DEBUG_FindPlayerCharacterByName(const class FString& Name_0, class UAC_jRPG_CharacterBattleStats_C** AC_jRPG_CharacterStats);
	void DEBUG_GetBattleBuffClassByName(const class FString& _className, TSubclassOf<class UBP_BattleBuffInstance_C>* BattleBuffInstanceClass);
	void Debug_PrintCharacterTurns(class FText* debugStr);
	void Debug_PrintToCategory();
	void Disable_Targeting_and_Input();
	void DisableFreeAimControls();
	void DispatchEnemiesAlongSpline();
	void EnableFreeAimControls(EFreeAimType FreeAimType);
	void End_Character_Turn(double UsedInitiative);
	void EndAOECounterAttack();
	void EventBattleStart();
	void ExecuteUbergraph_AC_jRPG_BattleManager(int32 EntryPoint);
	void FeedbackSuccessfulDefend(class UBP_BattleFeedbackState_C* DefendInfo);
	void FeedbackSuccessfulDodge(class UBP_BattleFeedbackState_C* DodgeInfo);
	void FeedbackSuccessfulParry(class UBP_BattleFeedbackState_C* ParryInfo);
	void FindActiveSkillSequenceBP(class ABP_EpicBattleSequenceActor_C** EpicSequenceBP);
	void FindBattleModifierBuffByClass(class UClass* BuffClass, TArray<class UBP_BattleBuffInstanceWrapper_C*>* ActiveBuffInstanceWrappers);
	void FindCharacterAtBattleSpot(ECharacterTeamSelector Team, int32 SpotIndex, class ABP_jRPG_Character_Battle_Base_C** Character);
	void FindCharacterStatsBattleActor(class UAC_jRPG_CharacterBattleStats_C* CharacterStats, class ABP_jRPG_Character_Battle_Base_C** BattleCharacterActor);
	void ForceBattleEnd(EBattleEndResult BattleEndResult);
	class UBP_GameDirectorComponent_C* Get_Game_Director_Component();
	void GetActiveCharacter(class ABP_jRPG_Character_Battle_Base_C** CurrentCharacter_0);
	TArray<class ABP_jRPG_Character_Battle_Base_C*> GetAliveEnemies();
	void GetAllActiveBattleBuffComponents(TArray<class UBP_BattleBuffComponent_C*>* Array);
	void GetAllAliveCharacters(TArray<class ABP_jRPG_Character_Battle_Base_C*>* AllCharacters);
	void GetAllAllyCharacters_SortedBySpotIndex(TArray<class ABP_jRPG_Character_Battle_Base_C*>* AllCharacters);
	void GetAllCharacters(TArray<class ABP_jRPG_Character_Battle_Base_C*>* AllCharacters);
	void GetAllEnemyCharacters_SortedBySpotIndex(TArray<class ABP_jRPG_Character_Battle_Base_C*>* AllEnemies);
	void GetAllItemsUsableInBattle(TArray<struct FS_jRPG_Item_DynamicData>* UsableItem);
	void GetAllPlayerCharacters(TArray<class ABP_jRPG_Character_Battle_Base_C*>* AllCharacters);
	void GetAssetsToLoadForBattle(TArray<TSoftClassPtr<class UClass>>* ClassesToLoad);
	EBattleEndResult GetBattleEndState();
	void GetBattleItemSkills(TArray<class UBP_DataAsset_Skill_C*>* ItemSkills);
	void GetBattleItemSkillsScriptClasses(TArray<TSoftClassPtr<class UClass>>* ItemSkillScriptSoftClasses);
	void GetCharacterAssetDependencies(class FName CharacterId, TArray<TSoftClassPtr<class UClass>>& OutClasses);
	void GetCharacterData(class FName CharacterId, class UBP_CharacterData_C** CharacterData);
	double GetCharacterRadiusForPlacement(class ACharacter* Character);
	void GetCharactersState(TArray<class ABP_jRPG_Character_Battle_Base_C*>& Characters, TArray<double>* CharactersInitiative, TArray<bool>* CharactersEngagementBonus);
	void GetCharactersWithFormation(TArray<class ABP_jRPG_Character_Battle_Base_C*>& CharactersArray, E_jRPG_FormationType DesiredFormation, TArray<class ABP_jRPG_Character_Battle_Base_C*>* Result);
	void GetCharacterWithMaxInitiative(bool DEBUG_Verbose, bool* Success_, class ABP_jRPG_Character_Battle_Base_C** Character, double* TimeToTurn);
	void GetCharacterWithMaxInitiativeSimulate(TArray<class ABP_jRPG_Character_Battle_Base_C*>& Characters, TArray<double>& CharactersInitiative, TArray<bool>& HasEngagementBonus, int32 SimulationStep, bool DEBUG_Verbose, bool* Success_, class ABP_jRPG_Character_Battle_Base_C** Character, double* TimeToTurn);
	E_GameDifficulty GetCurrentBattleDifficulty();
	TArray<class UAC_jRPG_CharacterBattleStats_C*> GetCurrentlyCounteringCharacters();
	void GetCurrentlyTargetingSkillState(class UBP_SkillState_C** SkillState);
	class ABP_jRPG_Character_Battle_Base_C* GetDummyMiddleCharacter();
	void GetEquippedCharacterGradientAttacks(class ABP_jRPG_Character_Battle_Base_C* Character, TArray<class UBP_DataAsset_Skill_C*>* EquippedSkills);
	void GetEquippedCharacterSkills(class ABP_jRPG_Character_Battle_Base_C* Character, TArray<class UBP_DataAsset_Skill_C*>* EquippedSkills);
	TMap<class FName, int32> GetExtraLootItems();
	TArray<class UAC_jRPG_CharacterBattleStats_C*> GetForcedNextCharacters();
	void GetGlobalDodgeWindowModifier(class UModifierStack_Float** Stack);
	void GetGlobalParryWindowModifier(class UModifierStack_Float** Stack);
	void GetJRPGControllerWorld(class ABP_jRPG_Controller_World_C** JRPG_Controller);
	void GetKickedCharacterStateFromHandle(struct FGuid& KickedCharacterHandle, bool* Success, struct FFBattleCharacterStoredState* CharacterState);
	class ABP_LGUI_UIContainer_BattleWheelRoot_C* GetLGUIActor_BattleWheels();
	void GetPlayerCharacterAtBattleSpot(int32 SpotIndex, class ABP_jRPG_Character_Battle_Base_C** Character);
	void GetProperBattleSpawnPointTransform(bool EnemySpot_, int32 SpotIndex, E_jRPG_FormationType FormationType, struct FTransform* BattleSpotTransform, E_jRPG_FormationType* BattleSpotFormationType);
	class UAC_jRPG_TargetingManager_C* GetTargetingManager();
	void GetTeamMotivationLevel(ETeamMotivationLevelType* LevelType, double* LevelProgress);
	void GetTurnCount(int32* TurnCount_0);
	void GetWorldEnemiesTransforms(TMap<class FName, struct FTransform>* EnemiesTransforms);
	void GoBackToExploration();
	void GoBackToExplorationExitFlow_Internal();
	bool HasBattleModifierBuffOfClass(class UClass* BuffClass);
	void Helper_AddRolledLootToMap(TMap<class FName, struct FS_RolledLootEntry>& RolledLootMap, class FName ItemId, int32 Quantity, int32 GeneratedLootLevelOffset);
	void Helper_TryAddRolledLootToMap(const TMap<class FName, struct FS_RolledLootEntry>& RolledBattleLootEntries, class FName ItemDefinitionID, int32 Quantity, int32 OffsetLootContext, const struct FS_LootContext& LootContext);
	void HideBattleMenuTooltip();
	void InitPlayerCharactersGear();
	void Internal_MakePlayerCharacterDead(const class ABP_jRPG_Character_Battle_Base_C*& Character);
	void Is_Attacking_Heroes(class ABP_jRPG_Enemy_Battle_Base_C* Enemy, bool* IsAttacking, TArray<class ABP_jRPG_Character_Battle_Base_C*>* TargetedHeroes);
	bool IsAFullTeamDead();
	bool IsBattleEnding();
	bool IsGradientChargeUnlocked();
	void IsKickedCharacterStateHandleValid(struct FGuid& KickedCharacterHandle, bool* Success);
	bool IsLastStandActive();
	bool IsNarrativeBattle();
	void IsPlayerTeamCharacterBase(class ABP_jRPG_Character_Battle_Base_C* CharacterBattle, bool* IsPlayerTeam);
	void IsPlayerTeamCharacterStats(class UAC_jRPG_CharacterBattleStats_C* CharacterBattleStats, bool* IsPlayerTeam);
	void IsShowingTooltip(bool* IsShowingTooltip_0);
	void IsSkipImpossible(bool* SkipImpossible);
	void KickCharacterFromBattle_Internal(const class ABP_jRPG_Character_Battle_Base_C*& Character, struct FGuid* KickedCharacterHandle);
	void LoadEncounterSettings();
	void LoadParty();
	void MoveCharactersBackToTheirSpots(class USF_BlueprintLatentAction* LatentAction, const class FString& DebugReason);
	void On_Character_Has_Received_Damage(class UBP_BattleDamages_C* BattleDamages);
	void OnAllBattleStartEventsTriggered();
	void OnAllEnemiesKilled();
	void OnAllEnemiesKilledInternal();
	void OnAllHeroesKilled();
	void OnAllLastStandsCompleted_Internal();
	void OnBackupTeamLoaded();
	void OnBattleDependenciesFullyLoaded();
	void OnBattleEndBlockerLifted(bool _isActive);
	void OnBattleEndVictory();
	void OnBattleMapReady();
	void OnCancelTargeting();
	void OnCharacterActionFinished(class ABP_jRPG_Character_Battle_Base_C* Character);
	void OnCharacterDashBackComplete(class ABP_jRPG_Character_Battle_Base_C* CharacterBase);
	void OnCharacterDashBackCompleteComponent(class UAC_jRPG_CombatMovement_C* MovementComponent);
	void OnCharacterLastStandEnded(class UAC_jRPG_CharacterBattleStats_C* CharacterStats);
	void OnCharacterLastStandStarted(class UAC_jRPG_CharacterBattleStats_C* CharacterStats);
	void OnCharacterReceivedDamages(class UAC_jRPG_CharacterBattleStats_C* TargetCharacterStats, double Damages, class UAC_jRPG_CharacterBattleStats_C* SourceCharacterStats, class UBP_BattleDamages_C* BattleDamages);
	void OnComboPressed();
	void OnCounterAttackFinished();
	void OnDataLayersActivated();
	void OnDefendStart();
	void OnDefendStop();
	void OnDefendSuccess(class ABP_jRPG_Character_Battle_Base_C* Character, class ABP_jRPG_Character_Battle_Base_C* Enemy);
	void OnDodgeAction();
	void OnDodgeSuccess(class ABP_jRPG_Character_Battle_Base_C* Character, class ABP_jRPG_Character_Battle_Base_C* Enemy);
	void OnEnemyKilled(class ABP_jRPG_Character_Battle_Base_C* Enemy);
	void OnFinished_2D0A3697490DFAD752C11F89FD2218CA();
	void OnFinished_3B9680914EC52C5987B913AB52568CD9();
	void OnFinished_58BC12074BE00B90B5CACAAD8F0606F4();
	void OnFinished_58BC12074BE00B90B5CACAAD978D45F2();
	void OnFinished_58BC12074BE00B90B5CACAADC430CF2B();
	void OnFinished_6D90D4DD4291EFA19FD1D188BD270CC6();
	void OnFinished_7574233641EBEE55E33399A458B6A201();
	void OnFinished_81711B71411E4D69320D38B39A03F19F();
	void OnFinished_846FEEF2465960CA826606AD5416E647();
	void OnFinished_87FC6BA24FD98A8FD85B999AF19DF012();
	void OnFinished_AA7B24BA438CCF872213CCB429A957E8();
	void OnFinished_BACC7CD44396AB29EC64CAA6E6A2885D();
	void OnFinished_D23A3CB34350BC4B7F58FA81A8CA41AF();
	void OnFinished_FDED7E8741285BACE8169884161F56D8();
	void OnGameOverScreenClosed();
	void OnGradientCounterAction();
	void OnGradientCounterSuccess();
	void OnJumpAction();
	void OnJumpShot();
	void OnLastStandDuringFreeAimFinishedFlow();
	void OnLastStandFinished();
	void OnLoaded_F58B7C71485B149C4ED04FB5D95BEB82(class UObject* Loaded);
	void OnParryAction();
	void OnParrySuccess(class ABP_jRPG_Character_Battle_Base_C* Character, class ABP_jRPG_Character_Battle_Base_C* Enemy);
	void OnPlayerCharacterKilled(class ABP_jRPG_Character_Battle_Base_C* PlayerCharacter);
	void OnPlayerCharacterResurrected(class ABP_jRPG_Character_Battle_Base_C* PlayerCharacter);
	void OnPlayerCharacterTurnStart();
	void OnPlayerTurnPreStart();
	void OnRequestDone_8C2416AD4A8AC40CBFE10886B5BA038C();
	void OnReserveTeamResponse(bool ShouldSendReserve);
	void OnSelectFlee();
	void OnSelectSkillMenu();
	void OnSelectSkip();
	void OnSkillSelectionClosed();
	void OnStartTargeting();
	void OnStopTargeting(bool WasPreTargeting);
	void OnTargetChanged();
	void OnTargetingUpdate();
	void OnTurnEndEventBegin(class ABP_jRPG_Character_Battle_Base_C* Character);
	void OnTurnEndEventEnd();
	void OnTurnSkipped();
	void OnVictoryScreenClosedFlow();
	void PerformFlee();
	void PerformLastStandFlow();
	void PlayFreezeFrameInternal(class USF_BlueprintLatentAction* LatentAction, float TimeDilation, float GameDuration);
	void PrepareForBackupTeam(TArray<class FName>* BackupTeam, TArray<TSoftClassPtr<class UClass>>* ClassesToLoad);
	void ProcessAdditionalTurnEndEvent();
	void ProcessLastStandEvents(class USF_BlueprintLatentAction* LatentAction);
	void ProcessNextCharacterBattleStartEvent();
	void ProcessNextCharacterTurnEnd();
	void ProcessNextFeedback();
	void ProcessNextPendingResurrect(class USF_BlueprintLatentAction* LatentAction);
	void ProcessNextTurnStartListener();
	void ProcessVictoryEndFlow();
	void QueueForcedNextCharacter(const class UAC_jRPG_CharacterBattleStats_C*& CharacterStats);
	void ReceiveBattleExperience(int32 InputPin);
	void ReceiveBattleRewards(struct FS_BattleRewards& BattleRewards);
	void ReceiveBeginPlay();
	void ReceiveTick(float DeltaSeconds);
	void RegisterBattleListener(const TScriptInterface<class IBPI_BattleListener_C>& NewListener);
	void RegisterPendingResurrect(const class UAC_jRPG_CharacterBattleStats_C*& CharacterStats);
	void ReintegrateCharacterToBattle(struct FGuid& KickedCharacterHandle, class ABP_jRPG_Character_Battle_Base_C** RespawnedCharacter);
	void RemoveBattleScreenHUD();
	void RemoveGlobalDodgeWindowModifier(struct FSF_ModifierStackEntryHandle& OutModifierHandle);
	void RemoveGlobalParryWindowModifier(struct FSF_ModifierStackEntryHandle& OutModifierHandle);
	void RemoveInvalidKickedCharacterStateHandles(TArray<struct FGuid>& KickedCharacterHandles);
	void RequestActionExecution(TArray<class ABP_jRPG_Character_Battle_Base_C*>& TargetedCharacters);
	void ResetBattle();
	void ResetGlobalTimeDilationForBattle();
	void ResetInterceptions(class USF_BlueprintLatentAction* LatentAction);
	void ResumeAudioFromBattle();
	void ResumeBattle();
	void ResumeBattleNew();
	void RollBattleRewards(struct FS_BattleRewards* BattleRewards);
	void Sandfall_AddAP(const class FString& Character, int32 Amount);
	void Sandfall_ApplyBuffToAllEnemies(const class FString& BuffBPClass);
	void Sandfall_ApplyBuffToAlly(const class FString& AllyName, const class FString& BuffBPClass);
	void Sandfall_ApplyShieldToEnemies(int32 ShieldAmount);
	void Sandfall_ChangePerfection(const class FString& CharacterId, int32 PerfectionChange);
	void Sandfall_DamageCharacter_(const class FString& CharacterName);
	void Sandfall_DamageEnemies(double Damages);
	void Sandfall_HeroesIgnoreDamage(bool Ignore);
	void Sandfall_KillAllEnemies();
	void Sandfall_KillAllies();
	void Sandfall_KillCharacter(const class FString& CharacterName);
	void Sandfall_KillCharacterByObject(class UAC_jRPG_CharacterBattleStats_C* Target, class UAC_jRPG_CharacterBattleStats_C* Source);
	void Sandfall_KillEnemy();
	void Sandfall_ReproBurnDeath();
	void Sandfall_SetAllAlliesAP(int32 Amount);
	void Sandfall_SetAllAlliesHP(int32 HP);
	void Sandfall_SetAllEnemiesHP(int32 NewHPValue);
	void Sandfall_TestInterception();
	void SelectAction(E_jRPG_ActionType ActionType);
	void SelectSecondaryAction(class FName SelectedSecondaryAction_0);
	void SetBattleInputEnabled(bool Enabled);
	void SetBattleMapInternal(class ABP_BattleMap_C* BattleMapActor);
	void SetCurrentCharacter(class ABP_jRPG_Character_Battle_Base_C* CurrentCharacter_0);
	void SetDebugFlowState(const class FString& StateName);
	void SetDefenseState(bool WantedDefense_0);
	void SetInputMappingContextEnabled(bool bIsEnabled, const class UInputMappingContext* MappingContext);
	void SetIsSkipImpossible(bool IsSkipImpossible);
	void SetLastFatalDamageReceivedReason(EDamageReason LastDamageReceivedReason);
	void SetupBattleMap();
	bool ShouldQueueRevive();
	bool ShouldUpdateCharacterDataWithFinalBattleState();
	void ShowBattleMenuTooltip(const class FText& TooltipName, const class FText& TooltipDesc);
	void ShowBattleTooltip(const class FText& ToolTipText, bool AutoFadeout);
	void ShowReserveTeamGameOver();
	void ShowSkillTooltip(const class FText& TooltipName, const class FText& TooltipDesc);
	void Spawn_Player_Character(class UBP_CharacterData_C* CharacterData, int32 BattleSpotIndex, E_jRPG_FormationType FormationType, class ABP_jRPG_Character_Battle_Base_C** SpawnedCharacter);
	void SpawnAllCharacters();
	void SpawnBackupTeam();
	void SpawnBattleSequence(class ULevelSequence* LevelSequence, class ABP_jRPG_Character_Battle_Base_C* SourceCharacter, TArray<class ABP_jRPG_Character_Battle_Base_C*>& TargetCharacters, bool SnapOnTarget, bool UseTargetAsOrigin, bool UseTargetOrientation, bool LookAtTarget, bool LookAtAttacker, bool DisableSequenceSnapping, class ABP_EpicBattleSequenceActor_C** EpicSequence, struct FTransform* AttackerFirstPosition);
	void SpawnCharacterFromStoredState(const struct FFBattleCharacterStoredState& StoredState, class ABP_jRPG_Character_Battle_Base_C** SpawnedCharacter);
	void SpawnEnemies();
	void SpawnEnemyOnSpot(int32 BattleSpotIndex, class FName CharacterHardcodedName, bool NotifyBattleStart, class ABP_jRPG_Character_Battle_Base_C** SpawnedEnemy, struct FVector* EnemySpawnedLocation);
	void SpawnExtraPlayerCharacter(class UBP_CharacterData_C* CharacterData);
	void SpawnOnlyRequestedTeam();
	void SpawnPlayerCharactersFromParty();
	class ABP_jRPG_Character_Battle_Base_C* SpawnPuppetCharacter(class UClass* CharacterBPClass, class UAC_jRPG_CharacterBattleStats_C* PuppetedBy, double Scale);
	void StartAudioForBattle(class USF_BlueprintLatentAction* LatentAction);
	void StartBattle(E_jRPG_EngageTypes EngageType);
	void StartBattleEndFlow(EBattleEndResult BattleEndResult);
	void StartBattleNEW(const struct FFBattleStartParams& BattleStartParams);
	void StartBattleTransition(class USF_BlueprintLatentAction* TransitionIntroLatentAction);
	void StartCharacterTurn(class ABP_jRPG_Character_Battle_Base_C* Character);
	void StartCharacterTurn_Phase2();
	void StartCounterAttackInternal(class ABP_jRPG_Character_Battle_Base_C* Source, class ABP_jRPG_Character_Battle_Base_C* Target);
	void StartFreeAimFromUI();
	void StartFreezeFrame(E_FreezeFrame FreezeFrameType, class USF_BlueprintLatentAction** LatentAction);
	void StartPlayerTurnChoice();
	void StartPreloadingBattleDependencies();
	void StopBattleSystems();
	void SwitchCamera(class FName PathID, bool RandomStartDistance, bool Loop, bool UpdatePathLocation);
	void TODO_STARTBATTLE();
	void TriggerBattleStartEvents(class USF_BlueprintLatentAction* LatentAction);
	void TriggerBattleStartEventsForCharacters(TArray<class ABP_jRPG_Character_Battle_Base_C*>& CharactersToProcess, class USF_BlueprintLatentAction* LatentAction);
	void TriggerBattleStartEventsInstant();
	void TriggerSkill(TArray<class ABP_jRPG_Character_Battle_Base_C*>& TargetedCharacters, class UAC_jRPG_CharacterBattleStats_C* Source, class UClass* SkillClass);
	void TriggerSkillCounter(class UAC_jRPG_CharacterBattleStats_C* TargetCharacterStats, class UAC_jRPG_CharacterBattleStats_C* CounteringCharacterStats, class UClass* Skill);
	void TryCounterAttack(class UBP_BattleFeedbackState_C* ParryState);
	void TryForceUnregisterPendingResurrect(const class UAC_jRPG_CharacterBattleStats_C*& CharStats);
	void TryGetInterceptingCharacter(class UAC_jRPG_CharacterBattleStats_C* TargetedCharacterStats, class UAC_jRPG_CharacterBattleStats_C* AttackerCharacterStats, class UAC_jRPG_CharacterBattleStats_C** CharacterStats);
	void TryGetTargetedAllies(bool* Valid, TArray<class ABP_jRPG_Character_Battle_Base_C*>* TargetedHeroes);
	void TryGradientCounterAttack(class UBP_BattleFeedbackState_C* ParryState);
	void TryLastStand(class ABP_jRPG_Character_Battle_Base_C* CharacterBattle, EDamageReason DeathReason, bool* HasLastStand);
	void TryProcessPendingBattleEnd();
	void TryRemoveQueuedForcedNextCharacter(const class UAC_jRPG_CharacterBattleStats_C*& CharacterStats);
	void TryResumeBattle();
	void TryStealConsumableFromPlayer(class UAC_jRPG_CharacterBattleStats_C* Thief, const struct FDataTableRowHandle& ConsumableDataRow, int32 Quantity, int32* RemovedQuantity);
	void UnlockNoDamageBossAchievement();
	void UnregisterBattleListener(const TScriptInterface<class IBPI_BattleListener_C>& Item);
	void UnspawnEnemies();
	void UnspawnPlayerCharacters();
	void UpdateBattleEndVictoryScreen(TArray<class UAC_jRPG_CharacterBattleStats_C*>& CharacterBattleStats, struct FS_BattleRewards& BattleRewards);
	void UpdateBattleTurns();
	void UpdateCharacterDataWithBattleFinalState();
	void UpdateCharacterNextTurns();
	void UpdateDefend(const class FText& DebugReason);
	void UpdateDefenseControls();
	void UpdateDummyMiddleCharacterLocation();
	void UpdateFreeAimHover();
	void UpdateMouseTargeting();
	void UpdateTargetingArrowsState();
	bool Was_Battle_No_Damage();

	void CheckIfAlreadyLootedItem(TArray<struct FS_jRPG_Item_DynamicData>& LootedItems, class FName ItemHardcodedName, bool* AlreadyLooted_, int32* SlotIndex) const;
	void ConcatActors(TArray<class AActor*>& Actors, class FText* Result) const;
	void GetQTEManager(class UBP_QTEManager_C** QTEManager) const;

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"AC_jRPG_BattleManager_C">();
	}
	static class UAC_jRPG_BattleManager_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAC_jRPG_BattleManager_C>();
	}
};
static_assert(alignof(UAC_jRPG_BattleManager_C) == 0x000008, "Wrong alignment on UAC_jRPG_BattleManager_C");
static_assert(sizeof(UAC_jRPG_BattleManager_C) == 0x0009F0, "Wrong size on UAC_jRPG_BattleManager_C");
static_assert(offsetof(UAC_jRPG_BattleManager_C, UberGraphFrame) == 0x0000A0, "Member 'UAC_jRPG_BattleManager_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, IsBattleInitialized) == 0x0000A8, "Member 'UAC_jRPG_BattleManager_C::IsBattleInitialized' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, ResumeBattleRequested) == 0x0000A9, "Member 'UAC_jRPG_BattleManager_C::ResumeBattleRequested' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, CurrentCharacter) == 0x0000B0, "Member 'UAC_jRPG_BattleManager_C::CurrentCharacter' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, PlayerCharacters) == 0x0000B8, "Member 'UAC_jRPG_BattleManager_C::PlayerCharacters' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, Enemies) == 0x0000C8, "Member 'UAC_jRPG_BattleManager_C::Enemies' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, InitiativeNeededToTakeTurn) == 0x0000D8, "Member 'UAC_jRPG_BattleManager_C::InitiativeNeededToTakeTurn' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, BattleEndScreenReference) == 0x0000E0, "Member 'UAC_jRPG_BattleManager_C::BattleEndScreenReference' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, GameInstanceReference) == 0x0000E8, "Member 'UAC_jRPG_BattleManager_C::GameInstanceReference' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, BattleEndCharacterSlotsReference) == 0x0000F0, "Member 'UAC_jRPG_BattleManager_C::BattleEndCharacterSlotsReference' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, EnemiesBySpotIndex) == 0x000100, "Member 'UAC_jRPG_BattleManager_C::EnemiesBySpotIndex' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, DeadPlayerCharacters) == 0x000150, "Member 'UAC_jRPG_BattleManager_C::DeadPlayerCharacters' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, DeadEnemies) == 0x000160, "Member 'UAC_jRPG_BattleManager_C::DeadEnemies' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, SelectedAction) == 0x000170, "Member 'UAC_jRPG_BattleManager_C::SelectedAction' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, SelectedSecondaryAction) == 0x000174, "Member 'UAC_jRPG_BattleManager_C::SelectedSecondaryAction' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, NextCharacterTurns) == 0x000180, "Member 'UAC_jRPG_BattleManager_C::NextCharacterTurns' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, EncounterName) == 0x000190, "Member 'UAC_jRPG_BattleManager_C::EncounterName' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, BattleListeners) == 0x000198, "Member 'UAC_jRPG_BattleManager_C::BattleListeners' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, VictorySong) == 0x0001A8, "Member 'UAC_jRPG_BattleManager_C::VictorySong' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, TeamMotivationValue) == 0x0001B0, "Member 'UAC_jRPG_BattleManager_C::TeamMotivationValue' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, TeamMotivationData) == 0x0001B8, "Member 'UAC_jRPG_BattleManager_C::TeamMotivationData' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, OldControlledPawn) == 0x0001D0, "Member 'UAC_jRPG_BattleManager_C::OldControlledPawn' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, OnlySpawnHeroesAtNextBattleStart) == 0x0001D8, "Member 'UAC_jRPG_BattleManager_C::OnlySpawnHeroesAtNextBattleStart' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, OnlySpawnEnemiesAtNextBattleStart) == 0x0001D9, "Member 'UAC_jRPG_BattleManager_C::OnlySpawnEnemiesAtNextBattleStart' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, OnBattleFinished) == 0x0001E0, "Member 'UAC_jRPG_BattleManager_C::OnBattleFinished' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, HasSpawnedHeroes) == 0x0001F0, "Member 'UAC_jRPG_BattleManager_C::HasSpawnedHeroes' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, HasSpawnedEnemies) == 0x0001F1, "Member 'UAC_jRPG_BattleManager_C::HasSpawnedEnemies' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, DefendingHeroes) == 0x0001F8, "Member 'UAC_jRPG_BattleManager_C::DefendingHeroes' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, PreviousDefendingHeroes) == 0x000208, "Member 'UAC_jRPG_BattleManager_C::PreviousDefendingHeroes' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, SuccessfulDodgeFeedback) == 0x000218, "Member 'UAC_jRPG_BattleManager_C::SuccessfulDodgeFeedback' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, SuccessfulParryFeedback) == 0x000220, "Member 'UAC_jRPG_BattleManager_C::SuccessfulParryFeedback' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, SuccessfulDefendFeedback) == 0x000228, "Member 'UAC_jRPG_BattleManager_C::SuccessfulDefendFeedback' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, DefendSuccessFeedback) == 0x000230, "Member 'UAC_jRPG_BattleManager_C::DefendSuccessFeedback' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, DodgeSuccessFeedback) == 0x000248, "Member 'UAC_jRPG_BattleManager_C::DodgeSuccessFeedback' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, ParrySuccessFeedback) == 0x000260, "Member 'UAC_jRPG_BattleManager_C::ParrySuccessFeedback' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, DEBUG_ComboAutoSuccessCount) == 0x000278, "Member 'UAC_jRPG_BattleManager_C::DEBUG_ComboAutoSuccessCount' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, SkillComboQTE_SuccessFeedback) == 0x000280, "Member 'UAC_jRPG_BattleManager_C::SkillComboQTE_SuccessFeedback' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, SkillComboQTE_FailFeedback) == 0x000298, "Member 'UAC_jRPG_BattleManager_C::SkillComboQTE_FailFeedback' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, FEATURE_UseNewBattleUI) == 0x0002B0, "Member 'UAC_jRPG_BattleManager_C::FEATURE_UseNewBattleUI' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, DEBUG_OverlayInfo) == 0x0002B1, "Member 'UAC_jRPG_BattleManager_C::DEBUG_OverlayInfo' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, BattleScreenWidget) == 0x0002B8, "Member 'UAC_jRPG_BattleManager_C::BattleScreenWidget' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, WantedDefense) == 0x0002C0, "Member 'UAC_jRPG_BattleManager_C::WantedDefense' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, HasActiveCounterAttack) == 0x0002C1, "Member 'UAC_jRPG_BattleManager_C::HasActiveCounterAttack' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, HasActiveTurnEndEvent) == 0x0002C2, "Member 'UAC_jRPG_BattleManager_C::HasActiveTurnEndEvent' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, CurrentHoveredCharacter) == 0x0002C8, "Member 'UAC_jRPG_BattleManager_C::CurrentHoveredCharacter' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, FEATURE_UseBattleChecks) == 0x0002D0, "Member 'UAC_jRPG_BattleManager_C::FEATURE_UseBattleChecks' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, BattleMapBP) == 0x0002D8, "Member 'UAC_jRPG_BattleManager_C::BattleMapBP' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, APRecoverFeedback) == 0x0002E0, "Member 'UAC_jRPG_BattleManager_C::APRecoverFeedback' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, APConsumedFeedback) == 0x0002F8, "Member 'UAC_jRPG_BattleManager_C::APConsumedFeedback' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, Play_Battle_Camera_Intro_) == 0x000310, "Member 'UAC_jRPG_BattleManager_C::Play_Battle_Camera_Intro_' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, CanAddTurnEndEvent) == 0x000311, "Member 'UAC_jRPG_BattleManager_C::CanAddTurnEndEvent' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, TurnStartNotifyDependencies) == 0x000318, "Member 'UAC_jRPG_BattleManager_C::TurnStartNotifyDependencies' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, TurnStartNextPhase) == 0x000320, "Member 'UAC_jRPG_BattleManager_C::TurnStartNextPhase' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, TurnStartBattleListenersToProcess) == 0x000328, "Member 'UAC_jRPG_BattleManager_C::TurnStartBattleListenersToProcess' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, OnTurnStart) == 0x000338, "Member 'UAC_jRPG_BattleManager_C::OnTurnStart' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, SoundEvent_TargetChange_Enemy) == 0x000348, "Member 'UAC_jRPG_BattleManager_C::SoundEvent_TargetChange_Enemy' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, SoundEvent_TargetChange_Ally) == 0x000358, "Member 'UAC_jRPG_BattleManager_C::SoundEvent_TargetChange_Ally' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, SoundEvent_Skill_TargetEnemy_Start) == 0x000368, "Member 'UAC_jRPG_BattleManager_C::SoundEvent_Skill_TargetEnemy_Start' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, SoundEvent_Skill_TargetAlly_Start) == 0x000378, "Member 'UAC_jRPG_BattleManager_C::SoundEvent_Skill_TargetAlly_Start' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, SoundEvent_Item_TargetAlly_Start) == 0x000388, "Member 'UAC_jRPG_BattleManager_C::SoundEvent_Item_TargetAlly_Start' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, SoundEvent_Item_TargetEnemy_Start) == 0x000398, "Member 'UAC_jRPG_BattleManager_C::SoundEvent_Item_TargetEnemy_Start' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, SoundEvent_TurnStart_Ally) == 0x0003A8, "Member 'UAC_jRPG_BattleManager_C::SoundEvent_TurnStart_Ally' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, SoundEvent_TurnStart_Enemy) == 0x0003B8, "Member 'UAC_jRPG_BattleManager_C::SoundEvent_TurnStart_Enemy' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, SoundEvent_BattleStart) == 0x0003C8, "Member 'UAC_jRPG_BattleManager_C::SoundEvent_BattleStart' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, TurnCount) == 0x0003D8, "Member 'UAC_jRPG_BattleManager_C::TurnCount' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, OnBattleReadyToStart) == 0x0003E0, "Member 'UAC_jRPG_BattleManager_C::OnBattleReadyToStart' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, CurrentHoveredCharacterFreeAim) == 0x0003F0, "Member 'UAC_jRPG_BattleManager_C::CurrentHoveredCharacterFreeAim' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, LastMouseHitLocation) == 0x0003F8, "Member 'UAC_jRPG_BattleManager_C::LastMouseHitLocation' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, OnBattleFlee) == 0x000410, "Member 'UAC_jRPG_BattleManager_C::OnBattleFlee' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, BlockAllDefensiveMoves) == 0x000420, "Member 'UAC_jRPG_BattleManager_C::BlockAllDefensiveMoves' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, DisableCriticalHit) == 0x000421, "Member 'UAC_jRPG_BattleManager_C::DisableCriticalHit' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, OnEnemyKilledEvent) == 0x000428, "Member 'UAC_jRPG_BattleManager_C::OnEnemyKilledEvent' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, OnResurected) == 0x000438, "Member 'UAC_jRPG_BattleManager_C::OnResurected' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, UseDiegeticQTE) == 0x000448, "Member 'UAC_jRPG_BattleManager_C::UseDiegeticQTE' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, OnParrySuccessful) == 0x000450, "Member 'UAC_jRPG_BattleManager_C::OnParrySuccessful' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, OnDodgeSuccessful) == 0x000460, "Member 'UAC_jRPG_BattleManager_C::OnDodgeSuccessful' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, OnDefendSuccessful) == 0x000470, "Member 'UAC_jRPG_BattleManager_C::OnDefendSuccessful' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, SoundEvent_DodgeTriggered) == 0x000480, "Member 'UAC_jRPG_BattleManager_C::SoundEvent_DodgeTriggered' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, SoundEvent_ParryTriggered) == 0x000490, "Member 'UAC_jRPG_BattleManager_C::SoundEvent_ParryTriggered' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, GameActionsAfterBattle) == 0x0004A0, "Member 'UAC_jRPG_BattleManager_C::GameActionsAfterBattle' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, AllPlayerCharactersBySpotIndex) == 0x0004B0, "Member 'UAC_jRPG_BattleManager_C::AllPlayerCharactersBySpotIndex' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, CurrentTurn_CanChooseAction) == 0x0004C0, "Member 'UAC_jRPG_BattleManager_C::CurrentTurn_CanChooseAction' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, CurrentBattleStartParams) == 0x0004C8, "Member 'UAC_jRPG_BattleManager_C::CurrentBattleStartParams' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, WasLastBattleLost) == 0x000620, "Member 'UAC_jRPG_BattleManager_C::WasLastBattleLost' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, SD_BattleStarts) == 0x000628, "Member 'UAC_jRPG_BattleManager_C::SD_BattleStarts' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, SD_FirstStrike) == 0x000630, "Member 'UAC_jRPG_BattleManager_C::SD_FirstStrike' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, AllEnemyCharactersBySpotIndex) == 0x000638, "Member 'UAC_jRPG_BattleManager_C::AllEnemyCharactersBySpotIndex' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, SD_GameOverMusic) == 0x000648, "Member 'UAC_jRPG_BattleManager_C::SD_GameOverMusic' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, SoundEvent_GradientCounterTriggered) == 0x000650, "Member 'UAC_jRPG_BattleManager_C::SoundEvent_GradientCounterTriggered' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, WasCurrentSkillInterrupted) == 0x000660, "Member 'UAC_jRPG_BattleManager_C::WasCurrentSkillInterrupted' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, WaitingForCharactersToDashBack) == 0x000668, "Member 'UAC_jRPG_BattleManager_C::WaitingForCharactersToDashBack' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, KickedCharacters) == 0x000678, "Member 'UAC_jRPG_BattleManager_C::KickedCharacters' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, BattleEndBlockerRefCount) == 0x0006C8, "Member 'UAC_jRPG_BattleManager_C::BattleEndBlockerRefCount' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, OnCharacterKilled) == 0x0006E8, "Member 'UAC_jRPG_BattleManager_C::OnCharacterKilled' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, DEBUG_RandomHeroAcquireOverride) == 0x0006F8, "Member 'UAC_jRPG_BattleManager_C::DEBUG_RandomHeroAcquireOverride' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, BattleStartNotifyDependencies) == 0x000700, "Member 'UAC_jRPG_BattleManager_C::BattleStartNotifyDependencies' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, BattleStartEvents_CharactersToProcess) == 0x000708, "Member 'UAC_jRPG_BattleManager_C::BattleStartEvents_CharactersToProcess' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, DataLayerRequestReference) == 0x000718, "Member 'UAC_jRPG_BattleManager_C::DataLayerRequestReference' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, LastStandSystem) == 0x000738, "Member 'UAC_jRPG_BattleManager_C::LastStandSystem' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, CurrentCharacterStack) == 0x000740, "Member 'UAC_jRPG_BattleManager_C::CurrentCharacterStack' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, CurrentTurnCharacter) == 0x000750, "Member 'UAC_jRPG_BattleManager_C::CurrentTurnCharacter' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, CurrentBattleEnemies) == 0x000758, "Member 'UAC_jRPG_BattleManager_C::CurrentBattleEnemies' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, FleeImpossible) == 0x0007A8, "Member 'UAC_jRPG_BattleManager_C::FleeImpossible' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, HasBattleStartedEndFlow) == 0x0007A9, "Member 'UAC_jRPG_BattleManager_C::HasBattleStartedEndFlow' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, CurrentBattleEncounterLevel) == 0x0007AC, "Member 'UAC_jRPG_BattleManager_C::CurrentBattleEncounterLevel' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, LastReceivedBattleRewards) == 0x0007B0, "Member 'UAC_jRPG_BattleManager_C::LastReceivedBattleRewards' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, BattleSummaryStatsManager) == 0x0007C8, "Member 'UAC_jRPG_BattleManager_C::BattleSummaryStatsManager' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, PendingResurrects) == 0x0007D0, "Member 'UAC_jRPG_BattleManager_C::PendingResurrects' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, IsProcessingKilledCharacter) == 0x0007E0, "Member 'UAC_jRPG_BattleManager_C::IsProcessingKilledCharacter' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, HasSentReserveTeam) == 0x0007E1, "Member 'UAC_jRPG_BattleManager_C::HasSentReserveTeam' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, IsWaitingForTurnEndBeforeGameOver) == 0x0007E2, "Member 'UAC_jRPG_BattleManager_C::IsWaitingForTurnEndBeforeGameOver' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, GradientGaugeSystem) == 0x0007E8, "Member 'UAC_jRPG_BattleManager_C::GradientGaugeSystem' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, CurrentBattleExtraLoot) == 0x0007F0, "Member 'UAC_jRPG_BattleManager_C::CurrentBattleExtraLoot' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, BattleAudioControlSystem) == 0x000840, "Member 'UAC_jRPG_BattleManager_C::BattleAudioControlSystem' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, OnCharacterReceivedDamage) == 0x000848, "Member 'UAC_jRPG_BattleManager_C::OnCharacterReceivedDamage' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, BattleModifiersBuffComponent) == 0x000858, "Member 'UAC_jRPG_BattleManager_C::BattleModifiersBuffComponent' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, BattleParty) == 0x000860, "Member 'UAC_jRPG_BattleManager_C::BattleParty' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, GameOverScreenWidget) == 0x000870, "Member 'UAC_jRPG_BattleManager_C::GameOverScreenWidget' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, BattleTransitionWidget) == 0x000878, "Member 'UAC_jRPG_BattleManager_C::BattleTransitionWidget' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, OnStartedTargeting) == 0x000880, "Member 'UAC_jRPG_BattleManager_C::OnStartedTargeting' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, LGUI_Actor_BattleWheels) == 0x000890, "Member 'UAC_jRPG_BattleManager_C::LGUI_Actor_BattleWheels' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, LastFatalDamageReceivedReason) == 0x000898, "Member 'UAC_jRPG_BattleManager_C::LastFatalDamageReceivedReason' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, CameraFinisherMap) == 0x0008A0, "Member 'UAC_jRPG_BattleManager_C::CameraFinisherMap' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, OnCharacterBreakStunned) == 0x0008F0, "Member 'UAC_jRPG_BattleManager_C::OnCharacterBreakStunned' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, GlobalDodgeWindowModifierStack) == 0x000900, "Member 'UAC_jRPG_BattleManager_C::GlobalDodgeWindowModifierStack' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, GlobalParryWindowModifierStack) == 0x000908, "Member 'UAC_jRPG_BattleManager_C::GlobalParryWindowModifierStack' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, BattleEndState) == 0x000910, "Member 'UAC_jRPG_BattleManager_C::BattleEndState' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, Deactivate_Battle_EndCameraMovement) == 0x000911, "Member 'UAC_jRPG_BattleManager_C::Deactivate_Battle_EndCameraMovement' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, OnEnemySpawned) == 0x000918, "Member 'UAC_jRPG_BattleManager_C::OnEnemySpawned' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, DummyMiddleCharacter) == 0x000928, "Member 'UAC_jRPG_BattleManager_C::DummyMiddleCharacter' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, AliveCharactersAtTurnStart) == 0x000930, "Member 'UAC_jRPG_BattleManager_C::AliveCharactersAtTurnStart' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, SoundEventSlowMo) == 0x000940, "Member 'UAC_jRPG_BattleManager_C::SoundEventSlowMo' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, CurrentlyCounteringCharacters) == 0x000950, "Member 'UAC_jRPG_BattleManager_C::CurrentlyCounteringCharacters' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, CurrentCounteredCharacter) == 0x000960, "Member 'UAC_jRPG_BattleManager_C::CurrentCounteredCharacter' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, OnCharacterHealSuccessful) == 0x000968, "Member 'UAC_jRPG_BattleManager_C::OnCharacterHealSuccessful' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, OnShieldPointsIncreased) == 0x000978, "Member 'UAC_jRPG_BattleManager_C::OnShieldPointsIncreased' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, OnAPChanged) == 0x000988, "Member 'UAC_jRPG_BattleManager_C::OnAPChanged' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, BattleDifficulty) == 0x000998, "Member 'UAC_jRPG_BattleManager_C::BattleDifficulty' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, NewVar) == 0x0009A0, "Member 'UAC_jRPG_BattleManager_C::NewVar' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, ForcedNextCharactersQueue) == 0x0009A8, "Member 'UAC_jRPG_BattleManager_C::ForcedNextCharactersQueue' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, LoadedBattleMusic) == 0x0009B8, "Member 'UAC_jRPG_BattleManager_C::LoadedBattleMusic' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, DisableReactionBattleLines) == 0x0009C0, "Member 'UAC_jRPG_BattleManager_C::DisableReactionBattleLines' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, bIsSkipImpossible) == 0x0009C1, "Member 'UAC_jRPG_BattleManager_C::bIsSkipImpossible' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, OnSkipImpossibleChanged) == 0x0009C8, "Member 'UAC_jRPG_BattleManager_C::OnSkipImpossibleChanged' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, DebugLastFlowState) == 0x0009D8, "Member 'UAC_jRPG_BattleManager_C::DebugLastFlowState' has a wrong offset!");
static_assert(offsetof(UAC_jRPG_BattleManager_C, bIsNarrativeBattle) == 0x0009E8, "Member 'UAC_jRPG_BattleManager_C::bIsNarrativeBattle' has a wrong offset!");

}

