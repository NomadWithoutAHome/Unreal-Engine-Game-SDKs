#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_MerchantComponent

#include "Basic.hpp"

#include "BP_MerchantComponent_classes.hpp"
#include "BP_MerchantComponent_parameters.hpp"


namespace SDK
{

// Function BP_MerchantComponent.BP_MerchantComponent_C.AddItemToInventory
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FS_MerchantItemSellData&   MerchantItem                                           (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_MerchantComponent_C::AddItemToInventory(const struct FS_MerchantItemSellData& MerchantItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MerchantComponent_C", "AddItemToInventory");

	Params::BP_MerchantComponent_C_AddItemToInventory Parms{};

	Parms.MerchantItem = std::move(MerchantItem);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_MerchantComponent.BP_MerchantComponent_C.CanStartMerchantBattle
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_MerchantComponent_C::CanStartMerchantBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MerchantComponent_C", "CanStartMerchantBattle");

	Params::BP_MerchantComponent_C_CanStartMerchantBattle Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_MerchantComponent.BP_MerchantComponent_C.CheckForErrors
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FText>&                    ErrorMessages                                          (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_MerchantComponent_C::CheckForErrors(TArray<class FText>& ErrorMessages)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MerchantComponent_C", "CheckForErrors");

	Params::BP_MerchantComponent_C_CheckForErrors Parms{};

	Parms.ErrorMessages = std::move(ErrorMessages);

	UObject::ProcessEvent(Func, &Parms);

	ErrorMessages = std::move(Parms.ErrorMessages);

	return Parms.ReturnValue;
}


// Function BP_MerchantComponent.BP_MerchantComponent_C.CheckIfItemIsConditional
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FS_MerchantItemData&       MerchantItemData                                       (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsConditional                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MerchantComponent_C::CheckIfItemIsConditional(const struct FS_MerchantItemData& MerchantItemData, bool* IsConditional)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MerchantComponent_C", "CheckIfItemIsConditional");

	Params::BP_MerchantComponent_C_CheckIfItemIsConditional Parms{};

	Parms.MerchantItemData = std::move(MerchantItemData);

	UObject::ProcessEvent(Func, &Parms);

	if (IsConditional != nullptr)
		*IsConditional = Parms.IsConditional;
}


// Function BP_MerchantComponent.BP_MerchantComponent_C.CheckIfItemIsVisible
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FS_MerchantItemData&       MerchantItemData                                       (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsAvailable                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MerchantComponent_C::CheckIfItemIsVisible(const struct FS_MerchantItemData& MerchantItemData, bool* IsAvailable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MerchantComponent_C", "CheckIfItemIsVisible");

	Params::BP_MerchantComponent_C_CheckIfItemIsVisible Parms{};

	Parms.MerchantItemData = std::move(MerchantItemData);

	UObject::ProcessEvent(Func, &Parms);

	if (IsAvailable != nullptr)
		*IsAvailable = Parms.IsAvailable;
}


// Function BP_MerchantComponent.BP_MerchantComponent_C.ComputeAvailableItemsFromTable
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UDataTable*                       Table                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_MerchantComponent_C::ComputeAvailableItemsFromTable(class UDataTable* Table)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MerchantComponent_C", "ComputeAvailableItemsFromTable");

	Params::BP_MerchantComponent_C_ComputeAvailableItemsFromTable Parms{};

	Parms.Table = Table;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_MerchantComponent.BP_MerchantComponent_C.ComputeItemPrice
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FS_MerchantItemData&       MerchantItem                                           (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// class UBP_ItemInstance_Base_C*          ItemInstance                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32*                                  Price                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MerchantComponent_C::ComputeItemPrice(const struct FS_MerchantItemData& MerchantItem, class UBP_ItemInstance_Base_C* ItemInstance, int32* Price)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MerchantComponent_C", "ComputeItemPrice");

	Params::BP_MerchantComponent_C_ComputeItemPrice Parms{};

	Parms.MerchantItem = std::move(MerchantItem);
	Parms.ItemInstance = ItemInstance;

	UObject::ProcessEvent(Func, &Parms);

	if (Price != nullptr)
		*Price = Parms.Price;
}


// Function BP_MerchantComponent.BP_MerchantComponent_C.ComputeItemToSell
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UDataTable*                       ItemsDataTable                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class FName                             ItemRowName                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FS_MerchantItemSellData*         MerchantItemSellData                                   (Parm, OutParm, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_MerchantComponent_C::ComputeItemToSell(class UDataTable* ItemsDataTable, class FName ItemRowName, struct FS_MerchantItemSellData* MerchantItemSellData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MerchantComponent_C", "ComputeItemToSell");

	Params::BP_MerchantComponent_C_ComputeItemToSell Parms{};

	Parms.ItemsDataTable = ItemsDataTable;
	Parms.ItemRowName = ItemRowName;

	UObject::ProcessEvent(Func, &Parms);

	if (MerchantItemSellData != nullptr)
		*MerchantItemSellData = std::move(Parms.MerchantItemSellData);
}


// Function BP_MerchantComponent.BP_MerchantComponent_C.ComputeMerchantItemLevelForLootContext
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

int32 UBP_MerchantComponent_C::ComputeMerchantItemLevelForLootContext()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MerchantComponent_C", "ComputeMerchantItemLevelForLootContext");

	Params::BP_MerchantComponent_C_ComputeMerchantItemLevelForLootContext Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_MerchantComponent.BP_MerchantComponent_C.ComputeMerchantItemLevelWithOverride
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FS_MerchantItemData&       MerchantItemData                                       (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

int32 UBP_MerchantComponent_C::ComputeMerchantItemLevelWithOverride(const struct FS_MerchantItemData& MerchantItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MerchantComponent_C", "ComputeMerchantItemLevelWithOverride");

	Params::BP_MerchantComponent_C_ComputeMerchantItemLevelWithOverride Parms{};

	Parms.MerchantItemData = std::move(MerchantItemData);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_MerchantComponent.BP_MerchantComponent_C.ComputeMerchantState
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_MerchantSaveData*             MerchantState                                          (Parm, OutParm, HasGetValueTypeHash)

void UBP_MerchantComponent_C::ComputeMerchantState(struct FS_MerchantSaveData* MerchantState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MerchantComponent_C", "ComputeMerchantState");

	Params::BP_MerchantComponent_C_ComputeMerchantState Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (MerchantState != nullptr)
		*MerchantState = std::move(Parms.MerchantState);
}


// Function BP_MerchantComponent.BP_MerchantComponent_C.ComputePictoPrice
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class UBP_ItemInstance_Base_C*&   ItemInstance                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// int32*                                  Price                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MerchantComponent_C::ComputePictoPrice(const class UBP_ItemInstance_Base_C*& ItemInstance, int32* Price)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MerchantComponent_C", "ComputePictoPrice");

	Params::BP_MerchantComponent_C_ComputePictoPrice Parms{};

	Parms.ItemInstance = ItemInstance;

	UObject::ProcessEvent(Func, &Parms);

	if (Price != nullptr)
		*Price = Parms.Price;
}


// Function BP_MerchantComponent.BP_MerchantComponent_C.ComputeWeaponPrice
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class UBP_ItemInstance_Base_C*&   ItemInstance                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// int32*                                  Price                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MerchantComponent_C::ComputeWeaponPrice(const class UBP_ItemInstance_Base_C*& ItemInstance, int32* Price)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MerchantComponent_C", "ComputeWeaponPrice");

	Params::BP_MerchantComponent_C_ComputeWeaponPrice Parms{};

	Parms.ItemInstance = ItemInstance;

	UObject::ProcessEvent(Func, &Parms);

	if (Price != nullptr)
		*Price = Parms.Price;
}


// Function BP_MerchantComponent.BP_MerchantComponent_C.CreateItemInstance
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FS_MerchantItemData&       MerchantItem                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// class UBP_ItemInstance_Base_C**         ItemInstance                                           (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_MerchantComponent_C::CreateItemInstance(const struct FS_MerchantItemData& MerchantItem, class UBP_ItemInstance_Base_C** ItemInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MerchantComponent_C", "CreateItemInstance");

	Params::BP_MerchantComponent_C_CreateItemInstance Parms{};

	Parms.MerchantItem = std::move(MerchantItem);

	UObject::ProcessEvent(Func, &Parms);

	if (ItemInstance != nullptr)
		*ItemInstance = Parms.ItemInstance;
}


// Function BP_MerchantComponent.BP_MerchantComponent_C.GetAvailableItems
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TMap<class FName, struct FS_MerchantItemSellData>*AvailableItems_0                                       (Parm, OutParm, ContainsInstancedReference)

void UBP_MerchantComponent_C::GetAvailableItems(TMap<class FName, struct FS_MerchantItemSellData>* AvailableItems_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MerchantComponent_C", "GetAvailableItems");

	Params::BP_MerchantComponent_C_GetAvailableItems Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (AvailableItems_0 != nullptr)
		*AvailableItems_0 = std::move(Parms.AvailableItems_0);
}


// Function BP_MerchantComponent.BP_MerchantComponent_C.GetBuyValueFromScalingTable
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UDataTable*                       Table                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   Level                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MerchantComponent_C::GetBuyValueFromScalingTable(class UDataTable* Table, int32 Level, int32* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MerchantComponent_C", "GetBuyValueFromScalingTable");

	Params::BP_MerchantComponent_C_GetBuyValueFromScalingTable Parms{};

	Parms.Table = Table;
	Parms.Level = Level;

	UObject::ProcessEvent(Func, &Parms);

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function BP_MerchantComponent.BP_MerchantComponent_C.GetConditionDisplayName
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FS_MerchantItemData&       MerchantItemData                                       (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// class FText*                            ConditionDisplayName                                   (Parm, OutParm)

void UBP_MerchantComponent_C::GetConditionDisplayName(const struct FS_MerchantItemData& MerchantItemData, class FText* ConditionDisplayName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MerchantComponent_C", "GetConditionDisplayName");

	Params::BP_MerchantComponent_C_GetConditionDisplayName Parms{};

	Parms.MerchantItemData = std::move(MerchantItemData);

	UObject::ProcessEvent(Func, &Parms);

	if (ConditionDisplayName != nullptr)
		*ConditionDisplayName = std::move(Parms.ConditionDisplayName);
}


// Function BP_MerchantComponent.BP_MerchantComponent_C.GetConditionDisplayTooltip
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FS_MerchantItemData&       MerchantItemData                                       (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// class FText*                            ConditionDisplayTooltip                                (Parm, OutParm)

void UBP_MerchantComponent_C::GetConditionDisplayTooltip(const struct FS_MerchantItemData& MerchantItemData, class FText* ConditionDisplayTooltip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MerchantComponent_C", "GetConditionDisplayTooltip");

	Params::BP_MerchantComponent_C_GetConditionDisplayTooltip Parms{};

	Parms.MerchantItemData = std::move(MerchantItemData);

	UObject::ProcessEvent(Func, &Parms);

	if (ConditionDisplayTooltip != nullptr)
		*ConditionDisplayTooltip = std::move(Parms.ConditionDisplayTooltip);
}


// Function BP_MerchantComponent.BP_MerchantComponent_C.GetItemFromMerchantItemData
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FS_MerchantItemData&       MerchantItem                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// struct FS_jRPG_Item_StaticData*         Item                                                   (Parm, OutParm, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_MerchantComponent_C::GetItemFromMerchantItemData(const struct FS_MerchantItemData& MerchantItem, struct FS_jRPG_Item_StaticData* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MerchantComponent_C", "GetItemFromMerchantItemData");

	Params::BP_MerchantComponent_C_GetItemFromMerchantItemData Parms{};

	Parms.MerchantItem = std::move(MerchantItem);

	UObject::ProcessEvent(Func, &Parms);

	if (Item != nullptr)
		*Item = std::move(Parms.Item);
}


// Function BP_MerchantComponent.BP_MerchantComponent_C.GetItemFromName
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const class FName&                      ItemRowName                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FS_jRPG_Item_StaticData*         Item                                                   (Parm, OutParm, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_MerchantComponent_C::GetItemFromName(const class FName& ItemRowName, struct FS_jRPG_Item_StaticData* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MerchantComponent_C", "GetItemFromName");

	Params::BP_MerchantComponent_C_GetItemFromName Parms{};

	Parms.ItemRowName = ItemRowName;

	UObject::ProcessEvent(Func, &Parms);

	if (Item != nullptr)
		*Item = std::move(Parms.Item);
}


// Function BP_MerchantComponent.BP_MerchantComponent_C.GetRemainingQuantityForItem
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const class FName&                      MerchantItemRowName                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FS_MerchantItemData&       MerchantItem                                           (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// int32*                                  Quantity                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MerchantComponent_C::GetRemainingQuantityForItem(const class FName& MerchantItemRowName, const struct FS_MerchantItemData& MerchantItem, int32* Quantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MerchantComponent_C", "GetRemainingQuantityForItem");

	Params::BP_MerchantComponent_C_GetRemainingQuantityForItem Parms{};

	Parms.MerchantItemRowName = MerchantItemRowName;
	Parms.MerchantItem = std::move(MerchantItem);

	UObject::ProcessEvent(Func, &Parms);

	if (Quantity != nullptr)
		*Quantity = Parms.Quantity;
}


// Function BP_MerchantComponent.BP_MerchantComponent_C.LoadMerchantData
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TMap<class FName, struct FS_MerchantItemSellData>*AvailableItems_0                                       (Parm, OutParm, ContainsInstancedReference)

void UBP_MerchantComponent_C::LoadMerchantData(TMap<class FName, struct FS_MerchantItemSellData>* AvailableItems_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MerchantComponent_C", "LoadMerchantData");

	Params::BP_MerchantComponent_C_LoadMerchantData Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (AvailableItems_0 != nullptr)
		*AvailableItems_0 = std::move(Parms.AvailableItems_0);
}


// Function BP_MerchantComponent.BP_MerchantComponent_C.ReadMerchantState
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FS_MerchantSaveData*             State                                                  (Parm, OutParm, HasGetValueTypeHash)

void UBP_MerchantComponent_C::ReadMerchantState(struct FS_MerchantSaveData* State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MerchantComponent_C", "ReadMerchantState");

	Params::BP_MerchantComponent_C_ReadMerchantState Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (State != nullptr)
		*State = std::move(Parms.State);
}


// Function BP_MerchantComponent.BP_MerchantComponent_C.SaveMerchantState
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_MerchantComponent_C::SaveMerchantState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MerchantComponent_C", "SaveMerchantState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_MerchantComponent.BP_MerchantComponent_C.SetupLevelForItemInstanceGear
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FS_MerchantItemData&       MerchantItemData                                       (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// class UBP_ItemInstance_Gear_C*          ItemInstance                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_MerchantComponent_C::SetupLevelForItemInstanceGear(const struct FS_MerchantItemData& MerchantItemData, class UBP_ItemInstance_Gear_C* ItemInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MerchantComponent_C", "SetupLevelForItemInstanceGear");

	Params::BP_MerchantComponent_C_SetupLevelForItemInstanceGear Parms{};

	Parms.MerchantItemData = std::move(MerchantItemData);
	Parms.ItemInstance = ItemInstance;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_MerchantComponent.BP_MerchantComponent_C.StartMerchantBattle
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FS_jRPG_PartySlot>&       BattlePaty                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBP_MerchantComponent_C::StartMerchantBattle(TArray<struct FS_jRPG_PartySlot>& BattlePaty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MerchantComponent_C", "StartMerchantBattle");

	Params::BP_MerchantComponent_C_StartMerchantBattle Parms{};

	Parms.BattlePaty = std::move(BattlePaty);

	UObject::ProcessEvent(Func, &Parms);

	BattlePaty = std::move(Parms.BattlePaty);
}


// Function BP_MerchantComponent.BP_MerchantComponent_C.TryBuyItem
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             MerchantItemRowName                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_MerchantComponent_C::TryBuyItem(class FName MerchantItemRowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MerchantComponent_C", "TryBuyItem");

	Params::BP_MerchantComponent_C_TryBuyItem Parms{};

	Parms.MerchantItemRowName = MerchantItemRowName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}

}

