#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_Chest_Regular

#include "Basic.hpp"

#include "BP_Chest_Regular_classes.hpp"
#include "BP_Chest_Regular_parameters.hpp"


namespace SDK
{

// Function BP_Chest_Regular.BP_Chest_Regular_C.AddItemsFromChestToInventory
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Chest_Regular_C::AddItemsFromChestToInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Chest_Regular_C", "AddItemsFromChestToInventory");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Chest_Regular.BP_Chest_Regular_C.CanInteractWithMount
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   CanInteract                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Chest_Regular_C::CanInteractWithMount(bool* CanInteract)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Chest_Regular_C", "CanInteractWithMount");

	Params::BP_Chest_Regular_C_CanInteractWithMount Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CanInteract != nullptr)
		*CanInteract = Parms.CanInteract;
}


// Function BP_Chest_Regular.BP_Chest_Regular_C.CheckForErrors
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FText>&                    ErrorMessages                                          (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_Chest_Regular_C::CheckForErrors(TArray<class FText>& ErrorMessages)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Chest_Regular_C", "CheckForErrors");

	Params::BP_Chest_Regular_C_CheckForErrors Parms{};

	Parms.ErrorMessages = std::move(ErrorMessages);

	UObject::ProcessEvent(Func, &Parms);

	ErrorMessages = std::move(Parms.ErrorMessages);

	return Parms.ReturnValue;
}


// Function BP_Chest_Regular.BP_Chest_Regular_C.CompareItemTypesForFeedback
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_jRPG_ItemType                         Existing                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_jRPG_ItemType                         New                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsBetter                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Chest_Regular_C::CompareItemTypesForFeedback(E_jRPG_ItemType Existing, E_jRPG_ItemType New, bool* IsBetter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Chest_Regular_C", "CompareItemTypesForFeedback");

	Params::BP_Chest_Regular_C_CompareItemTypesForFeedback Parms{};

	Parms.Existing = Existing;
	Parms.New = New;

	UObject::ProcessEvent(Func, &Parms);

	if (IsBetter != nullptr)
		*IsBetter = Parms.IsBetter;
}


// Function BP_Chest_Regular.BP_Chest_Regular_C.ComputeChestDominantItemType
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_jRPG_ItemType*                        ItemType                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Chest_Regular_C::ComputeChestDominantItemType(E_jRPG_ItemType* ItemType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Chest_Regular_C", "ComputeChestDominantItemType");

	Params::BP_Chest_Regular_C_ComputeChestDominantItemType Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ItemType != nullptr)
		*ItemType = Parms.ItemType;
}


// Function BP_Chest_Regular.BP_Chest_Regular_C.ComputeChestLootContext
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FS_LootContext*                  S_LootContext                                          (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Chest_Regular_C::ComputeChestLootContext(struct FS_LootContext* S_LootContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Chest_Regular_C", "ComputeChestLootContext");

	Params::BP_Chest_Regular_C_ComputeChestLootContext Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (S_LootContext != nullptr)
		*S_LootContext = std::move(Parms.S_LootContext);
}


// Function BP_Chest_Regular.BP_Chest_Regular_C.ComputeChestLootTableSections
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FS_LootTableSection>*     LootTableSections                                      (Parm, OutParm)
// double*                                 RollChanceMultipler                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Chest_Regular_C::ComputeChestLootTableSections(TArray<struct FS_LootTableSection>* LootTableSections, double* RollChanceMultipler)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Chest_Regular_C", "ComputeChestLootTableSections");

	Params::BP_Chest_Regular_C_ComputeChestLootTableSections Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (LootTableSections != nullptr)
		*LootTableSections = std::move(Parms.LootTableSections);

	if (RollChanceMultipler != nullptr)
		*RollChanceMultipler = Parms.RollChanceMultipler;
}


// Function BP_Chest_Regular.BP_Chest_Regular_C.ComputeEncounterLevelOverride
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

int32 ABP_Chest_Regular_C::ComputeEncounterLevelOverride()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Chest_Regular_C", "ComputeEncounterLevelOverride");

	Params::BP_Chest_Regular_C_ComputeEncounterLevelOverride Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Chest_Regular.BP_Chest_Regular_C.ComputePreviewChestItemType
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_jRPG_ItemType*                        ItemType                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Chest_Regular_C::ComputePreviewChestItemType(E_jRPG_ItemType* ItemType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Chest_Regular_C", "ComputePreviewChestItemType");

	Params::BP_Chest_Regular_C_ComputePreviewChestItemType Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ItemType != nullptr)
		*ItemType = Parms.ItemType;
}


// Function BP_Chest_Regular.BP_Chest_Regular_C.ConstructInteractionPopUpText
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FText*                            PopUpText                                              (Parm, OutParm)
// class FText*                            Item_Description1                                      (Parm, OutParm)
// class UTexture2D**                      Item_Icon1                                             (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32*                                  Items_amount1                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Chest_Regular_C::ConstructInteractionPopUpText(class FText* PopUpText, class FText* Item_Description1, class UTexture2D** Item_Icon1, int32* Items_amount1)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Chest_Regular_C", "ConstructInteractionPopUpText");

	Params::BP_Chest_Regular_C_ConstructInteractionPopUpText Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PopUpText != nullptr)
		*PopUpText = std::move(Parms.PopUpText);

	if (Item_Description1 != nullptr)
		*Item_Description1 = std::move(Parms.Item_Description1);

	if (Item_Icon1 != nullptr)
		*Item_Icon1 = Parms.Item_Icon1;

	if (Items_amount1 != nullptr)
		*Items_amount1 = Parms.Items_amount1;
}


// Function BP_Chest_Regular.BP_Chest_Regular_C.ExecuteUbergraph_BP_Chest_Regular
// (Final, UbergraphFunction)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Chest_Regular_C::ExecuteUbergraph_BP_Chest_Regular(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Chest_Regular_C", "ExecuteUbergraph_BP_Chest_Regular");

	Params::BP_Chest_Regular_C_ExecuteUbergraph_BP_Chest_Regular Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Chest_Regular.BP_Chest_Regular_C.FindDuplicateID
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_Chest_Regular_C::FindDuplicateID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Chest_Regular_C", "FindDuplicateID");

	Params::BP_Chest_Regular_C_FindDuplicateID Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Chest_Regular.BP_Chest_Regular_C.GenerateObjectID
// (Private, BlueprintCallable, BlueprintEvent)

void ABP_Chest_Regular_C::GenerateObjectID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Chest_Regular_C", "GenerateObjectID");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Chest_Regular.BP_Chest_Regular_C.GetInteractionPromptParams
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FFPromptParams*                  PromptParams                                           (Parm, OutParm, HasGetValueTypeHash)

void ABP_Chest_Regular_C::GetInteractionPromptParams(struct FFPromptParams* PromptParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Chest_Regular_C", "GetInteractionPromptParams");

	Params::BP_Chest_Regular_C_GetInteractionPromptParams Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PromptParams != nullptr)
		*PromptParams = std::move(Parms.PromptParams);
}


// Function BP_Chest_Regular.BP_Chest_Regular_C.GetItemTypeScore
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_jRPG_ItemType                         ItemType                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

int32 ABP_Chest_Regular_C::GetItemTypeScore(E_jRPG_ItemType ItemType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Chest_Regular_C", "GetItemTypeScore");

	Params::BP_Chest_Regular_C_GetItemTypeScore Parms{};

	Parms.ItemType = ItemType;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Chest_Regular.BP_Chest_Regular_C.GetSectionsFromLootTableReferences
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FLootTableReference>&     LootTableReferences_0                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FS_LootTableSection>*     LootTableSections                                      (Parm, OutParm)

void ABP_Chest_Regular_C::GetSectionsFromLootTableReferences(TArray<struct FLootTableReference>& LootTableReferences_0, TArray<struct FS_LootTableSection>* LootTableSections)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Chest_Regular_C", "GetSectionsFromLootTableReferences");

	Params::BP_Chest_Regular_C_GetSectionsFromLootTableReferences Parms{};

	Parms.LootTableReferences_0 = std::move(LootTableReferences_0);

	UObject::ProcessEvent(Func, &Parms);

	LootTableReferences_0 = std::move(Parms.LootTableReferences_0);

	if (LootTableSections != nullptr)
		*LootTableSections = std::move(Parms.LootTableSections);
}


// Function BP_Chest_Regular.BP_Chest_Regular_C.OnInteractionRequested
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_jRPG_Character_World_C*       InteractingWorldCharacter                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Instant                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Chest_Regular_C::OnInteractionRequested(class ABP_jRPG_Character_World_C* InteractingWorldCharacter, bool Instant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Chest_Regular_C", "OnInteractionRequested");

	Params::BP_Chest_Regular_C_OnInteractionRequested Parms{};

	Parms.InteractingWorldCharacter = InteractingWorldCharacter;
	Parms.Instant = Instant;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Chest_Regular.BP_Chest_Regular_C.OnLoaded_3A9C66874010891688933A9C2368EED3
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Loaded                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Chest_Regular_C::OnLoaded_3A9C66874010891688933A9C2368EED3(class UObject* Loaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Chest_Regular_C", "OnLoaded_3A9C66874010891688933A9C2368EED3");

	Params::BP_Chest_Regular_C_OnLoaded_3A9C66874010891688933A9C2368EED3 Parms{};

	Parms.Loaded = Loaded;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Chest_Regular.BP_Chest_Regular_C.OnObjectInteractionStateLoaded
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    InteractionState                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Chest_Regular_C::OnObjectInteractionStateLoaded(bool InteractionState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Chest_Regular_C", "OnObjectInteractionStateLoaded");

	Params::BP_Chest_Regular_C_OnObjectInteractionStateLoaded Parms{};

	Parms.InteractionState = InteractionState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Chest_Regular.BP_Chest_Regular_C.PlayForceFeedback
// (BlueprintCallable, BlueprintEvent)

void ABP_Chest_Regular_C::PlayForceFeedback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Chest_Regular_C", "PlayForceFeedback");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Chest_Regular.BP_Chest_Regular_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void ABP_Chest_Regular_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Chest_Regular_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Chest_Regular.BP_Chest_Regular_C.RollChestItems
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FS_LootContext&            LootContext                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TMap<class FName, int32>*               ItemsToLoot_0                                          (Parm, OutParm)

void ABP_Chest_Regular_C::RollChestItems(const struct FS_LootContext& LootContext, TMap<class FName, int32>* ItemsToLoot_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Chest_Regular_C", "RollChestItems");

	Params::BP_Chest_Regular_C_RollChestItems Parms{};

	Parms.LootContext = std::move(LootContext);

	UObject::ProcessEvent(Func, &Parms);

	if (ItemsToLoot_0 != nullptr)
		*ItemsToLoot_0 = std::move(Parms.ItemsToLoot_0);
}


// Function BP_Chest_Regular.BP_Chest_Regular_C.UpdateFeedbackParameters
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FS_ChestFeedbackParameters&ChestFeedbackParameters                                (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_Chest_Regular_C::UpdateFeedbackParameters(const struct FS_ChestFeedbackParameters& ChestFeedbackParameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Chest_Regular_C", "UpdateFeedbackParameters");

	Params::BP_Chest_Regular_C_UpdateFeedbackParameters Parms{};

	Parms.ChestFeedbackParameters = std::move(ChestFeedbackParameters);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Chest_Regular.BP_Chest_Regular_C.UpdateFeedbackParametersFromLoot
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Chest_Regular_C::UpdateFeedbackParametersFromLoot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Chest_Regular_C", "UpdateFeedbackParametersFromLoot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Chest_Regular.BP_Chest_Regular_C.UpdateVisuals
// (Protected, BlueprintCallable, BlueprintEvent)

void ABP_Chest_Regular_C::UpdateVisuals()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Chest_Regular_C", "UpdateVisuals");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Chest_Regular.BP_Chest_Regular_C.UserConstructionScript
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ABP_Chest_Regular_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Chest_Regular_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Chest_Regular.BP_Chest_Regular_C.GetInteractionLocation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// struct FVector*                         Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Chest_Regular_C::GetInteractionLocation(struct FVector* Location) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Chest_Regular_C", "GetInteractionLocation");

	Params::BP_Chest_Regular_C_GetInteractionLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Location != nullptr)
		*Location = std::move(Parms.Location);
}

}

