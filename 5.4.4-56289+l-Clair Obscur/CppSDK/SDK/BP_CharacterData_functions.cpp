#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_CharacterData

#include "Basic.hpp"

#include "BP_CharacterData_classes.hpp"
#include "BP_CharacterData_parameters.hpp"


namespace SDK
{

// Function BP_CharacterData.BP_CharacterData_C.AddExperience
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   XP                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::AddExperience(int32 XP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "AddExperience");

	Params::BP_CharacterData_C_AddExperience Parms{};

	Parms.XP = XP;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.AddLuminaPointFromConsumable
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_CharacterData_C::AddLuminaPointFromConsumable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "AddLuminaPointFromConsumable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_CharacterData.BP_CharacterData_C.ApplyCharacterCustomizationItem
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ItemName                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::ApplyCharacterCustomizationItem(class FName ItemName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "ApplyCharacterCustomizationItem");

	Params::BP_CharacterData_C_ApplyCharacterCustomizationItem Parms{};

	Parms.ItemName = ItemName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.AssignPointToAttribute
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// ECharacterAttribute                     Attribute                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::AssignPointToAttribute(ECharacterAttribute Attribute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "AssignPointToAttribute");

	Params::BP_CharacterData_C_AssignPointToAttribute Parms{};

	Parms.Attribute = Attribute;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.BPI_GetDependencies
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<TSoftClassPtr<class UClass>>*    Classes                                                (Parm, OutParm)
// TArray<TSoftObjectPtr<class UObject>>*  Assets                                                 (Parm, OutParm)
// TArray<TScriptInterface<class IBPI_LoadingDependenciesSource_C>>*ExternalDependencies                                   (Parm, OutParm)

void UBP_CharacterData_C::BPI_GetDependencies(TArray<TSoftClassPtr<class UClass>>* Classes, TArray<TSoftObjectPtr<class UObject>>* Assets, TArray<TScriptInterface<class IBPI_LoadingDependenciesSource_C>>* ExternalDependencies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "BPI_GetDependencies");

	Params::BP_CharacterData_C_BPI_GetDependencies Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Classes != nullptr)
		*Classes = std::move(Parms.Classes);

	if (Assets != nullptr)
		*Assets = std::move(Parms.Assets);

	if (ExternalDependencies != nullptr)
		*ExternalDependencies = std::move(Parms.ExternalDependencies);
}


// Function BP_CharacterData.BP_CharacterData_C.CanAffordLuminaCost
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   LuminaCost                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_CharacterData_C::CanAffordLuminaCost(int32 LuminaCost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "CanAffordLuminaCost");

	Params::BP_CharacterData_C_CanAffordLuminaCost Parms{};

	Parms.LuminaCost = LuminaCost;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_CharacterData.BP_CharacterData_C.CanAffordSkillUnlock
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UBP_DataAsset_Skill_C*            Skill                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_CharacterData_C::CanAffordSkillUnlock(class UBP_DataAsset_Skill_C* Skill)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "CanAffordSkillUnlock");

	Params::BP_CharacterData_C_CanAffordSkillUnlock Parms{};

	Parms.Skill = Skill;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_CharacterData.BP_CharacterData_C.CanEquipItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FS_jRPG_Item_StaticData&   ItemData                                               (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_CharacterData_C::CanEquipItem(const struct FS_jRPG_Item_StaticData& ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "CanEquipItem");

	Params::BP_CharacterData_C_CanEquipItem Parms{};

	Parms.ItemData = std::move(ItemData);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_CharacterData.BP_CharacterData_C.CanEquipLuminaPassive
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FFPassiveEffect&           PassiveEffectDefinition                                (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// const struct FFPassiveEffectProgression&PassiveEffectProgression                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  EffectiveCost                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_CharacterData_C::CanEquipLuminaPassive(const struct FFPassiveEffect& PassiveEffectDefinition, const struct FFPassiveEffectProgression& PassiveEffectProgression, int32* EffectiveCost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "CanEquipLuminaPassive");

	Params::BP_CharacterData_C_CanEquipLuminaPassive Parms{};

	Parms.PassiveEffectDefinition = std::move(PassiveEffectDefinition);
	Parms.PassiveEffectProgression = std::move(PassiveEffectProgression);

	UObject::ProcessEvent(Func, &Parms);

	if (EffectiveCost != nullptr)
		*EffectiveCost = Parms.EffectiveCost;

	return Parms.ReturnValue;
}


// Function BP_CharacterData.BP_CharacterData_C.CanLearnSkill
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const class UBP_DataAsset_Skill_C*&     Skill                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ELearnSkillBlockedReason*               BlockedReason                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_CharacterData_C::CanLearnSkill(const class UBP_DataAsset_Skill_C*& Skill, ELearnSkillBlockedReason* BlockedReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "CanLearnSkill");

	Params::BP_CharacterData_C_CanLearnSkill Parms{};

	Parms.Skill = Skill;

	UObject::ProcessEvent(Func, &Parms);

	if (BlockedReason != nullptr)
		*BlockedReason = Parms.BlockedReason;

	return Parms.ReturnValue;
}


// Function BP_CharacterData.BP_CharacterData_C.CanLearnSkill_OLD
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const class UBP_DataAsset_Skill_C*&     Skill                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ELearnSkillBlockedReason*               BlockedReason                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_CharacterData_C::CanLearnSkill_OLD(const class UBP_DataAsset_Skill_C*& Skill, ELearnSkillBlockedReason* BlockedReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "CanLearnSkill_OLD");

	Params::BP_CharacterData_C_CanLearnSkill_OLD Parms{};

	Parms.Skill = Skill;

	UObject::ProcessEvent(Func, &Parms);

	if (BlockedReason != nullptr)
		*BlockedReason = Parms.BlockedReason;

	return Parms.ReturnValue;
}


// Function BP_CharacterData.BP_CharacterData_C.CanUpdateInternals
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_CharacterData_C::CanUpdateInternals()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "CanUpdateInternals");

	Params::BP_CharacterData_C_CanUpdateInternals Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_CharacterData.BP_CharacterData_C.CanUseGearPassiveEffects
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UBP_ItemInstance_Base_C*          ItemInstance                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_CharacterData_C::CanUseGearPassiveEffects(class UBP_ItemInstance_Base_C* ItemInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "CanUseGearPassiveEffects");

	Params::BP_CharacterData_C_CanUseGearPassiveEffects Parms{};

	Parms.ItemInstance = ItemInstance;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_CharacterData.BP_CharacterData_C.CanUseWeaponPassiveEffects
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_CharacterData_C::CanUseWeaponPassiveEffects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "CanUseWeaponPassiveEffects");

	Params::BP_CharacterData_C_CanUseWeaponPassiveEffects Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_CharacterData.BP_CharacterData_C.ComputeAttributeStats
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TMap<ECharacterAttribute, int32>& AssignedAttributes                                     (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBP_CharacterData_C::ComputeAttributeStats(const TMap<ECharacterAttribute, int32>& AssignedAttributes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "ComputeAttributeStats");

	Params::BP_CharacterData_C_ComputeAttributeStats Parms{};

	Parms.AssignedAttributes = std::move(AssignedAttributes);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.ComputeEquipmentStats
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TMap<struct FFEquipmentSlot, class UBP_ItemInstance_Gear_C*>&EquipmentInstances                                     (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TMap<E_jRPG_StatType, double>*          EquipmentStats_0                                       (Parm, OutParm)

void UBP_CharacterData_C::ComputeEquipmentStats(const TMap<struct FFEquipmentSlot, class UBP_ItemInstance_Gear_C*>& EquipmentInstances, TMap<E_jRPG_StatType, double>* EquipmentStats_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "ComputeEquipmentStats");

	Params::BP_CharacterData_C_ComputeEquipmentStats Parms{};

	Parms.EquipmentInstances = std::move(EquipmentInstances);

	UObject::ProcessEvent(Func, &Parms);

	if (EquipmentStats_0 != nullptr)
		*EquipmentStats_0 = std::move(Parms.EquipmentStats_0);
}


// Function BP_CharacterData.BP_CharacterData_C.ComputeStatsFromParts
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TMap<E_jRPG_StatType, double>&    base                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// const TMap<E_jRPG_StatType, double>&    Leveling                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// const TMap<E_jRPG_StatType, double>&    Equipment                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// const TMap<E_jRPG_StatType, double>&    Attributes                                             (BlueprintVisible, BlueprintReadOnly, Parm)
// TMap<E_jRPG_StatType, double>*          ComputedStats_0                                        (Parm, OutParm)

void UBP_CharacterData_C::ComputeStatsFromParts(const TMap<E_jRPG_StatType, double>& base, const TMap<E_jRPG_StatType, double>& Leveling, const TMap<E_jRPG_StatType, double>& Equipment, const TMap<E_jRPG_StatType, double>& Attributes, TMap<E_jRPG_StatType, double>* ComputedStats_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "ComputeStatsFromParts");

	Params::BP_CharacterData_C_ComputeStatsFromParts Parms{};

	Parms.base = std::move(base);
	Parms.Leveling = std::move(Leveling);
	Parms.Equipment = std::move(Equipment);
	Parms.Attributes = std::move(Attributes);

	UObject::ProcessEvent(Func, &Parms);

	if (ComputedStats_0 != nullptr)
		*ComputedStats_0 = std::move(Parms.ComputedStats_0);
}


// Function BP_CharacterData.BP_CharacterData_C.CreateCopy
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_CharacterData_C*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash)

class UBP_CharacterData_C* UBP_CharacterData_C::CreateCopy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "CreateCopy");

	Params::BP_CharacterData_C_CreateCopy Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_CharacterData.BP_CharacterData_C.DEBUG_CVarChange_IgnoreLuminaCost
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NewValue                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::DEBUG_CVarChange_IgnoreLuminaCost(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "DEBUG_CVarChange_IgnoreLuminaCost");

	Params::BP_CharacterData_C_DEBUG_CVarChange_IgnoreLuminaCost Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.DEBUG_ForceProgressEquippedLumina
// (BlueprintCallable, BlueprintEvent)

void UBP_CharacterData_C::DEBUG_ForceProgressEquippedLumina()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "DEBUG_ForceProgressEquippedLumina");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_CharacterData.BP_CharacterData_C.DEBUG_UnlockAllLuminaPassives
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_CharacterData_C::DEBUG_UnlockAllLuminaPassives()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "DEBUG_UnlockAllLuminaPassives");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_CharacterData.BP_CharacterData_C.DispatchModificationsIfPossible
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    DebugReason                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UBP_CharacterData_C::DispatchModificationsIfPossible(const class FString& DebugReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "DispatchModificationsIfPossible");

	Params::BP_CharacterData_C_DispatchModificationsIfPossible Parms{};

	Parms.DebugReason = std::move(DebugReason);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.DoEquippedItemsGivePassiveEffect
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             PassiveEffectID                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   GivePassiveEffect                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::DoEquippedItemsGivePassiveEffect(class FName PassiveEffectID, bool* GivePassiveEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "DoEquippedItemsGivePassiveEffect");

	Params::BP_CharacterData_C_DoEquippedItemsGivePassiveEffect Parms{};

	Parms.PassiveEffectID = PassiveEffectID;

	UObject::ProcessEvent(Func, &Parms);

	if (GivePassiveEffect != nullptr)
		*GivePassiveEffect = Parms.GivePassiveEffect;
}


// Function BP_CharacterData.BP_CharacterData_C.EquipItemInSlot
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FFEquipmentSlot&           Slot                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FS_jRPG_Item_StaticData&         Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_CharacterData_C::EquipItemInSlot(const struct FFEquipmentSlot& Slot, struct FS_jRPG_Item_StaticData& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "EquipItemInSlot");

	Params::BP_CharacterData_C_EquipItemInSlot Parms{};

	Parms.Slot = std::move(Slot);
	Parms.Item = std::move(Item);

	UObject::ProcessEvent(Func, &Parms);

	Item = std::move(Parms.Item);
}


// Function BP_CharacterData.BP_CharacterData_C.EquipItemInstanceInSlot
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FFEquipmentSlot&           Slot                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UBP_ItemInstance_Gear_C*          Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::EquipItemInstanceInSlot(const struct FFEquipmentSlot& Slot, class UBP_ItemInstance_Gear_C* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "EquipItemInstanceInSlot");

	Params::BP_CharacterData_C_EquipItemInstanceInSlot Parms{};

	Parms.Slot = std::move(Slot);
	Parms.Item = Item;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.EquipLuminaPassive
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Name_0                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::EquipLuminaPassive(class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "EquipLuminaPassive");

	Params::BP_CharacterData_C_EquipLuminaPassive Parms{};

	Parms.Name_0 = Name_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.EquipMissingLuminaPassivesFromItemInstance
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_ItemInstance_Gear_C*          ItemInstance                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::EquipMissingLuminaPassivesFromItemInstance(class UBP_ItemInstance_Gear_C* ItemInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "EquipMissingLuminaPassivesFromItemInstance");

	Params::BP_CharacterData_C_EquipMissingLuminaPassivesFromItemInstance Parms{};

	Parms.ItemInstance = ItemInstance;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.EquipMissingLuminaPassivesFromItems
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_jRPG_Item_StaticData&         Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_CharacterData_C::EquipMissingLuminaPassivesFromItems(struct FS_jRPG_Item_StaticData& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "EquipMissingLuminaPassivesFromItems");

	Params::BP_CharacterData_C_EquipMissingLuminaPassivesFromItems Parms{};

	Parms.Item = std::move(Item);

	UObject::ProcessEvent(Func, &Parms);

	Item = std::move(Parms.Item);
}


// Function BP_CharacterData.BP_CharacterData_C.EquipSkill
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_DataAsset_Skill_C*            SkillID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::EquipSkill(class UBP_DataAsset_Skill_C* SkillID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "EquipSkill");

	Params::BP_CharacterData_C_EquipSkill Parms{};

	Parms.SkillID = SkillID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.Error_PassiveEffectNotFoundInDT
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Name_0                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::Error_PassiveEffectNotFoundInDT(class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "Error_PassiveEffectNotFoundInDT");

	Params::BP_CharacterData_C_Error_PassiveEffectNotFoundInDT Parms{};

	Parms.Name_0 = Name_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.ExecuteUbergraph_BP_CharacterData
// (Final, UbergraphFunction)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::ExecuteUbergraph_BP_CharacterData(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "ExecuteUbergraph_BP_CharacterData");

	Params::BP_CharacterData_C_ExecuteUbergraph_BP_CharacterData Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.FlushDeferredUpdate
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_CharacterData_C::FlushDeferredUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "FlushDeferredUpdate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_CharacterData.BP_CharacterData_C.Get Weapon Power
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FS_WeaponInstanceData&     WeaponInstanceData                                     (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// int32*                                  PhysicalPower                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  MagicalPower                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  BasePhysicalPower                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  BaseMagicalPower                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  ScalingPhysicalPower                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  ScalingMagicalPower                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::Get_Weapon_Power(const struct FS_WeaponInstanceData& WeaponInstanceData, int32* PhysicalPower, int32* MagicalPower, int32* BasePhysicalPower, int32* BaseMagicalPower, int32* ScalingPhysicalPower, int32* ScalingMagicalPower)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "Get Weapon Power");

	Params::BP_CharacterData_C_Get_Weapon_Power Parms{};

	Parms.WeaponInstanceData = std::move(WeaponInstanceData);

	UObject::ProcessEvent(Func, &Parms);

	if (PhysicalPower != nullptr)
		*PhysicalPower = Parms.PhysicalPower;

	if (MagicalPower != nullptr)
		*MagicalPower = Parms.MagicalPower;

	if (BasePhysicalPower != nullptr)
		*BasePhysicalPower = Parms.BasePhysicalPower;

	if (BaseMagicalPower != nullptr)
		*BaseMagicalPower = Parms.BaseMagicalPower;

	if (ScalingPhysicalPower != nullptr)
		*ScalingPhysicalPower = Parms.ScalingPhysicalPower;

	if (ScalingMagicalPower != nullptr)
		*ScalingMagicalPower = Parms.ScalingMagicalPower;
}


// Function BP_CharacterData.BP_CharacterData_C.GetActionsOrder
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class FName>*                    CharacterActionsOrder                                  (Parm, OutParm)

void UBP_CharacterData_C::GetActionsOrder(TArray<class FName>* CharacterActionsOrder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetActionsOrder");

	Params::BP_CharacterData_C_GetActionsOrder Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CharacterActionsOrder != nullptr)
		*CharacterActionsOrder = std::move(Parms.CharacterActionsOrder);
}


// Function BP_CharacterData.BP_CharacterData_C.GetAllEquipmentSlotTypes
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FFEquipmentSlot>*         EquipmentSlots                                         (Parm, OutParm)

void UBP_CharacterData_C::GetAllEquipmentSlotTypes(TArray<struct FFEquipmentSlot>* EquipmentSlots)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetAllEquipmentSlotTypes");

	Params::BP_CharacterData_C_GetAllEquipmentSlotTypes Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (EquipmentSlots != nullptr)
		*EquipmentSlots = std::move(Parms.EquipmentSlots);
}


// Function BP_CharacterData.BP_CharacterData_C.GetAllowedEquipmentSubtypes
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TSet<E_jRPG_ItemSubtype>*               AllowedEquipmentSubtypes                               (Parm, OutParm)

void UBP_CharacterData_C::GetAllowedEquipmentSubtypes(TSet<E_jRPG_ItemSubtype>* AllowedEquipmentSubtypes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetAllowedEquipmentSubtypes");

	Params::BP_CharacterData_C_GetAllowedEquipmentSubtypes Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (AllowedEquipmentSubtypes != nullptr)
		*AllowedEquipmentSubtypes = std::move(Parms.AllowedEquipmentSubtypes);
}


// Function BP_CharacterData.BP_CharacterData_C.GetArmUITexture
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash)

class UTexture2D* UBP_CharacterData_C::GetArmUITexture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetArmUITexture");

	Params::BP_CharacterData_C_GetArmUITexture Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_CharacterData.BP_CharacterData_C.GetAssignedAttributePoints
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const ECharacterAttribute               Attribute                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::GetAssignedAttributePoints(const ECharacterAttribute Attribute, int32* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetAssignedAttributePoints");

	Params::BP_CharacterData_C_GetAssignedAttributePoints Parms{};

	Parms.Attribute = Attribute;

	UObject::ProcessEvent(Func, &Parms);

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function BP_CharacterData.BP_CharacterData_C.GetAttributePointsToAssign
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

int32 UBP_CharacterData_C::GetAttributePointsToAssign()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetAttributePointsToAssign");

	Params::BP_CharacterData_C_GetAttributePointsToAssign Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_CharacterData.BP_CharacterData_C.GetAttributeStats
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TMap<E_jRPG_StatType, double>*          EquipmentStats_0                                       (Parm, OutParm)

void UBP_CharacterData_C::GetAttributeStats(TMap<E_jRPG_StatType, double>* EquipmentStats_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetAttributeStats");

	Params::BP_CharacterData_C_GetAttributeStats Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (EquipmentStats_0 != nullptr)
		*EquipmentStats_0 = std::move(Parms.EquipmentStats_0);
}


// Function BP_CharacterData.BP_CharacterData_C.GetAudioProfile_Battle
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FFCharacterBattleAudioProfile*   BattleAudioProfile                                     (Parm, OutParm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_CharacterData_C::GetAudioProfile_Battle(struct FFCharacterBattleAudioProfile* BattleAudioProfile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetAudioProfile_Battle");

	Params::BP_CharacterData_C_GetAudioProfile_Battle Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (BattleAudioProfile != nullptr)
		*BattleAudioProfile = std::move(Parms.BattleAudioProfile);
}


// Function BP_CharacterData.BP_CharacterData_C.GetAudioProfile_Exploration
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UBP_DataAsset_CharacterExplorationAudioProfile_C*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash)

class UBP_DataAsset_CharacterExplorationAudioProfile_C* UBP_CharacterData_C::GetAudioProfile_Exploration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetAudioProfile_Exploration");

	Params::BP_CharacterData_C_GetAudioProfile_Exploration Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_CharacterData.BP_CharacterData_C.GetAvailableLuminaPoints
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

int32 UBP_CharacterData_C::GetAvailableLuminaPoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetAvailableLuminaPoints");

	Params::BP_CharacterData_C_GetAvailableLuminaPoints Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_CharacterData.BP_CharacterData_C.GetAvailablePassiveEffects
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FName>*                    PassiveEffectIDs                                       (Parm, OutParm)
// TArray<class FName>*                    EquipmentPassiveEffectIDs                              (Parm, OutParm)
// TArray<class FName>*                    LearntPassiveEffectIDs                                 (Parm, OutParm)

void UBP_CharacterData_C::GetAvailablePassiveEffects(TArray<class FName>* PassiveEffectIDs, TArray<class FName>* EquipmentPassiveEffectIDs, TArray<class FName>* LearntPassiveEffectIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetAvailablePassiveEffects");

	Params::BP_CharacterData_C_GetAvailablePassiveEffects Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PassiveEffectIDs != nullptr)
		*PassiveEffectIDs = std::move(Parms.PassiveEffectIDs);

	if (EquipmentPassiveEffectIDs != nullptr)
		*EquipmentPassiveEffectIDs = std::move(Parms.EquipmentPassiveEffectIDs);

	if (LearntPassiveEffectIDs != nullptr)
		*LearntPassiveEffectIDs = std::move(Parms.LearntPassiveEffectIDs);
}


// Function BP_CharacterData.BP_CharacterData_C.GetAvailablePassiveEffectsForSlots
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FFEquipmentSlot>&         Slots                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<class FName>*                    PassiveEffectIDs                                       (Parm, OutParm)

void UBP_CharacterData_C::GetAvailablePassiveEffectsForSlots(TArray<struct FFEquipmentSlot>& Slots, TArray<class FName>* PassiveEffectIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetAvailablePassiveEffectsForSlots");

	Params::BP_CharacterData_C_GetAvailablePassiveEffectsForSlots Parms{};

	Parms.Slots = std::move(Slots);

	UObject::ProcessEvent(Func, &Parms);

	Slots = std::move(Parms.Slots);

	if (PassiveEffectIDs != nullptr)
		*PassiveEffectIDs = std::move(Parms.PassiveEffectIDs);
}


// Function BP_CharacterData.BP_CharacterData_C.GetAvailableSkillPoints
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

int32 UBP_CharacterData_C::GetAvailableSkillPoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetAvailableSkillPoints");

	Params::BP_CharacterData_C_GetAvailableSkillPoints Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_CharacterData.BP_CharacterData_C.GetBaseStats
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TMap<E_jRPG_StatType, double>*          CharacterStats                                         (Parm, OutParm)

void UBP_CharacterData_C::GetBaseStats(TMap<E_jRPG_StatType, double>* CharacterStats)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetBaseStats");

	Params::BP_CharacterData_C_GetBaseStats Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CharacterStats != nullptr)
		*CharacterStats = std::move(Parms.CharacterStats);
}


// Function BP_CharacterData.BP_CharacterData_C.GetBattleAudioProfile
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FFCharacterBattleAudioProfile*   BattleAudioProfile                                     (Parm, OutParm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_CharacterData_C::GetBattleAudioProfile(struct FFCharacterBattleAudioProfile* BattleAudioProfile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetBattleAudioProfile");

	Params::BP_CharacterData_C_GetBattleAudioProfile Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (BattleAudioProfile != nullptr)
		*BattleAudioProfile = std::move(Parms.BattleAudioProfile);
}


// Function BP_CharacterData.BP_CharacterData_C.GetBattleIcon
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UTexture2D**                      CharacterIconBattle                                    (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::GetBattleIcon(class UTexture2D** CharacterIconBattle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetBattleIcon");

	Params::BP_CharacterData_C_GetBattleIcon Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CharacterIconBattle != nullptr)
		*CharacterIconBattle = Parms.CharacterIconBattle;
}


// Function BP_CharacterData.BP_CharacterData_C.GetBattleSoftClass
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TSoftClassPtr<class UClass>*            CharacterActorSoftClass                                (Parm, OutParm, HasGetValueTypeHash)

void UBP_CharacterData_C::GetBattleSoftClass(TSoftClassPtr<class UClass>* CharacterActorSoftClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetBattleSoftClass");

	Params::BP_CharacterData_C_GetBattleSoftClass Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CharacterActorSoftClass != nullptr)
		*CharacterActorSoftClass = Parms.CharacterActorSoftClass;
}


// Function BP_CharacterData.BP_CharacterData_C.GetBattleStartAP_Count
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32*                                  AP_Count                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::GetBattleStartAP_Count(int32* AP_Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetBattleStartAP_Count");

	Params::BP_CharacterData_C_GetBattleStartAP_Count Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (AP_Count != nullptr)
		*AP_Count = Parms.AP_Count;
}


// Function BP_CharacterData.BP_CharacterData_C.GetCharacterDeadPortrait
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UMaterialInstance**               CharacterDeadPortrait                                  (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::GetCharacterDeadPortrait(class UMaterialInstance** CharacterDeadPortrait)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetCharacterDeadPortrait");

	Params::BP_CharacterData_C_GetCharacterDeadPortrait Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CharacterDeadPortrait != nullptr)
		*CharacterDeadPortrait = Parms.CharacterDeadPortrait;
}


// Function BP_CharacterData.BP_CharacterData_C.GetCharacterDisplayName
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FText*                            CharacterDisplayName                                   (Parm, OutParm)

void UBP_CharacterData_C::GetCharacterDisplayName(class FText* CharacterDisplayName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetCharacterDisplayName");

	Params::BP_CharacterData_C_GetCharacterDisplayName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CharacterDisplayName != nullptr)
		*CharacterDisplayName = std::move(Parms.CharacterDisplayName);
}


// Function BP_CharacterData.BP_CharacterData_C.GetCharacterGenderTag
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// ETextGender*                            GenderTag                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::GetCharacterGenderTag(ETextGender* GenderTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetCharacterGenderTag");

	Params::BP_CharacterData_C_GetCharacterGenderTag Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (GenderTag != nullptr)
		*GenderTag = Parms.GenderTag;
}


// Function BP_CharacterData.BP_CharacterData_C.GetCharacterIconBig
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UTexture2D**                      CharacterIconBig                                       (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::GetCharacterIconBig(class UTexture2D** CharacterIconBig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetCharacterIconBig");

	Params::BP_CharacterData_C_GetCharacterIconBig Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CharacterIconBig != nullptr)
		*CharacterIconBig = Parms.CharacterIconBig;
}


// Function BP_CharacterData.BP_CharacterData_C.GetCharacterPortrait
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UTexture2D**                      CharacterIcon                                          (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::GetCharacterPortrait(class UTexture2D** CharacterIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetCharacterPortrait");

	Params::BP_CharacterData_C_GetCharacterPortrait Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CharacterIcon != nullptr)
		*CharacterIcon = Parms.CharacterIcon;
}


// Function BP_CharacterData.BP_CharacterData_C.GetCharacterStats
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TMap<E_jRPG_StatType, double>*          Stats                                                  (Parm, OutParm)

void UBP_CharacterData_C::GetCharacterStats(TMap<E_jRPG_StatType, double>* Stats)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetCharacterStats");

	Params::BP_CharacterData_C_GetCharacterStats Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Stats != nullptr)
		*Stats = std::move(Parms.Stats);
}


// Function BP_CharacterData.BP_CharacterData_C.GetCommonBattleStats
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FFCharacterStats*                CommonStats                                            (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::GetCommonBattleStats(struct FFCharacterStats* CommonStats)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetCommonBattleStats");

	Params::BP_CharacterData_C_GetCommonBattleStats Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CommonStats != nullptr)
		*CommonStats = std::move(Parms.CommonStats);
}


// Function BP_CharacterData.BP_CharacterData_C.GetCurrentLevelExperience
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32*                                  CurrentExperienceInLevel_0                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::GetCurrentLevelExperience(int32* CurrentExperienceInLevel_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetCurrentLevelExperience");

	Params::BP_CharacterData_C_GetCurrentLevelExperience Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CurrentExperienceInLevel_0 != nullptr)
		*CurrentExperienceInLevel_0 = Parms.CurrentExperienceInLevel_0;
}


// Function BP_CharacterData.BP_CharacterData_C.GetCurrentLevelExperienceProgression
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double*                                 Progress                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::GetCurrentLevelExperienceProgression(double* Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetCurrentLevelExperienceProgression");

	Params::BP_CharacterData_C_GetCurrentLevelExperienceProgression Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Progress != nullptr)
		*Progress = Parms.Progress;
}


// Function BP_CharacterData.BP_CharacterData_C.GetCurrentlyUsedLuminaPoints
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

int32 UBP_CharacterData_C::GetCurrentlyUsedLuminaPoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetCurrentlyUsedLuminaPoints");

	Params::BP_CharacterData_C_GetCurrentlyUsedLuminaPoints Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_CharacterData.BP_CharacterData_C.GetCustomizationTypeForCharacter
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FS_jRPG_Item_StaticData&   Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)
// E_CustomizationItemType*                CustomizationType                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::GetCustomizationTypeForCharacter(const struct FS_jRPG_Item_StaticData& Item, E_CustomizationItemType* CustomizationType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetCustomizationTypeForCharacter");

	Params::BP_CharacterData_C_GetCustomizationTypeForCharacter Parms{};

	Parms.Item = std::move(Item);

	UObject::ProcessEvent(Func, &Parms);

	if (CustomizationType != nullptr)
		*CustomizationType = Parms.CustomizationType;
}


// Function BP_CharacterData.BP_CharacterData_C.GetEffectiveLuminaCost
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FFPassiveEffect&           PassiveEffectDefinition                                (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// const struct FFPassiveEffectProgression&PassiveEffectProgression                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

int32 UBP_CharacterData_C::GetEffectiveLuminaCost(const struct FFPassiveEffect& PassiveEffectDefinition, const struct FFPassiveEffectProgression& PassiveEffectProgression)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetEffectiveLuminaCost");

	Params::BP_CharacterData_C_GetEffectiveLuminaCost Parms{};

	Parms.PassiveEffectDefinition = std::move(PassiveEffectDefinition);
	Parms.PassiveEffectProgression = std::move(PassiveEffectProgression);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_CharacterData.BP_CharacterData_C.GetElementForSkill
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_DataAsset_Skill_C*            SkillDefinition                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// EAttackType                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

EAttackType UBP_CharacterData_C::GetElementForSkill(class UBP_DataAsset_Skill_C* SkillDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetElementForSkill");

	Params::BP_CharacterData_C_GetElementForSkill Parms{};

	Parms.SkillDefinition = SkillDefinition;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_CharacterData.BP_CharacterData_C.GetEquipmentSaveData
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TMap<struct FFEquipmentSlot, class FName>*local_equipmentPerSlotSave1                            (Parm, OutParm)

void UBP_CharacterData_C::GetEquipmentSaveData(TMap<struct FFEquipmentSlot, class FName>* local_equipmentPerSlotSave1)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetEquipmentSaveData");

	Params::BP_CharacterData_C_GetEquipmentSaveData Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (local_equipmentPerSlotSave1 != nullptr)
		*local_equipmentPerSlotSave1 = std::move(Parms.local_equipmentPerSlotSave1);
}


// Function BP_CharacterData.BP_CharacterData_C.GetEquipmentStats
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TMap<E_jRPG_StatType, double>*          EquipmentStats_0                                       (Parm, OutParm)

void UBP_CharacterData_C::GetEquipmentStats(TMap<E_jRPG_StatType, double>* EquipmentStats_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetEquipmentStats");

	Params::BP_CharacterData_C_GetEquipmentStats Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (EquipmentStats_0 != nullptr)
		*EquipmentStats_0 = std::move(Parms.EquipmentStats_0);
}


// Function BP_CharacterData.BP_CharacterData_C.GetEquippedPassiveEffectsData
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FFPassiveEffect>*         PassiveEffectDefinitions                               (Parm, OutParm)

void UBP_CharacterData_C::GetEquippedPassiveEffectsData(TArray<struct FFPassiveEffect>* PassiveEffectDefinitions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetEquippedPassiveEffectsData");

	Params::BP_CharacterData_C_GetEquippedPassiveEffectsData Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PassiveEffectDefinitions != nullptr)
		*PassiveEffectDefinitions = std::move(Parms.PassiveEffectDefinitions);
}


// Function BP_CharacterData.BP_CharacterData_C.GetEquippedSkills
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class UBP_DataAsset_Skill_C*>*   EquippedSkills_0                                       (Parm, OutParm)

void UBP_CharacterData_C::GetEquippedSkills(TArray<class UBP_DataAsset_Skill_C*>* EquippedSkills_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetEquippedSkills");

	Params::BP_CharacterData_C_GetEquippedSkills Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (EquippedSkills_0 != nullptr)
		*EquippedSkills_0 = std::move(Parms.EquippedSkills_0);
}


// Function BP_CharacterData.BP_CharacterData_C.GetEquippedSkillsSaveData
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class FName>*                    EquippedSkillIDs                                       (Parm, OutParm)

void UBP_CharacterData_C::GetEquippedSkillsSaveData(TArray<class FName>* EquippedSkillIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetEquippedSkillsSaveData");

	Params::BP_CharacterData_C_GetEquippedSkillsSaveData Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (EquippedSkillIDs != nullptr)
		*EquippedSkillIDs = std::move(Parms.EquippedSkillIDs);
}


// Function BP_CharacterData.BP_CharacterData_C.GetEquippedWeaponDefinition
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   Valid                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FS_WeaponDefinition              ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash)

struct FS_WeaponDefinition UBP_CharacterData_C::GetEquippedWeaponDefinition(bool* Valid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetEquippedWeaponDefinition");

	Params::BP_CharacterData_C_GetEquippedWeaponDefinition Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Valid != nullptr)
		*Valid = Parms.Valid;

	return Parms.ReturnValue;
}


// Function BP_CharacterData.BP_CharacterData_C.GetEquippedWeaponItem
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   Valid                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FS_jRPG_Item_StaticData          ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, HasGetValueTypeHash)

struct FS_jRPG_Item_StaticData UBP_CharacterData_C::GetEquippedWeaponItem(bool* Valid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetEquippedWeaponItem");

	Params::BP_CharacterData_C_GetEquippedWeaponItem Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Valid != nullptr)
		*Valid = Parms.Valid;

	return Parms.ReturnValue;
}


// Function BP_CharacterData.BP_CharacterData_C.GetEquippedWeaponItemInstance
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   Valid                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UBP_ItemInstance_Gear_Weapon_C*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash)

class UBP_ItemInstance_Gear_Weapon_C* UBP_CharacterData_C::GetEquippedWeaponItemInstance(bool* Valid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetEquippedWeaponItemInstance");

	Params::BP_CharacterData_C_GetEquippedWeaponItemInstance Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Valid != nullptr)
		*Valid = Parms.Valid;

	return Parms.ReturnValue;
}


// Function BP_CharacterData.BP_CharacterData_C.GetExplorationAudioProfile
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UBP_DataAsset_CharacterExplorationAudioProfile_C**AudioProfileAsset                                      (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::GetExplorationAudioProfile(class UBP_DataAsset_CharacterExplorationAudioProfile_C** AudioProfileAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetExplorationAudioProfile");

	Params::BP_CharacterData_C_GetExplorationAudioProfile Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (AudioProfileAsset != nullptr)
		*AudioProfileAsset = Parms.AudioProfileAsset;
}


// Function BP_CharacterData.BP_CharacterData_C.GetGearItemsFromEquipmentSlots
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TMap<struct FFEquipmentSlot, struct FS_jRPG_Item_StaticData>&EquipmentPerSlot_0                                     (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference)

void UBP_CharacterData_C::GetGearItemsFromEquipmentSlots(const TMap<struct FFEquipmentSlot, struct FS_jRPG_Item_StaticData>& EquipmentPerSlot_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetGearItemsFromEquipmentSlots");

	Params::BP_CharacterData_C_GetGearItemsFromEquipmentSlots Parms{};

	Parms.EquipmentPerSlot_0 = std::move(EquipmentPerSlot_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.GetGearPassiveEffects
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_ItemInstance_Gear_C*          GearInstance                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// TArray<class FName>*                    PassiveEffectIDs                                       (Parm, OutParm)

void UBP_CharacterData_C::GetGearPassiveEffects(class UBP_ItemInstance_Gear_C* GearInstance, TArray<class FName>* PassiveEffectIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetGearPassiveEffects");

	Params::BP_CharacterData_C_GetGearPassiveEffects Parms{};

	Parms.GearInstance = GearInstance;

	UObject::ProcessEvent(Func, &Parms);

	if (PassiveEffectIDs != nullptr)
		*PassiveEffectIDs = std::move(Parms.PassiveEffectIDs);
}


// Function BP_CharacterData.BP_CharacterData_C.GetHPPercent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double*                                 HPPercent                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::GetHPPercent(double* HPPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetHPPercent");

	Params::BP_CharacterData_C_GetHPPercent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (HPPercent != nullptr)
		*HPPercent = Parms.HPPercent;
}


// Function BP_CharacterData.BP_CharacterData_C.GetIsExcluded
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   Excluded                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::GetIsExcluded(bool* Excluded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetIsExcluded");

	Params::BP_CharacterData_C_GetIsExcluded Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Excluded != nullptr)
		*Excluded = Parms.Excluded;
}


// Function BP_CharacterData.BP_CharacterData_C.GetItemInSlot
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FFEquipmentSlot&           Slot                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FS_jRPG_Item_StaticData*         Value                                                  (Parm, OutParm, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_CharacterData_C::GetItemInSlot(const struct FFEquipmentSlot& Slot, struct FS_jRPG_Item_StaticData* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetItemInSlot");

	Params::BP_CharacterData_C_GetItemInSlot Parms{};

	Parms.Slot = std::move(Slot);

	UObject::ProcessEvent(Func, &Parms);

	if (Value != nullptr)
		*Value = std::move(Parms.Value);
}


// Function BP_CharacterData.BP_CharacterData_C.GetItemInstanceInSlot
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FFEquipmentSlot&           Slot                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UBP_ItemInstance_Gear_C**         ItemInstance                                           (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::GetItemInstanceInSlot(const struct FFEquipmentSlot& Slot, class UBP_ItemInstance_Gear_C** ItemInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetItemInstanceInSlot");

	Params::BP_CharacterData_C_GetItemInstanceInSlot Parms{};

	Parms.Slot = std::move(Slot);

	UObject::ProcessEvent(Func, &Parms);

	if (ItemInstance != nullptr)
		*ItemInstance = Parms.ItemInstance;
}


// Function BP_CharacterData.BP_CharacterData_C.GetLearntSkills
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TMap<class FName, int32>*               LearntSkills_0                                         (Parm, OutParm)

void UBP_CharacterData_C::GetLearntSkills(TMap<class FName, int32>* LearntSkills_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetLearntSkills");

	Params::BP_CharacterData_C_GetLearntSkills Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (LearntSkills_0 != nullptr)
		*LearntSkills_0 = std::move(Parms.LearntSkills_0);
}


// Function BP_CharacterData.BP_CharacterData_C.GetLuminaDisplayDataFromName
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Name_0                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FS_PassiveEffectDisplayData*     PassiveEffectDisplayData                               (Parm, OutParm, HasGetValueTypeHash)

void UBP_CharacterData_C::GetLuminaDisplayDataFromName(class FName Name_0, struct FS_PassiveEffectDisplayData* PassiveEffectDisplayData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetLuminaDisplayDataFromName");

	Params::BP_CharacterData_C_GetLuminaDisplayDataFromName Parms{};

	Parms.Name_0 = Name_0;

	UObject::ProcessEvent(Func, &Parms);

	if (PassiveEffectDisplayData != nullptr)
		*PassiveEffectDisplayData = std::move(Parms.PassiveEffectDisplayData);
}


// Function BP_CharacterData.BP_CharacterData_C.GetLuminaInfoFromName
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Name_0                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FFPassiveEffect*                 Definition                                             (Parm, OutParm, HasGetValueTypeHash)
// struct FFPassiveEffectProgression*      Progression                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::GetLuminaInfoFromName(class FName Name_0, struct FFPassiveEffect* Definition, struct FFPassiveEffectProgression* Progression)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetLuminaInfoFromName");

	Params::BP_CharacterData_C_GetLuminaInfoFromName Parms{};

	Parms.Name_0 = Name_0;

	UObject::ProcessEvent(Func, &Parms);

	if (Definition != nullptr)
		*Definition = std::move(Parms.Definition);

	if (Progression != nullptr)
		*Progression = std::move(Parms.Progression);
}


// Function BP_CharacterData.BP_CharacterData_C.GetMaxAttributePoints
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

int32 UBP_CharacterData_C::GetMaxAttributePoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetMaxAttributePoints");

	Params::BP_CharacterData_C_GetMaxAttributePoints Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_CharacterData.BP_CharacterData_C.GetMaxHP
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double*                                 MaxHP                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::GetMaxHP(double* MaxHP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetMaxHP");

	Params::BP_CharacterData_C_GetMaxHP Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (MaxHP != nullptr)
		*MaxHP = Parms.MaxHP;
}


// Function BP_CharacterData.BP_CharacterData_C.GetMaxLuminaPoints
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

int32 UBP_CharacterData_C::GetMaxLuminaPoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetMaxLuminaPoints");

	Params::BP_CharacterData_C_GetMaxLuminaPoints Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_CharacterData.BP_CharacterData_C.GetMaxLuminaPointsDetails
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32*                                  FromLevel                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  FromConsumables                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::GetMaxLuminaPointsDetails(int32* FromLevel, int32* FromConsumables)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetMaxLuminaPointsDetails");

	Params::BP_CharacterData_C_GetMaxLuminaPointsDetails Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (FromLevel != nullptr)
		*FromLevel = Parms.FromLevel;

	if (FromConsumables != nullptr)
		*FromConsumables = Parms.FromConsumables;
}


// Function BP_CharacterData.BP_CharacterData_C.GetOverdriveSources
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FS_jRPG_OverdriveSource*         OverdriveSources                                       (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::GetOverdriveSources(struct FS_jRPG_OverdriveSource* OverdriveSources)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetOverdriveSources");

	Params::BP_CharacterData_C_GetOverdriveSources Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OverdriveSources != nullptr)
		*OverdriveSources = std::move(Parms.OverdriveSources);
}


// Function BP_CharacterData.BP_CharacterData_C.GetPassiveEffectProgression
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const class FName&                      PassiveEffectID                                        (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FFPassiveEffectProgression*      Progression                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::GetPassiveEffectProgression(const class FName& PassiveEffectID, struct FFPassiveEffectProgression* Progression)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetPassiveEffectProgression");

	Params::BP_CharacterData_C_GetPassiveEffectProgression Parms{};

	Parms.PassiveEffectID = PassiveEffectID;

	UObject::ProcessEvent(Func, &Parms);

	if (Progression != nullptr)
		*Progression = std::move(Parms.Progression);
}


// Function BP_CharacterData.BP_CharacterData_C.GetPassiveEffectProgressionFromItem
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FS_jRPG_Item_StaticData&   ItemData                                               (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)
// bool*                                   Found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FFPassiveEffectProgression*      Progression                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::GetPassiveEffectProgressionFromItem(const struct FS_jRPG_Item_StaticData& ItemData, bool* Found, struct FFPassiveEffectProgression* Progression)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetPassiveEffectProgressionFromItem");

	Params::BP_CharacterData_C_GetPassiveEffectProgressionFromItem Parms{};

	Parms.ItemData = std::move(ItemData);

	UObject::ProcessEvent(Func, &Parms);

	if (Found != nullptr)
		*Found = Parms.Found;

	if (Progression != nullptr)
		*Progression = std::move(Parms.Progression);
}


// Function BP_CharacterData.BP_CharacterData_C.GetSkillGraph
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UBP_DataAsset_SkillGraph_C**      SkillGraph_0                                           (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::GetSkillGraph(class UBP_DataAsset_SkillGraph_C** SkillGraph_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetSkillGraph");

	Params::BP_CharacterData_C_GetSkillGraph Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SkillGraph_0 != nullptr)
		*SkillGraph_0 = Parms.SkillGraph_0;
}


// Function BP_CharacterData.BP_CharacterData_C.GetSkillState
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_DataAsset_Skill_C*            Skill                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// ESkillNodeState*                        NodeState                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::GetSkillState(class UBP_DataAsset_Skill_C* Skill, ESkillNodeState* NodeState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetSkillState");

	Params::BP_CharacterData_C_GetSkillState Parms{};

	Parms.Skill = Skill;

	UObject::ProcessEvent(Func, &Parms);

	if (NodeState != nullptr)
		*NodeState = Parms.NodeState;
}


// Function BP_CharacterData.BP_CharacterData_C.GetSkillTree
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UBP_DataAsset_SkillTree_C**       SkillTree                                              (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::GetSkillTree(class UBP_DataAsset_SkillTree_C** SkillTree)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetSkillTree");

	Params::BP_CharacterData_C_GetSkillTree Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SkillTree != nullptr)
		*SkillTree = Parms.SkillTree;
}


// Function BP_CharacterData.BP_CharacterData_C.GetSlotForItem
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ItemId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FFEquipmentSlot*                 Slot                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::GetSlotForItem(class FName ItemId, bool* Found, struct FFEquipmentSlot* Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetSlotForItem");

	Params::BP_CharacterData_C_GetSlotForItem Parms{};

	Parms.ItemId = ItemId;

	UObject::ProcessEvent(Func, &Parms);

	if (Found != nullptr)
		*Found = Parms.Found;

	if (Slot != nullptr)
		*Slot = std::move(Parms.Slot);
}


// Function BP_CharacterData.BP_CharacterData_C.GetTotalAssignedAttributePoints
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32*                                  TotalAssignedAttributePoints                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::GetTotalAssignedAttributePoints(int32* TotalAssignedAttributePoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetTotalAssignedAttributePoints");

	Params::BP_CharacterData_C_GetTotalAssignedAttributePoints Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (TotalAssignedAttributePoints != nullptr)
		*TotalAssignedAttributePoints = Parms.TotalAssignedAttributePoints;
}


// Function BP_CharacterData.BP_CharacterData_C.GetTotalSkillPoints
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

int32 UBP_CharacterData_C::GetTotalSkillPoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetTotalSkillPoints");

	Params::BP_CharacterData_C_GetTotalSkillPoints Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_CharacterData.BP_CharacterData_C.GetUnlockedSkillSaveData
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class FName>*                    UnlockedSkillIDs                                       (Parm, OutParm)

void UBP_CharacterData_C::GetUnlockedSkillSaveData(TArray<class FName>* UnlockedSkillIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetUnlockedSkillSaveData");

	Params::BP_CharacterData_C_GetUnlockedSkillSaveData Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (UnlockedSkillIDs != nullptr)
		*UnlockedSkillIDs = std::move(Parms.UnlockedSkillIDs);
}


// Function BP_CharacterData.BP_CharacterData_C.GetWeaponInstancePower
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_ItemInstance_Gear_Weapon_C*   WeaponInstanceData                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32*                                  TotalDamage                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  BaseDamage                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  ScalingDamage                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TMap<ECharacterAttribute, int32>*       ScalingDamageByAttribute                               (Parm, OutParm)

void UBP_CharacterData_C::GetWeaponInstancePower(class UBP_ItemInstance_Gear_Weapon_C* WeaponInstanceData, int32* TotalDamage, int32* BaseDamage, int32* ScalingDamage, TMap<ECharacterAttribute, int32>* ScalingDamageByAttribute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetWeaponInstancePower");

	Params::BP_CharacterData_C_GetWeaponInstancePower Parms{};

	Parms.WeaponInstanceData = WeaponInstanceData;

	UObject::ProcessEvent(Func, &Parms);

	if (TotalDamage != nullptr)
		*TotalDamage = Parms.TotalDamage;

	if (BaseDamage != nullptr)
		*BaseDamage = Parms.BaseDamage;

	if (ScalingDamage != nullptr)
		*ScalingDamage = Parms.ScalingDamage;

	if (ScalingDamageByAttribute != nullptr)
		*ScalingDamageByAttribute = std::move(Parms.ScalingDamageByAttribute);
}


// Function BP_CharacterData.BP_CharacterData_C.GetWeaponScalingPotencyMultiplier
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// EAttributeScalingGrade                  ScalingGrade                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const ECharacterAttribute               Attribute                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 Multiplier                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::GetWeaponScalingPotencyMultiplier(EAttributeScalingGrade ScalingGrade, const ECharacterAttribute Attribute, double* Multiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "GetWeaponScalingPotencyMultiplier");

	Params::BP_CharacterData_C_GetWeaponScalingPotencyMultiplier Parms{};

	Parms.ScalingGrade = ScalingGrade;
	Parms.Attribute = Attribute;

	UObject::ProcessEvent(Func, &Parms);

	if (Multiplier != nullptr)
		*Multiplier = Parms.Multiplier;
}


// Function BP_CharacterData.BP_CharacterData_C.HasItemEquipped
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ItemId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsEquipped                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FFEquipmentSlot*                 Slot                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::HasItemEquipped(class FName ItemId, bool* IsEquipped, struct FFEquipmentSlot* Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "HasItemEquipped");

	Params::BP_CharacterData_C_HasItemEquipped Parms{};

	Parms.ItemId = ItemId;

	UObject::ProcessEvent(Func, &Parms);

	if (IsEquipped != nullptr)
		*IsEquipped = Parms.IsEquipped;

	if (Slot != nullptr)
		*Slot = std::move(Parms.Slot);
}


// Function BP_CharacterData.BP_CharacterData_C.HasLearnableSkills
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_CharacterData_C::HasLearnableSkills()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "HasLearnableSkills");

	Params::BP_CharacterData_C_HasLearnableSkills Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_CharacterData.BP_CharacterData_C.HasLearntAnyAdjacentSkill
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const class UBP_DataAsset_Skill_C*&     Skill                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_CharacterData_C::HasLearntAnyAdjacentSkill(const class UBP_DataAsset_Skill_C*& Skill)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "HasLearntAnyAdjacentSkill");

	Params::BP_CharacterData_C_HasLearntAnyAdjacentSkill Parms{};

	Parms.Skill = Skill;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_CharacterData.BP_CharacterData_C.HasMoreSkillsToEquip
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_CharacterData_C::HasMoreSkillsToEquip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "HasMoreSkillsToEquip");

	Params::BP_CharacterData_C_HasMoreSkillsToEquip Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_CharacterData.BP_CharacterData_C.HasPassiveEffectProgressionData
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const class FName&                      Key                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_CharacterData_C::HasPassiveEffectProgressionData(const class FName& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "HasPassiveEffectProgressionData");

	Params::BP_CharacterData_C_HasPassiveEffectProgressionData Parms{};

	Parms.Key = Key;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_CharacterData.BP_CharacterData_C.HasReachedMaximulLevel
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_CharacterData_C::HasReachedMaximulLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "HasReachedMaximulLevel");

	Params::BP_CharacterData_C_HasReachedMaximulLevel Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_CharacterData.BP_CharacterData_C.InitializeAssignedAttributePoints
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_CharacterData_C::InitializeAssignedAttributePoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "InitializeAssignedAttributePoints");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_CharacterData.BP_CharacterData_C.InitLuminaPassiveProgression
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             PassiveEffectID                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::InitLuminaPassiveProgression(class FName PassiveEffectID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "InitLuminaPassiveProgression");

	Params::BP_CharacterData_C_InitLuminaPassiveProgression Parms{};

	Parms.PassiveEffectID = PassiveEffectID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.IsPassiveEffectUnlocked
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             PassiveEffectName                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsUnlocked                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   BecauseLearnt                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   BecauseEquipment                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::IsPassiveEffectUnlocked(class FName PassiveEffectName, bool* IsUnlocked, bool* BecauseLearnt, bool* BecauseEquipment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "IsPassiveEffectUnlocked");

	Params::BP_CharacterData_C_IsPassiveEffectUnlocked Parms{};

	Parms.PassiveEffectName = PassiveEffectName;

	UObject::ProcessEvent(Func, &Parms);

	if (IsUnlocked != nullptr)
		*IsUnlocked = Parms.IsUnlocked;

	if (BecauseLearnt != nullptr)
		*BecauseLearnt = Parms.BecauseLearnt;

	if (BecauseEquipment != nullptr)
		*BecauseEquipment = Parms.BecauseEquipment;
}


// Function BP_CharacterData.BP_CharacterData_C.IsSkillUnlocked
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const class UBP_DataAsset_Skill_C*&     Skill                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_CharacterData_C::IsSkillUnlocked(const class UBP_DataAsset_Skill_C*& Skill)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "IsSkillUnlocked");

	Params::BP_CharacterData_C_IsSkillUnlocked Parms{};

	Parms.Skill = Skill;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_CharacterData.BP_CharacterData_C.IsSlotEmpty
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FFEquipmentSlot&           Slot                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_CharacterData_C::IsSlotEmpty(const struct FFEquipmentSlot& Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "IsSlotEmpty");

	Params::BP_CharacterData_C_IsSlotEmpty Parms{};

	Parms.Slot = std::move(Slot);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_CharacterData.BP_CharacterData_C.IsSlotUsed
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FFEquipmentSlot&           Key                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_CharacterData_C::IsSlotUsed(const struct FFEquipmentSlot& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "IsSlotUsed");

	Params::BP_CharacterData_C_IsSlotUsed Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_CharacterData.BP_CharacterData_C.LoadAssignedAttributePoints
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TMap<ECharacterAttribute, int32>& InputPin                                               (BlueprintVisible, BlueprintReadOnly, Parm)

void UBP_CharacterData_C::LoadAssignedAttributePoints(const TMap<ECharacterAttribute, int32>& InputPin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "LoadAssignedAttributePoints");

	Params::BP_CharacterData_C_LoadAssignedAttributePoints Parms{};

	Parms.InputPin = std::move(InputPin);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.LoadBattleFinalState
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAC_jRPG_CharacterBattleStats_C*  CharacterStats                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::LoadBattleFinalState(class UAC_jRPG_CharacterBattleStats_C* CharacterStats)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "LoadBattleFinalState");

	Params::BP_CharacterData_C_LoadBattleFinalState Parms{};

	Parms.CharacterStats = CharacterStats;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.LoadCharacterBaseDataFromID
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             HardcodedNameID_0                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::LoadCharacterBaseDataFromID(class FName HardcodedNameID_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "LoadCharacterBaseDataFromID");

	Params::BP_CharacterData_C_LoadCharacterBaseDataFromID Parms{};

	Parms.HardcodedNameID_0 = HardcodedNameID_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.LoadCharacterBaseDataLegacy
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FS_jRPG_CharacterSaveState&Legacy_CharacterSaveData                               (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// class UBP_jRPG_GI_Custom_C*&            LegacyOnly_GameInstance                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::LoadCharacterBaseDataLegacy(const struct FS_jRPG_CharacterSaveState& Legacy_CharacterSaveData, class UBP_jRPG_GI_Custom_C*& LegacyOnly_GameInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "LoadCharacterBaseDataLegacy");

	Params::BP_CharacterData_C_LoadCharacterBaseDataLegacy Parms{};

	Parms.Legacy_CharacterSaveData = std::move(Legacy_CharacterSaveData);
	Parms.LegacyOnly_GameInstance = LegacyOnly_GameInstance;

	UObject::ProcessEvent(Func, &Parms);

	LegacyOnly_GameInstance = Parms.LegacyOnly_GameInstance;
}


// Function BP_CharacterData.BP_CharacterData_C.LoadCharacterCustomizationFromItemData
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_CharacterData_C::LoadCharacterCustomizationFromItemData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "LoadCharacterCustomizationFromItemData");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_CharacterData.BP_CharacterData_C.LoadCharacterDefinition
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FS_jRPG_CharacterDefinition&CharacterDefinition_0                                  (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_CharacterData_C::LoadCharacterDefinition(const struct FS_jRPG_CharacterDefinition& CharacterDefinition_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "LoadCharacterDefinition");

	Params::BP_CharacterData_C_LoadCharacterDefinition Parms{};

	Parms.CharacterDefinition_0 = std::move(CharacterDefinition_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.LoadCharacterState
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FS_jRPG_CharacterSaveState&CharacterState                                         (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void UBP_CharacterData_C::LoadCharacterState(const struct FS_jRPG_CharacterSaveState& CharacterState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "LoadCharacterState");

	Params::BP_CharacterData_C_LoadCharacterState Parms{};

	Parms.CharacterState = std::move(CharacterState);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.MergeCurrentEquipmentInstancesWithOverrides
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TMap<struct FFEquipmentSlot, class UBP_ItemInstance_Gear_C*>&EquipmentOverrides                                     (BlueprintVisible, BlueprintReadOnly, Parm)
// TMap<struct FFEquipmentSlot, class UBP_ItemInstance_Gear_C*>*MergedEquipment                                        (Parm, OutParm)

void UBP_CharacterData_C::MergeCurrentEquipmentInstancesWithOverrides(const TMap<struct FFEquipmentSlot, class UBP_ItemInstance_Gear_C*>& EquipmentOverrides, TMap<struct FFEquipmentSlot, class UBP_ItemInstance_Gear_C*>* MergedEquipment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "MergeCurrentEquipmentInstancesWithOverrides");

	Params::BP_CharacterData_C_MergeCurrentEquipmentInstancesWithOverrides Parms{};

	Parms.EquipmentOverrides = std::move(EquipmentOverrides);

	UObject::ProcessEvent(Func, &Parms);

	if (MergedEquipment != nullptr)
		*MergedEquipment = std::move(Parms.MergedEquipment);
}


// Function BP_CharacterData.BP_CharacterData_C.OnNewItemAcquired
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_jRPG_Item_StaticData&         ItemStaticData                                         (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_CharacterData_C::OnNewItemAcquired(struct FS_jRPG_Item_StaticData& ItemStaticData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "OnNewItemAcquired");

	Params::BP_CharacterData_C_OnNewItemAcquired Parms{};

	Parms.ItemStaticData = std::move(ItemStaticData);

	UObject::ProcessEvent(Func, &Parms);

	ItemStaticData = std::move(Parms.ItemStaticData);
}


// Function BP_CharacterData.BP_CharacterData_C.OnSkillGraphStateChanged
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_CharacterData_C::OnSkillGraphStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "OnSkillGraphStateChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_CharacterData.BP_CharacterData_C.PreviewStatsWithEquipmentOverrides
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TMap<struct FFEquipmentSlot, class UBP_ItemInstance_Gear_C*>&EquipmentOverrides                                     (BlueprintVisible, BlueprintReadOnly, Parm)
// TMap<E_jRPG_StatType, double>*          StatsPreview                                           (Parm, OutParm)

void UBP_CharacterData_C::PreviewStatsWithEquipmentOverrides(const TMap<struct FFEquipmentSlot, class UBP_ItemInstance_Gear_C*>& EquipmentOverrides, TMap<E_jRPG_StatType, double>* StatsPreview)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "PreviewStatsWithEquipmentOverrides");

	Params::BP_CharacterData_C_PreviewStatsWithEquipmentOverrides Parms{};

	Parms.EquipmentOverrides = std::move(EquipmentOverrides);

	UObject::ProcessEvent(Func, &Parms);

	if (StatsPreview != nullptr)
		*StatsPreview = std::move(Parms.StatsPreview);
}


// Function BP_CharacterData.BP_CharacterData_C.ProgressEquippedLuminas
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_CharacterData_C::ProgressEquippedLuminas()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "ProgressEquippedLuminas");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_CharacterData.BP_CharacterData_C.ProgressPassiveEffectShared
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             PassiveEffectID                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::ProgressPassiveEffectShared(class FName PassiveEffectID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "ProgressPassiveEffectShared");

	Params::BP_CharacterData_C_ProgressPassiveEffectShared Parms{};

	Parms.PassiveEffectID = PassiveEffectID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.ReceiveExplorationDamage
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::ReceiveExplorationDamage(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "ReceiveExplorationDamage");

	Params::BP_CharacterData_C_ReceiveExplorationDamage Parms{};

	Parms.Amount = Amount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.ReceiveExplorationDamagePercent
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Percent                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::ReceiveExplorationDamagePercent(int32 Percent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "ReceiveExplorationDamagePercent");

	Params::BP_CharacterData_C_ReceiveExplorationDamagePercent Parms{};

	Parms.Percent = Percent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.RefreshUsedLuminaPointsInternal
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_CharacterData_C::RefreshUsedLuminaPointsInternal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "RefreshUsedLuminaPointsInternal");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_CharacterData.BP_CharacterData_C.ReplaceItemInSlot
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FFEquipmentSlot&           Slot                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FS_jRPG_Item_StaticData&         Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_CharacterData_C::ReplaceItemInSlot(const struct FFEquipmentSlot& Slot, struct FS_jRPG_Item_StaticData& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "ReplaceItemInSlot");

	Params::BP_CharacterData_C_ReplaceItemInSlot Parms{};

	Parms.Slot = std::move(Slot);
	Parms.Item = std::move(Item);

	UObject::ProcessEvent(Func, &Parms);

	Item = std::move(Parms.Item);
}


// Function BP_CharacterData.BP_CharacterData_C.ReplaceItemInstanceInSlot
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FFEquipmentSlot&           Slot                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UBP_ItemInstance_Gear_C*          Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::ReplaceItemInstanceInSlot(const struct FFEquipmentSlot& Slot, class UBP_ItemInstance_Gear_C* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "ReplaceItemInstanceInSlot");

	Params::BP_CharacterData_C_ReplaceItemInstanceInSlot Parms{};

	Parms.Slot = std::move(Slot);
	Parms.Item = Item;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.ResetAssignedAttributePoints
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_CharacterData_C::ResetAssignedAttributePoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "ResetAssignedAttributePoints");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_CharacterData.BP_CharacterData_C.SaveCharacterState
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_jRPG_CharacterSaveState&      OutState                                               (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, HasGetValueTypeHash)
// struct FS_jRPG_CharacterSaveState*      StructOut                                              (Parm, OutParm, HasGetValueTypeHash)

void UBP_CharacterData_C::SaveCharacterState(struct FS_jRPG_CharacterSaveState& OutState, struct FS_jRPG_CharacterSaveState* StructOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "SaveCharacterState");

	Params::BP_CharacterData_C_SaveCharacterState Parms{};

	Parms.OutState = std::move(OutState);

	UObject::ProcessEvent(Func, &Parms);

	OutState = std::move(Parms.OutState);

	if (StructOut != nullptr)
		*StructOut = std::move(Parms.StructOut);
}


// Function BP_CharacterData.BP_CharacterData_C.SetCharacterCustomizationItemData
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FS_CharacterCustomizationItemData&CharacterCustomizationItemData_0                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::SetCharacterCustomizationItemData(const struct FS_CharacterCustomizationItemData& CharacterCustomizationItemData_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "SetCharacterCustomizationItemData");

	Params::BP_CharacterData_C_SetCharacterCustomizationItemData Parms{};

	Parms.CharacterCustomizationItemData_0 = std::move(CharacterCustomizationItemData_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.SetEquippedSkillOverrides
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UBP_DataAsset_Skill_C*>&   EquippedSkills_0                                       (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBP_CharacterData_C::SetEquippedSkillOverrides(TArray<class UBP_DataAsset_Skill_C*>& EquippedSkills_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "SetEquippedSkillOverrides");

	Params::BP_CharacterData_C_SetEquippedSkillOverrides Parms{};

	Parms.EquippedSkills_0 = std::move(EquippedSkills_0);

	UObject::ProcessEvent(Func, &Parms);

	EquippedSkills_0 = std::move(Parms.EquippedSkills_0);
}


// Function BP_CharacterData.BP_CharacterData_C.SetIsExcluded
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Excluded                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::SetIsExcluded(bool Excluded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "SetIsExcluded");

	Params::BP_CharacterData_C_SetIsExcluded Parms{};

	Parms.Excluded = Excluded;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.SetLevel
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   NewLevel                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::SetLevel(int32 NewLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "SetLevel");

	Params::BP_CharacterData_C_SetLevel Parms{};

	Parms.NewLevel = NewLevel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.SetShouldDispatchModifications
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ShouldDispatchModifications_0                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::SetShouldDispatchModifications(bool ShouldDispatchModifications_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "SetShouldDispatchModifications");

	Params::BP_CharacterData_C_SetShouldDispatchModifications Parms{};

	Parms.ShouldDispatchModifications_0 = ShouldDispatchModifications_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.StartDeferUpdate
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_CharacterData_C::StartDeferUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "StartDeferUpdate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_CharacterData.BP_CharacterData_C.TryEquipLuminaPassive
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Name_0                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Successful                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::TryEquipLuminaPassive(class FName Name_0, bool* Successful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "TryEquipLuminaPassive");

	Params::BP_CharacterData_C_TryEquipLuminaPassive Parms{};

	Parms.Name_0 = Name_0;

	UObject::ProcessEvent(Func, &Parms);

	if (Successful != nullptr)
		*Successful = Parms.Successful;
}


// Function BP_CharacterData.BP_CharacterData_C.TryUnlockLevelUpAchievements
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_CharacterData_C::TryUnlockLevelUpAchievements()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "TryUnlockLevelUpAchievements");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_CharacterData.BP_CharacterData_C.TryUnlockSkill
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_DataAsset_Skill_C*            Skill                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::TryUnlockSkill(class UBP_DataAsset_Skill_C* Skill, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "TryUnlockSkill");

	Params::BP_CharacterData_C_TryUnlockSkill Parms{};

	Parms.Skill = Skill;

	UObject::ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BP_CharacterData.BP_CharacterData_C.UnequipItem
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FS_jRPG_Item_StaticData&   Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_CharacterData_C::UnequipItem(const struct FS_jRPG_Item_StaticData& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "UnequipItem");

	Params::BP_CharacterData_C_UnequipItem Parms{};

	Parms.Item = std::move(Item);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.UnequipItemFromInstance
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_ItemInstance_Gear_C*          GearInstance                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::UnequipItemFromInstance(class UBP_ItemInstance_Gear_C* GearInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "UnequipItemFromInstance");

	Params::BP_CharacterData_C_UnequipItemFromInstance Parms{};

	Parms.GearInstance = GearInstance;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.UnequipItemInSlot
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FFEquipmentSlot&           Slot                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::UnequipItemInSlot(const struct FFEquipmentSlot& Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "UnequipItemInSlot");

	Params::BP_CharacterData_C_UnequipItemInSlot Parms{};

	Parms.Slot = std::move(Slot);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.UnequipItemInstanceInSlot
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FFEquipmentSlot&           Slot                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::UnequipItemInstanceInSlot(const struct FFEquipmentSlot& Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "UnequipItemInstanceInSlot");

	Params::BP_CharacterData_C_UnequipItemInstanceInSlot Parms{};

	Parms.Slot = std::move(Slot);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.UnequipLuminaPassive
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Name_0                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::UnequipLuminaPassive(class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "UnequipLuminaPassive");

	Params::BP_CharacterData_C_UnequipLuminaPassive Parms{};

	Parms.Name_0 = Name_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.UnequipLuminaPassiveList
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FName>&                    PassiveIDs                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBP_CharacterData_C::UnequipLuminaPassiveList(TArray<class FName>& PassiveIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "UnequipLuminaPassiveList");

	Params::BP_CharacterData_C_UnequipLuminaPassiveList Parms{};

	Parms.PassiveIDs = std::move(PassiveIDs);

	UObject::ProcessEvent(Func, &Parms);

	PassiveIDs = std::move(Parms.PassiveIDs);
}


// Function BP_CharacterData.BP_CharacterData_C.UnequipLuminaPassiveListInternal
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FName>&                    PassiveIDs                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBP_CharacterData_C::UnequipLuminaPassiveListInternal(TArray<class FName>& PassiveIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "UnequipLuminaPassiveListInternal");

	Params::BP_CharacterData_C_UnequipLuminaPassiveListInternal Parms{};

	Parms.PassiveIDs = std::move(PassiveIDs);

	UObject::ProcessEvent(Func, &Parms);

	PassiveIDs = std::move(Parms.PassiveIDs);
}


// Function BP_CharacterData.BP_CharacterData_C.UnequipSkill
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_DataAsset_Skill_C*            SkillID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::UnequipSkill(class UBP_DataAsset_Skill_C* SkillID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "UnequipSkill");

	Params::BP_CharacterData_C_UnequipSkill Parms{};

	Parms.SkillID = SkillID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_CharacterData.BP_CharacterData_C.Update Attribute Stats
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_CharacterData_C::Update_Attribute_Stats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "Update Attribute Stats");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_CharacterData.BP_CharacterData_C.UpdateEquipmentStats
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_CharacterData_C::UpdateEquipmentStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "UpdateEquipmentStats");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_CharacterData.BP_CharacterData_C.UpdateLevelingStats
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_CharacterData_C::UpdateLevelingStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "UpdateLevelingStats");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_CharacterData.BP_CharacterData_C.UpdateLuminaSystem
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_CharacterData_C::UpdateLuminaSystem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "UpdateLuminaSystem");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_CharacterData.BP_CharacterData_C.UpdatePassiveEffectProgression
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FFPassiveEffectProgression&DirtyProgression                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FFPassiveEffectProgression*      UpdatedProgression                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_CharacterData_C::UpdatePassiveEffectProgression(const struct FFPassiveEffectProgression& DirtyProgression, struct FFPassiveEffectProgression* UpdatedProgression)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "UpdatePassiveEffectProgression");

	Params::BP_CharacterData_C_UpdatePassiveEffectProgression Parms{};

	Parms.DirtyProgression = std::move(DirtyProgression);

	UObject::ProcessEvent(Func, &Parms);

	if (UpdatedProgression != nullptr)
		*UpdatedProgression = std::move(Parms.UpdatedProgression);
}


// Function BP_CharacterData.BP_CharacterData_C.UpdateStats
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_CharacterData_C::UpdateStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_CharacterData_C", "UpdateStats");

	UObject::ProcessEvent(Func, nullptr);
}

}

