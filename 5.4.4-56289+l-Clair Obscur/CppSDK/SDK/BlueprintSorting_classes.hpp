#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BlueprintSorting

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "BlueprintSorting_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class BlueprintSorting.BlueprintSortingHelperLibrary
// 0x0000 (0x0028 - 0x0028)
class UBlueprintSortingHelperLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool GreaterThanOrEqualArrayLength(const TArray<int32>& TargetArray, int32* Index_0);
	static int32 Increment(int32 ToIncrement);
	static bool LessThanOrEqualArrayLength(const TArray<int32>& TargetArray, int32* Index_0);
	static void SwapItems(const TArray<int32>& TargetArray, int32* index1, int32* index2);
	static void TestItem(int32* TargetItem);
	static void TestThreeItems(int32* TargetItem1, int32* TargetItem2, int32* TargetItem3);
	static void TestTwoItems(int32* TargetItem1, int32* TargetItem2);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintSortingHelperLibrary">();
	}
	static class UBlueprintSortingHelperLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintSortingHelperLibrary>();
	}
};
static_assert(alignof(UBlueprintSortingHelperLibrary) == 0x000008, "Wrong alignment on UBlueprintSortingHelperLibrary");
static_assert(sizeof(UBlueprintSortingHelperLibrary) == 0x000028, "Wrong size on UBlueprintSortingHelperLibrary");

// Class BlueprintSorting.OrderingResult
// 0x0008 (0x0030 - 0x0028)
class UOrderingResult final : public UObject
{
public:
	ESortOrdering                                 Result;                                            // 0x0028(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsFirstAfterSecond(class UOrderingResult* OrderingResult, ESortDirection SortDirection);
	static class UOrderingResult* MakeOrderingResult();

	void SetForFloat(float R, float Epsilon);
	void SetForInt(int32 R);
	void SetForInts(int32 A, int32 B);
	void SetForStrings(const class FString& A, const class FString& B);
	void SetForTexts(const class FText& A, const class FText& B);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrderingResult">();
	}
	static class UOrderingResult* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrderingResult>();
	}
};
static_assert(alignof(UOrderingResult) == 0x000008, "Wrong alignment on UOrderingResult");
static_assert(sizeof(UOrderingResult) == 0x000030, "Wrong size on UOrderingResult");
static_assert(offsetof(UOrderingResult, Result) == 0x000028, "Member 'UOrderingResult::Result' has a wrong offset!");

}

