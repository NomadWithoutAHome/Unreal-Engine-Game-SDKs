#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_CharacterReactionSystem

#include "Basic.hpp"

#include "ECharacterTeamSelector_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// BlueprintGeneratedClass BP_CharacterReactionSystem.BP_CharacterReactionSystem_C
// 0x0040 (0x00E0 - 0x00A0)
class UBP_CharacterReactionSystem_C final : public UActorComponent
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x00A0(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	bool                                          AllyWasAttackedDuringTurn;                         // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAC_jRPG_CharacterBattleStats_C*        AttackedAllyDuringTurn;                            // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	class UAC_jRPG_CharacterBattleStats_C*        Character_Turn;                                    // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	class UAC_jRPG_BattleManager_C*               BattleManagerReference;                            // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	class UAC_jRPG_CharacterBattleStats_C*        LastAllyCharacterToPlay;                           // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	class UBP_BattleLineGatherer_C*               ActiveBattleLineGatherer;                          // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	bool                                          SkipAllRolls;                                      // 0x00D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

public:
	void BeginChoosingBattleLines(class UBP_BattleLineGatherer_C** Gatherer);
	void DEBUG_CVarChange_BattleLine_SkipRoll(bool NewValue);
	void EndChooseBattleLines(class UBP_BattleLineGatherer_C* Gatherer);
	void ExecuteUbergraph_BP_CharacterReactionSystem(int32 EntryPoint);
	void GetAnyAllyCharacterExcept(class UAC_jRPG_CharacterBattleStats_C* Except, class ABP_jRPG_Character_Battle_Base_C** CharacterActor);
	void GetBattleLineSettings(class UBP_BattleLineSettings_C** Settings);
	void Internal_EndGatherBattleLines_OLD();
	void LogPerCharacterReaction(const class FString& Reaction, class UAC_jRPG_CharacterBattleStats_C* ReactingCharacter, class UAC_jRPG_CharacterBattleStats_C* SubjectCharacter);
	void OnBattleEnds();
	void OnBattleStart(class UAC_jRPG_BattleManager_C* BattleManager);
	void OnCharacterBuffed(class UBP_BattleBuffInstance_C* BuffInstance, class UAC_jRPG_CharacterBattleStats_C* TargetCharacter, class UAC_jRPG_CharacterBattleStats_C* SourceCharacter);
	void OnCharacterHealed(class UBP_BattleHeal_C* HealEvent);
	void OnCharacterHealSuccessful(class UBP_BattleHeal_C* HealObject);
	void OnCharacterKilled(class UBP_BattleDamages_C* LethalDamages);
	void OnCharacterReceivedDamage(class UAC_jRPG_CharacterBattleStats_C* AttackedCharacter, class UAC_jRPG_CharacterBattleStats_C* AttackerCharacter, double DamageAmount);
	void OnCharacterRevived(class UAC_jRPG_CharacterBattleStats_C* RevivedCharacter, class UAC_jRPG_CharacterBattleStats_C* RevivingCharacter);
	void OnEnemyAcquiredTarget(class UAC_jRPG_CharacterBattleStats_C* EnemyStats, class UAC_jRPG_CharacterBattleStats_C* TargetedStats);
	void OnTurnStart(class UAC_jRPG_CharacterBattleStats_C* CharacterTurn);
	void ReceiveBeginPlay();
	void ResetTurnState();
	void RollFromPool(const struct FS_BattleLinePool& BattleLinePool, struct FS_BattleLine* BattleLine);
	bool ShouldSkipAllRolls();

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BP_CharacterReactionSystem_C">();
	}
	static class UBP_CharacterReactionSystem_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBP_CharacterReactionSystem_C>();
	}
};
static_assert(alignof(UBP_CharacterReactionSystem_C) == 0x000008, "Wrong alignment on UBP_CharacterReactionSystem_C");
static_assert(sizeof(UBP_CharacterReactionSystem_C) == 0x0000E0, "Wrong size on UBP_CharacterReactionSystem_C");
static_assert(offsetof(UBP_CharacterReactionSystem_C, UberGraphFrame) == 0x0000A0, "Member 'UBP_CharacterReactionSystem_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(UBP_CharacterReactionSystem_C, AllyWasAttackedDuringTurn) == 0x0000A8, "Member 'UBP_CharacterReactionSystem_C::AllyWasAttackedDuringTurn' has a wrong offset!");
static_assert(offsetof(UBP_CharacterReactionSystem_C, AttackedAllyDuringTurn) == 0x0000B0, "Member 'UBP_CharacterReactionSystem_C::AttackedAllyDuringTurn' has a wrong offset!");
static_assert(offsetof(UBP_CharacterReactionSystem_C, Character_Turn) == 0x0000B8, "Member 'UBP_CharacterReactionSystem_C::Character_Turn' has a wrong offset!");
static_assert(offsetof(UBP_CharacterReactionSystem_C, BattleManagerReference) == 0x0000C0, "Member 'UBP_CharacterReactionSystem_C::BattleManagerReference' has a wrong offset!");
static_assert(offsetof(UBP_CharacterReactionSystem_C, LastAllyCharacterToPlay) == 0x0000C8, "Member 'UBP_CharacterReactionSystem_C::LastAllyCharacterToPlay' has a wrong offset!");
static_assert(offsetof(UBP_CharacterReactionSystem_C, ActiveBattleLineGatherer) == 0x0000D0, "Member 'UBP_CharacterReactionSystem_C::ActiveBattleLineGatherer' has a wrong offset!");
static_assert(offsetof(UBP_CharacterReactionSystem_C, SkipAllRolls) == 0x0000D8, "Member 'UBP_CharacterReactionSystem_C::SkipAllRolls' has a wrong offset!");

}

