#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_jRPG_Enemy_World_Base_Seamless

#include "Basic.hpp"

#include "BP_jRPG_Enemy_World_Base_Seamless_classes.hpp"
#include "BP_jRPG_Enemy_World_Base_Seamless_parameters.hpp"


namespace SDK
{

// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.AddAggroLock
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FName&                      LockName                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::AddAggroLock(const class FName& LockName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "AddAggroLock");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_AddAggroLock Parms{};

	Parms.LockName = LockName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.AddInteractable
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Interactable                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::AddInteractable(class AActor* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "AddInteractable");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_AddInteractable Parms{};

	Parms.Interactable = Interactable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.BeginCustomScriptState
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          SourceObject                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::BeginCustomScriptState(class UObject* SourceObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "BeginCustomScriptState");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_BeginCustomScriptState Parms{};

	Parms.SourceObject = SourceObject;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.BndEvt__BP_jRPG_Enemy_World_Base_Seamless_EncounterCapsuleRange_K2Node_ComponentBoundEvent_5_ComponentBeginOverlapSignature__DelegateSignature
// (HasOutParams, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bFromSweep                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FHitResult&                SweepResult                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_jRPG_Enemy_World_Base_Seamless_C::BndEvt__BP_jRPG_Enemy_World_Base_Seamless_EncounterCapsuleRange_K2Node_ComponentBoundEvent_5_ComponentBeginOverlapSignature__DelegateSignature(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "BndEvt__BP_jRPG_Enemy_World_Base_Seamless_EncounterCapsuleRange_K2Node_ComponentBoundEvent_5_ComponentBeginOverlapSignature__DelegateSignature");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_BndEvt__BP_jRPG_Enemy_World_Base_Seamless_EncounterCapsuleRange_K2Node_ComponentBoundEvent_5_ComponentBeginOverlapSignature__DelegateSignature Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.BndEvt__BP_jRPG_Enemy_World_Base_Seamless_PPBattleTransitionZone_K2Node_ComponentBoundEvent_6_ComponentBeginOverlapSignature__DelegateSignature
// (HasOutParams, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bFromSweep                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FHitResult&                SweepResult                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_jRPG_Enemy_World_Base_Seamless_C::BndEvt__BP_jRPG_Enemy_World_Base_Seamless_PPBattleTransitionZone_K2Node_ComponentBoundEvent_6_ComponentBeginOverlapSignature__DelegateSignature(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "BndEvt__BP_jRPG_Enemy_World_Base_Seamless_PPBattleTransitionZone_K2Node_ComponentBoundEvent_6_ComponentBeginOverlapSignature__DelegateSignature");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_BndEvt__BP_jRPG_Enemy_World_Base_Seamless_PPBattleTransitionZone_K2Node_ComponentBoundEvent_6_ComponentBeginOverlapSignature__DelegateSignature Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.BndEvt__BP_jRPG_Enemy_World_Base_Seamless_PPBattleTransitionZone_K2Node_ComponentBoundEvent_7_ComponentEndOverlapSignature__DelegateSignature
// (BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::BndEvt__BP_jRPG_Enemy_World_Base_Seamless_PPBattleTransitionZone_K2Node_ComponentBoundEvent_7_ComponentEndOverlapSignature__DelegateSignature(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "BndEvt__BP_jRPG_Enemy_World_Base_Seamless_PPBattleTransitionZone_K2Node_ComponentBoundEvent_7_ComponentEndOverlapSignature__DelegateSignature");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_BndEvt__BP_jRPG_Enemy_World_Base_Seamless_PPBattleTransitionZone_K2Node_ComponentBoundEvent_7_ComponentEndOverlapSignature__DelegateSignature Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.BoxTriggered
// (BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::BoxTriggered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "BoxTriggered");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.CanInteractWithMount
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   CanInteract                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::CanInteractWithMount(bool* CanInteract)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "CanInteractWithMount");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_CanInteractWithMount Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CanInteract != nullptr)
		*CanInteract = Parms.CanInteract;
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.CanStartBattleWithCharacter
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ABP_jRPG_Character_World_C*       Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_jRPG_Enemy_World_Base_Seamless_C::CanStartBattleWithCharacter(class ABP_jRPG_Character_World_C* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "CanStartBattleWithCharacter");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_CanStartBattleWithCharacter Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.CheckForErrors
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FText>&                    ErrorMessages                                          (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_jRPG_Enemy_World_Base_Seamless_C::CheckForErrors(TArray<class FText>& ErrorMessages)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "CheckForErrors");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_CheckForErrors Parms{};

	Parms.ErrorMessages = std::move(ErrorMessages);

	UObject::ProcessEvent(Func, &Parms);

	ErrorMessages = std::move(Parms.ErrorMessages);

	return Parms.ReturnValue;
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.ComputeDetectionParameters
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FActorDetectionParameters*       DetectionParameters                                    (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::ComputeDetectionParameters(struct FActorDetectionParameters* DetectionParameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "ComputeDetectionParameters");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_ComputeDetectionParameters Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (DetectionParameters != nullptr)
		*DetectionParameters = std::move(Parms.DetectionParameters);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.DEBUG_OnCVarChanged_DisplayVisionDebug
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NewValue                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::DEBUG_OnCVarChanged_DisplayVisionDebug(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "DEBUG_OnCVarChanged_DisplayVisionDebug");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_DEBUG_OnCVarChanged_DisplayVisionDebug Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.DEBUG_SetOptimizationActive
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    LODOptimizationActive_0                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::DEBUG_SetOptimizationActive(bool LODOptimizationActive_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "DEBUG_SetOptimizationActive");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_DEBUG_SetOptimizationActive Parms{};

	Parms.LODOptimizationActive_0 = LODOptimizationActive_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.DEBUG_ShowState
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::DEBUG_ShowState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "DEBUG_ShowState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.EndCustomScriptState
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class UObject*&                   CustomScriptSource                                     (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// E_AiStates                              DesiredState                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::EndCustomScriptState(const class UObject*& CustomScriptSource, E_AiStates DesiredState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "EndCustomScriptState");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_EndCustomScriptState Parms{};

	Parms.CustomScriptSource = CustomScriptSource;
	Parms.DesiredState = DesiredState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.EnterDetectPlayerStateInternal
// (BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::EnterDetectPlayerStateInternal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "EnterDetectPlayerStateInternal");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.EnterStunState
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  StunDuration                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::EnterStunState(double StunDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "EnterStunState");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_EnterStunState Parms{};

	Parms.StunDuration = StunDuration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.ExecuteUbergraph_BP_jRPG_Enemy_World_Base_Seamless
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::ExecuteUbergraph_BP_jRPG_Enemy_World_Base_Seamless(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "ExecuteUbergraph_BP_jRPG_Enemy_World_Base_Seamless");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_ExecuteUbergraph_BP_jRPG_Enemy_World_Base_Seamless Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.ExplorationAttacked
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_jRPG_Character_World_C*       PlayerCharacter                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   ImpactPoint                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::ExplorationAttacked(class ABP_jRPG_Character_World_C* PlayerCharacter, const struct FVector& ImpactPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "ExplorationAttacked");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_ExplorationAttacked Parms{};

	Parms.PlayerCharacter = PlayerCharacter;
	Parms.ImpactPoint = std::move(ImpactPoint);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.FreeAimHit
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_jRPG_Character_World_C*       PlayerCharacterWorld                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   HitLocation                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsDisabled                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::FreeAimHit(class ABP_jRPG_Character_World_C* PlayerCharacterWorld, const struct FVector& HitLocation, bool IsDisabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "FreeAimHit");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_FreeAimHit Parms{};

	Parms.PlayerCharacterWorld = PlayerCharacterWorld;
	Parms.HitLocation = std::move(HitLocation);
	Parms.IsDisabled = IsDisabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.GetAllAudioComponents
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UAudioComponent*>*         AudioComponents                                        (Parm, OutParm, ContainsInstancedReference)

void ABP_jRPG_Enemy_World_Base_Seamless_C::GetAllAudioComponents(TArray<class UAudioComponent*>* AudioComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "GetAllAudioComponents");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_GetAllAudioComponents Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (AudioComponents != nullptr)
		*AudioComponents = std::move(Parms.AudioComponents);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.GetAudioCharacterManager
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UActorComponent**                 AudioCharacterManager                                  (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::GetAudioCharacterManager(class UActorComponent** AudioCharacterManager)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "GetAudioCharacterManager");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_GetAudioCharacterManager Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (AudioCharacterManager != nullptr)
		*AudioCharacterManager = Parms.AudioCharacterManager;
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.GetAudioComponentByType
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const EInWorldAudioContainerComponents  Type                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UAudioComponent**                 AudioComponent                                         (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::GetAudioComponentByType(const EInWorldAudioContainerComponents Type, class UAudioComponent** AudioComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "GetAudioComponentByType");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_GetAudioComponentByType Parms{};

	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);

	if (AudioComponent != nullptr)
		*AudioComponent = Parms.AudioComponent;
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.GetAudioComponents
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAudioComponent**                 AC_SFX_01_0                                            (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UAudioComponent**                 AC_Foleys_01_0                                         (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UAudioComponent**                 AC_FT_L_0                                              (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UAudioComponent**                 AC_Vocals_01                                           (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UAudioComponent**                 AC_SFX_02_0                                            (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UAudioComponent**                 AC_Foleys_02_0                                         (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UAudioComponent**                 AC_FT_R_0                                              (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UAudioComponent**                 AC_Vocals_02                                           (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UAudioComponent**                 AC_Idle_0                                              (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UAudioComponent**                 AC_Weapon_L_01                                         (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UAudioComponent**                 AC_Weapon_L_02                                         (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UAudioComponent**                 AC_Weapon_R_01                                         (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UAudioComponent**                 AC_Hand_L_01                                           (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UAudioComponent**                 AC_Hand_R_01                                           (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::GetAudioComponents(class UAudioComponent** AC_SFX_01_0, class UAudioComponent** AC_Foleys_01_0, class UAudioComponent** AC_FT_L_0, class UAudioComponent** AC_Vocals_01, class UAudioComponent** AC_SFX_02_0, class UAudioComponent** AC_Foleys_02_0, class UAudioComponent** AC_FT_R_0, class UAudioComponent** AC_Vocals_02, class UAudioComponent** AC_Idle_0, class UAudioComponent** AC_Weapon_L_01, class UAudioComponent** AC_Weapon_L_02, class UAudioComponent** AC_Weapon_R_01, class UAudioComponent** AC_Hand_L_01, class UAudioComponent** AC_Hand_R_01)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "GetAudioComponents");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_GetAudioComponents Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (AC_SFX_01_0 != nullptr)
		*AC_SFX_01_0 = Parms.AC_SFX_01_0;

	if (AC_Foleys_01_0 != nullptr)
		*AC_Foleys_01_0 = Parms.AC_Foleys_01_0;

	if (AC_FT_L_0 != nullptr)
		*AC_FT_L_0 = Parms.AC_FT_L_0;

	if (AC_Vocals_01 != nullptr)
		*AC_Vocals_01 = Parms.AC_Vocals_01;

	if (AC_SFX_02_0 != nullptr)
		*AC_SFX_02_0 = Parms.AC_SFX_02_0;

	if (AC_Foleys_02_0 != nullptr)
		*AC_Foleys_02_0 = Parms.AC_Foleys_02_0;

	if (AC_FT_R_0 != nullptr)
		*AC_FT_R_0 = Parms.AC_FT_R_0;

	if (AC_Vocals_02 != nullptr)
		*AC_Vocals_02 = Parms.AC_Vocals_02;

	if (AC_Idle_0 != nullptr)
		*AC_Idle_0 = Parms.AC_Idle_0;

	if (AC_Weapon_L_01 != nullptr)
		*AC_Weapon_L_01 = Parms.AC_Weapon_L_01;

	if (AC_Weapon_L_02 != nullptr)
		*AC_Weapon_L_02 = Parms.AC_Weapon_L_02;

	if (AC_Weapon_R_01 != nullptr)
		*AC_Weapon_R_01 = Parms.AC_Weapon_R_01;

	if (AC_Hand_L_01 != nullptr)
		*AC_Hand_L_01 = Parms.AC_Hand_L_01;

	if (AC_Hand_R_01 != nullptr)
		*AC_Hand_R_01 = Parms.AC_Hand_R_01;
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.GetBattleCameraTransition
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UCameraAnimationSequence**        CameraTransition                                       (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::GetBattleCameraTransition(class UCameraAnimationSequence** CameraTransition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "GetBattleCameraTransition");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_GetBattleCameraTransition Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CameraTransition != nullptr)
		*CameraTransition = Parms.CameraTransition;
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.GetClosestInteractable
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor**                          Interactable                                           (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::GetClosestInteractable(class AActor** Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "GetClosestInteractable");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_GetClosestInteractable Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Interactable != nullptr)
		*Interactable = Parms.Interactable;
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.GetCurrentInputDevice
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EInputDevices::EInputDevices*           InputDevice                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::GetCurrentInputDevice(EInputDevices::EInputDevices* InputDevice)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "GetCurrentInputDevice");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_GetCurrentInputDevice Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (InputDevice != nullptr)
		*InputDevice = Parms.InputDevice;
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.GetGlobalObjectIDWithGroup
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName*                            ObjectId                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::GetGlobalObjectIDWithGroup(class FName* ObjectId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "GetGlobalObjectIDWithGroup");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_GetGlobalObjectIDWithGroup Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ObjectId != nullptr)
		*ObjectId = Parms.ObjectId;
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.GetInitialTransform
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FTransform ABP_jRPG_Enemy_World_Base_Seamless_C::GetInitialTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "GetInitialTransform");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_GetInitialTransform Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.GetInteractionPromptParams
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FFPromptParams*                  PromptParams                                           (Parm, OutParm, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::GetInteractionPromptParams(struct FFPromptParams* PromptParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "GetInteractionPromptParams");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_GetInteractionPromptParams Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PromptParams != nullptr)
		*PromptParams = std::move(Parms.PromptParams);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.GetLookAtRotator
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FRotator*                        Rotator                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_jRPG_Enemy_World_Base_Seamless_C::GetLookAtRotator(class AActor* Target, struct FRotator* Rotator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "GetLookAtRotator");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_GetLookAtRotator Parms{};

	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);

	if (Rotator != nullptr)
		*Rotator = std::move(Parms.Rotator);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.GetPlayerCharacterIsInDetectionRange
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   PlayerCharacterIsInDetectionRange_0                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::GetPlayerCharacterIsInDetectionRange(bool* PlayerCharacterIsInDetectionRange_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "GetPlayerCharacterIsInDetectionRange");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_GetPlayerCharacterIsInDetectionRange Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PlayerCharacterIsInDetectionRange_0 != nullptr)
		*PlayerCharacterIsInDetectionRange_0 = Parms.PlayerCharacterIsInDetectionRange_0;
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.GetTest
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::GetTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "GetTest");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.InitializeGameplayRooms
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::InitializeGameplayRooms()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "InitializeGameplayRooms");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.InterruptEnterChaseMode
// (BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::InterruptEnterChaseMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "InterruptEnterChaseMode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.IsActorAggroTriggerRoom
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsTriggerRoom                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::IsActorAggroTriggerRoom(class AActor* Actor, bool* IsTriggerRoom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "IsActorAggroTriggerRoom");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_IsActorAggroTriggerRoom Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);

	if (IsTriggerRoom != nullptr)
		*IsTriggerRoom = Parms.IsTriggerRoom;
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.IsFreeAimTargetDisabled
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   IsDisabled                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::IsFreeAimTargetDisabled(bool* IsDisabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "IsFreeAimTargetDisabled");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_IsFreeAimTargetDisabled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsDisabled != nullptr)
		*IsDisabled = Parms.IsDisabled;
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.IsInteractionAvailable
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   Available                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::IsInteractionAvailable(bool* Available)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "IsInteractionAvailable");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_IsInteractionAvailable Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Available != nullptr)
		*Available = Parms.Available;
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.IsInteractionDone
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   Done                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::IsInteractionDone(bool* Done)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "IsInteractionDone");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_IsInteractionDone Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Done != nullptr)
		*Done = Parms.Done;
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.IsPlayerTooPowerfullToChase
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_jRPG_Enemy_World_Base_Seamless_C::IsPlayerTooPowerfullToChase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "IsPlayerTooPowerfullToChase");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_IsPlayerTooPowerfullToChase Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.IsWithinMaxAggroRange
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_jRPG_Enemy_World_Base_Seamless_C::IsWithinMaxAggroRange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "IsWithinMaxAggroRange");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_IsWithinMaxAggroRange Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.OnBattleFinished
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EBattleEndResult                        BattleEndResult                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::OnBattleFinished(EBattleEndResult BattleEndResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "OnBattleFinished");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_OnBattleFinished Parms{};

	Parms.BattleEndResult = BattleEndResult;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.OnBattleFled
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::OnBattleFled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "OnBattleFled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.OnCharacterDetected
// (BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::OnCharacterDetected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "OnCharacterDetected");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.OnCharacterEnteredVisionRange
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_jRPG_Character_World_C*       JRPG_Character_world                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::OnCharacterEnteredVisionRange(class ABP_jRPG_Character_World_C* JRPG_Character_world)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "OnCharacterEnteredVisionRange");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_OnCharacterEnteredVisionRange Parms{};

	Parms.JRPG_Character_world = JRPG_Character_world;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.OnCharacterLeftVisionHysteresisTimerCompleted
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::OnCharacterLeftVisionHysteresisTimerCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "OnCharacterLeftVisionHysteresisTimerCompleted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.OnDetectedCharacterChangedRoom
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_jRPG_Character_World_C*       Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::OnDetectedCharacterChangedRoom(class ABP_jRPG_Character_World_C* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "OnDetectedCharacterChangedRoom");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_OnDetectedCharacterChangedRoom Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.OnDetectionComplete
// (BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::OnDetectionComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "OnDetectionComplete");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.OnEnemyBattledEvent
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             EnemyID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::OnEnemyBattledEvent(class FName EnemyID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "OnEnemyBattledEvent");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_OnEnemyBattledEvent Parms{};

	Parms.EnemyID = EnemyID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.OnEnemyBattleStateLoaded
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    BattleState                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::OnEnemyBattleStateLoaded(bool BattleState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "OnEnemyBattleStateLoaded");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_OnEnemyBattleStateLoaded Parms{};

	Parms.BattleState = BattleState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.OnExtraVisionShapeBeginOverlap
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bFromSweep                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FHitResult&                SweepResult                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_jRPG_Enemy_World_Base_Seamless_C::OnExtraVisionShapeBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "OnExtraVisionShapeBeginOverlap");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_OnExtraVisionShapeBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.OnExtraVisionShapeEndOverlap
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::OnExtraVisionShapeEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "OnExtraVisionShapeEndOverlap");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_OnExtraVisionShapeEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.OnFailedDetection
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::OnFailedDetection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "OnFailedDetection");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.OnInteractionDisabled
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::OnInteractionDisabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "OnInteractionDisabled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.OnInteractionEnabled
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::OnInteractionEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "OnInteractionEnabled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.OnInteractionRequested
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_jRPG_Character_World_C*       InteractingWorldCharacter                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Instant                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::OnInteractionRequested(class ABP_jRPG_Character_World_C* InteractingWorldCharacter, bool Instant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "OnInteractionRequested");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_OnInteractionRequested Parms{};

	Parms.InteractingWorldCharacter = InteractingWorldCharacter;
	Parms.Instant = Instant;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.OnObjectInteractionStateLoaded
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    InteractionState                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::OnObjectInteractionStateLoaded(bool InteractionState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "OnObjectInteractionStateLoaded");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_OnObjectInteractionStateLoaded Parms{};

	Parms.InteractionState = InteractionState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.OnStunRecoveryAnimationFinished
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::OnStunRecoveryAnimationFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "OnStunRecoveryAnimationFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.OnVisionShapeBeginOverlap
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class UPrimitiveComponent*&       Primitive                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, InstancedReference, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// const class FString&                    Reason                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::OnVisionShapeBeginOverlap(const class UPrimitiveComponent*& Primitive, const class FString& Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "OnVisionShapeBeginOverlap");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_OnVisionShapeBeginOverlap Parms{};

	Parms.Primitive = Primitive;
	Parms.Reason = std::move(Reason);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.OnVisionShapeEndOverlap
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class UPrimitiveComponent*&       Component                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, InstancedReference, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const class FString&                    Reason                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// bool*                                   ValidEvent                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::OnVisionShapeEndOverlap(const class UPrimitiveComponent*& Component, class AActor* Actor, const class FString& Reason, bool* ValidEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "OnVisionShapeEndOverlap");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_OnVisionShapeEndOverlap Parms{};

	Parms.Component = Component;
	Parms.Actor = Actor;
	Parms.Reason = std::move(Reason);

	UObject::ProcessEvent(Func, &Parms);

	if (ValidEvent != nullptr)
		*ValidEvent = Parms.ValidEvent;
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.OnWaitBetweenDetectionTimerElapsed
// (Private, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::OnWaitBetweenDetectionTimerElapsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "OnWaitBetweenDetectionTimerElapsed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.OptimizeCharacterMovementComponent
// (Private, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::OptimizeCharacterMovementComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "OptimizeCharacterMovementComponent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.OptimizeSkeletalMeshComponents
// (Private, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::OptimizeSkeletalMeshComponents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "OptimizeSkeletalMeshComponents");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.PauseAllSound
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::PauseAllSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "PauseAllSound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.PlayBattleBeginTransition
// (BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::PlayBattleBeginTransition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "PlayBattleBeginTransition");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.PlayBattleCameraTransition
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::PlayBattleCameraTransition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "PlayBattleCameraTransition");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.PlayChasingSound
// (Private, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::PlayChasingSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "PlayChasingSound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.PlayExplorationSound
// (Private, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::PlayExplorationSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "PlayExplorationSound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.PlayFeedbackHitCanBeAttacked
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::PlayFeedbackHitCanBeAttacked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "PlayFeedbackHitCanBeAttacked");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.PlayFeedbackHitCanNotBeAttacked
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::PlayFeedbackHitCanNotBeAttacked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "PlayFeedbackHitCanNotBeAttacked");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.ReceiveEndPlay
// (Event, Protected, BlueprintEvent)
// Parameters:
// EEndPlayReason                          EndPlayReason                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::ReceiveEndPlay(EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "ReceiveEndPlay");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_ReceiveEndPlay Parms{};

	Parms.EndPlayReason = EndPlayReason;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "ReceiveTick");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_ReceiveTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.RegisterEvents
// (Private, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::RegisterEvents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "RegisterEvents");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.RegisterExtraVisionShape
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              Primitive                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::RegisterExtraVisionShape(class UPrimitiveComponent* Primitive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "RegisterExtraVisionShape");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_RegisterExtraVisionShape Parms{};

	Parms.Primitive = Primitive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.RemoveAggroLock
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FName&                      LockName                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::RemoveAggroLock(const class FName& LockName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "RemoveAggroLock");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_RemoveAggroLock Parms{};

	Parms.LockName = LockName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.RemoveInteractable
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Interactable                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::RemoveInteractable(class AActor* Interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "RemoveInteractable");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_RemoveInteractable Parms{};

	Parms.Interactable = Interactable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.RequestStopEnterChaseMode
// (BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::RequestStopEnterChaseMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "RequestStopEnterChaseMode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.ResetAggro
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::ResetAggro()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "ResetAggro");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.ResetAnimation
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::ResetAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "ResetAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.ResetState
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::ResetState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "ResetState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.ResetStateInternal
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::ResetStateInternal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "ResetStateInternal");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.RestoreTransformIfNeeded
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::RestoreTransformIfNeeded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "RestoreTransformIfNeeded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.SetAiState
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_AiStates                              NewAiState                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::SetAiState(E_AiStates NewAiState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "SetAiState");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_SetAiState Parms{};

	Parms.NewAiState = NewAiState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.SetAllOverlapCollision
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ECollisionEnabled                       NewType                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::SetAllOverlapCollision(ECollisionEnabled NewType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "SetAllOverlapCollision");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_SetAllOverlapCollision Parms{};

	Parms.NewType = NewType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.SetCurrentBT
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBehaviorTree*                    BTAsset                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_jRPG_Enemy_World_Base_Seamless_C::SetCurrentBT(class UBehaviorTree* BTAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "SetCurrentBT");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_SetCurrentBT Parms{};

	Parms.BTAsset = BTAsset;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.SetCurrentIdleState
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_EnemyIdleState                        CurrentIdleState_0                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::SetCurrentIdleState(E_EnemyIdleState CurrentIdleState_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "SetCurrentIdleState");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_SetCurrentIdleState Parms{};

	Parms.CurrentIdleState_0 = CurrentIdleState_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.SetGameplayPaused
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Paused                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::SetGameplayPaused(bool Paused)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "SetGameplayPaused");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_SetGameplayPaused Parms{};

	Parms.Paused = Paused;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.ShouldEncounterCapsuleGenerateOverlaps
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_jRPG_Enemy_World_Base_Seamless_C::ShouldEncounterCapsuleGenerateOverlaps()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "ShouldEncounterCapsuleGenerateOverlaps");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_ShouldEncounterCapsuleGenerateOverlaps Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.ShouldHideDistantInteraction
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_jRPG_Enemy_World_Base_Seamless_C::ShouldHideDistantInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "ShouldHideDistantInteraction");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_ShouldHideDistantInteraction Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.ShouldReactToCharacter
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          DebugReason                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

bool ABP_jRPG_Enemy_World_Base_Seamless_C::ShouldReactToCharacter(class FString* DebugReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "ShouldReactToCharacter");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_ShouldReactToCharacter Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (DebugReason != nullptr)
		*DebugReason = std::move(Parms.DebugReason);

	return Parms.ReturnValue;
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.SpawnDesintegrationFX
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::SpawnDesintegrationFX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "SpawnDesintegrationFX");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.StartBattle
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_jRPG_EngageTypes                      EngagementType                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::StartBattle(E_jRPG_EngageTypes EngagementType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "StartBattle");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_StartBattle Parms{};

	Parms.EngagementType = EngagementType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.StartChasingSoundTimer
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::StartChasingSoundTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "StartChasingSoundTimer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.StartExplorationSoundTimer
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::StartExplorationSoundTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "StartExplorationSoundTimer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.StopChasing
// (BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::StopChasing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "StopChasing");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.Timeline_0__FinishedFunc
// (BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::Timeline_0__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "Timeline_0__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.Timeline_0__UpdateFunc
// (BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::Timeline_0__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "Timeline_0__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.UnpauseAllSound
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::UnpauseAllSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "UnpauseAllSound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.UpdateCharacterDetection
// (BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::UpdateCharacterDetection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "UpdateCharacterDetection");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.UpdateCharacterDetectionTick
// (BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::UpdateCharacterDetectionTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "UpdateCharacterDetectionTick");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.UpdateCharacterRoomsRequirement
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_jRPG_Character_World_C*       Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_jRPG_Enemy_World_Base_Seamless_C::UpdateCharacterRoomsRequirement(class ABP_jRPG_Character_World_C* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "UpdateCharacterRoomsRequirement");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_UpdateCharacterRoomsRequirement Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.UpdateDetectionInVisionCone
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FActorDetectionParameters& DetectionParameters                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   Detected                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::UpdateDetectionInVisionCone(const struct FActorDetectionParameters& DetectionParameters, bool* Detected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "UpdateDetectionInVisionCone");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_UpdateDetectionInVisionCone Parms{};

	Parms.DetectionParameters = std::move(DetectionParameters);

	UObject::ProcessEvent(Func, &Parms);

	if (Detected != nullptr)
		*Detected = Parms.Detected;
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.UpdateDetectionProgress
// (Private, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::UpdateDetectionProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "UpdateDetectionProgress");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.UpdateDetectionProgressDurationMultiplier
// (Private, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::UpdateDetectionProgressDurationMultiplier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "UpdateDetectionProgressDurationMultiplier");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.UpdateDetectionProgressDurationMultiplierByGait
// (Private, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::UpdateDetectionProgressDurationMultiplierByGait()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "UpdateDetectionProgressDurationMultiplierByGait");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.UpdateDetectionProgressMultiplierByDistance
// (Private, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::UpdateDetectionProgressMultiplierByDistance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "UpdateDetectionProgressMultiplierByDistance");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.UpdateDetectionProgressValue
// (Private, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::UpdateDetectionProgressValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "UpdateDetectionProgressValue");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.UpdateDetectionWithLineOfSight
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FActorDetectionParameters& DetectionParameters                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsVisible                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::UpdateDetectionWithLineOfSight(const struct FActorDetectionParameters& DetectionParameters, bool* IsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "UpdateDetectionWithLineOfSight");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_UpdateDetectionWithLineOfSight Parms{};

	Parms.DetectionParameters = std::move(DetectionParameters);

	UObject::ProcessEvent(Func, &Parms);

	if (IsVisible != nullptr)
		*IsVisible = Parms.IsVisible;
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.UpdateEncounterCapsuleSettings
// (Protected, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::UpdateEncounterCapsuleSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "UpdateEncounterCapsuleSettings");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.UpdateFreeAimCollisionBox
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::UpdateFreeAimCollisionBox()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "UpdateFreeAimCollisionBox");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.UpdateInteractables
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::UpdateInteractables()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "UpdateInteractables");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.UpdatePlayerCharacterDetection
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   Detected                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::UpdatePlayerCharacterDetection(bool* Detected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "UpdatePlayerCharacterDetection");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_UpdatePlayerCharacterDetection Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Detected != nullptr)
		*Detected = Parms.Detected;
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.UserConstructionScript
// (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_jRPG_Enemy_World_Base_Seamless_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.DEBUG_ShowVisionCone
// (Public, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// float                                   Lifetime                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::DEBUG_ShowVisionCone(float Lifetime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "DEBUG_ShowVisionCone");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_DEBUG_ShowVisionCone Parms{};

	Parms.Lifetime = Lifetime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.DisplayVisionAngle
// (Public, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// const struct FVector&                   Center                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  A                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Lifetime                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FLinearColor&              Color                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Radius                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::DisplayVisionAngle(const struct FVector& Center, double A, float Lifetime, const struct FLinearColor& Color, float Radius) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "DisplayVisionAngle");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_DisplayVisionAngle Parms{};

	Parms.Center = std::move(Center);
	Parms.A = A;
	Parms.Lifetime = Lifetime;
	Parms.Color = std::move(Color);
	Parms.Radius = Radius;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.Editor_DrawDebugShapes
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_jRPG_Enemy_World_Base_Seamless_C::Editor_DrawDebugShapes() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "Editor_DrawDebugShapes");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_Editor_DrawDebugShapes Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.Editor_GetDebugShapes
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// TArray<struct FEditorDebugShape_Arrow>& Arrows                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FEditorDebugShape_Arrow>& Lines                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_jRPG_Enemy_World_Base_Seamless_C::Editor_GetDebugShapes(TArray<struct FEditorDebugShape_Arrow>& Arrows, TArray<struct FEditorDebugShape_Arrow>& Lines) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "Editor_GetDebugShapes");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_Editor_GetDebugShapes Parms{};

	Parms.Arrows = std::move(Arrows);
	Parms.Lines = std::move(Lines);

	UObject::ProcessEvent(Func, &Parms);

	Arrows = std::move(Parms.Arrows);
	Lines = std::move(Parms.Lines);

	return Parms.ReturnValue;
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.GetInteractionFeedbackLocation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// struct FVector*                         Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::GetInteractionFeedbackLocation(struct FVector* Location) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "GetInteractionFeedbackLocation");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_GetInteractionFeedbackLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Location != nullptr)
		*Location = std::move(Parms.Location);
}


// Function BP_jRPG_Enemy_World_Base_Seamless.BP_jRPG_Enemy_World_Base_Seamless_C.GetInteractionLocation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// struct FVector*                         Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_jRPG_Enemy_World_Base_Seamless_C::GetInteractionLocation(struct FVector* Location) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_jRPG_Enemy_World_Base_Seamless_C", "GetInteractionLocation");

	Params::BP_jRPG_Enemy_World_Base_Seamless_C_GetInteractionLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Location != nullptr)
		*Location = std::move(Parms.Location);
}

}

